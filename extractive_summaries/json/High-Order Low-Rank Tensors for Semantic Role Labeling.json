{
  "sections": [{
    "text": "Human Language Technologies: The 2015 Annual Conference of the North American Chapter of the ACL, pages 1150–1160, Denver, Colorado, May 31 – June 5, 2015. c©2015 Association for Computational Linguistics"
  }, {
    "heading": "1 Introduction",
    "text": "The accuracy of Semantic Role Labeling (SRL) systems depends strongly on the features used by the underlying classifiers. For instance, the top performing system on the CoNLL–2009 shared task employs over 50 language-specific templates for feature generation (Che et al., 2009). The templates\n1Our code is available at https://github.com/ taolei87/SRLParser.\nare manually created and thus offer specific means of incorporating prior knowledge into the method. However, finding compact, informative templates is difficult since the relevant signal may be spread over many correlated features. Moreover, the use of lexicalized features, which are inevitably sparse, leads to overfitting. In this case it is advantageous to try to automatically compress the feature set to use a small number of underlying co-varying dimensions. Dimensionality reduction of this kind can be incorporated into the classifier directly by utilizing tensor calculus. In this paper, we adopt this strategy.\nWe start by building high-dimensional feature vectors that are subsequently mapped into a lowdimensional representation. Since this highdimensional representation has to reflect the interaction between different indicators of semantic relations, we construct it as a cross-product of smaller feature vectors that capture distinct facets of semantic dependence: predicate, argument, syntactic path and role label. By compressing this sparse representation into lower dimensions, we obtain dense representations for words (predicate, argument) and their connecting paths, uncovering meaningful interactions. The associated parameters are maintained as a four-way low-rank tensor, and optimized for SRL performance. Tensor modularity enables us to employ standard online algorithms for training.\nOur approach to SRL is inspired by recent success of our tensor-based approaches in dependency parsing (Lei et al., 2014). Applying analogous techniques to SRL brings about new challenges, however. The scoring function needs to reflect the highorder interactions between the predicate, argument,\n1150\ntheir syntactic path and the corresponding role label. Therefore, we parametrize the scoring function as a four-way tensor. Generalization to high-order tensors also requires new initialization and update procedures. For instance, the SVD initialization used in our dependency parsing work results in memory explosion when extending to our 4-way tensor. Instead, we employ the power method (De Lathauwer et al., 1995) to build the initial tensor from smaller pieces, one rank-1 component at a time. For learning, in order to optimize an overall non-convex objective function with respect to the tensor parameters, we modify the passive-aggressive algorithm to update all the low-rank components in one step. The update strategy readily generalizes to any high-order tensor.\nWe evaluate our tensor-based approach for SRL on the CoNLL–2009 shared task benchmark datasets of five languages: English, German, Chinese, Catalan and Spanish (Surdeanu et al., 2008). As a baseline, we use a simple SRL model that relies on a minimal set of standard features. Our results demonstrate that the tensor-based model outperforms the original SRL model by a significant margin, yielding absolute improvements of 2.1% F1 score. We also compare our results against the best performing system on this task (Zhao et al., 2009a). On three out of five languages, the tensor-based model outperforms this system. These results are particularly notable because the system of Zhao et al. (2009a) employs a rich set of language-specific features carefully engineered for this task. Finally, we demonstrate that using four-way tensor yields better performance than its three-way counterpart, highlighting the importance of modeling the relation between role labels and properties of the path."
  }, {
    "heading": "2 Related Work",
    "text": "A great deal of SRL research has been dedicated to designing rich, expressive features. The initial work by Gildea and Jurafsky (2002) already identified a compact core set of features, which were widely adopted by the SRL community. These features describe the predicate, the candidate argument, and the syntactic relation between them (path). Early systems primarily extended this core set by including local context lexicalized patterns (e.g., n-grams),\nseveral extended representations of the path features, and some linguistically motivated syntactic patterns, as the syntactic frame (Surdeanu et al., 2003; Xue and Palmer, 2004; Pradhan et al., 2005).\nMore recent approaches explored a broader range of features. Among others, Toutanova et al. (2008), Martins and Almeida (2014) and Yang and Zong (2014) have explored high-order features involving several arguments and even pairs of sentence predicates. Other approaches have focused on semantic generalizations of lexical features using selectional preferences, neural network embeddings or latent word language models (Zapirain et al., 2013; Collobert et al., 2011; Deschacht and Moens, 2009; Roth and Woodsend, 2014). To avoid the intensive feature engineering inherent in SRL, Moschitti et al. (2008) employ kernel learning. Although attractive from this perspective, the kernel-based approach comes with a high computational cost. In contrast to prior work, our approach effectively learns lowdimensional representation of words and their roles, eliminating the need for heavy manual feature engineering. Finally, system combination approaches such as reranking typically outperform individual systems (Björkelund et al., 2010). Our method can be easily integrated as a component in one of those systems.\nIn technical terms, our work builds on our recent tensor-based approach for dependency parsing (Lei et al., 2014). In that work, we use a three-way tensor to score candidate dependency relations within a first-order scoring function. The tensor captures the interaction between words and their syntactic (headmodifier) relations. In contrast, the scoring function in SRL involves higher-order interactions between the path, argument, predicate and their associated role label. Therefore, we parametrized the scoring function with a four-way low-rank tensor. To help with this extension, we developed a new initialization and update strategy. Our experimental results demonstrate that the new representation tailored to SRL outperforms previous approaches."
  }, {
    "heading": "3 Problem Formulation",
    "text": "Our setup follows the CoNLL–2009 shared task (Hajič et al., 2009). Each token in sentence x is annotated with a predicted POS tag and predicted\nUNESCO is holding its meetings in Paris\nA0 A1\nAM-LOC\nword lemma. Some tokens are also marked as predicates, i.e., argument-bearing tokens. The goal is to determine the semantic dependencies for each predicate pi (cf. upper part of Figure 1). These dependencies identify the arguments of each predicate and their role labels. In this work, we focus only on the semantic side – that is, identification and classification of predicate arguments. To this end, our system takes as input a syntactic dependency tree ysyn derived from a state-of-the-art parser (bottom part of Figure 1).\nMore formally, let {pi} ⊂ x be the set of verbal and nominal predicates in the sentence. For each predicate pi (e.g., “holding”), our goal is to predict tuples (pi, aij , rij) specifying the semantic dependency arcs, where aij ∈ x is one argument (e.g., “meetings”), and rij is the corresponding semantic role label (e.g., A1). The semantic parse is then the collection of predicted arcs zsem = {(pi, aij , rij)}.\nWe decouple syntactic and semantic inference problems into two separate steps. We first run our syntactic dependency parser RBGParser2 to obtain the syntactic dependency tree ysyn. The semantic parse zsem is then found conditionally on the syntactic part:\nz∗sem = arg maxzsem Ssem(x,ysyn, zsem), (1)\nHere Ssem(·) is the parametrized scoring function to be learned. We build our scoring function by combining a traditional feature scoring function with a tensor-based scoring function.\n2https://github.com/taolei87/RBGParser"
  }, {
    "heading": "3.1 Traditional Scoring Using Manually-designed Features",
    "text": "In a typical feature-based approach (Johansson, 2009; Che et al., 2009), feature templates give rise to rich feature descriptions of the semantic structure. The score Ssem(x,ysyn, zsem) is then defined as the inner product between the parameter vector and the feature vector. In the first-order arc-factored case,\nSsem(x,ysyn, zsem) = w · φ(x,ysyn, zsem) = ∑ (p,a,r)∈zsem w · φ(p, a, r),\nwhere w are the model parameters and φ(p, a, r) is the feature vector representing a single semantic arc (p, a, r) (we suppress its dependence on x and ysyn). We also experiment with second order features, i.e., considering two arguments associated with the same predicate, or two predicates sharing the same token as argument.\nFor the arc-factored model, there are mainly four types of atomic information that define the arc features in φ(p, a, r):\n(a) the predicate token p (and its local context); (b) the argument token a (and its local context); (c) the dependency label path that connects p and\na in the syntactic tree; (d) the semantic role label r of the arc.\nThese pieces of atomic information are either used directly or combined as unigram up to 4-gram features into traditional models. To avoid heavy feature engineering and overfitting, we use a light and compact feature set derived from the information in (a)–(d). Table 1 shows the complete list of feature\ntemplates, used as our first-order semantic baseline in the experiments."
  }, {
    "heading": "3.2 Low-rank Scoring via Projected Representations",
    "text": "Now, we describe the tensor-based scoring function. We characterize each semantic arc (p, a, r) using the cross-product of atomic feature vectors associated with the four types of information described above: the predicate vector φ(p), the argument vector φ(a), the dependency path vector φ(path) and the semantic role label vector φ(r). For example, in the simplest case φ(p),φ(a) ∈ [0, 1]n are one-hot indicator vectors, where n is the size of the vocabulary. Similarly, φ(path) ∈ [0, 1]m and φ(r) ∈ [0, 1]l are indicator vectors where m is the number of unique paths (seen in the training set) and l is the number of semantic role labels. Of course, we can add other atomic information into these atomic vectors. For example, φ(p) will not only indicate the word form of the current predicate p, but also the word lemma, POS tag and surrounding tokens as well. The crossproduct of these four vectors is an extremely highdimensional rank-1 tensor,\nφ(p)⊗ φ(a)⊗ φ(path)⊗ φ(r) ∈ Rn×n×m×l\nin which each entry indicates the combination of four atomic features appearing in the semantic arc (p, a, r)3. The rank-1 tensor (cross-product) captures all possible combinations over atomic units, and therefore it is a full feature expansion over the manually selected feature set in Table 1. Similar to the traditional scoring, the semantic arc score is the inner product between a 4-way parameter tensor A and this feature tensor:\nA ∈ Rn×n×m×l : vec(A) · vec (φ(p)⊗ φ(a)⊗ φ(path)⊗ φ(r)) ,\n(2)\nwhere vec(·) denotes the vector representation of a matrix / tensor.\nInstead of reducing and pruning possible feature concatenations (e.g., by manual feature template\n3We always add a bias term into these atomic vectors (e.g., a fixed “1” attached to the beginning of every vector). Therefore, their cross-product will contain all unigram to 4-gram concatenations, not just 4-gram concatenations.\nconstruction as in the traditional approach), this tensor scoring method avoids parameter explosion and overfitting by assuming a low-rank factorization of the parameters A. Specifically, A is decomposed into the sum of k simple rank-1 components,\nA = k∑\ni=1\nP (i)⊗Q(i)⊗R(i)⊗ S(i). (3)\nHere k is a small constant, P,Q ∈ Rk×n, R ∈ Rk×m and S ∈ Rk×l are parameter matrices, and P (i) (and similarly Q(i), R(i) and S(i)) represents the i-th row vector of matrix P .\nThe advantages of this low-rank assumption are as follows. First, computing the score no longer requires maintaining and constructing extremely large tensors. Instead, we can project atomic vectors via P , Q, R and S obtaining small dense vectors, and subsequently calculating the arc score by\nk∑ i=1 [Pφ(p)]i [Qφ(a)]i [Rφ(path)]i [Sφ(r)]i .\nSecond, projecting atomic units such as words, POS tags and labels into dense, low-dimensional vectors can effectively alleviate the sparsity problem, and it enables the model to capture high-order feature interactions between atomic units, while avoiding the parameter explosion problem."
  }, {
    "heading": "3.3 Combined System",
    "text": "Similar to our low-rank syntactic dependency parsing model (Lei et al., 2014), our final scoring function Ssem(x,ysyn, zsem) is the combination of the traditional scoring and the low-rank scoring,\nSsem(x,ysyn, zsem) =\nγ w · φ(x,ysyn, zsem) + (1− γ) ∑\n(p,a,r)∈zsem\nk∑ i=1\n[Pφ(p)]i [Qφ(a)]i [Rφ(path)]i [Sφ(r)]i .\nwhere γ ∈ [0, 1] is a hyper-parameter balancing the two scoring terms. We tune this value on the development set. Finally, the set of parameters of our model is denoted as θ = {w, P,Q,R, S}. Our goal is to optimize the weight vector w as well as the four projection matrices given the training set."
  }, {
    "heading": "4 Learning",
    "text": "We now describe the learning method for our SRL model. Let D = {(x̂(i), ˆysyn(i), ˆzsem(i))}Ni=1 be the collection of N training samples. The values of the set of parameters θ = {w, P,Q,R, S} are estimated on the basis of this training set. Following standard practice, we optimize the parameter values in a maximum soft-margin framework. That is, for the given sentence x̂ and the corresponding syntactic tree ˆysyn, we adjust parameter values to separate gold semantic parse and other incorrect alternatives:\n∀zsem ∈ Z(x̂, ˆysyn) : Ssem(x̂, ˆysyn, ˆzsem) ≥ Ssem(x̂, ˆysyn, zsem) + cost( ˆzsem, zsem) (4)\nwhere Z(x̂, ˆysyn) represent the set of all possible semantic parses, and cost( ˆzsem, zsem) is a non-negative function representing the structural difference between ˆzsem and zsem. The cost is zero when zsem = ˆzsem, otherwise it becomes positive and therefore is the “margin” to separate the two parses. Following previous work (Johansson, 2009; Martins and Almeida, 2014), this cost function is defined as the sum of arc errors – we add 1.0 for each false-positive arc, 2.0 for each false-negative arc (a missing arc) and 0.5 if the predicate-argument pair (p, a) is in both parses but the semantic role label r is incorrect."
  }, {
    "heading": "4.1 Online Update",
    "text": "The parameters are updated successively after each training sentence. Each update first checks whether the constraint (4) is violated. This requires “costaugmented decoding” to find the maximum violation with respect to the gold semantic parse:\n˜zsem = arg max zsem Ssem(x̂, ˆysyn, zsem)\n+ cost( ˆzsem, zsem)\nWhen the constraint (4) is violated (i.e. ˜zsem 6= ˆzsem), we seek a parameter update ∆θ to fix this violation. In other words, we define the hinge loss for this example as follows,\nloss(θ) = max{ 0, Ssem(x̂, ˆysyn, ˜zsem) + cost( ˆzsem, ˜zsem)− Ssem(x̂, ˆysyn, ˆzsem) }\nand we revise the parameter values to minimize this loss function.\nSince this loss function is neither linear nor convex with respect to the parameters θ (more precisely the low-rank component matrices P , Q, R and S), we can use the same alternating passive-aggressive (PA) update strategy in our previous work (Lei et al., 2014) to update one parameter matrix at one time while fixing the other matrices. However, as we demonstrated later, modifying the passiveaggressive algorithm slightly can give us a joint update over all components in θ. Our preliminary experiment shows this modified version achieves better results compared to the alternating PA."
  }, {
    "heading": "4.2 Joint PA Update for Tensor",
    "text": "The original passive-aggressive parameter update ∆θ is derived for a linear, convex loss function by solving a quadatic optimization problem. Although our scoring function Ssem(·) is not linear, we can simply approximate it with its first-order Taylor expansion:\nS(x,y, z; θ + ∆θ) ≈ S(x,y, z; θ) + dS dθ ·∆θ\nIn fact, by plugging this into the hinge loss function and the quadratic optimization problem, we get a joint closed-form update which can be simply described as,\n∆θ = max { C,\nloss(θ) ‖gθ‖2\n} gθ\nwhere\ngθ = dS dθ (x̂, ˆysyn, ˆzsem)− dS dθ (x̂, ˆysyn, ˜zsem),\nand C is a regularization hyper-parameter controlling the maximum step size of each update. Note that θ is the set of all parameters, the update jointly adjusts all low-rank matrices and the traditional weight vector. The PA update is “adaptive” in the sense that its step size is propotional to the loss(θ) of the current training sample. Therefore the step size is adaptively decreased as the model fits the training data."
  }, {
    "heading": "4.3 Tensor Initialization",
    "text": "Since the scoring and loss function with high-order tensor components is highly non-convex, our model\nperformance can be impacted by the initialization of the matrices P , Q, R and S. In addition to intializing these low-rank components randomly, we also experiment with a strategy to provide a good guess of the low-rank tensor.\nFirst, note that the traditional manually-selected feature set (i.e., φ(p, a, r) in our notation) is an expressive and informative subset of the huge feature expansion covered in the feature tensor. We can train our model using only the manual feature set and then use the corresponding feature weights w to intialize the tensor. Specifically, we create a sparse tensor T ∈ Rn×n×m×l by putting each parameter weight in w into its corresponding entry in T . We then try to find a low-rank approximation of sparse tensor T by approximately minimizing the squared error:\nmin P,Q,R,S\n‖T − ∑\ni\nP (i)⊗Q(i)⊗R(i)⊗ S(i)‖22\nIn the low-rank dependency parsing work (Lei et al., 2014), this is achieved by unfolding the sparse tensor T into a n× nml matrix and taking the SVD to get the top low-rank components. Unfortunately this strategy does not apply in our case (and other high-order tensor cases) because even the number of columns in the unfolded matrix is huge, nml > 1011, and simply taking the SVD would fail because of memory limits.\nInstead, we adopt the generalized high-order power method, a.k.a. power iteration (De Lathauwer et al., 1995), to incrementally obtain the most important rank-1 component one-by-one – P (i), Q(i), R(i) and S(i) for each i = 1..k. This method is a very simple iterative algorithm and is used to find the largest eigenvalues and eigenvectors (or singular values and vectors in SVD case) of a matrix. Its generalization directly applies to our high-order tensor case."
  }, {
    "heading": "5 Implementation Details",
    "text": "Decoding Following Lluı́s et al. (2013), the decoding of SRL is formulated as a bipartite maximum assignment problem, where we assign arguments to semantic roles for each predicate. We use the maximum weighted assignment algorithm (Kuhn, 1955). For syntactic dependency parsing, we employ the randomized hill-climbing algorithm from our previous work (Zhang et al., 2014).\nFeatures Table 1 summarizes the first-order feature templates. These features are mainly drawn from previous work (Johansson, 2009). In addition, we extend each template with the argument label.\nTable 2 summarizes the atomic features used in φ(p) and φ(a) for the tensor component. For each predicate or argument, the feature vector includes its word form and POS tag, as well as the POS tags of the context words. We also add unsupervised word embeddings learned on raw corpus.4 For atomic vectors φ(path) and φ(r) representing the path and the semantic role label, we use the indicator feature and a bias term."
  }, {
    "heading": "6 Experimental Setup",
    "text": "Dataset We evaluate our model on the English dataset and other 4 datasets in the CoNLL-2009 shared task (Surdeanu et al., 2008). We use the\n4https://github.com/wolet/ sprml13-word-embeddings\nofficial split for training, development and testing. For English, the data is mainly drawn from the Wall Street Journal. In addition, a subset of the Brown corpus is used as the secondary out-of-domain test set, in order to evaluate how well the model generalizes to a different domain. Following the official practice, we use predicted POS tags, lemmas and morphological analysis provided in the dataset across all our experiments. The predicates in each sentence are also given during both training and testing. However, we neither predict nor use the sense for each predicate.\nSystems for Comparisons We compare against three systems that achieve the top average performance in the joint syntactic and semantic parsing track of the CoNLL-2009 shared task (Che et al., 2009; Zhao et al., 2009a; Gesmundo et al., 2009). All approaches extensively explored rich features for the SRL task. We also compare with the stateof-the-art parser (Björkelund et al., 2010) for English, an improved version of systems participated in CoNLL-2009. This system combines the pipeline of dependency parser and semantic role labeler with a global reranker. Finally, we compare with the recent approach which employs distributional word representations for SRL (Roth and Woodsend, 2014). We directly obtain the outputs of all these systems from the CoNLL-2009 website5 or the authors.\nModel Variants Our full model utilizes 4-way tensor component and a standard feature set\n5http://ufal.mff.cuni.cz/conll2009-st/ results/results.php\nfrom (Johansson, 2009). We also compare against our model without the tensor component, as well as a variant with a 3-way tensor by combining the path and semantic role label parts into a single mode (dimension).\nEvaluation Measures Following standard practice in the SRL evaluation, we measure the performance using labeled F-score. To this end, we apply the evaluation script provided on the official website.6 The standard evaluation script considers the predicate sense prediction as a special kind of semantic label.7 Since we are neither predicting nor using the predicate sense information, we exclude this information in most of the evaluation. In addition, we combine the predicate sense classification output of (Björkelund et al., 2010) with our semantic role labeling output, to provide results directly comparable to previous reported numbers.\nExperimental Details Across all experiments, we fix the rank of the tensor to 50 and train our model for a maximum of 20 epochs. Following common practice, we average parameters over all iterations. For each experimental setting, we tune the hyper-parameter γ ∈ {0.3, 0.5, 0.7, 0.9} and C ∈ {0.01, 0.1, 1} on the development set and apply the best model on the test set. Each model is evaluated on the development set after every epoch to pick the the best number of training epoch. For the experiments with random initialization on the tensor component, the vectors are initialized as random unit vectors. We combine our SRL model with our syntactic dependency parser, RBGParser v1.1 (Lei et al., 2014), for joint syntactic and semantic parsing. The labeled attachment score (LAS) of RBGParser is 90.4 on English, when we train the “standard” model type using the unsupervised word vectors."
  }, {
    "heading": "7 Results",
    "text": "We first report the performance of our methods and other state-of-the-art SRL systems on English datasets (See Table 3). We single out performance\n6http://ufal.mff.cuni.cz/conll2009-st/ scorer.html\n7Note that the original script includes such prediction in the F-score calculation, although the predicate sense is typically predicted in a separate step before semantic label classification.\non English corpora because these datasets are most commonly used for system evalutation. As a single system without reranking, our model outperforms the five top performing systems (second block in Table 3) on both in-domain and out-of-domain datasets. The improvement from the F-score of 82.08% to our result 82.51% on the WSJ in-domain test set is significant with p < 0.05, which is computed using a randomized test tool8 based on Yeh (2000). For comparison purposes, we also report F-score performance when predicate senses are included in evaluation. The relative performance between the systems is consistent independent of whether the predicate senses are included or excluded.\nTable 4 shows the results of our system on other languages in the CoNLL-2009 shared task. Out of five languages, our model rivals the best performing system on three languages, achieving statistically significant gains on English and Chinese. Note that our model uses the same feature configuration for all the languages. In contrast, Zhao et al. (2009b) rely on language-specific configurations obtained via “huge feature engineering” (as noted by the authors).\nResults in Table 3 and 4 also highlight the con-\n8http://www.nlpado.de/˜sebastian/ software/sigf.shtml\ntribution of the tensor to the model performance, which is consistent across languages. Without the tensor component, our system trails the top two performing systems. However, adding the tensor component provides on average 2.1% absolute gain, resulting in competitive performance. The mode of the tensor also contributes to the performance – the 4-way tensor model performs better than the 3-way counterpart, demonstrating the importance of modeling the interactions between dependency paths and semantic role labels.\nTable 5 shows the impact of initialization on the performance of the tensor-based model. The initialization based on the power method yields superior results compared to random initialization, for both\n3-way and 4-way tensors. However, random initialization still delivers reasonable performance, outperforming the tensor-free model by more than 1% in F-score.\nFinally, we compare our tensor-based approach against a simpler model that captures interactions between predicate, argument and syntactic path using word embeddings (Roth and Woodsend, 2014). Table 6 demonstrates that modeling feature interactions using tensor yields higher gains than using word embeddings alone. For instance, the highest gain achieved by Roth and Woodsend (2014) when the embeddings of the arguments are averaged is 0.5%, compared to 1.6% obtained by our model."
  }, {
    "heading": "8 Conclusions",
    "text": "In this paper we introduce a tensor-based approach to SRL that induces a compact feature representation for words and their relations. In this sense, our dimensionality reduction method provides a clear alternative to a traditional feature engineering approach used in SRL. Augmenting a simple, yet competitive SRL model with the tensor component yields significant performance gains. We demonstrate that our full model outperforms the best performing systems on the CoNLL-2009 shared task."
  }, {
    "heading": "Acknowledgments",
    "text": "The authors acknowledge the support of the MURI program (W911NF-10-1-0533) and the DARPA BOLT program. This research is developed in a collaboration of MIT with the Arabic Language Technologies (ALT) group at Qatar Computing Research Institute (QCRI) within the Interactive sYstems for Answer Search (IYAS) project. We are grateful to Anders Bjökelund and Michael Roth for providing the outputs of their systems. We thank Yu Xin, Tommi Jaakkola, the MIT NLP group and the ACL reviewers for their comments. Any opinions, findings, conclusions, or recommendations expressed in this paper are those of the authors, and do not necessarily reflect the views of the funding organizations."
  }],
  "year": 2015,
  "references": [{
    "title": "A high-performance syntactic and semantic dependency parser",
    "authors": ["Anders Björkelund", "Bernd Bohnet", "Love Hafdell", "Pierre Nugues."],
    "venue": "Proceedings of the 23rd International Conference on Computational Linguistics: Demonstrations. Association for Compu-",
    "year": 2010
  }, {
    "title": "Multilingual dependency-based syntactic and semantic parsing",
    "authors": ["Wanxiang Che", "Zhenghua Li", "Yongqiang Li", "Yuhang Guo", "Bing Qin", "Ting Liu."],
    "venue": "Proceedings of the Thirteenth Conference on Computational Natural Language Learning (CoNLL 2009):",
    "year": 2009
  }, {
    "title": "Natural language processing (almost) from scratch",
    "authors": ["Ronan Collobert", "Jason Weston", "Léon Bottou", "Michael Karlen", "Koray Kavukcuoglu", "Pavel Kuksa."],
    "venue": "Journal of Machine Learning Research, 11(Aug):2493–2537.",
    "year": 2011
  }, {
    "title": "Higher-order power method",
    "authors": ["Lieven De Lathauwer", "Pierre Comon", "Bart De Moor", "Joos Vandewalle."],
    "venue": "Nonlinear Theory and its Applications, NOLTA95, 1.",
    "year": 1995
  }, {
    "title": "Semi-supervised semantic role labeling using the Latent Words Language Model",
    "authors": ["Koen Deschacht", "Marie-Francine Moens."],
    "venue": "Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 21–29, Singapore, Au-",
    "year": 2009
  }, {
    "title": "A latent variable model of synchronous syntactic-semantic parsing for multiple languages",
    "authors": ["Andrea Gesmundo", "James Henderson", "Paola Merlo", "Ivan Titov."],
    "venue": "Proceedings of the Thirteenth Conference on Computational Natural Language Learning:",
    "year": 2009
  }, {
    "title": "Automatic labeling of semantic roles",
    "authors": ["Daniel Gildea", "Daniel Jurafsky."],
    "venue": "Computational Linguistics, 28(3):245–288.",
    "year": 2002
  }, {
    "title": "Statistical bistratal dependency parsing",
    "authors": ["Richard Johansson."],
    "venue": "Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 561–569, Singapore.",
    "year": 2009
  }, {
    "title": "The hungarian method for the assignment problem",
    "authors": ["Harold W Kuhn."],
    "venue": "Naval research logistics quarterly, 2(1-2):83–97.",
    "year": 1955
  }, {
    "title": "Low-rank tensors for scoring dependency structures",
    "authors": ["Tao Lei", "Yu Xin", "Yuan Zhang", "Regina Barzilay", "Tommi Jaakkola."],
    "venue": "Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages",
    "year": 2014
  }, {
    "title": "Joint arc-factored parsing of syntactic and semantic dependencies",
    "authors": ["Xavier Lluı́s", "Xavier Carreras", "Lluı́s Màrquez"],
    "venue": "Transactions of the Association for Computational Linguistics,",
    "year": 2013
  }, {
    "title": "Priberam: A turbo semantic parser with second order features",
    "authors": ["André F.T. Martins", "Mariana S.C. Almeida."],
    "venue": "Proceedings of the 8th International Workshop on Semantic Evaluation (SemEval 2014), pages 471–476, Dublin, Ireland, August. Association",
    "year": 2014
  }, {
    "title": "Tree kernels for semantic role labeling",
    "authors": ["Alessandro Moschitti", "Daniele Pighin", "Roberto Basili."],
    "venue": "Computational Linguistics, 34(2):193–224.",
    "year": 2008
  }, {
    "title": "Support vector learning for semantic argument classification",
    "authors": ["Sameer Pradhan", "Kadri Hacioglu", "Valerie Krugler", "Wayne Ward", "James H. Martin", "Daniel Jurafsky."],
    "venue": "Machine Learning, 60(1):11–39.",
    "year": 2005
  }, {
    "title": "Composition of word representations improves semantic role labelling",
    "authors": ["Michael Roth", "Kristian Woodsend."],
    "venue": "Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP). Association for Computational Linguistics.",
    "year": 2014
  }, {
    "title": "Using predicate-argument structures for information extraction",
    "authors": ["Mihai Surdeanu", "Sanda Harabagiu", "John Williams", "Paul Aarseth."],
    "venue": "Proceedings of the 41st Annual Meeting of the Association for Computational Linguistics, pages 8–15, Sapporo, Japan.",
    "year": 2003
  }, {
    "title": "The conll-2008 shared task on joint parsing of syntactic and semantic dependencies",
    "authors": ["Mihai Surdeanu", "Richard Johansson", "Adam Meyers", "Lluı́s Màrquez", "Joakim Nivre"],
    "venue": "In Proceedings of the Twelfth Conference on Computational Natural",
    "year": 2008
  }, {
    "title": "A global joint model for semantic role labeling",
    "authors": ["Kristina Toutanova", "Aria Haghighi", "Christopher Manning."],
    "venue": "Computational Linguistics, 34(2):161– 191.",
    "year": 2008
  }, {
    "title": "Calibrating features for semantic role labeling",
    "authors": ["Nianwen Xue", "Martha Palmer."],
    "venue": "Dekang Lin and Dekai Wu, editors, Proceedings of EMNLP 2004, pages 88–94, Barcelona, Spain, July. Association for Computational Linguistics.",
    "year": 2004
  }, {
    "title": "Multipredicate semantic role labeling",
    "authors": ["Haitong Yang", "Chengqing Zong."],
    "venue": "Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 363–373, Doha, Qatar, October. Association for Computational",
    "year": 2014
  }, {
    "title": "More accurate tests for the statistical significance of result differences",
    "authors": ["Alexander Yeh."],
    "venue": "Proceedings of the 18th conference on Computational linguisticsVolume 2. Association for Computational Linguistics.",
    "year": 2000
  }, {
    "title": "Selectional preferences for semantic role classification",
    "authors": ["Benat Zapirain", "Eneko Agirre", "Lluı́s Màrquez", "Mihai Surdeanu"],
    "venue": "Computational Linguistics,",
    "year": 2013
  }, {
    "title": "Greed is good if randomized: New inference for dependency parsing",
    "authors": ["Yuan Zhang", "Tao Lei", "Regina Barzilay", "Tommi Jaakkola."],
    "venue": "Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP). Association for",
    "year": 2014
  }, {
    "title": "Multilingual dependency learning: Exploiting rich features for tagging syntactic and semantic dependencies",
    "authors": ["Hai Zhao", "Wenliang Chen", "Jun’ichi Kazama", "Kiyotaka Uchimoto", "Kentaro Torisawa"],
    "venue": "In Proceedings of the Thirteenth Conference on Com-",
    "year": 2009
  }, {
    "title": "Multilingual dependency learning: A huge feature engineering method to semantic dependency parsing",
    "authors": ["Hai Zhao", "Wenliang Chen", "Chunyu Kity", "Guodong Zhou."],
    "venue": "Proceedings of the Thirteenth Conference on Computational Natural Language Learning",
    "year": 2009
  }],
  "id": "SP:ecdf475e610e2ae1e6c5ab0fd55b5f50a79dd85b",
  "authors": [{
    "name": "Tao Lei",
    "affiliations": []
  }, {
    "name": "Yuan Zhang",
    "affiliations": []
  }, {
    "name": "Lluı́s Màrquez",
    "affiliations": []
  }, {
    "name": "Alessandro Moschitti",
    "affiliations": []
  }, {
    "name": "Regina Barzilay",
    "affiliations": []
  }],
  "abstractText": "This paper introduces a tensor-based approach to semantic role labeling (SRL). The motivation behind the approach is to automatically induce a compact feature representation for words and their relations, tailoring them to the task. In this sense, our dimensionality reduction method provides a clear alternative to the traditional feature engineering approach used in SRL. To capture meaningful interactions between the argument, predicate, their syntactic path and the corresponding role label, we compress each feature representation first to a lower dimensional space prior to assessing their interactions. This corresponds to using an overall cross-product feature representation and maintaining associated parameters as a four-way low-rank tensor. The tensor parameters are optimized for the SRL performance using standard online algorithms. Our tensor-based approach rivals the best performing system on the CoNLL-2009 shared task. In addition, we demonstrate that adding the representation tensor to a competitive tensorfree model yields 2% absolute increase in Fscore.1",
  "title": "High-Order Low-Rank Tensors for Semantic Role Labeling"
}