{
  "sections": [{
    "text": "Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics, pages 484–495 Vancouver, Canada, July 30 - August 4, 2017. c©2017 Association for Computational Linguistics\nhttps://doi.org/10.18653/v1/P17-1045"
  }, {
    "heading": "1 Introduction",
    "text": "The design of intelligent assistants which interact with users in natural language ranks high on the agenda of current NLP research. With an increasing focus on the use of statistical and machine learning based approaches (Young et al., 2013), the last few years have seen some truly remarkable conversational agents appear on the market (e.g. Apple Siri, Microsoft Cortana, Google Allo). These agents can perform simple tasks, answer\n1The source code is available at: https://github. com/MiuLab/KB-InfoBot\nfactual questions, and sometimes also aimlessly chit-chat with the user, but they still lag far behind a human assistant in terms of both the variety and complexity of tasks they can perform. In particular, they lack the ability to learn from interactions with a user in order to improve and adapt with time. Recently, Reinforcement Learning (RL) has been explored to leverage user interactions to adapt various dialogue agents designed, respectively, for task completion (Gašić et al., 2013), information access (Wen et al., 2016b), and chitchat (Li et al., 2016a).\nWe focus on KB-InfoBots, a particular type of dialogue agent that helps users navigate a Knowledge Base (KB) in search of an entity, as illustrated by the example in Figure 1. Such agents must necessarily query databases in order to retrieve the requested information. This is usually done by performing semantic parsing on the input to construct a symbolic query representing the beliefs of the agent about the user goal, such as Wen et al. (2016b), Williams and Zweig (2016), and Li et al. (2017)’s work. We call such an operation a Hard-KB lookup. While natural, this approach has two drawbacks: (1) the retrieved results do not carry any information about uncertainty in semantic parsing, and (2) the retrieval operation is non differentiable, and hence the parser and dialog policy are trained separately. This makes online endto-end learning from user feedback difficult once the system is deployed.\nIn this work, we propose a probabilistic framework for computing the posterior distribution of the user target over a knowledge base, which we term a Soft-KB lookup. This distribution is constructed from the agent’s belief about the attributes of the entity being searched for. The dialogue policy network, which decides the next system action, receives as input this full distribution instead of a handful of retrieved results. We show in our ex-\n484\nperiments that this framework allows the agent to achieve a higher task success rate in fewer dialogue turns. Further, the retrieval process is differentiable, allowing us to construct an end-to-end trainable KB-InfoBot, all of whose components are updated online using RL.\nReinforcement learners typically require an environment to interact with, and hence static dialogue corpora cannot be used for their training. Running experiments on human subjects, on the other hand, is unfortunately too expensive. A common workaround in the dialogue community (Young et al., 2013; Schatzmann et al., 2007b; Scheffler and Young, 2002) is to instead use user simulators which mimic the behavior of real users in a consistent manner. For training KB-InfoBot, we adapt the publicly available2 simulator described in Li et al. (2016b).\nEvaluation of dialogue agents has been the subject of much research (Walker et al., 1997; Möller et al., 2006). While the metrics for evaluating an InfoBot are relatively clear — the agent should return the correct entity in a minimum number of turns — the environment for testing it not so much. Unlike previous KB-based QA systems, our focus is on multi-turn interactions, and as such there are no publicly available benchmarks for this problem. We evaluate several versions of KB-InfoBot with the simulator and on real users, and show that the proposed Soft-KB lookup helps the reinforcement learner discover better dialogue policies. Initial experiments on the end-to-end agent also demonstrate its strong learning capability.\n2 https://github.com/MiuLab/TC-Bot"
  }, {
    "heading": "2 Related Work",
    "text": "Our work is motivated by the neural GenQA (Yin et al., 2016a) and neural enquirer (Yin et al., 2016b) models for querying KBs via natural language in a fully “neuralized” way. However, the key difference is that these systems assume that users can compose a complicated, compositional natural language query that can uniquely identify the element/answer in the KB. The research task is to parse the query, i.e., turning the natural language query into a sequence of SQL-like operations. Instead we focus on how to query a KB interactively without composing such complicated queries in the first place. Our work is motivated by the observations that (1) users are more used to issuing simple queries of length less than 5 words (Spink et al., 2001); (2) in many cases, it is unreasonable to assume that users can construct compositional queries without prior knowledge of the structure of the KB to be queried.\nAlso related is the growing body of literature focused on building end-to-end dialogue systems, which combine feature extraction and policy optimization using deep neural networks. Wen et al. (2016b) introduced a modular neural dialogue agent, which uses a Hard-KB lookup, thus breaking the differentiability of the whole system. As a result, training of various components of the dialogue system is performed separately. The intent network and belief trackers are trained using supervised labels specifically collected for them; while the policy network and generation network are trained separately on the system utterances. We retain modularity of the network by keeping the belief trackers separate, but replace the hard lookup with a differentiable one.\nDialogue agents can also interface with the database by augmenting their output action space with predefined API calls (Williams and Zweig, 2016; Zhao and Eskenazi, 2016; Bordes and Weston, 2016; Li et al., 2017). The API calls modify a query hypothesis maintained outside the end-toend system which is used to retrieve results from this KB. This framework does not deal with uncertainty in language understanding since the query hypothesis can only hold one slot-value at a time. Our approach, on the other hand, directly models the uncertainty to construct the posterior over the KB.\nWu et al. (2015) presented an entropy minimization dialogue management strategy for In-\nfoBots. The agent always asks for the value of the slot with maximum entropy over the remaining entries in the database, which is optimal in the absence of language understanding errors, and serves as a baseline against our approach. Reinforcement learning neural turing machines (RLNTM) (Zaremba and Sutskever, 2015) also allow neural controllers to interact with discrete external interfaces. The interface considered in that work is a one-dimensional memory tape, while in our work it is an entity-centric KB."
  }, {
    "heading": "3 Probabilistic KB Lookup",
    "text": "This section describes a probabilistic framework for querying a KB given the agent’s beliefs over the fields in the KB."
  }, {
    "heading": "3.1 Entity-Centric Knowledge Base (EC-KB)",
    "text": "A Knowledge Base consists of triples of the form (h, r, t), which denotes that relation r holds between the head h and tail t. We assume that the KB-InfoBot has access to a domain-specific entity-centric knowledge base (EC-KB) (Zwicklbauer et al., 2013) where all head entities are of a particular type (such as movies or persons), and the relations correspond to attributes of these head entities. Such a KB can be converted to a table format whose rows correspond to the unique head entities, columns correspond to the unique relation types (slots henceforth), and some entries may be missing. An example is shown in Figure 1."
  }, {
    "heading": "3.2 Notations and Assumptions",
    "text": "Let T denote the KB table described above and Ti,j denote the jth slot-value of the ith entity. 1 ≤ i ≤ N and 1 ≤ j ≤M . We let V j denote the vocabulary of each slot, i.e. the set of all distinct values in the j-th column. We denote missing values from the table with a special token and write Ti,j = Ψ. Mj = {i : Ti,j = Ψ} denotes the set of entities for which the value of slot j is missing. Note that the user may still know the actual value of Ti,j , and we assume this lies in V j . We do not deal with new entities or relations at test time.\nWe assume a uniform prior G ∼ U [{1, ...N}] over the rows in the table T , and let binary random variables Φj ∈ {0, 1} indicate whether the user knows the value of slot j or not. The agent maintains M multinomial distributions ptj(v) for v ∈ V j denoting the probability at turn t that the user constraint for slot j is v, given their utterances\nU t1 till that turn. The agent also maintains M binomials qtj = Pr(Φj = 1) which denote the probability that the user knows the value of slot j.\nWe assume that column values are independently distributed to each other. This is a strong assumption but it allows us to model the user goal for each slot independently, as opposed to modeling the user goal over KB entities directly. Typically maxj |V j | < N and hence this assumption reduces the number of parameters in the model."
  }, {
    "heading": "3.3 Soft-KB Lookup",
    "text": "Let ptT (i) = Pr(G = i|U t1) be the posterior probability that the user is interested in row i of the table, given the utterances up to turn t. We assume all probabilities are conditioned on user inputs U t1 and drop it from the notation below. From our assumption of independence of slot values, we can write ptT (i) ∝ ∏M j=1 Pr(Gj = i), where Pr(Gj = i) denotes the posterior probability of user goal for slot j pointing to Ti,j . Marginalizing this over Φj gives:\nPr(Gj = i) =\n1∑\nφ=0\nPr(Gj = i,Φj = φ) (1)\n= qtj Pr(Gj = i|Φj = 1)+ (1− qtj) Pr(Gj = i|Φj = 0).\nFor Φj = 0, the user does not know the value of the slot, and from the prior:\nPr(Gj = i|Φj = 0) = 1\nN , 1 ≤ i ≤ N (2)\nFor Φj = 1, the user knows the value of slot j, but this may be missing from T , and we again have two cases:\nPr(Gj = i|Φj = 1) = { 1 N , i ∈Mj\nptj(v) Nj(v)\n( 1− |Mj |\nN\n) , i 6∈Mj (3)\nHere, Nj(v) is the count of value v in slot j. Detailed derivation for (3) is provided in Appendix A. Combining (1), (2), and (3) gives us the procedure for computing the posterior over KB entities."
  }, {
    "heading": "4 Towards an End-to-End-KB-InfoBot",
    "text": "We claim that the Soft-KB lookup method has two benefits over the Hard-KB method – (1) it helps the agent discover better dialogue policies by providing it more information from the language understanding unit, (2) it allows end-to-end training of both dialogue policy and language understanding in an online setting. In this section we describe several agents to test these claims."
  }, {
    "heading": "4.1 Overview",
    "text": "Figure 2 shows an overview of the components of the KB-InfoBot. At each turn, the agent receives a natural language utterance ut as input, and selects an action at as output. The action space, denoted byA, consists ofM+1 actions — request(slot=i) for 1 ≤ i ≤ M will ask the user for the value of slot i, and inform(I) will inform the user with an ordered list of results I from the KB. The dialogue ends once the agent chooses inform.\nWe adopt a modular approach, typical to goaloriented dialogue systems (Wen et al., 2016b), consisting of: a belief tracker module for identifying user intents, extracting associated slots, and tracking the dialogue state (Yao et al., 2014; Hakkani-Tür et al., 2016; Chen et al., 2016b; Henderson et al., 2014; Henderson, 2015); an interface with the database to query for relevant results (Soft-KB lookup); a summary module to summarize the state into a vector; a dialogue policy which selects the next system action based on current state (Young et al., 2013). We assume the agent only responds with dialogue acts. A templatebased Natural Language Generator (NLG) can be easily constructed for converting dialogue acts into natural language."
  }, {
    "heading": "4.2 Belief Trackers",
    "text": "The InfoBot consists of M belief trackers, one for each slot, which get the user input xt and produce two outputs, ptj and q t j , which we shall collectively call the belief state: ptj is a multinomial distribution over the slot values v, and qtj is a scalar probability of the user knowing the value of slot j. We describe two versions of the belief tracker.\nHand-Crafted Tracker: We first identify mentions of slot-names (such as “actor”) or slot-values (such as “Bill Murray”) from the user input ut, using token-level keyword search. Let {w ∈ x} de-\nnote the set of tokens in a string x3, then for each slot in 1 ≤ j ≤ M and each value v ∈ V j , we compute its matching score as follows:\nstj [v] = |{w ∈ ut} ∩ {w ∈ v}|\n|{w ∈ v}| (4)\nA similar score btj is computed for the slot-names. A one-hot vector reqt ∈ {0, 1}M denotes the previously requested slot from the agent, if any. qtj is set to 0 if reqt[j] is 1 but stj [v] = 0 ∀v ∈ V j , i.e. the agent requested for a slot but did not receive a valid value in return, else it is set to 1.\nStarting from an prior distribution p0j (based on the counts of the values in the KB), ptj [v] is updated as:\nptj [v] ∝ pt−1j [v] + C ( stj [v] + b t j + 1(req t[j] = 1) ) (5)\nHere C is a tuning parameter, and the normalization is given by setting the sum over v to 1.\nNeural Belief Tracker: For the neural tracker the user input ut is converted to a vector representation xt, using a bag of n-grams (with n = 2) representation. Each element of xt is an integer indicating the count of a particular n-gram in ut. We let V n denote the number of unique n-grams, hence xt ∈ NV n0 .\nRecurrent neural networks have been used for belief tracking (Henderson et al., 2014; Wen et al., 2016b) since the output distribution at turn t depends on all user inputs till that turn. We use a Gated Recurrent Unit (GRU) (Cho et al., 2014) for each tracker, which, starting from h0j = 0 computes htj = GRU(x\n1, . . . , xt) (see Appendix B for details). htj ∈ Rd can be interpreted as a summary of what the user has said about slot j till turn t. The belief states are computed from this vector as follows:\nptj = softmax(W p j h t j + b p j ) (6) qtj = σ(W Φ j h t j + b Φ j ) (7)\nHere W pj ∈ RV j×d, bpj ∈ RV j , WΦj ∈ Rd and bΦj ∈ R, are trainable parameters."
  }, {
    "heading": "4.3 Soft-KB Lookup + Summary",
    "text": "This module uses the Soft-KB lookup described in section 3.3 to compute the posterior ptT ∈ RN over the EC-KB from the belief states (ptj , q t j).\n3We use the NLTK tokenizer available at http://www. nltk.org/api/nltk.tokenize.html\nCollectively, outputs of the belief trackers and the soft-KB lookup can be viewed as the current dialogue state internal to the KB-InfoBot. Let st = [pt1, p t 2, ..., p t M , q t 1, q t 2, ..., q t M , p t T ] be the vector of\nsize ∑\nj V j+M+N denoting this state. It is pos-\nsible for the agent to directly use this state vector to select its next action at. However, the large size of the state vector would lead to a large number of parameters in the policy network. To improve efficiency we extract summary statistics from the belief states, similar to (Williams and Young, 2005).\nEach slot is summarized into an entropy statistic over a distribution wtj computed from elements of the KB posterior ptT as follows:\nwtj(v) ∝ ∑\ni:Ti,j=v ptT (i) + p 0 j (v)\n∑\ni:Ti,j=Ψ ptT (i) .\n(8) Here, p0j is a prior distribution over the values of slot j, estimated using counts of each value in the KB. The probability mass of v in this distribution is the agent’s confidence that the user goal has value v in slot j. This two terms in (8) correspond to rows in KB which have value v, and rows whose value is unknown (weighted by the prior probability that an unknown might be v). Then the summary statistic for slot j is the entropy H(wtj). The KB posterior ptT is also summarized into an entropy statistic H(ptT ).\nThe scalar probabilities qtj are passed as is to the dialogue policy, and the final summary vector is s̃t = [H(p̃t1), ...,H(p̃ t M ), q t 1, ..., q t M , H(p t T )]. Note that this vector has size 2M + 1."
  }, {
    "heading": "4.4 Dialogue Policy",
    "text": "The dialogue policy’s job is to select the next action based on the current summary state s̃t and the dialogue history. We present a hand-crafted baseline and a neural policy network.\nHand-Crafted Policy: The rule based policy is adapted from (Wu et al., 2015). It asks for the slot ĵ = arg minH(p̃tj) with the minimum entropy, except if – (i) the KB posterior entropy H(ptT ) < αR, (ii) H(p̃ t j) < min(αT , βH(p̃ 0 j ), (iii) slot j has already been requestedQ times. αR, αT , β,Q are tuned to maximize reward against the simulator.\nNeural Policy Network: For the neural approach, similar to (Williams and Zweig, 2016; Zhao and Eskenazi, 2016), we use an RNN to allow the network to maintain an internal state of\ndialogue history. Specifically, we use a GRU unit followed by a fully-connected layer and softmax nonlinearity to model the policy π over actions in A (W π ∈ R|A|×d, bπ ∈ R|A|):\nhtπ = GRU(s̃ 1, ..., s̃t) (9) π = softmax(W πhtπ + b π) . (10)\nDuring training, the agent samples its actions from the policy to encourage exploration. If this action is inform(), it must also provide an ordered set of entities indexed by I = (i1, i2, . . . , iR) in the KB to the user. This is done by sampling R items from the KB-posterior ptT . This mimics a search engine type setting, where R may be the number of results on the first page."
  }, {
    "heading": "5 Training",
    "text": "Parameters of the neural components (denoted by θ) are trained using the REINFORCE algorithm (Williams, 1992). We assume that the learner has access to a reward signal rt throughout the course of the dialogue, details of which are in the next section. We can write the expected discounted return of the agent under policy π as J(θ) = Eπ [∑H t=0 γ trt ] (γ is the discounting factor). We also use a baseline reward signal b, which is the average of all rewards in a batch, to reduce the variance in the updates (Greensmith et al., 2004). When only training the dialogue policy π using this signal, updates are given by (details in Appendix C):\n∇θJ(θ) = Eπ [ H∑\nk=0\n∇θ log πθ(ak) H∑\nt=0\nγt(rt−b) ] ,\n(11) For end-to-end training we need to update both the dialogue policy and the belief trackers using the reinforcement signal, and we can view the retrieval as another policy µθ (see Appendix C). The updates are given by:\n∇θJ(θ) =Ea∼π,I∼µ [( ∇θ logµθ(I)+\nH∑\nh=0\n∇θ log πθ(ah) ) H∑\nk=0\nγk(rk − b) ] ,\n(12)\nIn the case of end-to-end learning, we found that for a moderately sized KB, the agent almost always fails if starting from random initialization.\nIn this case, credit assignment is difficult for the agent, since it does not know whether the failure is due to an incorrect sequence of actions or incorrect set of results from the KB. Hence, at the beginning of training we have an Imitation Learning (IL) phase where the belief trackers and policy network are trained to mimic the hand-crafted agents. Assume that p̂tj and q̂ t j are the belief states from a rule-based agent, and ât its action at turn t. Then the loss function for imitation learning is: L(θ) = E [ D(p̂tj ||ptj(θ))+H(q̂tj , qtj(θ))−log πθ(ât) ]\nD(p||q) and H(p, q) denote the KL divergence and cross-entropy between p and q respectively.\nThe expectations are estimated using a minibatch of dialogues of size B. For RL we use RMSProp (Hinton et al., 2012) and for IL we use vanilla SGD updates to train the parameters θ."
  }, {
    "heading": "6 Experiments and Results",
    "text": "Previous work in KB-based QA has focused on single-turn interactions and is not directly comparable to the present study. Instead we compare different versions of the KB-InfoBot described above to test our claims."
  }, {
    "heading": "6.1 KB-InfoBot versions",
    "text": "We have described two belief trackers – (A) HandCrafted and (B) Neural, and two dialogue policies – (C) Hand-Crafted and (D) Neural.\nRule agents use the hand-crafted belief trackers and hand-crafted policy (A+C). RL agents use the hand-crafted belief trackers and the neural policy (A+D). We compare three variants of both sets of agents, which differ only in the inputs to the dialogue policy. The No-KB version only takes entropy H(p̂tj) of each of the slot distributions. The Hard-KB version performs a hard-KB lookup and selects the next action based on the entropy of the slots over retrieved results. This is the same approach as in Wen et al. (2016b), except that we take entropy instead of summing probabilities. The Soft-KB version takes summary statistics of the slots and KB posterior described in Section 4. At the end of the dialogue, all versions inform the user with the top results from the KB posterior ptT , hence the difference only lies in the policy for action selection. Lastly, the E2E agent uses the neural belief tracker and the neural policy (B+D), with a Soft-KB lookup. For the RL agents, we also append q̂tj and a one-hot encoding of the previous\nagent action to the policy network input. Hyperparameter details for the agents are provided in Appendix D."
  }, {
    "heading": "6.2 User Simulator",
    "text": "Training reinforcement learners is challenging because they need an environment to operate in. In the dialogue community it is common to use simulated users for this purpose (Schatzmann et al., 2007a,b; Cuayáhuitl et al., 2005; Asri et al., 2016). In this work we adapt the publicly-available user simulator presented in Li et al. (2016b) to follow a simple agenda while interacting with the KB-InfoBot, as well as produce natural language utterances . Details about the simulator are included in Appendix E. During training, the simulated user also provides a reward signal at the end of each dialogue. The dialogue is a success if the user target is in top R = 5 results returned by the agent; and the reward is computed as max(0, 2(1 − (r − 1)/R)), where r is the actual rank of the target. For a failed dialogue the agent receives a reward of −1, and at each turn it receives a reward of −0.1 to encourage short sessions4. The maximum length of a dialogue is 10 turns beyond which it is deemed a failure."
  }, {
    "heading": "6.3 Movies-KB",
    "text": "We use a movie-centric KB constructed using the IMDBPy5 package. We constructed four different splits of the dataset, with increasing number of entities, whose statistics are given in Table 1. The original KB was modified to reduce the number of actors and directors in order to make the task more challenging6. We randomly remove 20% of the values from the agent’s copy of the KB to simulate a scenario where the KB may be incomplete. The user, however, may still know these values.\n4A turn consists of one user action and one agent action. 5http://imdbpy.sourceforge.net/ 6We restricted the vocabulary to the first few unique values of these slots and replaced all other values with a random value from this set."
  }, {
    "heading": "6.4 Simulated User Evaluation",
    "text": "We compare each of the discussed versions along three metrics: the average rewards obtained (R), success rate (S) (where success is defined as providing the user target among top R results), and the average number of turns per dialogue (T). For the RL and E2E agents, during training we fix the model every 100 updates and run 2000 simulations with greedy action selection to evaluate its performance. Then after training we select the model with the highest average reward and run a further 5000 simulations and report the performance in Table 2. For reference we also show the performance of an agent which receives perfect information about the user target without any errors, and selects actions based on the entropy of the slots (Max). This can be considered as an upper bound on the performance of any agent (Wu et al., 2015).\nIn each case the Soft-KB versions achieve the highest average reward, which is the metric all agents optimize. In general, the trade-off between minimizing average turns and maximizing success rate can be controlled by changing the reward signal. Note that, except the E2E version, all versions share the same belief trackers, but by re-asking values of some slots they can have different posteriors ptT to inform the results. This shows that having full information about the current state of beliefs over the KB helps the Soft-KB agent discover better policies. Further, reinforcement learning helps discover better policies than the handcrafted rule-based agents, and we see a higher reward for RL agents compared to Rule ones. This is due to the noisy natural language inputs; with perfect information the rule-based strategy is optimal. Interestingly, the RL-Hard agent has the minimum number of turns in 2 out of the 4 settings, at the cost of a lower success rate and average reward. This agent does not receive any information about the uncertainty in semantic parsing, and it tends to\ninform as soon as the number of retrieved results becomes small, even if they are incorrect.\nAmong the Soft-KB agents, we see that E2E>RL>Rule, except for the X-Large KB. For E2E, the action space grows exponentially with the size of the KB, and hence credit assignment gets more difficult. Future work should focus on improving the E2E agent in this setting. The difficulty of a KB-split depends on number of entities it has, as well as the number of unique values for each slot (more unique values make the problem easier). Hence we see that both the “Small” and “X-Large” settings lead to lower reward for the agents, since maxj |V\nj | N is small for them."
  }, {
    "heading": "6.5 Human Evaluation",
    "text": "We further evaluate the KB-InfoBot versions trained using the simulator against real subjects, recruited from the author’s affiliations. In each session, in a typed interaction, the subject was first presented with a target movie from the “Medium” KB-split along with a subset of its associated slot-\nvalues from the KB. To simulate the scenario where end-users may not know slot values correctly, the subjects in our evaluation were presented multiple values for the slots from which they could choose any one while interacting with the agent. Subjects were asked to initiate the conversation by specifying some of these values, and respond to the agent’s subsequent requests, all in natural language. We test RL-Hard and the three Soft-KB agents in this study, and in each session one of the agents was picked at random for testing. In total, we collected 433 dialogues, around 20 per subject. Figure 3 shows a comparison of these agents in terms of success rate and number of turns, and Figure 4 shows some sample dialogues from the user interactions with RL-Soft.\nIn comparing Hard-KB versus Soft-KB lookup methods we see that both Rule-Soft and RL-Soft agents achieve a higher success rate than RL-Hard, while E2E-Soft does comparably. They do so in an increased number of average turns, but achieve a higher average reward as well. Between RL-Soft and Rule-Soft agents, the success rate is similar, however the RL agent achieves that rate in a lower number of turns on average. RL-Soft achieves a success rate of 74% on the human evaluation and 80% against the simulated user, indicating minimal overfitting. However, all agents take a higher number of turns against real users as compared to the simulator, due to the noisier inputs.\nThe E2E gets the highest success rate against the simulator, however, when tested against real users it performs poorly with a lower success rate and a higher number of turns. Since it has more trainable components, this agent is also most prone to overfitting. In particular, the vocabulary of the simulator it is trained against is quite limited (V n = 3078), and hence when real users\nprovided inputs outside this vocabulary, it performed poorly. In the future we plan to fix this issue by employing a better architecture for the language understanding and belief tracker components Hakkani-Tür et al. (2016); Liu and Lane (2016); Chen et al. (2016b,a), as well as by pretraining on separate data.\nWhile its generalization performance is poor, the E2E system also exhibits the strongest learning capability. In Figure 5, we compare how different agents perform against the simulator as the temperature of the output softmax in its NLG is increased. A higher temperature means a more uniform output distribution, which leads to generic simulator responses irrelevant to the agent questions. This is a simple way of introducing noise in the utterances. The performance of all agents drops as the temperature is increased, but less so for the E2E agent, which can adapt its belief tracker to the inputs it receives. Such adaptation\nis key to the personalization of dialogue agents, which motivates us to introduce the E2E agent."
  }, {
    "heading": "7 Conclusions and Discussion",
    "text": "This work is aimed at facilitating the move towards end-to-end trainable dialogue agents for information access. We propose a differentiable probabilistic framework for querying a database given the agent’s beliefs over its fields (or slots). We show that such a framework allows the downstream reinforcement learner to discover better dialogue policies by providing it more information. We also present an E2E agent for the task, which demonstrates a strong learning capacity in simulations but suffers from overfitting when tested on real users. Given these results, we propose the following deployment strategy that allows a dialogue system to be tailored to specific users via learning from agent-user interactions. The system could start off with an RL-Soft agent (which gives good performance out-of-the-box). As the user interacts with this agent, the collected data can be used to train the E2E agent, which has a strong learning capability. Gradually, as more experience is collected, the system can switch from RL-Soft to the personalized E2E agent. Effective implementation of this, however, requires the E2E agent to learn quickly and this is the research direction we plan to focus on in the future."
  }, {
    "heading": "Acknowledgements",
    "text": "We would like to thank Dilek Hakkani-Tür and reviewers for their insightful comments on the paper. We would also like to acknowledge the volunteers from Carnegie Mellon University and Microsoft Research for helping us with the human evaluation. Yun-Nung Chen is supported by the Ministry of Science and Technology of Taiwan under the contract number 105-2218-E-002-033, Institute for Information Industry, and MediaTek."
  }, {
    "heading": "A Posterior Derivation",
    "text": "Here, we present a derivation for equation 3, i.e., the posterior over the KB slot when the user knows the value of that slot. For brevity, we drop Φj = 0 from the condition in all probabilities below. For the case when i ∈Mj , we can write:\nPr(Gj = i)\n= Pr(Gj ∈Mj) Pr(Gj = i|Gj ∈Mj) = |Mj | N 1 |Mj | = 1 N , (13)\nwhere we assume all missing values to be equally likely, and estimate the prior probability of the goal being missing from the count of missing values in that slot. For the case when i = v 6∈Mj :\nPr(Gj = i)\n= Pr(Gj 6∈Mj) Pr(Gj = i|Gj 6∈Mj)\n= ( 1− |Mj |\nN\n) × ptj(v)\nNj(v) , (14)\nwhere the second term comes from taking the probability mass associated with v in the belief tracker and dividing it equally among all rows with value v.\nWe can also verify that the above distribution is valid: i.e., it sums to 1:\n∑\ni\nPr(Gj = i)\n= ∑\ni∈Mj Pr(Gj = i) +\n∑\ni 6∈Mj Pr(Gj = i)\n= ∑\ni∈Mj\n1 N + ∑\ni 6∈Mj\n( 1− |Mj |\nN\n) ptj(v)\n#jv\n= |Mj | N +\n( 1− |Mj |\nN\n) ∑\ni 6∈Mj\nptj(v)\n#jv\n= |Mj | N +\n( 1− |Mj |\nN\n)∑\ni∈V j #jv\nptj(v)\n#jv\n= |Mj | N +\n( 1− |Mj |\nN\n) × 1\n= 1 ."
  }, {
    "heading": "B Gated Recurrent Units",
    "text": "A Gated Recurrent Unit (GRU) (Cho et al., 2014) is a recurrent neural network which operates on an input sequence x1, . . . , xt. Starting from an initial\nstate h0 (usually set to 0 it iteratively computes the final output ht as follows:\nrt = σ(Wrxt + Urht−1 + br)\nzt = σ(Wzxt + Uzht−1 + bz)\nh̃t = tanh(Whxt + Uh(rt ht−1) + bh) ht = (1− zt) ht−1 + zt h̃t . (15)\nHere σ denotes the sigmoid nonlinearity, and an element-wise product."
  }, {
    "heading": "C REINFORCE updates",
    "text": "We assume that the learner has access to a reward signal rt throughout the course of the dialogue, details of which are in the next section. We can write the expected discounted return of the agent under policy π as follows:\nJ(θ) = E\n[ H∑\nt=0\nγtrt ] (16)\nHere, the expectation is over all possible trajectories τ of the dialogue, θ denotes the trainable parameters of the learner, H is the maximum length of an episode, and γ is the discounting factor. We can use the likelihood ratio trick (Glynn, 1990) to write the gradient of the objective as follows:\n∇θJ(θ) = E [ ∇θ log pθ(τ) H∑\nt=0\nγtrt ] , (17)\nwhere pθ(τ) is the probability of observing a particular trajectory under the current policy. With a Markovian assumption, we can write\npθ(τ) = p(s0) H∏\nk=0\np(sk+1|sk, ak)πθ(ak|sk),\n(18) where θ denotes dependence on the neural network parameters. From 17,18 we obtain\n∇θJ(θ) = Ea∼π [ H∑\nk=0\n∇θ log πθ(ak) H∑\nt=0\nγtrt ] ,\n(19) If we need to train both the policy network and the belief trackers using the reinforcement signal, we can view the KB posterior ptT as another policy. During training then, to encourage exploration, when the agent selects the inform action we\nsampleR results from the following distribution to return to the user:\nµ(I) = ptT (i1)× ptT (i2)\n1− ptT (i1) × · · · . (20)\nThis formulation also leads to a modified version of the episodic REINFORCE update rule (Williams, 1992). Specifically, eq. 18 now becomes,\npθ(τ) = [ p(s0) H∏\nk=0\np(sk+1|sk, ak)πθ(ak|sk) ] µθ(I),\n(21) Notice the last term µθ above which is the posterior of a set of results from the KB. From 17,21 we obtain\n∇θJ(θ) =Ea∼π,I∼µ [( ∇θ logµθ(I)+\nH∑\nh=0\n∇θ log πθ(ah) ) H∑\nk=0\nγkrk ] , (22)"
  }, {
    "heading": "D Hyperparameters",
    "text": "We use GRU hidden state size of d = 50 for the RL agents and d = 100 for the E2E, a learning rate of 0.05 for the imitation learning phase and 0.005 for the reinforcement learning phase, and minibatch size 128. For the rule agents, hyperparameters were tuned to maximize the average reward of each agent in simulations. For the E2E agent, imitation learning was performed for 500 updates, after which the agent switched to reinforcement learning. The input vocabulary is constructed from the NLG vocabulary and bigrams in the KB, and its size is 3078."
  }, {
    "heading": "E User Simulator",
    "text": "At the beginning of each dialogue, the simulated user randomly samples a target entity from the ECKB and a random combination of informable slots for which it knows the value of the target. The remaining slot-values are unknown to the user. The user initiates the dialogue by providing a subset of its informable slots to the agent and requesting for an entity which matches them. In subsequent turns, if the agent requests for the value of a slot, the user complies by providing it or informs the agent that it does not know that value. If the agent informs results from the KB, the simulator checks whether the target is among them and provides the reward.\nWe convert dialogue acts from the user into natural language utterances using a separately trained natural language generator (NLG). The NLG is trained in a sequence-to-sequence fashion, using conversations between humans collected by crowd-sourcing. It takes the dialogue actions (DAs) as input, and generates template-like sentences with slot placeholders via an LSTM decoder. Then, a post-processing scan is performed to replace the slot placeholders with their actual values, which is similar to the decoder module in (Wen et al., 2015, 2016a). In the LSTM decoder, we apply beam search, which iteratively considers the top k best sentences up to time step t when generating the token of the time step t+ 1. For the sake of the trade-off between the speed and performance, we use the beam size of 3 in the following experiments.\nThere are several sources of error in user utterances. Any value provided by the user may be corrupted by noise, or substituted completely with an incorrect value of the same type (e.g., “Bill Murray” might become just “Bill” or “Tom Cruise”). The NLG described above is inherently stochastic, and may sometimes generate utterances irrelevant to the agent request. By increasing the temperature of the output softmax in the NLG we can increase the noise in user utterances."
  }],
  "year": 2017,
  "references": [{
    "title": "A sequence-to-sequence model for user simulation in spoken dialogue systems",
    "authors": ["Layla El Asri", "Jing He", "Kaheer Suleman."],
    "venue": "arXiv preprint arXiv:1607.00070 .",
    "year": 2016
  }, {
    "title": "Learning end-to-end goal-oriented dialog",
    "authors": ["Antoine Bordes", "Jason Weston."],
    "venue": "arXiv preprint arXiv:1605.07683 .",
    "year": 2016
  }, {
    "title": "End-to-end memory networks with knowledge carryover for multi-turn spoken language understanding",
    "authors": ["Yun-Nung Chen", "Dilek Hakkani-Tür", "Gokhan Tur", "Jianfeng Gao", "Li Deng."],
    "venue": "Proceedings of The 17th Annual Meeting of the Interna-",
    "year": 2016
  }, {
    "title": "Learning phrase representations using rnn encoder-decoder for statistical machine translation",
    "authors": ["Kyunghyun Cho", "Bart Van Merriënboer", "Caglar Gulcehre", "Dzmitry Bahdanau", "Fethi Bougares", "Holger Schwenk", "Yoshua Bengio."],
    "venue": "EMNLP .",
    "year": 2014
  }, {
    "title": "Human-computer dialogue simulation using hidden markov models",
    "authors": ["Heriberto Cuayáhuitl", "Steve Renals", "Oliver Lemon", "Hiroshi Shimodaira."],
    "venue": "Automatic Speech Recognition and Understanding, 2005 IEEE Workshop on. IEEE, pages 290–295.",
    "year": 2005
  }, {
    "title": "Online policy optimisation of bayesian spoken dialogue systems via human interaction",
    "authors": ["M Gašić", "Catherine Breslin", "Matthew Henderson", "Dongho Kim", "Martin Szummer", "Blaise Thomson", "Pirros Tsiakoulis", "Steve Young."],
    "venue": "2013 IEEE Inter-",
    "year": 2013
  }, {
    "title": "Likelihood ratio gradient estimation for stochastic systems",
    "authors": ["Peter W Glynn."],
    "venue": "Communications of the ACM 33(10):75–84.",
    "year": 1990
  }, {
    "title": "Variance reduction techniques for gradient estimates in reinforcement learning",
    "authors": ["Evan Greensmith", "Peter L Bartlett", "Jonathan Baxter."],
    "venue": "Journal of Machine Learning Research 5(Nov):1471–1530.",
    "year": 2004
  }, {
    "title": "Multi-domain joint semantic frame parsing using bi-directional RNN-LSTM",
    "authors": ["Dilek Hakkani-Tür", "Gokhan Tur", "Asli Celikyilmaz", "Yun-Nung Chen", "Jianfeng Gao", "Li Deng", "YeYi Wang."],
    "venue": "Proceedings of The 17th Annual Meeting of the Interna-",
    "year": 2016
  }, {
    "title": "Machine learning for dialog state tracking: A review",
    "authors": ["Matthew Henderson."],
    "venue": "Machine Learning in Spoken Language Processing Workshop .",
    "year": 2015
  }, {
    "title": "Word-based dialog state tracking with recurrent neural networks",
    "authors": ["Matthew Henderson", "Blaise Thomson", "Steve Young."],
    "venue": "Proceedings of the 15th Annual Meeting of the Special Interest Group on Discourse and Dialogue (SIGDIAL). pages 292–",
    "year": 2014
  }, {
    "title": "Lecture 6a overview of mini–batch gradient descent",
    "authors": ["Geoffrey Hinton", "N Srivastava", "Kevin Swersky."],
    "venue": "Coursera Lecture slides https://class. coursera. org/neuralnets-2012-001/lecture,[Online .",
    "year": 2012
  }, {
    "title": "Deep reinforcement learning for dialogue generation",
    "authors": ["Jiwei Li", "Will Monroe", "Alan Ritter", "Michel Galley", "Jianfeng Gao", "Dan Jurafsky."],
    "venue": "EMNLP .",
    "year": 2016
  }, {
    "title": "A user simulator for task-completion dialogues",
    "authors": ["Xiujun Li", "Zachary C Lipton", "Bhuwan Dhingra", "Lihong Li", "Jianfeng Gao", "Yun-Nung Chen."],
    "venue": "arXiv preprint arXiv:1612.05688 .",
    "year": 2016
  }, {
    "title": "End-to-end task-completion neural dialogue systems",
    "authors": ["Xuijun Li", "Yun-Nung Chen", "Lihong Li", "Jianfeng Gao."],
    "venue": "arXiv preprint arXiv:1703.01008 .",
    "year": 2017
  }, {
    "title": "Attention-based recurrent neural network models for joint intent detection and slot filling",
    "authors": ["Bing Liu", "Ian Lane."],
    "venue": "Interspeech 2016 pages 685–689.",
    "year": 2016
  }, {
    "title": "Memo: towards automatic usability evaluation of spoken dialogue services by user error",
    "authors": ["Sebastian Möller", "Roman Englert", "Klaus-Peter Engelbrecht", "Verena Vanessa Hafner", "Anthony Jameson", "Antti Oulasvirta", "Alexander Raake", "Norbert Reithinger"],
    "year": 2006
  }, {
    "title": "Agenda-based user simulation for bootstrapping a pomdp dialogue system",
    "authors": ["Jost Schatzmann", "Blaise Thomson", "Karl Weilhammer", "Hui Ye", "Steve Young."],
    "venue": "Human Language Technologies 2007: The Conference of the North American Chapter",
    "year": 2007
  }, {
    "title": "Statistical user simulation with a hidden agenda",
    "authors": ["Jost Schatzmann", "Blaise Thomson", "Steve Young."],
    "venue": "Proc SIGDial, Antwerp 273282(9).",
    "year": 2007
  }, {
    "title": "Automatic learning of dialogue strategy using dialogue simulation and reinforcement learning",
    "authors": ["Konrad Scheffler", "Steve Young."],
    "venue": "Proceedings of the second international conference on Human Language Technology Research. Morgan Kaufmann",
    "year": 2002
  }, {
    "title": "Searching the web: The public and their queries",
    "authors": ["Amanda Spink", "Dietmar Wolfram", "Major BJ Jansen", "Tefko Saracevic."],
    "venue": "Journal of the Association for Information Science and Technology 52(3):226– 234.",
    "year": 2001
  }, {
    "title": "Paradise: A framework for evaluating spoken dialogue agents",
    "authors": ["Marilyn A Walker", "Diane J Litman", "Candace A Kamm", "Alicia Abella."],
    "venue": "Proceedings of the eighth conference on European chapter of the Association for Computational Linguistics. Associa-",
    "year": 1997
  }, {
    "title": "Conditional generation and snapshot learning in neural dialogue systems",
    "authors": ["Tsung-Hsien Wen", "Milica Gašić", "Nikola Mrkšić", "Lina M. Rojas-Barahona", "Pei-Hao Su", "Stefan Ultes", "David Vandyke", "Steve Young."],
    "venue": "EMNLP .",
    "year": 2016
  }, {
    "title": "A network-based end-to-end trainable task-oriented dialogue system",
    "authors": ["Tsung-Hsien Wen", "Milica Gašić", "Nikola Mrkšić", "Lina M. Rojas-Barahona", "Pei-Hao Su", "Stefan Ultes", "David Vandyke", "Steve Young."],
    "venue": "arXiv preprint arXiv:1604.04562 .",
    "year": 2016
  }, {
    "title": "Semantically conditioned lstm-based natural language generation for spoken dialogue systems",
    "authors": ["Tsung-Hsien Wen", "Milica Gašić", "Nikola Mrkšić", "PeiHao Su", "David Vandyke", "Steve Young."],
    "venue": "EMNLP .",
    "year": 2015
  }, {
    "title": "Scaling up POMDPs for dialog management: The “Summary POMDP” method",
    "authors": ["Jason D Williams", "Steve Young."],
    "venue": "IEEE Workshop on Automatic Speech Recognition and Understanding, 2005.. IEEE, pages 177–182.",
    "year": 2005
  }, {
    "title": "Endto-end lstm-based dialog control optimized with supervised and reinforcement learning",
    "authors": ["Jason D Williams", "Geoffrey Zweig."],
    "venue": "arXiv preprint arXiv:1606.01269 .",
    "year": 2016
  }, {
    "title": "Simple statistical gradientfollowing algorithms for connectionist reinforcement learning",
    "authors": ["Ronald J Williams."],
    "venue": "Machine learning 8(3-4):229–256.",
    "year": 1992
  }, {
    "title": "A probabilistic framework for representing dialog systems and entropy-based dialog management through dynamic stochastic state evolution",
    "authors": ["Ji Wu", "Miao Li", "Chin-Hui Lee."],
    "venue": "IEEE/ACM Transactions on Audio, Speech, and Language Processing",
    "year": 2015
  }, {
    "title": "Spoken language understanding using long short-term memory neural networks",
    "authors": ["Kaisheng Yao", "Baolin Peng", "Yu Zhang", "Dong Yu", "Geoffrey Zweig", "Yangyang Shi."],
    "venue": "Spoken Language Technology Workshop (SLT), 2014 IEEE. IEEE, pages 189–194.",
    "year": 2014
  }, {
    "title": "Neural generative question answering",
    "authors": ["Jun Yin", "Xin Jiang", "Zhengdong Lu", "Lifeng Shang", "Hang Li", "Xiaoming Li."],
    "venue": "International Joint Conference on Artificial Intelligence .",
    "year": 2016
  }, {
    "title": "Neural enquirer: Learning to query tables",
    "authors": ["Pengcheng Yin", "Zhengdong Lu", "Hang Li", "Ben Kao."],
    "venue": "International Joint Conference on Artificial Intelligence .",
    "year": 2016
  }, {
    "title": "POMDP-based statistical spoken dialog systems: A review",
    "authors": ["Steve Young", "Milica Gašić", "Blaise Thomson", "Jason D Williams."],
    "venue": "Proceedings of the IEEE 101(5):1160–1179.",
    "year": 2013
  }, {
    "title": "Reinforcement learning neural Turing machines-revised",
    "authors": ["Wojciech Zaremba", "Ilya Sutskever."],
    "venue": "arXiv preprint arXiv:1505.00521 .",
    "year": 2015
  }, {
    "title": "Towards end-to-end learning for dialog state tracking and management using deep reinforcement learning",
    "authors": ["Tiancheng Zhao", "Maxine Eskenazi."],
    "venue": "arXiv preprint arXiv:1606.02560 .",
    "year": 2016
  }, {
    "title": "Do we need entity-centric knowledge bases for entity disambiguation",
    "authors": ["Stefan Zwicklbauer", "Christin Seifert", "Michael Granitzer"],
    "venue": "In Proceedings of the 13th International Conference on Knowledge Management and Knowledge Technolo-",
    "year": 2013
  }],
  "id": "SP:cfef4debe7d50ba97cfd5bc2b4f0983c80b5c900",
  "authors": [{
    "name": "Bhuwan Dhingra",
    "affiliations": []
  }, {
    "name": "Lihong Li",
    "affiliations": []
  }, {
    "name": "Xiujun Li",
    "affiliations": []
  }, {
    "name": "Jianfeng Gao",
    "affiliations": []
  }, {
    "name": "Yun-Nung Chen",
    "affiliations": []
  }, {
    "name": "Faisal Ahmed",
    "affiliations": []
  }, {
    "name": "Li Deng",
    "affiliations": []
  }],
  "abstractText": "This paper proposes KB-InfoBot1 — a multi-turn dialogue agent which helps users search Knowledge Bases (KBs) without composing complicated queries. Such goal-oriented dialogue agents typically need to interact with an external database to access real-world knowledge. Previous systems achieved this by issuing a symbolic query to the KB to retrieve entries based on their attributes. However, such symbolic operations break the differentiability of the system and prevent endto-end training of neural dialogue agents. In this paper, we address this limitation by replacing symbolic queries with an induced “soft” posterior distribution over the KB that indicates which entities the user is interested in. Integrating the soft retrieval process with a reinforcement learner leads to higher task success rate and reward in both simulations and against real users. We also present a fully neural end-to-end agent, trained entirely from user feedback, and discuss its application towards personalized dialogue agents.",
  "title": "Towards End-to-End Reinforcement Learning of Dialogue Agents for Information Access"
}