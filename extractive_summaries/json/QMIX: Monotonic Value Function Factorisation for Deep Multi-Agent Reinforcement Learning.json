{
  "sections": [{
    "heading": "1. Introduction",
    "text": "Reinforcement learning (RL) holds considerable promise to help address a variety of cooperative multi-agent problems, such as coordination of robot swarms (Hüttenrauch et al., 2017) and autonomous cars (Cao et al., 2012).\n*Equal contribution 1University of Oxford, Oxford, United Kingdom 2Russian-Armenian University, Yerevan, Armenia. Correspondence to: Tabish Rashid <tabish.rashid@cs.ox.ac.uk>, Mikayel Samvelyan <mikayel@samvelyan.com>.\nProceedings of the 35 th International Conference on Machine Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018 by the author(s).\nIn many such settings, partial observability and/or communication constraints necessitate the learning of decentralised policies, which condition only on the local actionobservation history of each agent. Decentralised policies also naturally attenuate the problem that joint action spaces grow exponentially with the number of agents, often rendering the application of traditional single-agent RL methods impractical.\nFortunately, decentralised policies can often be learned in a centralised fashion in a simulated or laboratory setting. This often grants access to additional state information, otherwise hidden from agents, and removes inter-agent communication constraints. The paradigm of centralised training with decentralised execution (Oliehoek et al., 2008; Kraemer & Banerjee, 2016) has recently attracted attention in the RL community (Jorge et al., 2016; Foerster et al., 2018). However, many challenges surrounding how to best exploit centralised training remain open.\nOne of these challenges is how to represent and use the action-value function that most RL methods learn. On the one hand, properly capturing the effects of the agents’ actions requires a centralised action-value function Qtot that conditions on the global state and the joint action. On the other hand, such a function is difficult to learn when there are many agents and, even if it can be learned, offers no obvious way to extract decentralised policies that allow each agent to select only an individual action based on an individual observation.\nThe simplest option is to forgo a centralised action-value function and let each agent a learn an individual action-value function Qa independently, as in independent Q-learning (IQL) (Tan, 1993). However, this approach cannot explicitly represent interactions between the agents and may not converge, as each agent’s learning is confounded by the learning and exploration of others.\nAt the other extreme, we can learn a fully centralised stateaction value function Qtot and then use it to guide the optimisation of decentralised policies in an actor-critic framework, an approach taken by counterfactual multi-agent (COMA) policy gradients (Foerster et al., 2018), as well as work by Gupta et al. (2017). However, this requires onpolicy learning, which can be sample-inefficient, and training the fully centralised critic becomes impractical when there are more than a handful of agents.\nIn between these two extremes, we can learn a centralised but factored Qtot, an approach taken by value decomposition networks (VDN) (Sunehag et al., 2017). By representing Qtot as a sum of individual value functions Qa that condition only on individual observations and actions, a decentralised policy arises simply from each agent selecting actions greedily with respect to its Qa. However, VDN severely limits the complexity of centralised action-value functions that can be represented and ignores any extra state information available during training.\nIn this paper, we propose a new approach called QMIX which, like VDN, lies between the extremes of IQL and COMA, but can represent a much richer class of actionvalue functions. Key to our method is the insight that the full factorisation of VDN is not necessary to extract decentralised policies. Instead, we only need to ensure that a global argmax performed on Qtot yields the same result as a set of individual argmax operations performed on each Qa. To this end, it suffices to enforce a monotonicity constraint on the relationship between Qtot and each Qa:\n∂Qtot ∂Qa ≥ 0, ∀a. (1)\nQMIX consists of agent networks representing each Qa, and a mixing network that combines them into Qtot, not as a simple sum as in VDN, but in a complex non-linear way that ensures consistency between the centralised and decentralised policies. At the same time, it enforces the constraint of (1) by restricting the mixing network to have positive weights. As a result, QMIX can represent complex centralised action-value functions with a factored representation that scales well in the number of agents and allows decentralised policies to be easily extracted via linear-time individual argmax operations.\nWe evaluate QMIX on a range of unit micromanagement\ntasks built in StarCraft II1. (Vinyals et al., 2017). Our experiments show that QMIX outperforms IQL and VDN, both in terms of absolute performance and learning speed. In particular, our method shows considerable performance gains on a task with heterogeneous agents. Moreover, our ablations show both the necessity of conditioning on the state information and the non-linear mixing of agent Q-values in order to achieve consistent performance across tasks."
  }, {
    "heading": "2. Related Work",
    "text": "Recent work in multi-agent RL has started moving from tabular methods (Yang & Gu, 2004; Busoniu et al., 2008) to deep learning methods that can tackle high-dimensional state and action spaces (Tampuu et al., 2017; Foerster et al., 2018; Peng et al., 2017). In this paper, we focus on cooperative settings.\nOn the one hand, a natural approach to finding policies for a multi-agent system is to directly learn decentralised value functions or policies. Independent Q-learning (Tan, 1993) trains independent action-value functions for each agent using Q-learning (Watkins, 1989). (Tampuu et al., 2017) extend this approach to deep neural networks using DQN (Mnih et al., 2015). While trivially achieving decentralisation, these approaches are prone to instability arising from the non-stationarity of the environment induced by simultaneously learning and exploring agents. Omidshafiei et al. (2017) and Foerster et al. (2017) address learning stabilisation to some extent, but still learn decentralised value functions and do not allow for the inclusion of extra state information during training.\nOn the other hand, centralised learning of joint actions can naturally handle coordination problems and avoids nonstationarity, but is hard to scale, as the joint action space grows exponentially in the number of agents. Classical approaches to scalable centralised learning include coordination graphs (Guestrin et al., 2002), which exploit conditional independencies between agents by decomposing a global reward function into a sum of agent-local terms. Sparse cooperative Q-learning (Kok & Vlassis, 2006) is a tabular Q-learning algorithm that learns to coordinate the actions of a group of cooperative agents only in the states in which such coordination is necessary, encoding those dependencies in a coordination graph. These methods require the dependencies between agents to be pre-supplied, whereas we do not require such prior knowledge. Instead, we assume that each agent always contributes to the global reward, and learns the magnitude of its contribution in each state.\nMore recent approaches for centralised learning require even more communication during execution: CommNet\n1StarCraft and StarCraft II are trademarks of Blizzard EntertainmentTM.\n(Sukhbaatar et al., 2016) uses a centralised network architecture to exchange information between agents. BicNet (Peng et al., 2017) uses bidirectional RNNs to exchange information between agents in an actor-critic setting. This approach additionally requires estimating individual agent rewards.\nSome work has developed hybrid approaches that exploit the setting of centralised learning with fully decentralised execution. COMA (Foerster et al., 2018) uses a centralised critic to train decentralised actors, estimating a counterfactual advantage function for each agent in order to address multi-agent credit assignment. Similarly, Gupta et al. (2017) present a centralised actor-critic algorithm with per-agent critics, which scales better with the number of agents but mitigates the advantages of centralisation. Lowe et al. (2017) learn a centralised critic for each agent and apply this to competitive games with continuous action spaces. These approaches use on-policy policy gradient learning, which can have poor sample efficiency and is prone to getting stuck in sub-optimal local minima.\nSunehag et al. (2017) propose value decomposition networks (VDN), which allow for centralised value-function learning with decentralised execution. Their algorithm decomposes a central state-action value function into a sum of individual agent terms. This corresponds to the use of a degenerate fully disconnected coordination graph. VDN does not make use of additional state information during training and can represent only a limited class of centralised action-value functions.\nA number of papers have established unit micromanagement in StarCraft as a benchmark for deep multi-agent RL. Usunier et al. (2017) present an algorithm using a centralised greedy MDP and first-order optimisation. Peng et al. (2017) also evaluate their methods on StarCraft. However, neither requires decentralised execution. Similar to our setup is the work of Foerster et al. (2017), who evaluate replay stabilisation methods for IQL on combat scenarios with up to five agents. Foerster et al. (2018) also uses this setting. In this paper, we construct unit micromanagement tasks in the StarCraft II Learning Environment (SC2LE) (Vinyals et al., 2017) as opposed to StarCraft, because it is actively supported by the game developers and SC2LE offers a more stable testing environment.\nQMIX relies on a neural network to transform the centralised state into the weights of another neural network, in a manner reminiscent of hypernetworks (Ha et al., 2017). This second neural network is constrained to be monotonic with respect to its inputs by keeping its weights positive. Dugas et al. (2009) investigate such functional restrictions for neural networks."
  }, {
    "heading": "3. Background",
    "text": "A fully cooperative multi-agent task can be described as a Dec-POMDP (Oliehoek & Amato, 2016) consisting of a tuple G = 〈S,U, P, r, Z,O, n, γ〉. s ∈ S describes the true state of the environment. At each time step, each agent a ∈ A ≡ {1, ..., n} chooses an action ua ∈ U , forming a joint action u ∈ U ≡ Un. This causes a transition on the environment according to the state transition function P (s′|s,u) : S×U×S → [0, 1]. All agents share the same reward function r(s,u) : S ×U → R and γ ∈ [0, 1) is a discount factor.\nWe consider a partially observable scenario in which each agent draws individual observations z ∈ Z according to observation function O(s, a) : S × A → Z. Each agent has an action-observation history τa ∈ T ≡ (Z × U)∗, on which it conditions a stochastic policy πa(ua|τa) : T × U → [0, 1]. The joint policy π has a joint action-value function: Qπ(st,ut) = Est+1:∞,ut+1:∞ [Rt|st,ut], where Rt = ∑∞ i=0 γ irt+i is the discounted return.\nAlthough training is centralised, execution is decentralised, i.e., the learning algorithm has access to all local actionobservation histories τ and global state s, but each agent’s learnt policy can condition only on its own actionobservation history τa.\n3.1. Deep Q-Learning\nDeep Q-learning represents the action-value function with a deep neural network parameterised by θ. Deep Q-networks (DQNs) (Mnih et al., 2015) use a replay memory to store the transition tuple 〈s, u, r, s′〉, where the state s′ is observed after taking the action u in state s and receiving reward r. θ is learnt by sampling batches of b transitions from the replay memory and minimising the squared TD error:\nL(θ) = b∑ i=1 [( yDQNi −Q(s, u; θ) )2] , (2)\nwhere yDQN = r + γmaxu′ Q(s′, u′; θ−). θ− are the parameters of a target network that are periodically copied from θ and kept constant for a number of iterations.\n3.2. Deep Recurrent Q-Learning\nIn partially observable settings, agents can benefit from conditioning on their entire action-observation history. Hausknecht & Stone (2015) propose Deep Recurrent Qnetworks (DRQN) that make use of recurrent neural networks. Typically, gated architectures such as LSTM (Hochreiter & Schmidhuber, 1997) or GRU (Chung et al., 2014) are used to facilitate learning over longer timescales.\n3.3. Independent Q-Learning\nPerhaps the most commonly applied method in multi-agent learning is independent Q-learning (IQL) (Tan, 1993), which decomposes a multi-agent problem into a collection of simultaneous single-agent problems that share the same environment. This approach does not address the nonstationarity introduced due to the changing policies of the learning agents, and thus, unlike Q-learning, has no convergence guarantees even in the limit of infinite exploration. In practice, nevertheless, IQL commonly serves as a surprisingly strong benchmark even in mixed and competitive games (Tampuu et al., 2017; Leibo et al., 2017)."
  }, {
    "heading": "3.4. Value Decomposition Networks",
    "text": "By contrast, value decomposition networks (VDNs) (Sunehag et al., 2017) aim to learn a joint action-value function Qtot(τ ,u), where τ ∈ T ≡ T n is a joint actionobservation history and u is a joint action. It represents Qtot as a sum of individual value functions Qa(τa, ua; θa), one for each agent a, that condition only on individual action-observation histories:\nQtot(τ ,u) = n∑ i=1 Qi(τ i, ui; θi). (3)\nStrictly speaking, each Qa is a utility function (Guestrin et al., 2002) and not a value function since by itself it does not estimate an expected return. However, for terminological simplicity we refer to both Qtot and Qa as value functions.\nThe loss function for VDN is equivalent to (2), where Q is replaced by Qtot. An advantage of this representation is that a decentralised policy arises simply from each agent performing greedy action selection with respect to its Qa."
  }, {
    "heading": "4. QMIX",
    "text": "In this section, we propose a new approach called QMIX which, like VDN, lies between the extremes of IQL and centralised Q-learning, but can represent a much richer class of action-value functions.\nKey to our method is the insight that the full factorisation of VDN is not necessary in order to be able to extract decentralised policies that are fully consistent with their centralised counterpart. Instead, for consistency we only need to ensure that a global argmax performed on Qtot yields the same result as a set of individual argmax operations performed on each Qa:\nargmax u Qtot(τ ,u) =\n argmaxu1 Q1(τ 1, u1)\n... argmaxun Qn(τ n, un)\n . (4)\nThis allows each agent a to participate in a decentralised execution solely by choosing greedy actions with respect to its Qa. As a side effect, if (4) is satisfied, then taking the argmax of Qtot, required by off-policy learning updates, is trivially tractable.\nVDN’s representation is sufficient to satisfy (4). However, QMIX is based on the observation that this representation can be generalised to the larger family of monotonic functions that are also sufficient but not necessary to satisfy (4). Monotonicity can be enforced through a constraint on the relationship between Qtot and each Qa:\n∂Qtot ∂Qa ≥ 0, ∀a ∈ A. (5)\nTo enforce (5), QMIX represents Qtot using an architecture consisting of agent networks, a mixing network, and a set of hypernetworks (Ha et al., 2017). Figure 2 illustrates the overall setup.\nFor each agent a, there is one agent network that represents its individual value functionQa(τa, ua). We represent agent networks as DRQNs that receive the current individual observation oat and the last action u a t−1 as input at each time step, as shown in Figure 2c.\nThe mixing network is a feed-forward neural network that takes the agent network outputs as input and mixes them monotonically, producing the values of Qtot, as shown in Figure 2a. To enforce the monotonicity constraint of (5), the weights (but not the biases) of the mixing network are restricted to be non-negative. This allows the mixing network to approximate any monotonic function arbitrarily closely (Dugas et al., 2009).\nThe weights of the mixing network are produced by separate hypernetworks. Each hypernetwork takes the state s as input and generates the weights of one layer of the mixing network. Each hypernetwork consists of a single linear layer, followed by an absolute activation function, to ensure that the mixing network weights are non-negative. The output of the hypernetwork is then a vector, which is reshaped into a matrix of appropriate size. The biases are produced in the same manner but are not restricted to being non-negative. The final bias is produced by a 2 layer hypernetwork with a ReLU non-linearity. Figure 2a illustrates the mixing network and the hypernetworks.\nThe state is used by the hypernetworks rather than being passed directly into the mixing network because Qtot is allowed to depend on the extra state information in nonmonotonic ways. Thus, it would be overly constraining to pass some function of s through the monotonic network alongside the per-agent values. Instead, the use of hypernetworks makes it possible to condition the weights of the monotonic network on s in an arbitrary way, thus integrating the full state s into the joint action-value estimates as\nflexibly as possible.\nQMIX is trained end-to-end to minimise the following loss:\nL(θ) = b∑ i=1 [( ytoti −Qtot(τ ,u, s; θ) )2] , (6)\nwhere b is the batch size of transitions sampled from the replay buffer, ytot = r + γmaxu′ Qtot(τ ′,u′, s′; θ−) and θ− are the parameters of a target network as in DQN. (6) is analogous to the standard DQN loss of (2). Since (4) holds, we can perform the maximisation of Qtot in time linear in the number of agents (as opposed to scaling exponentially in the worst case)."
  }, {
    "heading": "4.1. Representational Complexity",
    "text": "The value function class representable with QMIX includes any value function that can be factored into a non-linear monotonic combination of the agents’ individual value functions in the fully observable setting. This expands upon the linear monotonic value functions that are representable by VDN. However, the constraint in (5) prevents QMIX from representing value functions that do not factorise in such a manner.\nIntuitively, any value function for which an agent’s best action depends on the actions of the other agents at the same time step will not factorise appropriately, and hence cannot be represented perfectly by QMIX. However, QMIX can approximate such value functions more accurately than VDN. Furthermore, it can take advantage of the extra state information available during training, which we show empirically. A more detailed discussion on the representation complexity is available in the supplementary materials."
  }, {
    "heading": "5. Two-Step Game",
    "text": "To illustrate the effects of representational complexity of VDN and QMIX, we devise a simple two-step cooperative matrix game for two agents.\nAt the first step, Agent 1 chooses which of the two matrix games to play in the next timestep. For the first time step, the actions of Agent 2 have no effect. In the second step, both agents choose an action and receive a global reward according to the payoff matrices depicted in Table 1.\nWe train VDN and QMIX on this task for 5000 episodes and examine the final learned value functions in the limit of full exploration ( = 1). Full exploration ensures that each method is guaranteed to eventually explore all available game states, such that the representational capacity of the state-action value function approximation remains the only limitation. The full details of the architecture and hyperparameters used are provided in the supplementary material.\nTable 2, which shows the learned values for Qtot, demonstrates that QMIX’s higher representational capacity allows\nit to accurately represent the joint-action value function whereas VDN cannot. This directly translates into VDN learning the suboptimal strategy of selecting Action A at the first step and receiving a reward of 7, whereas QMIX recovers the optimal strategy from its learnt joint-action values and receives a reward of 8."
  }, {
    "heading": "6. Experimental Setup",
    "text": "In this section, we describe the decentralised StarCraft II micromanagement problems to which we apply QMIX and the ablations we consider."
  }, {
    "heading": "6.1. Decentralised StarCraft II Micromanagement",
    "text": "Real-time strategy (RTS) games have recently emerged as challenging benchmarks for the RL community. StarCraft, in particular, offers a great opportunity to tackle competitive and cooperative multi-agent problems. Units in StarCraft have a rich set of complex micro-actions that allow the learning of complex interactions between collaborating agents. Previous work (Usunier et al., 2017; Foerster et al., 2018; Peng et al., 2017) applied RL to the original version of StarCraft: BW, which made use of the standard API or related wrappers (Synnaeve et al., 2016). We perform our experiments on the StarCraft II Learning Environment (SC2LE) (Vinyals et al., 2017), which is based on the second version of the game. Because it is supported by the developers of the game, SC2LE mitigates many of the practical difficulties in using StarCraft as an RL platform, such as the dependence on complicated APIs and external emulation software.\nIn this work, we focus on the decentralised micromanagement problem in StarCraft II, in which each of the learning agents controls an individual army unit. We consider combat scenarios where two groups of identical units are placed symmetrically on the map. The units of the first, allied, group are controlled by the decentralised agents. The enemy units are controlled by a built-in StarCraft II AI, which makes use of handcrafted heuristics. The initial placement of units within the groups varies across episodes. The difficulty of the computer AI controlling the enemy units is set\nto medium. At the beginning of each episode, the enemy units are ordered to attack the allies. We compare our results on a set of maps where each unit group consists of 3 Marines (3m), 5 Marines (5m), 8 Marines (8m), 2 Stalkers and 3 Zealots (2s 3z), 3 Stalkers and 5 Zealots (3s 5z), or 1 Colossus, 3 Stalkers and 5 Zealots (1c 3s 5z).\nSimilar to the work of Foerster et al. (2018), the action space of agents consists of the following set of discrete actions: move[direction], attack[enemy id], stop, and noop. Agents can only move in four directions: north, south, east, or west. A unit is allowed to perform the attack[enemy id] action only if the enemy is within its shooting range. This facilitates the decentralisation of the problem and prohibits the usage of the attack-move macroactions that are integrated into the game. Furthermore, we disable the following unit behaviour when idle: responding to enemy fire and attacking enemies if they are in range. By doing so, we force the agents to explore in order to find the optimal combat strategy themselves, rather than relying on built-in StarCraft II utilities.\nPartial observability is achieved by the introduction of unit sight range, which restricts the agents from receiving information about allied or enemy units that are out of range. Moreover, agents can only observe others if they are alive and cannot distinguish between units that are dead or out of range.\nAt each time step, the agents receive a joint reward equal to the total damage dealt on the enemy units. In addition, agents receive a bonus of 10 points after killing each opponent, and 200 points after killing all opponents. These rewards are all normalised to ensure the maximum cumulative reward achievable in an episode is 20.\nThe full details of the environmental setup, architecture and training are available in the supplementary material."
  }, {
    "heading": "6.2. Ablations",
    "text": "We perform ablation experiments in order to investigate the influence of the inclusion of extra state information and the necessity of non-linear transformations in the mixing network.\nFirst, we analyse the significance of extra state information on the mixing network by comparing against QMIX without hypernetworks. Thus, the weights and biases of the mixing network are learned in the standard way, without conditioning on the state. We refer to this method as QMIX-NS. We take the absolute value of the weights in order to enforce the monotonicity constraint.\nSecond, we investigate the necessity of non-linear mixing by removing the hidden layer of the mixing network. This method can be thought of as an extension of VDN that uses\nthe state s to perform a weighted sum over Qa values. We call this method QMIX-Lin.\nThird, we investigate the significance of utilising the state s in comparison to the non-linear mixing. To do this we extend VDN by adding a state-dependent term to the sum of the agent’sQ-Values. This state-dependent term is produced by a network with a single hidden layer of 32 units and a ReLU non-linearity, taking in the state s as input (the same as the hypernetwork producing the final bias in QMIX). We refer to this method as VDN-S.\nWe also show the performance of a non-learning heuristicbased algorithm with full observability, where each agent attacks the closest enemy and continues attacking the same target until the unit dies. Afterwards, the agent starts attacking the nearest enemy and so forth."
  }, {
    "heading": "7. Results",
    "text": "In order to evaluate each method’s performance, we adopt the following evaluation procedure: for each run of a method, we pause training every 100 episodes and run 20 independent episodes with each agent performing greedy decentralised action selection. The percentage of these episodes in which the method defeats all enemy units within the time limit is referred to as the test win rate.\nFigures 3 and 4 plot the mean test win rate across 20 runs for each method on selected maps, together with 95% confidence intervals. The graphs for all methods on all maps are available in the supplementary material."
  }, {
    "heading": "7.1. Main Results",
    "text": "In all scenarios, IQL fails to learn a policy that consistently defeats the enemy. In addition, the training is highly unstable due to the non-stationarity of the environment which arises due to the other agents changing their behaviour during training.\nThe benefits of learning the joint action-value function can be demonstrated by VDN’s superior performance over IQL in all scenarios. VDN is able to more consistently learn basic coordinated behaviour, in the form of focus firing which allows it to win the majority of its encounters on the 5m and 8m maps. On the 8m map, this simple strategy is sufficient for good performance, as evidenced by the extremely high win rate of the heuristic-based algorithm, and explains the performance parity with QMIX. However, on the 3m task, which requires more fine-grained control, it is unable to learn to consistently defeat the enemy.\nQMIX is noticeably the strongest performer on all of the maps, in particular on the maps with hetergenous agent types. The largest performance gap can be seen in the\n3s 5z and 1c 3s 5z maps, where VDN is unable to reach the performance of the simple heuristic. The superior representational capacity of QMIX combined with the state information presents a clear benefit over a more restricted linear decomposition."
  }, {
    "heading": "7.2. Ablation Results",
    "text": "Our additional ablation experiments reveal that QMIX outperforms, or is competitive with, all of its ablations discussed in Section 6.2. Figure 4a shows that non-linear value function factorisation is not always required on a map with homogeneous agent types. However, the additional complexity introduced through the extra hidden layer does not slow down learning. In contrast, Figures 4b and 4c show that on a map with heterogeneous agent types a combination of both central state information and non-linear value function factorisation is required to achieve good performance. QMIX-NS performs on par or slightly better than VDN in both scenarios, which suggests that a non-linear decomposition is not always beneficial when not conditioning on the central state in complex scenarios. Additionally, the performance of VDN-S compared to QMIX-Lin shows the necessity of allowing a non-linear mixing in order to fully leverage central state information."
  }, {
    "heading": "7.3. Learned Policies",
    "text": "We examine the learned behaviours of the policies in order to better understand the differences between the strategies learnt by the different methods. On the 8m scenario, both QMIX and VDN learn the particularly sophisticated strategy of first positioning the units into a semicircle in order to fire at the incoming enemy units from the sides (as opposed to just head on). On the 2s 3z scenario, VDN first runs left and then attacks the enemy once they are in range with no regards to positioning or unit match-ups. QMIX, on the other hand learns to position the Stalkers so that the enemy Zealots cannot attack them. This is especially important since Zealots counter Stalkers. QMIX achieves\nthis by having the allied Zealots first block off and then attack the enemy Zealots (whilst the Stalkers fire from a safe distance), before moving on to the enemy Stalkers. The same behaviour is observed in the 3s 5z scenario for QMIX. VDN-S does not learn to protect the Stalkers from the Zealots, and first positions the units around their starting location and then attacks the enemy as they move in.\nThe initial hump in the performance of both VDN and IQL is due to both methods initially learning the simple strategy of just attacking the first visible enemy (which is quite successful as shown by the heuristic). However, due to exploratory learning behaviour, they also attempt to move around (instead of just firing), which results in the rapid decline in performance. IQL is unable to then recover the initial strategy, whereas VDN learns how to combine small movements and firing together."
  }, {
    "heading": "8. Conclusion",
    "text": "This paper presented QMIX, a deep multi-agent RL method that allows end-to-end learning of decentralised policies in a centralised setting and makes efficient use of extra state information. QMIX allows the learning of a rich joint actionvalue function, which admits tractable decompositions into per-agent action-value functions. This is achieved by imposing a monotonicity constraint on the mixing network.\nOur results in decentralised unit micromanagement tasks in StarCraft II show that QMIX improves the final performance over other value-based multi-agent methods that employ less sophisticated joint state-value function factorisation, as well as independent Q-learning.\nIn the near future, we aim to conduct additional experiments to compare the methods across tasks with a larger number and greater diversity of units. In the longer term, we aim to complement QMIX with more coordinated exploration schemes for settings with many learning agents."
  }, {
    "heading": "Acknowledgements",
    "text": "This project has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement number 637713). It was also supported by the OxfordGoogle DeepMind Graduate Scholarship, the UK EPSRC CDT in Autonomous Intelligent Machines and Systems, Chevening Scholarship, Luys Scholarship and an EPSRC grant (EP/M508111/1, EP/N509711/1). This work is linked to and partly funded by the project Free the Drones (FreeD) under the Innovation Fund Denmark and Microsoft. The experiments were made possible by a generous equipment grant from NVIDIA.\nWe would like to thank Frans Oliehoek and Wendelin Boehmer for helpful comments and discussion. We also thank Oriol Vinyals, Kevin Calderone, and the rest of the SC2LE team at DeepMind and Blizzard for their work on the interface."
  }],
  "year": 2018,
  "references": [{
    "title": "A Comprehensive Survey of Multiagent Reinforcement Learning",
    "authors": ["Busoniu", "Lucian", "Babuska", "Robert", "De Schutter", "Bart"],
    "venue": "IEEE Transactions on Systems, Man, and Cybernetics, Part C (Applications and Reviews),",
    "year": 2008
  }, {
    "title": "An Overview of Recent Progress in the Study of Distributed Multi-agent Coordination",
    "authors": ["Cao", "Yongcan", "Yu", "Wenwu", "Ren", "Wei", "Chen", "Guanrong"],
    "venue": "IEEE Transactions on Industrial Informatics,",
    "year": 2012
  }, {
    "title": "Empirical evaluation of gated recurrent neural networks on sequence modeling",
    "authors": ["Chung", "Junyoung", "Gulcehre", "Caglar", "Cho", "Kyunghyun", "Bengio", "Yoshua"],
    "venue": "In NIPS 2014 Workshop on Deep Learning,",
    "year": 2014
  }, {
    "title": "Incorporating functional knowledge in neural networks",
    "authors": ["Dugas", "Charles", "Bengio", "Yoshua", "Blisle", "Franois", "Nadeau", "Claude", "Garcia", "Ren"],
    "venue": "Journal of Machine Learning Research,",
    "year": 2009
  }, {
    "title": "Counterfactual multi-agent policy gradients",
    "authors": ["Foerster", "Jakob", "Farquhar", "Gregory", "Afouras", "Triantafyllos", "Nardelli", "Nantas", "Whiteson", "Shimon"],
    "venue": "AAAI 2018: Proceedings of the Thirty-Second AAAI Conference on Artificial Intelligence,",
    "year": 2018
  }, {
    "title": "Multiagent Planning with Factored MDPs",
    "authors": ["Guestrin", "Carlos", "Koller", "Daphne", "Parr", "Ronald"],
    "venue": "In Advances in Neural Information Processing Systems",
    "year": 2002
  }, {
    "title": "Cooperative Multi-agent Control Using Deep Reinforcement Learning",
    "authors": ["Gupta", "Jayesh K", "Egorov", "Maxim", "Kochenderfer", "Mykel"],
    "venue": "In Autonomous Agents and Multiagent Systems,",
    "year": 2017
  }, {
    "title": "Deep Recurrent Q-Learning for Partially Observable MDPs",
    "authors": ["Hausknecht", "Matthew", "Stone", "Peter"],
    "venue": "In AAAI Fall Symposium on Sequential Decision Making for Intelligent Agents,",
    "year": 2015
  }, {
    "title": "Long short-term memory",
    "authors": ["Hochreiter", "Sepp", "Schmidhuber", "Jürgen"],
    "venue": "Neural computation,",
    "year": 1997
  }, {
    "title": "Guided Deep Reinforcement Learning for Swarm Systems",
    "authors": ["Hüttenrauch", "Maximilian", "Šošić", "Adrian", "Neumann", "Gerhard"],
    "venue": "AAMAS",
    "year": 2017
  }, {
    "title": "Learning to play guess who? and inventing a grounded language as a consequence",
    "authors": ["Jorge", "Emilio", "Kågebäck", "Mikael", "Gustavsson", "Emil"],
    "venue": "In NIPS Workshop on Deep Reinforcement Learning,",
    "year": 2016
  }, {
    "title": "Collaborative Multiagent Reinforcement Learning by Payoff Propagation",
    "authors": ["Kok", "Jelle R", "Vlassis", "Nikos"],
    "venue": "Journal of Machine Learning Research,",
    "year": 2006
  }, {
    "title": "Multi-agent reinforcement learning as a rehearsal for decentralized planning",
    "authors": ["Kraemer", "Landon", "Banerjee", "Bikramjit"],
    "year": 2016
  }, {
    "title": "Multi-agent reinforcement learning in sequential social dilemmas",
    "authors": ["Leibo", "Joel Z", "Zambaldi", "Vinicius", "Lanctot", "Marc", "Marecki", "Janusz", "Graepel", "Thore"],
    "venue": "In Proceedings of the 16th Conference on Autonomous Agents and Multiagent Systems,",
    "year": 2017
  }, {
    "title": "Multi-agent actorcritic for mixed cooperative-competitive environments",
    "authors": ["Lowe", "Ryan", "Wu", "Yi", "Tamar", "Aviv", "Harb", "Jean", "Abbeel", "OpenAI Pieter", "Mordatch", "Igor"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2017
  }, {
    "title": "A Concise Introduction to Decentralized POMDPs",
    "authors": ["Oliehoek", "Frans A", "Amato", "Christopher"],
    "venue": "SpringerBriefs in Intelligent Systems",
    "year": 2016
  }, {
    "title": "Optimal and Approximate Q-value Functions for Decentralized POMDPs",
    "authors": ["Oliehoek", "Frans A", "Spaan", "Matthijs T. J", "Vlassis", "Nikos"],
    "venue": "Journal of Artificial Intelligence Research,",
    "year": 2008
  }, {
    "title": "Deep Decentralized Multi-task Multi-Agent RL under Partial Observability",
    "authors": ["Omidshafiei", "Shayegan", "Pazis", "Jason", "Amato", "Christopher", "How", "Jonathan P", "Vian", "John"],
    "venue": "In Proceedings of the 34th International Conference on Machine Learning,",
    "year": 2017
  }, {
    "title": "Multiagent Bidirectionally-Coordinated Nets: Emergence of Humanlevel Coordination in Learning to Play StarCraft",
    "authors": ["Peng", "Wen", "Ying", "Yang", "Yaodong", "Yuan", "Quan", "Tang", "Zhenkun", "Long", "Haitao", "Wang", "Jun"],
    "venue": "Combat Games. arXiv preprint arXiv:1703.10069,",
    "year": 2017
  }, {
    "title": "Approximation theory of the mlp model in neural networks",
    "authors": ["Pinkus", "Allan"],
    "venue": "Acta numerica,",
    "year": 1999
  }, {
    "title": "Learning multiagent communication with backpropagation",
    "authors": ["Sukhbaatar", "Sainbayar", "Fergus", "Rob", "others"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2016
  }, {
    "title": "TorchCraft: a Library for Machine Learning Research on Real-Time Strategy Games",
    "authors": ["Synnaeve", "Gabriel", "Nardelli", "Nantas", "Auvolat", "Alex", "Chintala", "Soumith", "Lacroix", "Timothe", "Lin", "Zeming", "Richoux", "Florian", "Usunier", "Nicolas"],
    "venue": "arXiv preprint arXiv:1611.00625,",
    "year": 2016
  }, {
    "title": "Multiagent cooperation and competition with deep reinforcement learning",
    "authors": ["Tampuu", "Ardi", "Matiisen", "Tambet", "Kodelja", "Dorian", "Kuzovkin", "Ilya", "Korjus", "Kristjan", "Aru", "Juhan", "Jaan", "Vicente", "Raul"],
    "venue": "PloS one,",
    "year": 2017
  }, {
    "title": "Multi-agent reinforcement learning: Independent vs. cooperative agents",
    "authors": ["Tan", "Ming"],
    "venue": "In Proceedings of the Tenth International Conference on Machine Learning,",
    "year": 1993
  }, {
    "title": "Episodic Exploration for Deep Deterministic Policies: An Application to StarCraft Micromanagement Tasks",
    "authors": ["Usunier", "Nicolas", "Synnaeve", "Gabriel", "Lin", "Zeming", "Chintala", "Soumith"],
    "venue": "In Proceedings of the International Conference on Learning Representations (ICLR),",
    "year": 2017
  }, {
    "title": "StarCraft II: A New Challenge for Reinforcement Learning",
    "authors": ["selt", "Hado", "Silver", "David", "Lillicrap", "Timothy", "Calderone", "Kevin", "Keet", "Paul", "Brunasso", "Anthony", "Lawrence", "Ekermo", "Anders", "Repp", "Jacob", "Tsing", "Rodney"],
    "venue": "arXiv preprint arXiv:1708.04782,",
    "year": 2017
  }, {
    "title": "Learning from delayed rewards",
    "authors": ["Watkins", "Christopher"],
    "venue": "PhD thesis, University of Cambridge England,",
    "year": 1989
  }, {
    "title": "Multiagent reinforcement learning for multi-robot systems: A survey",
    "authors": ["Yang", "Erfu", "Gu", "Dongbing"],
    "venue": "Technical report,",
    "year": 2004
  }],
  "id": "SP:78c9538d2d78c49503b5d5f78d8b63c1d535a2ac",
  "authors": [{
    "name": "Tabish Rashid",
    "affiliations": []
  }, {
    "name": "Mikayel Samvelyan",
    "affiliations": []
  }, {
    "name": "Christian Schroeder de Witt",
    "affiliations": []
  }, {
    "name": "Gregory Farquhar",
    "affiliations": []
  }, {
    "name": "Jakob Foerster",
    "affiliations": []
  }, {
    "name": "Shimon Whiteson",
    "affiliations": []
  }],
  "abstractText": "In many real-world settings, a team of agents must coordinate their behaviour while acting in a decentralised way. At the same time, it is often possible to train the agents in a centralised fashion in a simulated or laboratory setting, where global state information is available and communication constraints are lifted. Learning joint actionvalues conditioned on extra state information is an attractive way to exploit centralised learning, but the best strategy for then extracting decentralised policies is unclear. Our solution is QMIX, a novel value-based method that can train decentralised policies in a centralised end-to-end fashion. QMIX employs a network that estimates joint action-values as a complex non-linear combination of per-agent values that condition only on local observations. We structurally enforce that the joint-action value is monotonic in the per-agent values, which allows tractable maximisation of the joint action-value in off-policy learning, and guarantees consistency between the centralised and decentralised policies. We evaluate QMIX on a challenging set of StarCraft II micromanagement tasks, and show that QMIX significantly outperforms existing value-based multi-agent reinforcement learning methods.",
  "title": "QMIX: Monotonic Value Function Factorisation for Deep Multi-Agent Reinforcement Learning"
}