{
  "sections": [{
    "text": "p k).\nIn this paper, we solve a key open problem raised therein, presenting a new Partitioned Robust (PRO) submodular maximization algorithm that achieves the same guarantee for more general ⌧ = o(k). Our algorithm constructs partitions consisting of buckets with exponentially increasing sizes, and applies standard submodular optimization subroutines on the buckets in order to construct the robust solution. We numerically demonstrate the performance of PRO in data summarization and influence maximization, demonstrating gains over both the greedy algorithm and the algorithm of (Orlin et al., 2016)."
  }, {
    "heading": "1. Introduction",
    "text": "Discrete optimization problems arise frequently in machine learning, and are often NP-hard even to approximate. In the case of a set function exhibiting submodularity, one can efficiently perform maximization subject to cardinality constraints with a 1 1\ne\n-factor approximation guarantee. Ap-\nplications include influence maximization (Kempe et al., 2003), document summarization (Lin & Bilmes, 2011), sensor placement (Krause & Guestrin, 2007), and active learning (Krause & Golovin, 2012), just to name a few.\n1LIONS, EPFL, Switzerland 2LTHC, EPFL, Switzerland. Correspondence to: Ilija Bogunovic <ilija.bogunovic@epfl.ch>, Slobodan Mitrović <slobodan.mitrovic@epfl.ch>, Jonathan Scarlett <jonathan.scarlett@epfl.ch>, Volkan Cevher <volkan.cevher@epfl.ch>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\nIn many applications of interest, one requires robustness in the solution set returned by the algorithm, in the sense that the objective value degrades as little as possible when some elements of the set are removed. For instance, (i) in influence maximization problems, a subset of the chosen users may decide not to spread the word about a product; (ii) in summarization problems, a user may choose to remove some items from the summary due to their personal preferences; (iii) in the problem of sensor placement for outbreak detection, some of the sensors might fail.\nIn situations where one does not have a reasonable prior distribution on the elements removed, or where one requires robustness guarantees with a high level of certainty, protecting against worst-case removals becomes important. This setting results in the robust submodular function maximization problem, in which we seek to return a set of cardinality k that is robust with respect to the worst-case removal of ⌧ elements.\nThe robust problem formulation was first introduced in (Krause et al., 2008), and was further studied in (Orlin et al., 2016). In fact, (Krause et al., 2008) considers a more general formulation where a constant-factor approximation guarantee is impossible in general, but shows that one can match the optimal (robust) objective value for a given set size at the cost of returning a set whose size is larger by a logarithmic factor. In contrast, (Orlin et al., 2016) designs an algorithm that obtains the first constant-factor approximation guarantee to the above problem when ⌧ = o( p k). A key difference between the two frameworks is that the algorithm complexity is exponential in ⌧ in (Krause et al., 2008), whereas the algorithm of (Orlin et al., 2016) runs in polynomial time.\nContributions. In this paper, we solve a key open problem posed in (Orlin et al., 2016), namely, whether a constantfactor approximation guarantee is possible for general ⌧ = o(k), as opposed to only ⌧ = o( p k). We answer this question in the affirmative, providing a new Partitioned Robust (PRO) submodular maximization algorithm that attains a constant-factor approximation guarantee; see Table 1 for comparison of different algorithms for robust monotone submodular optimization with a cardinality constraint.\nAchieving this result requires novelty both in the algorithm and its mathematical analysis: While our algorithm bears some similarity to that of (Orlin et al., 2016), it uses a novel structure in which the constructed set is arranged into partitions consisting of buckets whose sizes increase exponentially with the partition index. A key step in our analysis provides a recursive relationship between the objective values attained by buckets appearing in adjacent partitions.\nIn addition to the above contributions, we provide the first empirical study beyond what is demonstrated for ⌧ = 1 in (Krause et al., 2008). We demonstrate several scenarios in which our algorithm outperforms both the greedy algorithm and the algorithm of (Orlin et al., 2016)."
  }, {
    "heading": "2. Problem Statement",
    "text": "Let V be a ground set with cardinality |V | = n, and let f : 2V ! R 0 be a set function defined on V . The function f is said to be submodular if for any sets X ✓ Y ✓ V and any element e 2 V \\ Y , it holds that\nf(X [ {e}) f(X) f(Y [ {e}) f(Y ). We use the following notation to denote the marginal gain in the function value due to adding the elements of a set Y to the set X:\nf(Y |X) := f(X [ Y ) f(X). In the case that Y is a singleton of the form {e}, we adopt the shorthand f(e|X). We say that f is monotone if for any sets X ✓ Y ✓ V we have f(X)  f(Y ), and normalized if f(;) = 0. The problem of maximizing a normalized monotone submodular function subject to a cardinality constraint, i.e.,\nmax S✓V,|S|k f(S), (1)\nhas been studied extensively. A celebrated result of (Nemhauser et al., 1978) shows that a simple greedy algorithm that starts with an empty set and then iteratively adds elements with highest marginal gain provides a (1 1/e)-approximation.\nIn this paper, we consider the following robust version of (1), introduced in (Krause et al., 2008):\nmax S✓V,|S|k min Z✓S,|Z|⌧\nf(S \\ Z) (2)\nWe refer to ⌧ as the robustness parameter, representing the size of the subset Z that is removed from the selected set S. Our goal is to find a set S such that it is robust upon the worst possible removal of ⌧ elements, i.e., after the removal, the objective value should remain as large as possible. For ⌧ = 0, our problem reduces to Problem (1).\nThe greedy algorithm, which is near-optimal for Problem (1) can perform arbitrarily badly for Problem (2). As an elementary example, let us fix ✏ 2 [0, n 1) and n 0, and consider the non-negative monotone submodular function given in Table 2. For k = 2, the greedy algorithm selects {s1, s2}. The set that maximizes mins2S f(S\\s) (i.e., ⌧ = 1) is {s1, s3}. For this set, min\ns2{s 1 ,s 2 } f({s1, s2} \\ s) = n 1, while for the greedy set the robust objective value is ✏. As a result, the greedy algorithm can perform arbitrarily worse.\nIn our experiments on real-world data sets (see Section 5), we further explore the empirical behavior of the greedy solution in the robust setting. Among other things, we observe that the greedy solution tends to be less robust when the objective value largely depends on the first few elements selected by the greedy rule.\nRelated work. (Krause et al., 2008) introduces the following generalization of (2):\nmax S✓V,|S|k min i2{1,··· ,n} f i (S), (3)\nwhere f i are normalized monotone submodular functions. The authors show that this problem is inapproximable in general, but propose an algorithm SATURATE which, when applied to (2), returns a set of size k(1+⇥(log(⌧k log n))) whose robust objective is at least as good as the optimal size-k set. SATURATE requires a number of function evaluations that is exponential in ⌧ , making it very expensive to run even for small values. The work of (Powers et al., 2016) considers the same problem for different types of submodular constraints.\nRecently, robust versions of submodular maximization have been applied to influence maximization. In (He & Kempe, 2016), the formulation (3) is used to optimize a worst-case approximation ratio. The confidence interval setting is considered in (Chen et al., 2016), where two runs of the GREEDY algorithm (one pessimistic and one optimistic) are used to optimize the same ratio. By leveraging connections to continuous submodular optimization, (Staib & Jegelka, 2017) studies a related continuous robust budget allocation problem.\n(Orlin et al., 2016) considers the formulation in (2), and provides the first constant 0.387-factor approximation result, valid for ⌧ = o( p k). The algorithm proposed therein, which we refer to via the authors surnames as OSU, uses the greedy algorithm (henceforth referred to as GREEDY) as a sub-routine ⌧ +1 times. On each iteration, GREEDY is applied on the elements that are not yet selected on previous iterations, with these previously-selected elements ignored in the objective function. In the first ⌧ runs, each solution is of size ⌧ log k, while in the last run, the solution is of size k ⌧2 log k. The union of all the obtained disjoint solutions leads to the final solution set."
  }, {
    "heading": "3. Applications",
    "text": "In this section, we provide several examples of applications where the robustness of the solution is favorable. The objective functions in these applications are non-negative, monotone and submodular, and are used in our numerical experiments in Section 5.\nRobust influence maximization. The goal in the influence maximization problem is to find a set of k nodes (i.e., a targeted set) in a network that maximizes some measure of influence. For example, this problem appears in viral marketing, where companies wish to spread the word of a new product by targeting the most influential individuals in a social network. Due to poor incentives or dissatisfaction with the product, for instance, some of the users from the\ntargeted set might make the decision not to spread the word about the product.\nFor many of the existing diffusion models used in the literature (e.g., see (Kempe et al., 2003)), given the targeted set S, the expected number of influenced nodes at the end of the diffusion process is a monotone and submodular function of S (He & Kempe, 2016). For simplicity, we consider a basic model in which all of the neighbors of the users in S become influenced, as well as those in S itself.\nMore formally, we are given a graph G = (V,E), where V stands for nodes and E are the edges. For a set S, let N (S) denote all of its neighboring nodes. The goal is to solve the robust dominating set problem, i.e., to find a set of nodes S of size k that maximizes\nmin |RS |⌧,RS✓S\n|(S \\R S ) [N (S \\R S )|, (4)\nwhere R S ✓ S represents the users that decide not to spread the word. The non-robust version of this objective function has previously been considered in several different works, such as (Mirzasoleiman et al., 2015b) and (NorouziFard et al., 2016).\nRobust personalized image summarization. In the personalized image summarization problem, a user has a collection of images, and the goal is to find k images that are representative of the collection.\nAfter being presented with a solution, the user might decide to remove a certain number of images from the representative set due to various reasons (e.g., bad lighting, motion blur, etc.). Hence, our goal is to find a set of images that remain good representatives of the collection even after the removal of some number of them.\nOne popular way of finding a representative set in a massive dataset is via exemplar based clustering, i.e., by minimizing the sum of pairwise dissimilarities between the exemplars S and the elements of the data set V . This problem can be posed as a submodular maximization problem subject to a cardinality constraint; cf., (Lucic et al., 2016).\nHere, we are interested in solving the robust summarization problem, i.e., we want to find a set of images S of size k that maximizes\nmin |RS |⌧,RS✓S\nf({e0}) f((S \\RS) [ {e0}), (5)\nwhere e0 is a reference element and f(S) = 1\n|V | P\nv2V mins2S d(s, v) is the k-medoid loss function, and where d(s, v) measures the dissimilarity between images s and v.\nFurther potential applications not covered here include robust sensor placement (Krause et al., 2008), robust protection of networks (Bogunovic & Krause, 2012), and robust feature selection (Globerson & Roweis, 2006)."
  }, {
    "heading": "4. Algorithm and its Guarantees",
    "text": ""
  }, {
    "heading": "4.1. The algorithm",
    "text": "Our algorithm, which we call the Partitioned Robust (PRO) submodular maximization algorithm, is presented in Algorithm 1. As the input, we require a non-negative monotone submodular function f : 2V ! R 0, the ground set of elements V , and an optimization subroutine A. The subroutine A(k0, V 0) takes a cardinality constraint k0 and a ground set of elements V 0. Below, we describe the properties of A that are used to obtain approximation guarantees.\nThe output of the algorithm is a set S ✓ V of size k that is robust against the worst-case removal of ⌧ elements. The returned set consists of two sets S0 and S1, illustrated in Figure 1. S1 is obtained by running the subroutine A on V \\ S0 (i.e., ignoring the elements already placed into S0), and is of size k |S0|. We refer to the set S0 as the robust part of the solution set S. It consists of dlog ⌧e + 1 partitions, where every partition i 2 {0, · · · , dlog ⌧e} consists of d⌧/2ie buckets B\nj , j 2 {1, · · · , d⌧/2ie}. In partition i, every bucket contains 2i⌘ elements, where ⌘ 2 N+ is a parameter that is arbitrary for now; we use ⌘ = log2 k in our asymptotic theory, but our numerical studies indicate that even ⌘ = 1 works well in practice. Each bucket B\nj is created afresh by using the subroutine A on V \\ S0,prev, where S0,prev contains all elements belonging to the previous buckets.\nThe following proposition bounds the cardinality of S0, and is proved in the supplementary material.\nProposition 4.1 Fix k ⌧ and ⌘ 2 N+. The size of the robust part S0 constructed in Algorithm 1 is\n|S0| = dlog ⌧eX\ni=0\nd⌧/2ie2i⌘  3⌘⌧(log k + 2).\nThis proposition reveals that the feasible values of ⌧ (i.e., those with |S0|  k) can be as high as O k\n⌘⌧\n. We will\nlater set ⌘ = O(log2 k), thus permitting all ⌧ = o(k) up to a few logarithmic factors. In contrast, we recall that the algorithm OSU proposed in (Orlin et al., 2016) adopts a simpler approach where a robust set is used consisting of ⌧ buckets of equal size ⌧ log k, thereby only permitting the scaling ⌧ = o( p k).\nWe provide the following intuition as to why PRO succeeds despite having a smaller size for S0 compared to the algorithm given in (Orlin et al., 2016). First, by the design of the partitions, there always exists a bucket in partition i that at most 2i items are removed from. The bulk of our analysis is devoted to showing that the union of these buckets yields a sufficiently high objective value. While the earlier\nAlgorithm 1 Partitioned Robust Submodular optimization algorithm (PRO)\nRequire: Set V , k, ⌧ , ⌘ 2 N+, algorithm A Ensure: Set S ✓ V such that |S|  k\n1: S0, S1 ; 2: for i 0 to dlog ⌧e do 3: for j 1 to d⌧/2ie do 4: B\nj A (2i⌘, (V \\ S0)) 5: S0 S0 [Bj 6: S1 A (k |S0|, (V \\ S0)) 7: S S0 [ S1 8: return S\nbuckets have a smaller size, they also have a higher objective value per item due to diminishing returns, and our analysis quantifies and balances this trade-off. Similarly, our analysis quantifies the trade-off between how much the adversary can remove from the (typically large) set S1 and the robust part S0."
  }, {
    "heading": "4.2. Subroutine and assumptions",
    "text": "PRO accepts a subroutine A as the input. We consider a class of algorithms that satisfy the -iterative property, defined below. We assume that the algorithm outputs the final set in some specific order (v1, . . . , vk), and we refer to vi as the i-th output element.\nDefinition 4.2 Consider a normalized monotone submodular set function f on a ground set V , and an algorithm A. Given any set T ✓ V and size k, suppose that A outputs an ordered set (v1, . . . , vk) when applied to T , and define A\ni (T ) = {v1, . . . , vi} for i  k. We say that A satisfies the -iterative property if\nf(A i+1(T )) f(Ai(T )) 1\nmax v2T\nf(v|A i (T )). (6)\nIntuitively, (6) states that in every iteration, the algorithm adds an element whose marginal gain is at least a 1/ fraction of the maximum marginal. This necessarily requires that 1. Examples. Besides the classic greedy algorithm, which satisfies (6) with = 1, a good candidate for our subroutine is THRESHOLDING-GREEDY (Badanidiyuru & Vondrák, 2014), which satisfies the -iterative property with = 1/(1 ✏). This decreases the number of function evaluations to O(n/✏ log n/✏). STOCHASTIC-GREEDY (Mirzasoleiman et al., 2015a) is another potential subroutine candidate. While it is unclear whether this algorithm satisfies the -iterative property, it requires an even smaller number of function eval-\nuations, namely, O(n log 1/✏). We will see in Section 5 that PRO performs well empirically when used with this subroutine. We henceforth refer to PRO used along with its appropriate subroutine as PRO-GREEDY, PRO-THRESHOLDING-GREEDY, and so on.\nProperties. The following lemma generalizes a classical property of the greedy algorithm (Nemhauser et al., 1978; Krause & Golovin, 2012) to the class of algorithms satisfying the -iterative property. Here and throughout the paper, we use OPT(k, V ) to denote the following optimal set for non-robust maximization:\nOPT(k, V ) 2 argmax S✓V,|S|=k f(S),\nLemma 4.3 Consider a normalized monotone submodular function f : 2V ! R 0 and an algorithm A(T ), T ✓ V , that satisfies the -iterative property in (6). Let A\nl (T ) denote the set returned by the algorithm A(T ) after l iterations. Then for all k, l 2 N+\nf(A l (T )) ⇣ 1 e l k ⌘ f(OPT(k, T )). (7)\nWe will also make use of the following property, which is implied by the -iterative property.\nProposition 4.4 Consider a submodular set function f : 2V ! R 0 and an algorithm A that satisfies the - iterative property for some 1. Then, for any T ✓ V and element e 2 V \\ A(T ), we have\nf(e|A(T ))  f(A(T )) k . (8)\nIntuitively, (8) states that the marginal gain of any nonselected element cannot be more than times the average objective value of the selected elements. This is one of the rules used to define the -nice class of algorithms in (Mirrokni & Zadimoghaddam, 2015); however, we note that in general, neither the -nice nor -iterative classes are a subset of one another."
  }, {
    "heading": "4.3. Main result: Approximation guarantee",
    "text": "For the robust maximization problem, we let OPT(k, V, ⌧) denote the optimal set:\nOPT(k, V, ⌧) 2 argmax S✓V,|S|=k min E✓S,|E|⌧ f(S \\ E).\nMoreover, for a set S, we let E⇤ S denote the minimizer\nE⇤ S 2 argmin E✓S,|E|⌧ f(S \\ E). (9)\nWith these definitions, the main theoretical result of this paper is as follows.\nTheorem 4.5 Let f be a normalized monotone submodular function, and let A be a subroutine satisfying the - iterative property. For a given budget k and parameters 2  ⌧  k3⌘(log k+2) and ⌘ 4(log k + 1), PRO returns a set S of size k such that\nf(S \\ E⇤ S\n) ⌘ 5 3dlog ⌧e+⌘\n⇣ 1 e k |S0| (k ⌧) ⌘\n1 + ⌘5 3dlog ⌧e+⌘\n⇣ 1 e k |S0| (k ⌧) ⌘\n⇥ f(OPT(k, V, ⌧) \\ E⇤OPT(k,V,⌧)), (10) where E⇤\nS and E⇤OPT(k,V,⌧) are defined as in (9).\nIn addition, if ⌧ = o ⇣ k\n⌘ log k\n⌘ and ⌘ log2 k, then we\nhave the following as k !1:\nf(S \\ E⇤ S ) ✓ 1 e 1/ 2 e 1/ + o(1) ◆\n⇥ f(OPT(k, V, ⌧) \\ E⇤OPT(k,V,⌧)). (11) In particular, PRO-GREEDY achieves an asymptotic approximation factor of at least 0.387, and PROTHRESHOLDING-GREEDY with parameter ✏ achieves an asymptotic approximation factor of at least 0.387(1 ✏).\nThis result solves an open problem raised in (Orlin et al., 2016), namely, whether a constant-factor approximation guarantee can be obtained for ⌧ = o(k) as opposed to\nonly ⌧ = o p k . In the asymptotic limit, our constant factor of 0.387 for the greedy subroutine matches that of (Orlin et al., 2016), but our algorithm permits significantly “higher robustness” in the sense of allowing larger ⌧ values. To achieve this, we require novel proof techniques, which we now outline."
  }, {
    "heading": "4.4. High-level overview of the analysis",
    "text": "The proof of Theorem 4.5 is provided in the supplementary material. Here we provide a high-level overview of the main challenges.\nLet E denote a cardinality-⌧ subset of the returned set S that is removed. By the construction of the partitions, it is easy to verify that each partition i contains a bucket from which at most 2i items are removed. We denote these by B0, . . . , Bdlog ⌧e, and write EBi := E \\Bi. Moreover, we define E0 := E \\ S0 and E1 := E \\ S1. We establish the following lower bound on the final objective function value:\nf(S \\E) max ⇢ f(S0 \\E0), f(S1) f(E1|(S \\E)),\nf\n✓ dlog ⌧e[\ni=0\n(B i \\ E Bi)\n◆ . (12)\nThe arguments to the first and third terms are trivially seen to be subsets of S \\ E, and the second term represents the utility of the set S1 subsided by the utility of the elements removed from S1.\nThe first two terms above are easily lower bounded by convenient expressions via submodular and the -iterative property. The bulk of the proof is dedicated to bounding the third term. To do this, we establish the following recursive relations with suitably-defined “small” values of ↵\nj\n:\nf\nj[\ni=0\n(B i \\ E Bi)\n! 1 1\n1 + 1 ↵j\n! f(B\nj\n)\nf E\nBj\nj 1[\ni=0\n(B i \\ E Bi)\n!  ↵\nj\nf\nj 1[\ni=0\n(B i \\ E Bi)\n! .\nIntuitively, the first equation shows that the objective value from buckets i = 0, . . . , j with removals cannot be too much smaller than the objective value in bucket j without removals, and the second equation shows that the loss in bucket j due to the removals is at most a small fraction of the objective value from buckets 0, . . . , j 1. The proofs of both the base case of the induction and the inductive step make use of submodularity properties and the -iterative property (cf., Definition 4.2).\nOnce the suitable lower bounds are obtained for the terms in (12), the analysis proceeds similarly to (Orlin et al.,\n2016). Specifically, we can show that as the second term increases, the third term decreases, and accordingly lower bound their maximum by the value obtained when the two are equal. A similar balancing argument is then applied to the resulting term and the first term in (12).\nThe condition ⌧  k3⌘(log k+2) follows directly from Proposition 4.1; namely, it is a sufficient condition for |S0|  k, as is required by PRO."
  }, {
    "heading": "5. Experiments",
    "text": "In this section, we numerically validate the performance of PRO and the claims given in the preceding sections. In particular, we compare our algorithm against the OSU algorithm proposed in (Orlin et al., 2016) on different datasets and corresponding objective functions (see Table 3). We demonstrate matching or improved performance in a broad range of settings, as well as observing that PRO can be implemented with larger values of ⌧ , corresponding to a greater robustness. Moreover, we show that for certain realworld data sets, the classic GREEDY algorithm can perform badly for the robust problem. We do not compare against SATURATE (Krause et al., 2008), due to its high computational cost for even a small ⌧ .\nSetup. Given a solution set S of size k, we measure the performance in terms of the minimum objective value upon the worst-case removal of ⌧ elements, i.e. min\nZ✓S,|Z|⌧ f(S\\ Z). Unfortunately, for a given solution set S, finding such a set Z is an instance of the submodular minimization problem with a cardinality constraint,1 which is known to be NP-hard with polynomial approximation factors (Svitkina & Fleischer, 2011). Hence, in our experiments, we only implement the optimal “adversary” (i.e., removal of items) for small to moderate values of ⌧ and k, for which we use a fast C++ implementation of branch-and-bound.\nDespite the difficulty in implementing the optimal adversary, we observed in our experiments that the greedy adversary, which iteratively removes elements to reduce the objective value as much as possible, has a similar impact on the objective compared to the optimal adversary for the data sets considered. Hence, we also provide a larger-scale experiment in the presence of a greedy adversary. Throughout, we write OA and GA to abbreviate the optimal adversary and greedy adversary, respectively.\nIn our experiments, the size of the robust part of the solution set (i.e., |S0|) is set to ⌧2 and ⌧ log ⌧ for OSU and PRO, respectively. That is, we set ⌘ = 1 in PRO, and similarly ignore constant and logarithmic factors in OSU, since both appear to be unnecessary in practice. We show\n1This can be seen by noting that for submodular f and any Z ✓ X ✓ V , f 0(Z) = f(X \\ Z) remains submodular.\nboth the “raw” objective values of the solutions, as well as the objective values after the removal of ⌧ elements. In all experiments, we implement GREEDY using the LAZYGREEDY implementation given in (Minoux, 1978).\nThe objective functions shown in Table 3 are given in Section 3. For the exemplar objective function, we use d(s, v) = ks vk2, and let the reference element e0 be the zero vector. Instead of using the whole set V , we approximate the objective by considering a smaller random subset of V for improved computational efficiency. Since the objective is additively decomposable and bounded, standard concentration bounds (e.g., the Chernoff bound) ensure that the empirical mean over a random subsample can be made arbitrarily accurate.\nData sets. We consider the following datasets, along with the objective functions given in Section 3:\nResults. In the first set of experiments, we compare PROGREEDY (written using the shorthand PRO-GR in the legend) against GREEDY and OSU on the EGO-FACEBOOK and EGO-TWITTER datasets. In this experiment, the dominating set selection objective in (4) is considered. Figure 2 (a) and (c) show the results before and after the worst-case removal of ⌧ = 7 elements for different values of k. In Figure 2 (b) and (d), we show the objective value for fixed k = 50 and k = 100, respectively, while the robustness parameter ⌧ is varied.\nGREEDY achieves the highest raw objective value, followed by PRO-GREEDY and OSU. However, after the worst-case removal, PRO-GREEDY-OA outperforms both OSU-OA and GREEDY-OA. In Figure 2 (a) and (b), GREEDY-OA performs poorly due to a high concentration of the objective value on the first few elements selected by GREEDY. While OSU requires k ⌧2, PRO only requires k ⌧ log ⌧ , and hence it can be run for larger values of ⌧ (e.g., see Figure 2 (b) and (c)). Moreover, in Figure 2 (a) and (b), we can observe that although PRO uses a smaller number of elements to build the robust part of the solution set, it has better robustness in comparison with OSU.\nIn the second set of experiments, we perform the same type of comparisons on the TINY10 and CM-MOLECULES datasets. The exemplar based clustering in (5) is used as the objective function. In Figure 2 (e) and (h), the robustness parameter is fixed to ⌧ = 7 and ⌧ = 6, respectively, while the cardinality k is varied. In Figure 2 (f) and (h), the cardinality is fixed to k = 100 and k = 50, respectively, while the robustness parameter ⌧ is varied.\nAgain, GREEDY achieves the highest objective value. On the TINY10 dataset, GREEDY-OA (Figure 2 (e) and (f)) has a large gap between the raw and final objective, but it still slightly outperforms PRO-GREEDY-OA. This demonstrates that GREEDY can work well in some cases, despite failing in others. We observed that it succeeds here because the objective value is relatively more uniformly spread across the selected elements. On the same dataset, PRO-GREEDY-OA outperforms OSU-OA. On our second dataset CM-MOLECULES (Figure 2 (g) and (h)), PROGREEDY-OA achieves the highest robust objective value, followed by OSU-OA and GREEDY-OA.\nIn our final experiment (see Figure 2 (i)), we compare the performance of PRO-GREEDY against two instances of PRO-STOCHASTIC-GREEDY with ✏ = 0.01 and ✏ = 0.08 (shortened to PRO-ST in the legend), seeking to understand to what extent using the more efficient stochastic subroutine impacts the performance. We also show the performance of OSU. In this experiment, we fix k = 100 and vary ⌧ . We use the greedy adversary instead of the optimal one, since the latter becomes computationally challenging for larger values of ⌧ .\nIn Figure 2 (i), we observe a slight decrease in the objective value of PRO-STOCHASTIC-GREEDY due to the stochastic optimization. On the other hand, the gaps between the robust and non-robust solutions remain similar, or even shrink. Overall, we observe that at least in this example, the stochastic subroutine does not compromise the quality of the solution too significantly, despite having a lower computational complexity."
  }, {
    "heading": "6. Conclusion",
    "text": "We have provided a new Partitioned Robust (PRO) submodular maximization algorithm attaining a constantfactor approximation guarantee for general ⌧ = o(k), thus\nresolving an open problem posed in (Orlin et al., 2016). Our algorithm uses a novel partitioning structure with partitions consisting of buckets with exponentially decreasing size, thus providing a “robust part” of size O(⌧poly log ⌧). We have presented a variety of numerical experiments where PRO outperforms both GREEDY and OSU. A potentially interesting direction for further research is to understand the linear regime, in which ⌧ = ↵k for some constant ↵ 2 (0, 1), and in particular, to seek a constant-factor guarantee for this regime.\nAcknowledgment. This work was supported in part by the European Commission under Grant ERC Future Proof, SNF 200021-146750 and SNF CRSII2-147633, and ‘EPFL Fellows’ (Horizon2020 665667)."
  }],
  "year": 2017,
  "references": [{
    "title": "Fast algorithms for maximizing submodular functions",
    "authors": ["Badanidiyuru", "Ashwinkumar", "Vondrák", "Jan"],
    "venue": "In ACMSIAM Symp. Disc. Alg. (SODA), pp",
    "year": 2014
  }, {
    "title": "Robust protection of networks against cascading phenomena",
    "authors": ["Bogunovic", "Ilija", "Krause", "Andreas"],
    "venue": "Tech. Report ETH Zürich,",
    "year": 2012
  }, {
    "title": "Robust influence maximization",
    "authors": ["Chen", "Wei", "Lin", "Tian", "Tan", "Zihan", "Zhao", "Mingfei", "Zhou", "Xuren"],
    "venue": "arXiv preprint arXiv:1601.06551,",
    "year": 2016
  }, {
    "title": "Nightmare at test time: robust learning by feature deletion",
    "authors": ["Globerson", "Amir", "Roweis", "Sam"],
    "venue": "In Int. Conf. Mach. Learn. (ICML),",
    "year": 2006
  }, {
    "title": "Robust influence maximization",
    "authors": ["He", "Xinran", "Kempe", "David"],
    "venue": "In Int. Conf. Knowledge Discovery and Data Mining (KDD),",
    "year": 2016
  }, {
    "title": "Maximizing the spread of influence through a social network",
    "authors": ["Kempe", "David", "Kleinberg", "Jon", "Tardos", "Éva"],
    "venue": "In Int. Conf. on Knowledge Discovery and Data Mining (SIGKDD),",
    "year": 2003
  }, {
    "title": "Submodular function maximization. Tractability: Practical Approaches to Hard Problems",
    "authors": ["Krause", "Andreas", "Golovin", "Daniel"],
    "year": 2012
  }, {
    "title": "Near-optimal observation selection using submodular functions",
    "authors": ["Krause", "Andreas", "Guestrin", "Carlos"],
    "venue": "In Conf. Art. Intell. (AAAI),",
    "year": 2007
  }, {
    "title": "Robust submodular observation selection",
    "authors": ["Krause", "Andreas", "McMahan", "H Brendan", "Guestrin", "Carlos", "Gupta", "Anupam"],
    "venue": "Journal of Machine Learning Research,",
    "year": 2008
  }, {
    "title": "A class of submodular functions for document summarization",
    "authors": ["Lin", "Hui", "Bilmes", "Jeff"],
    "venue": "In Assoc. for Comp. Ling.: Human Language Technologies-Volume",
    "year": 2011
  }, {
    "title": "Horizontally scalable submodular maximization",
    "authors": ["Lucic", "Mario", "Bachem", "Olivier", "Zadimoghaddam", "Morteza", "Krause", "Andreas"],
    "venue": "In Proc. Int. Conf. Mach. Learn. (ICML),",
    "year": 2016
  }, {
    "title": "Discovering social circles in ego networks",
    "authors": ["Mcauley", "Julian", "Leskovec", "Jure"],
    "venue": "ACM Trans. Knowl. Discov. Data,",
    "year": 2014
  }, {
    "title": "Accelerated greedy algorithms for maximizing submodular set functions",
    "authors": ["Minoux", "Michel"],
    "venue": "In Optimization Techniques,",
    "year": 1978
  }, {
    "title": "Randomized composable core-sets for distributed submodular maximization",
    "authors": ["Mirrokni", "Vahab", "Zadimoghaddam", "Morteza"],
    "venue": "In ACM Symposium on Theory of Computing (STOC),",
    "year": 2015
  }, {
    "title": "Lazier than lazy greedy",
    "authors": ["Mirzasoleiman", "Baharan", "Badanidiyuru", "Ashwinkumar", "Karbasi", "Amin", "Vondrák", "Jan", "Krause", "Andreas"],
    "venue": "In Proc. Conf. Art. Intell. (AAAI),",
    "year": 2015
  }, {
    "title": "Distributed submodular cover: Succinctly summarizing massive data",
    "authors": ["Mirzasoleiman", "Baharan", "Karbasi", "Amin", "Badanidiyuru", "Ashwinkumar", "Krause", "Andreas"],
    "venue": "In Adv. Neur. Inf. Proc. Sys. (NIPS),",
    "year": 2015
  }, {
    "title": "An analysis of approximations for maximizing submodular set functionsi",
    "authors": ["Nemhauser", "George L", "Wolsey", "Laurence A", "Fisher", "Marshall L"],
    "venue": "Mathematical Programming,",
    "year": 1978
  }, {
    "title": "An efficient streaming algorithm for the submodular cover problem",
    "authors": ["Norouzi-Fard", "Ashkan", "Bazzi", "Abbas", "Bogunovic", "Ilija", "El Halabi", "Marwa", "Hsieh", "Ya-Ping", "Cevher", "Volkan"],
    "venue": "In Adv. Neur. Inf. Proc. Sys. (NIPS),",
    "year": 2016
  }, {
    "title": "Robust monotone submodular function maximization",
    "authors": ["Orlin", "James B", "Schulz", "Andreas S", "Udwani", "Rajan"],
    "venue": "In Int. Conf. on Integer Programming and Combinatorial Opt. (IPCO)",
    "year": 2016
  }, {
    "title": "Constrained robust submodular optimization",
    "authors": ["Powers", "Thomas", "Bilmes", "Jeff", "Wisdom", "Scott", "Krout", "David W", "Atlas", "Les"],
    "venue": "NIPS OPT2016 workshop,",
    "year": 2016
  }, {
    "title": "Machine learning for quantum mechanics in a nutshell",
    "authors": ["Rupp", "Matthias"],
    "venue": "Int. Journal of Quantum Chemistry,",
    "year": 2015
  }, {
    "title": "Submodular approximation: Sampling-based algorithms and lower bounds",
    "authors": ["Svitkina", "Zoya", "Fleischer", "Lisa"],
    "venue": "SIAM Journal on Computing,",
    "year": 2011
  }, {
    "title": "80 million tiny images: A large data set for nonparametric object and scene recognition",
    "authors": ["Torralba", "Antonio", "Fergus", "Rob", "Freeman", "William T"],
    "venue": "IEEE Trans. Patt. Ana. Mach. Intel.,",
    "year": 1958
  }],
  "id": "SP:dfd18b71f5c53ec2a95fcbe327cf7710da3b4851",
  "authors": [{
    "name": "Ilija Bogunovic",
    "affiliations": []
  }, {
    "name": "Slobodan Mitrović",
    "affiliations": []
  }, {
    "name": "Jonathan Scarlett",
    "affiliations": []
  }, {
    "name": "Volkan Cevher",
    "affiliations": []
  }],
  "abstractText": "We study the problem of maximizing a monotone submodular function subject to a cardinality constraint k, with the added twist that a number of items ⌧ from the returned set may be removed. We focus on the worst-case setting considered in (Orlin et al., 2016), in which a constant-factor approximation guarantee was given for ⌧ = o( p k). In this paper, we solve a key open problem raised therein, presenting a new Partitioned Robust (PRO) submodular maximization algorithm that achieves the same guarantee for more general ⌧ = o(k). Our algorithm constructs partitions consisting of buckets with exponentially increasing sizes, and applies standard submodular optimization subroutines on the buckets in order to construct the robust solution. We numerically demonstrate the performance of PRO in data summarization and influence maximization, demonstrating gains over both the greedy algorithm and the algorithm of (Orlin et al., 2016).",
  "title": "Robust Submodular Maximization:  A Non-Uniform Partitioning Approach"
}