{
  "sections": [{
    "heading": "1. Introduction",
    "text": "The key challenge of drug discovery is to find target molecules with desired chemical properties. Currently, this task takes years of development and exploration by expert chemists and pharmacologists. Our ultimate goal is to automate this process. From a computational perspective, we decompose the challenge into two complementary subtasks: learning to represent molecules in a continuous manner that facilitates the prediction and optimization of their properties (encoding); and learning to map an optimized continuous representation back into a molecular graph with improved properties (decoding). While deep learning has been extensively investigated for molecular graph encoding (Duvenaud et al., 2015; Kearnes et al., 2016; Gilmer et al., 2017), the harder combinatorial task of molecular graph generation from latent representation remains under-explored.\n1MIT Computer Science & Artificial Intelligence Lab. Correspondence to: Wengong Jin <wengong@csail.mit.edu>.\nProceedings of the 35 th International Conference on Machine Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018 by the author(s).\nPrior work on drug design formulated the graph generation task as a string generation problem (Gómez-Bombarelli et al., 2016; Kusner et al., 2017) in an attempt to side-step direct generation of graphs. Specifically, these models start by generating SMILES (Weininger, 1988), a linear string notation used in chemistry to describe molecular structures. SMILES strings can be translated into graphs via deterministic mappings (e.g., using RDKit (Landrum, 2006)). However, this design has two critical limitations. First, the SMILES representation is not designed to capture molecular similarity. For instance, two molecules with similar chemical structures may be encoded into markedly different SMILES strings (e.g., Figure 1). This prevents generative models like variational autoencoders from learning smooth molecular embeddings. Second, essential chemical properties such as molecule validity are easier to express on graphs rather than linear SMILES representations. We hypothesize that operating directly on graphs improves generative modeling of valid chemical structures.\nOur primary contribution is a new generative model of molecular graphs. While one could imagine solving the problem in a standard manner – generating graphs node by node – the approach is not ideal for molecules. This is because creating molecules atom by atom would force the model to generate chemically invalid intermediaries (see, e.g., Figure 2), delaying validation until a complete graph is generated. Instead, we propose to generate molecular graphs in two phases by exploiting valid subgraphs as components. The overall generative approach, cast as a junction tree variational autoencoder, first generates a tree structured object (a junction tree) whose role is to represent the scaffold of subgraph components and their coarse relative arrangements. The components are valid chemical substructures automatically extracted from the training set using tree decomposition and are used as building blocks. In the sec-\nond phase, the subgraphs (nodes in the tree) are assembled together into a coherent molecular graph.\nWe evaluate our model on multiple tasks ranging from molecular generation to optimization of a given molecule according to desired properties. As baselines, we utilize state-of-the-art SMILES-based generation approaches (Kusner et al., 2017; Dai et al., 2018). We demonstrate that our model produces 100% valid molecules when sampled from a prior distribution, outperforming the top performing baseline by a significant margin. In addition, we show that our model excels in discovering molecules with desired properties, yielding a 30% relative gain over the baselines."
  }, {
    "heading": "2. Junction Tree Variational Autoencoder",
    "text": "Our approach extends the variational autoencoder (Kingma & Welling, 2013) to molecular graphs by introducing a suitable encoder and a matching decoder. Deviating from previous work (Gómez-Bombarelli et al., 2016; Kusner et al., 2017), we interpret each molecule as having been built from subgraphs chosen out of a vocabulary of valid components. These components are used as building blocks both when encoding a molecule into a vector representation as well as when decoding latent vectors back into valid molecular graphs. The key advantage of this view is that the decoder can realize a valid molecule piece by piece by utilizing the collection of valid components and how they interact, rather than trying to build the molecule atom by atom through chemically invalid intermediaries (Figure 2). An aromatic bond, for example, is chemically invalid on its own unless the entire aromatic ring is present. It would be therefore challenging to learn to build rings atom by atom rather than by introducing rings as part of the basic vocabulary.\nOur vocabulary of components, such as rings, bonds and individual atoms, is chosen to be large enough so that a given molecule can be covered by overlapping components or clusters of atoms. The clusters serve the role analogous to cliques in graphical models, as they are expressive enough that a molecule can be covered by overlapping clusters without forming cluster cycles. In this sense, the clusters serve as cliques in a (non-optimal) triangulation of the molecular graph. We form a junction tree of such clusters and use it as the tree representation of the molecule. Since our choice of cliques is constrained a priori, we cannot guarantee that a junction tree exists with such clusters for an arbitrary\nmolecule. However, our clusters are built on the basis of the molecules in the training set to ensure that a corresponding junction tree can be found. Empirically, our clusters cover most of the molecules in the test set.\nThe original molecular graph and its associated junction tree offer two complementary representations of a molecule. We therefore encode the molecule into a two-part latent representation z = [zT , zG] where zT encodes the tree structure and what the clusters are in the tree without fully capturing how exactly the clusters are mutually connected. zG encodes the graph to capture the fine-grained connectivity. Both parts are created by tree and graph encoders q(zT |T ) and q(zG|G). The latent representation is then decoded back into a molecular graph in two stages. As illustrated in Figure 3, we first reproduce the junction tree using a tree decoder p(T |zT ) based on the information in zT . Second, we predict the fine grain connectivity between the clusters in the junction tree using a graph decoder p(G|T , zG) to realize the full molecular graph. The junction tree approach allows us to maintain chemical feasibility during generation.\nNotation A molecular graph is defined as G = (V,E) where V is the set of atoms (vertices) and E the set of bonds (edges). Let N(x) be the neighbor of x. We denote sigmoid function as σ(·) and ReLU function as τ(·). We use i, j, k for nodes in the tree and u, v, w for nodes in the graph."
  }, {
    "heading": "2.1. Junction Tree",
    "text": "A tree decomposition maps a graph G into a junction tree by contracting certain vertices into a single node so that G becomes cycle-free. Formally, given a graph G, a junction tree TG = (V, E ,X ) is a connected labeled tree whose node set is V = {C1, · · · , Cn} and edge set is E . Each node or cluster Ci = (Vi, Ei) is an induced subgraph of G, satisfying the following constraints:\n1. The union of all clusters equals G. That is, ⋃ i Vi = V\nand ⋃ iEi = E.\n2. Running intersection: For all clusters Ci, Cj and Ck, Vi ∩ Vj ⊆ Vk if Ck is on the path from Ci to Cj .\nViewing induced subgraphs as cluster labels, junction trees are labeled trees with label vocabulary X . By our molecule tree decomposition, X contains only cycles (rings) and single edges. Thus the vocabulary size is limited (|X | = 780 for a standard dataset with 250K molecules).\nTree Decomposition of Molecules Here we present our tree decomposition algorithm tailored for molecules, which finds its root in chemistry (Rarey & Dixon, 1998). Our cluster vocabulary X includes chemical structures such as bonds and rings (Figure 3). Given a graphG, we first find all its simple cycles, and its edges not belonging to any cycles. Two simple rings are merged together if they have more than two overlapping atoms, as they constitute a specific structure called bridged compounds (Clayden et al., 2001). Each of those cycles or edges is considered as a cluster. Next, a cluster graph is constructed by adding edges between all intersecting clusters. Finally, we select one of its spanning trees as the junction tree of G (Figure 3). As a result of ring merging, any two clusters in the junction tree have at most two atoms in common, facilitating efficient inference in the graph decoding phase. The detailed procedure is described in the supplementary."
  }, {
    "heading": "2.2. Graph Encoder",
    "text": "We first encode the latent representation of G by a graph message passing network (Dai et al., 2016; Gilmer et al., 2017). Each vertex v has a feature vector xv indicating the atom type, valence, and other properties. Similarly, each edge (u, v) ∈ E has a feature vector xuv indicating its bond type, and two hidden vectors νuv and νvu denoting the message from u to v and vice versa. Due to the loopy structure of the graph, messages are exchanged in a loopy belief propagation fashion:\nν(t)uv = τ(W g 1xu +W g 2xuv +W g 3 ∑ w∈N(u)\\v ν(t−1)wu ) (1)\nwhere ν(t)uv is the message computed in t-th iteration, initialized with ν(0)uv = 0. After T steps of iteration, we aggregate\nthose messages as the latent vector of each vertex, which captures its local graphical structure:\nhu = τ(U g 1xu + ∑ v∈N(u) Ug2ν (T ) vu ) (2)\nThe final graph representation is hG = ∑ i hi/|V |. The mean µG and log variance logσG of the variational posterior approximation are computed from hG with two separate affine layers. zG is sampled from a Gaussian N (µG,σG)."
  }, {
    "heading": "2.3. Tree Encoder",
    "text": "We similarly encode TG with a tree message passing network. Each cluster Ci is represented by a one-hot encoding xi representing its label type. Each edge (Ci, Cj) is associated with two message vectors mij and mji. We pick an arbitrary leaf node as the root and propagate messages in two phases. In the first bottom-up phase, messages are initiated from the leaf nodes and propagated iteratively towards root. In the top-down phase, messages are propagated from the root to all the leaf nodes. Message mij is updated as:\nmij = GRU(xi, {mki}k∈N(i)\\j) (3)\nwhere GRU is a Gated Recurrent Unit (Chung et al., 2014; Li et al., 2015) adapted for tree message passing:\nsij = ∑\nk∈N(i)\\j mki (4)\nzij = σ(W zxi +U zsij + b z) (5) rki = σ(W rxi +U rmki + b r) (6)\nm̃ij = tanh(Wxi +U ∑\nk∈N(i)\\j\nrki mki) (7)\nmij = (1− zij) sij + zij m̃ij (8)\nThe message passing follows the schedule where mij is computed only when all its precursors {mki | k ∈ N(i)\\j} have been computed. This architectural design is motivated by the belief propagation algorithm over trees and is thus different from the graph encoder.\nAfter the message passing, we obtain the latent representation of each node hi by aggregating its inward messages:\nhi = τ(W oxi + ∑ k∈N(i) Uomki) (9)\nThe final tree representation is hTG = hroot, which encodes a rooted tree (T , root). Unlike the graph encoder, we do not apply node average pooling because it confuses the tree decoder which node to generate first. zTG is sampled in a similar way as in the graph encoder. For simplicity, we abbreviate zTG as zT from now on.\nThis tree encoder plays two roles in our framework. First, it is used to compute zT , which only requires the bottom-up phase of the network. Second, after a tree T̂ is decoded\nfrom zT , it is used to compute messages m̂ij over the entire T̂ , to provide essential contexts of every node during graph decoding. This requires both top-down and bottom-up phases. We will elaborate this in section 2.5."
  }, {
    "heading": "2.4. Tree Decoder",
    "text": "We decode a junction tree T from its encoding zT with a tree structured decoder. The tree is constructed in a top-down fashion by generating one node at a time. As illustrated in Figure 4, our tree decoder traverses the entire tree from the root, and generates nodes in their depth-first order. For every visited node, the decoder first makes a topological prediction: whether this node has children to be generated. When a new child node is created, we predict its label and recurse this process. Recall that cluster labels represent subgraphs in a molecule. The decoder backtracks when a node has no more children to generate.\nAt each time step, a node receives information from other nodes in the current tree for making those predictions. The information is propagated through message vectors hij when trees are incrementally constructed. Formally, let Ẽ = {(i1, j1), · · · , (im, jm)} be the edges traversed in a depth first traversal over T = (V, E), where m = 2|E| as each edge is traversed in both directions. The model visits node it at time t. Let Ẽt be the first t edges in Ẽ . The message hit,jt is updated through previous messages:\nhit,jt = GRU(xit , {hk,it}(k,it)∈Ẽt,k 6=jt) (10)\nwhere GRU is the same recurrent unit as in the tree encoder.\nTopological Prediction When the model visits node it, it makes a binary prediction on whether it still has children to be generated. We compute this probability by combining\nAlgorithm 1 Tree decoding at sampling time Require: Latent representation zT\n1: Initialize: Tree T̂ ← ∅ 2: function SampleTree(i, t) 3: Set Xi ← all cluster labels that are chemically compatible with node i and its current neighbors. 4: Set dt ← expand with probability pt. . Eq.(11) 5: if dt = expand and Xi 6= ∅ then 6: Create a node j and add it to tree T̂ . 7: Sample the label of node j from Xi .. Eq.(12) 8: SampleTree(j, t+ 1) 9: end if\n10: end function\nzT , node features xit and inward messages hk,it via a one hidden layer network followed by a sigmoid function:\npt = σ(u d ·τ(Wd1xit+Wd2zT +Wd3 ∑ (k,it)∈Ẽt hk,it) (11)\nLabel Prediction When a child node j is generated from its parent i, we predict its node label with\nqj = softmax(Ulτ(Wl1zT +W l 2hij)) (12)\nwhere qj is a distribution over label vocabulary X . When j is a root node, its parent i is a virtual node and hij = 0.\nLearning The tree decoder aims to maximize the likelihood p(T |zT ). Let p̂t ∈ {0, 1} and q̂j be the ground truth topological and label values, the decoder minimizes the following cross entropy loss:1\nLc(T ) = ∑\nt Ld(pt, p̂t) + ∑ j Ll(qj , q̂j) (13)\nSimilar to sequence generation, during training we perform teacher forcing: after topological and label prediction at each step, we replace them with their ground truth so that the model makes predictions given correct histories.\nDecoding & Feasibility Check Algorithm 1 shows how a tree is sampled from zT . The tree is constructed recursively guided by topological predictions without any external guidance used in training. To ensure the sampled tree could be realized into a valid molecule, we define set Xi to be cluster labels that are chemically compatible with node i and its current neighbors. When a child node j is generated from node i, we sample its label from Xi with a renormalized distribution qj over Xi by masking out invalid labels."
  }, {
    "heading": "2.5. Graph Decoder",
    "text": "The final step of our model is to reproduce a molecular graph G that underlies the predicted junction tree T̂ = (V̂, Ê).\n1The node ordering is not unique as the order within sibling nodes is ambiguous. In this paper we train our model with one ordering and leave this issue for future work.\nNote that this step is not deterministic since there are potentially many molecules that correspond to the same junction tree. The underlying degree of freedom pertains to how neighboring clusters Ci and Cj are attached to each other as subgraphs. Our goal here is to assemble the subgraphs (nodes in the tree) together into the correct molecular graph.\nLet G(T ) be the set of graphs whose junction tree is T . Decoding graph Ĝ from T̂ = (V̂, Ê) is a structured prediction:\nĜ = arg max G′∈G(T̂ )\nfa(G′) (14)\nwhere fa is a scoring function over candidate graphs. We only consider scoring functions that decompose across the clusters and their neighbors. In other words, each term in the scoring function depends only on how a cluster Ci is attached to its neighboring clusters Cj , j ∈ NT̂ (i) in the tree T̂ . The problem of finding the highest scoring graph Ĝ – the assembly task – could be cast as a graphical model inference task in a model induced by the junction tree. However, for efficiency reasons, we will assemble the molecular graph one neighborhood at a time, following the order in which the tree itself was decoded. In other words, we start by sampling the assembly of the root and its neighbors according to their\nscores. Then we proceed to assemble the neighbors and their associated clusters (removing the degrees of freedom set by the root assembly), and so on.\nIt remains to be specified how each neighborhood realization is scored. Let Gi be the subgraph resulting from a particular merging of cluster Ci in the tree with its neighbors Cj , j ∈ NT̂ (i). We score Gi as a candidate subgraph by first deriving a vector representation hGi and then using fai (Gi) = hGi · zG as the subgraph score. To this end, let u, v specify atoms in the candidate subgraph Gi and let αv = i if v ∈ Ci and αv = j if v ∈ Cj \\ Ci. The indices αv are used to mark the position of the atoms in the junction tree, and to retrieve messages m̂i,j summarizing the subtree under i along the edge (i, j) obtained by running the tree encoding algorithm. The neural messages pertaining to the atoms and bonds in subgraph Gi are obtained and aggregated into hGi , similarly to the encoding step, but with different (learned) parameters:\nµ(t)uv = τ(W a 1xu +W a 2xuv +W a 3µ̃ (t−1) uv ) (15)\nµ̃(t−1)uv =\n{∑ w∈N(u)\\v µ (t−1) wu αu = αv\nm̂αu,αv + ∑ w∈N(u)\\v µ (t−1) wu αu 6= αv\nThe major difference from Eq. (1) is that we augment the model with tree messages m̂αu,αv derived by running the tree encoder over the predicted tree T̂ . m̂αu,αv provides a tree dependent positional context for bond (u, v) (illustrated as subtree A in Figure 5).\nLearning The graph decoder parameters are learned to maximize the log-likelihood of predicting correct subgraphs Gi of the ground true graph G at each tree node:\nLg(G) = ∑ i fa(Gi)− log ∑ G′i∈Gi exp(fa(G′i))  (16) where Gi is the set of possible candidate subgraphs at tree node i. During training, we again apply teacher forcing, i.e. we feed the graph decoder with ground truth trees as input.\nComplexity By our tree decomposition, any two clusters share at most two atoms, so we only need to merge at most two atoms or one bond. By pruning chemically invalid subgraphs and merging isomorphic graphs, |Gi| ≈ 4 on average when tested on a standard ZINC drug dataset. The computational complexity of JT-VAE is therefore linear in the number of clusters, scaling nicely to large graphs."
  }, {
    "heading": "3. Experiments",
    "text": "Our evaluation efforts measure various aspects of molecular generation. The first two evaluations follow previously proposed tasks (Kusner et al., 2017). We also introduce a third task — constrained molecule optimization.\n• Molecule reconstruction and validity We test the VAE models on the task of reconstructing input molecules from their latent representations, and decoding valid molecules when sampling from prior distribution. (Section 3.1) • Bayesian optimization Moving beyond generating valid\nmolecules, we test how the model can produce novel molecules with desired properties. To this end, we perform Bayesian optimization in the latent space to search molecules with specified properties. (Section 3.2)\n• Constrained molecule optimization The task is to modify given molecules to improve specified properties, while constraining the degree of deviation from the original molecule. This is a more realistic scenario in drug discovery, where development of new drugs usually starts with known molecules such as existing drugs (Besnard et al., 2012). Since it is a new task, we cannot compare to any existing baselines. (Section 3.3)\nBelow we describe the data, baselines and model configuration that are shared across the tasks. Additional setup details are provided in the task-specific sections.\nData We use the ZINC molecule dataset from Kusner et al. (2017) for our experiments, with the same training/testing split. It contains about 250K drug molecules extracted from the ZINC database (Sterling & Irwin, 2015).\nBaselines We compare our approach with SMILES-based baselines: 1) Character VAE (CVAE) (Gómez-Bombarelli et al., 2016) which generates SMILES strings character by character; 2) Grammar VAE (GVAE) (Kusner et al., 2017) that generates SMILES following syntactic constraints given\nby a context-free grammar; 3) Syntax-directed VAE (SDVAE) (Dai et al., 2018) that incorporates both syntactic and semantic constraints of SMILES via attribute grammar. For molecule generation task, we also compare with GraphVAE (Simonovsky & Komodakis, 2018) that directly generates atom labels and adjacency matrices of graphs.\nModel Configuration To be comparable with the above baselines, we set the latent space dimension as 56, i.e., the tree and graph representation hT and hG have 28 dimensions each. Full training details and model configurations are provided in the appendix."
  }, {
    "heading": "3.1. Molecule Reconstruction and Validity",
    "text": "Setup The first task is to reconstruct and sample molecules from latent space. Since both encoding and decoding process are stochastic, we estimate reconstruction accuracy by Monte Carlo method used in (Kusner et al., 2017): Each molecule is encoded 10 times and each encoding is decoded 10 times. We report the portion of the 100 decoded molecules that are identical to the input molecule.\nTo compute validity, we sample 1000 latent vectors from the prior distribution N (0, I), and decode each of these vectors 100 times. We report the percentage of decoded molecules that are chemically valid (checked by RDKit). For ablation study, we also report the validity of our model without validity check in decoding phase.\nResults Table 1 shows that JT-VAE outperforms previous models in molecule reconstruction, and always pro-\nduces valid molecules when sampled from prior distribution. When validity check is removed, our model could still generates 93.5% valid molecules. This shows our method does not heavily rely on prior knowledge. As shown in Figure 6, the sampled molecules have non-trivial structures such as simple chains. We further sampled 5000 molecules from prior and found they are all distinct from the training set. Thus our model is not a simple memorization.\nAnalysis We qualitatively examine the latent space of JTVAE by visualizing the neighborhood of molecules. Given a molecule, we follow the method in Kusner et al. (2017) to construct a grid visualization of its neighborhood. Figure 6 shows the local neighborhood of the same molecule visualized in Dai et al. (2018). In comparison, our neighborhood does not contain molecules with huge rings (with more than 7 atoms), which rarely occur in the dataset. We also highlight two groups of closely resembling molecules that have identical tree structures but vary only in how clusters are attached together. This demonstrates the smoothness of learned molecular embeddings."
  }, {
    "heading": "3.2. Bayesian Optimization",
    "text": "Setup The second task is to produce novel molecules with desired properties. Following (Kusner et al., 2017), our target chemical property y(·) is octanol-water partition coefficients (logP) penalized by the synthetic accessibility (SA) score and number of long cycles.2 To perform Bayesian optimization (BO), we first train a VAE and associate each molecule with a latent vector, given by the mean of the variational encoding distribution. After the VAE is learned, we train a sparse Gaussian process (SGP) to predict y(m) given its latent representation. Then we perform five iterations of batched BO using the expected improvement heuristic.\nFor comparison, we report 1) the predictive performance of SGP trained on latent encodings learned by different VAEs, measured by log-likelihood (LL) and root mean square error (RMSE) with 10-fold cross validation. 2) The top-3 molecules found by BO under different models.\n2y(m) = logP (m) − SA(m) − cycle(m) where cycle(m) counts the number of rings that have more than six atoms.\nResults As shown in Table 2, JT-VAE finds molecules with significantly better scores than previous methods. Figure 7 lists the top-3 best molecules found by JT-VAE. In fact, JT-VAE finds over 50 molecules with scores over 3.50 (the second best molecule proposed by SD-VAE). Moreover, the SGP yields better predictive performance when trained on JT-VAE embeddings (Table 3)."
  }, {
    "heading": "3.3. Constrained Optimization",
    "text": "Setup The third task is to perform molecule optimization in a constrained scenario. Given a molecule m, the task is to find a different molecule m′ that has the highest property value with the molecular similarity sim(m,m′) ≥ δ for some threshold δ. We use Tanimoto similarity with Morgan fingerprint (Rogers & Hahn, 2010) as the similarity metric, and penalized logP coefficient as our target chemical property. For this task, we jointly train a property predictor F (parameterized by a feed-forward network) with JT-VAE to predict y(m) from the latent embedding of m. To optimize a molecule m, we start from its latent representation, and apply gradient ascent in the latent space to improve the predicted score F (·), similar to (Mueller et al., 2017). After applying K = 80 gradient steps, K molecules are decoded from resulting latent trajectories, and we report the molecule with the highest F (·) that satisfies the similarity constraint. A modification succeeds if one of the decoded molecules satisfies the constraint and is distinct from the original.\nTo provide the greatest challenge, we selected 800 molecules with the lowest property score y(·) from the test set. We report the success rate (how often a modification succeeds), and among success cases the average improvement y(m′)− y(m) and molecular similarity sim(m,m′) between the original and modified molecules m and m′.\nResults Our results are summarized in Table 4. The unconstrained scenario (δ = 0) has the best average improvement, but often proposes dissimilar molecules. When we tighten the constraint to δ = 0.4, about 80% of the time our model finds similar molecules, with an average improvement 0.84. This also demonstrates the smoothness of the learned latent space. Figure 8 illustrates an effective modification resulting in a similar molecule with great improvement."
  }, {
    "heading": "4. Related Work",
    "text": "Molecule Generation Previous work on molecule generation mostly operates on SMILES strings. GómezBombarelli et al. (2016); Segler et al. (2017) built generative models of SMILES strings with recurrent decoders. Unfortunately, these models could generate invalid SMILES that do not result in any molecules. To remedy this issue, Kusner et al. (2017); Dai et al. (2018) complemented the decoder with syntactic and semantic constraints of SMILES by context free and attribute grammars, but these grammars do not fully capture chemical validity. Other techniques such as active learning (Janz et al., 2017) and reinforcement learning (Guimaraes et al., 2017) encourage the model to generate valid SMILES through additional training signal. Very recently, Simonovsky & Komodakis (2018) proposed to generate molecular graphs by predicting their adjacency matrices, and Li et al. (2018) generated molecules node by node. In comparison, our method enforces chemical validity and is more efficient due to the coarse-to-fine generation.\nGraph-structured Encoders The neural network formulation on graphs was first proposed by Gori et al. (2005); Scarselli et al. (2009), and later enhanced by Li et al. (2015) with gated recurrent units. For recurrent architectures over\ngraphs, Lei et al. (2017) designed Weisfeiler-Lehman kernel network inspired by graph kernels. Dai et al. (2016) considered a different architecture where graphs were viewed as latent variable graphical models, and derived their model from message passing algorithms. Our tree and graph encoder are closely related to this graphical model perspective, and to neural message passing networks (Gilmer et al., 2017). For convolutional architectures, Duvenaud et al. (2015) introduced a convolution-like propagation on molecular graphs, which was generalized to other domains by Niepert et al. (2016). Bruna et al. (2013); Henaff et al. (2015) developed graph convolution in spectral domain via graph Laplacian. For applications, graph neural networks are used in semisupervised classification (Kipf & Welling, 2016), computer vision (Monti et al., 2016), and chemical domains (Kearnes et al., 2016; Schütt et al., 2017; Jin et al., 2017).\nTree-structured Models Our tree encoder is related to recursive neural networks and tree-LSTM (Socher et al., 2013; Tai et al., 2015; Zhu et al., 2015). These models encode tree structures where nodes in the tree are bottom-up transformed into vector representations. In contrast, our model propagates information both bottom-up and top-down.\nOn the decoding side, tree generation naturally arises in natural language parsing (Dyer et al., 2016; Kiperwasser & Goldberg, 2016). Different from our approach, natural language parsers have access to input words and only predict the topology of the tree. For general purpose tree generation, Vinyals et al. (2015); Aharoni & Goldberg (2017) applied recurrent networks to generate linearized version of trees, but their architectures were entirely sequence-based. Dong & Lapata (2016); Alvarez-Melis & Jaakkola (2016) proposed tree-based architectures that construct trees top-down from the root. Our model is most closely related to Alvarez-Melis & Jaakkola (2016) that disentangles topological prediction from label prediction, but we generate nodes in a depth-first order and have additional steps that propagate information bottom-up. This forward-backward propagation also appears in Parisotto et al. (2016), but their model is node based whereas ours is based on message passing."
  }, {
    "heading": "5. Conclusion",
    "text": "In this paper we present a junction tree variational autoencoder for generating molecular graphs. Our method significantly outperforms previous work in molecule generation and optimization. For future work, we attempt to generalize our method for general low-treewidth graphs."
  }, {
    "heading": "Acknowledgement",
    "text": "We thank Jonas Mueller, Chengtao Li, Tao Lei and MIT NLP Group for their helpful comments. This work was supported by the DARPA Make-It program under contract ARO W911NF-16-2-0023."
  }],
  "year": 2018,
  "references": [{
    "title": "Towards string-to-tree neural machine translation",
    "authors": ["R. Aharoni", "Y. Goldberg"],
    "venue": "arXiv preprint arXiv:1704.04743,",
    "year": 2017
  }, {
    "title": "Tree-structured decoding with doubly-recurrent neural networks. 2016",
    "authors": ["D. Alvarez-Melis", "T.S. Jaakkola"],
    "year": 2016
  }, {
    "title": "Automated design of ligands to polypharmacological profiles",
    "authors": ["J. Besnard", "G.F. Ruda", "V. Setola", "K. Abecassis", "R.M. Rodriguiz", "Huang", "X.-P", "S. Norval", "M.F. Sassano", "A.I. Shin", "Webster", "L. A"],
    "year": 2012
  }, {
    "title": "Spectral networks and locally connected networks on graphs",
    "authors": ["J. Bruna", "W. Zaremba", "A. Szlam", "Y. LeCun"],
    "venue": "arXiv preprint arXiv:1312.6203,",
    "year": 2013
  }, {
    "title": "Empirical evaluation of gated recurrent neural networks on sequence modeling",
    "authors": ["J. Chung", "C. Gulcehre", "K. Cho", "Y. Bengio"],
    "venue": "arXiv preprint arXiv:1412.3555,",
    "year": 2014
  }, {
    "title": "Organic Chemistry",
    "authors": ["J. Clayden", "N. Greeves", "S. Warren", "P. Wothers"],
    "year": 2001
  }, {
    "title": "Discriminative embeddings of latent variable models for structured data",
    "authors": ["H. Dai", "B. Dai", "L. Song"],
    "venue": "In International Conference on Machine Learning,",
    "year": 2016
  }, {
    "title": "Syntaxdirected variational autoencoder for structured data",
    "authors": ["H. Dai", "Y. Tian", "B. Dai", "S. Skiena", "L. Song"],
    "venue": "International Conference on Learning Representations,",
    "year": 2018
  }, {
    "title": "Language to logical form with neural attention",
    "authors": ["L. Dong", "M. Lapata"],
    "venue": "arXiv preprint arXiv:1601.01280,",
    "year": 2016
  }, {
    "title": "Convolutional networks on graphs for learning molecular fingerprints",
    "authors": ["D.K. Duvenaud", "D. Maclaurin", "J. Iparraguirre", "R. Bombarell", "T. Hirzel", "A. Aspuru-Guzik", "R.P. Adams"],
    "venue": "In Advances in neural information processing systems,",
    "year": 2015
  }, {
    "title": "Recurrent neural network grammars",
    "authors": ["C. Dyer", "A. Kuncoro", "M. Ballesteros", "N.A. Smith"],
    "venue": "arXiv preprint arXiv:1602.07776,",
    "year": 2016
  }, {
    "title": "Neural message passing for quantum chemistry",
    "authors": ["J. Gilmer", "S.S. Schoenholz", "P.F. Riley", "O. Vinyals", "G.E. Dahl"],
    "venue": "arXiv preprint arXiv:1704.01212,",
    "year": 2017
  }, {
    "title": "A new model for learning in graph domains",
    "authors": ["M. Gori", "G. Monfardini", "F. Scarselli"],
    "venue": "In Neural Networks,",
    "year": 2005
  }, {
    "title": "Objective-reinforced generative adversarial networks (organ) for sequence generation models",
    "authors": ["G.L. Guimaraes", "B. Sanchez-Lengeling", "P.L.C. Farias", "A. Aspuru-Guzik"],
    "venue": "arXiv preprint arXiv:1705.10843,",
    "year": 2017
  }, {
    "title": "Deep convolutional networks on graph-structured data",
    "authors": ["M. Henaff", "J. Bruna", "Y. LeCun"],
    "venue": "arXiv preprint arXiv:1506.05163,",
    "year": 2015
  }, {
    "title": "Actively learning what makes a discrete sequence valid",
    "authors": ["D. Janz", "J. van der Westhuizen", "J.M. Hernández-Lobato"],
    "venue": "arXiv preprint arXiv:1708.04465,",
    "year": 2017
  }, {
    "title": "Predicting organic reaction outcomes with weisfeiler-lehman network",
    "authors": ["W. Jin", "C. Coley", "R. Barzilay", "T. Jaakkola"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2017
  }, {
    "title": "Molecular graph convolutions: moving beyond fingerprints",
    "authors": ["S. Kearnes", "K. McCloskey", "M. Berndl", "V. Pande", "P. Riley"],
    "venue": "Journal of computer-aided molecular design,",
    "year": 2016
  }, {
    "title": "Auto-encoding variational bayes",
    "authors": ["D.P. Kingma", "M. Welling"],
    "venue": "arXiv preprint arXiv:1312.6114,",
    "year": 2013
  }, {
    "title": "Easy-first dependency parsing with hierarchical tree lstms",
    "authors": ["E. Kiperwasser", "Y. Goldberg"],
    "venue": "arXiv preprint arXiv:1603.00375,",
    "year": 2016
  }, {
    "title": "Semi-supervised classification with graph convolutional networks",
    "authors": ["T.N. Kipf", "M. Welling"],
    "venue": "arXiv preprint arXiv:1609.02907,",
    "year": 2016
  }, {
    "title": "Grammar variational autoencoder",
    "authors": ["M.J. Kusner", "B. Paige", "J.M. Hernández-Lobato"],
    "venue": "arXiv preprint arXiv:1703.01925,",
    "year": 2017
  }, {
    "title": "Rdkit: Open-source cheminformatics",
    "authors": ["G. Landrum"],
    "venue": "Online). http://www. rdkit. org. Accessed,",
    "year": 2006
  }, {
    "title": "Deriving neural architectures from sequence and graph kernels",
    "authors": ["T. Lei", "W. Jin", "R. Barzilay", "T. Jaakkola"],
    "venue": "arXiv preprint arXiv:1705.09037,",
    "year": 2017
  }, {
    "title": "Gated graph sequence neural networks",
    "authors": ["Y. Li", "D. Tarlow", "M. Brockschmidt", "R. Zemel"],
    "venue": "arXiv preprint arXiv:1511.05493,",
    "year": 2015
  }, {
    "title": "Learning deep generative models of graphs. 2018",
    "authors": ["Y. Li", "O. Vinyals", "C. Dyer", "R. Pascanu", "P. Battaglia"],
    "venue": "URL https://openreview.net/forum? id=Hy1d-ebAb",
    "year": 2018
  }, {
    "title": "Geometric deep learning on graphs and manifolds using mixture model cnns",
    "authors": ["F. Monti", "D. Boscaini", "J. Masci", "E. Rodolà", "J. Svoboda", "M.M. Bronstein"],
    "venue": "arXiv preprint arXiv:1611.08402,",
    "year": 2016
  }, {
    "title": "Sequence to better sequence: continuous revision of combinatorial structures",
    "authors": ["J. Mueller", "D. Gifford", "T. Jaakkola"],
    "venue": "In International Conference on Machine Learning,",
    "year": 2017
  }, {
    "title": "Learning convolutional neural networks for graphs",
    "authors": ["M. Niepert", "M. Ahmed", "K. Kutzkov"],
    "venue": "In International Conference on Machine Learning,",
    "year": 2016
  }, {
    "title": "Neuro-symbolic program synthesis",
    "authors": ["E. Parisotto", "Mohamed", "A.-r", "R. Singh", "L. Li", "D. Zhou", "P. Kohli"],
    "venue": "arXiv preprint arXiv:1611.01855,",
    "year": 2016
  }, {
    "title": "Feature trees: a new molecular similarity measure based on tree matching",
    "authors": ["M. Rarey", "J.S. Dixon"],
    "venue": "Journal of computer-aided molecular design,",
    "year": 1998
  }, {
    "title": "Extended-connectivity fingerprints",
    "authors": ["D. Rogers", "M. Hahn"],
    "venue": "Journal of chemical information and modeling,",
    "year": 2010
  }, {
    "title": "The graph neural network model",
    "authors": ["F. Scarselli", "M. Gori", "A.C. Tsoi", "M. Hagenbuchner", "G. Monfardini"],
    "venue": "IEEE Transactions on Neural Networks,",
    "year": 2009
  }, {
    "title": "Schnet: A continuousfilter convolutional neural network for modeling quantum interactions",
    "authors": ["K. Schütt", "Kindermans", "P.-J", "H.E.S. Felix", "S. Chmiela", "A. Tkatchenko", "Müller", "K.-R"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2017
  }, {
    "title": "Generating focussed molecule libraries for drug discovery with recurrent neural networks",
    "authors": ["M.H. Segler", "T. Kogej", "C. Tyrchan", "M.P. Waller"],
    "venue": "arXiv preprint arXiv:1701.01329,",
    "year": 2017
  }, {
    "title": "Graphvae: Towards generation of small graphs using variational autoencoders",
    "authors": ["M. Simonovsky", "N. Komodakis"],
    "venue": "arXiv preprint arXiv:1802.03480,",
    "year": 2018
  }, {
    "title": "Recursive deep models for semantic compositionality over a sentiment treebank",
    "authors": ["R. Socher", "A. Perelygin", "J. Wu", "J. Chuang", "C.D. Manning", "A. Ng", "C. Potts"],
    "venue": "In Proceedings of the 2013 conference on empirical methods in natural language processing,",
    "year": 2013
  }, {
    "title": "Zinc 15–ligand discovery for everyone",
    "authors": ["T. Sterling", "J.J. Irwin"],
    "venue": "J. Chem. Inf. Model,",
    "year": 2015
  }, {
    "title": "Improved semantic representations from tree-structured long short-term memory networks",
    "authors": ["K.S. Tai", "R. Socher", "C.D. Manning"],
    "venue": "arXiv preprint arXiv:1503.00075,",
    "year": 2015
  }, {
    "title": "Grammar as a foreign language",
    "authors": ["O. Vinyals", "Ł. Kaiser", "T. Koo", "S. Petrov", "I. Sutskever", "G. Hinton"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2015
  }, {
    "title": "Smiles, a chemical language and information system. 1. introduction to methodology and encoding rules",
    "authors": ["D. Weininger"],
    "venue": "Journal of chemical information and computer sciences,",
    "year": 1988
  }, {
    "title": "Long short-term memory over recursive structures",
    "authors": ["X. Zhu", "P. Sobihani", "H. Guo"],
    "venue": "In International Conference on Machine Learning,",
    "year": 2015
  }],
  "id": "SP:3a7d666bfc3b50eab568eea8b97ff16d9c56f036",
  "authors": [{
    "name": "Wengong Jin",
    "affiliations": []
  }, {
    "name": "Regina Barzilay",
    "affiliations": []
  }, {
    "name": "Tommi Jaakkola",
    "affiliations": []
  }],
  "abstractText": "We seek to automate the design of molecules based on specific chemical properties. In computational terms, this task involves continuous embedding and generation of molecular graphs. Our primary contribution is the direct realization of molecular graphs, a task previously approached by generating linear SMILES strings instead of graphs. Our junction tree variational autoencoder generates molecular graphs in two phases, by first generating a tree-structured scaffold over chemical substructures, and then combining them into a molecule with a graph message passing network. This approach allows us to incrementally expand molecules while maintaining chemical validity at every step. We evaluate our model on multiple tasks ranging from molecular generation to optimization. Across these tasks, our model outperforms previous state-of-the-art baselines by a significant margin.",
  "title": "Junction Tree Variational Autoencoder for Molecular Graph Generation"
}