{
  "sections": [{
    "text": "Recently there has been significant interest in training machine-learning models at low precision: by reducing precision, one can reduce computation and communication by one order of magnitude. We examine training at reduced precision, both from a theoretical and practical perspective, and ask: is it possible to train models at end-to-end low precision with provable guarantees? Can this lead to consistent order-ofmagnitude speedups? We mainly focus on linear models, and the answer is yes for linear models. We develop a simple framework called ZipML based on one simple but novel strategy called double sampling. Our ZipML framework is able to execute training at low precision with no bias, guaranteeing convergence, whereas naive quantization would introduce significant bias. We validate our framework across a range of applications, and show that it enables an FPGA prototype that is up to 6.5× faster than an implementation using full 32-bit precision. We further develop a variance-optimal stochastic quantization strategy and show that it can make a significant difference in a variety of settings. When applied to linear models together with double sampling, we save up to another 1.7× in data movement compared with uniform quantization. When training deep networks with quantized models, we achieve higher accuracy than the state-of-theart XNOR-Net.\n1ETH Zurich, Switzerland 2Massachusetts Institute of Technology, USA 3IST Austria, Austria 4University of Rochester, USA. Correspondence to: Hantian Zhang <hantian.zhang@inf.ethz.ch>, Ce Zhang <ce.zhang@inf.ethz.ch>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\n(a) Linear Regression\n(c) 3D Reconstruction\n32Bit 12Bit\n(b) FPGA Speed Up (d) Deep Learning\nMachine Learning Models\nData Movement Channels Speed up because of\nour techniques Gradient Input Samples Model\nLinear Models De Sa et\nla., Alistarh\net al., …\n1. Double Sampling 2. Data-Optimal Encoding Stochastic Rounding Very Significant Speed up (Up to 10x)\nDeep Learning Courbariaux et al., Rastegari et al., … Data-Optimal Encoding Significant Speed up\n0 25 50 75 100\n32-bit Full Precision\nDouble Sampling 4-bit\n#Epochs\nTr ai\nni ng\nL os\ns\n#Epochs (a) Linear Regression (b) LS-SVM\n0 25 50 75 100\n.3\n0\nx0.01\n.12\n0\n.06\nx0.1\n32-bit Full Precision\nDouble Sampling 3-bit .18\n0.01 0.1 1 100 0.01 1\nHogwild!\nFPGA 2-bit\nTime (seconds)\nTr ai\nni ng\nL os\ns\nTime (seconds) (a) Linear Regression (b) LS-SVM\n.75\n0\nx0.01\n.2\n0\n.1\nx0.1FPGA 32-bit FPGA 2-bit\nHogwild!\nFPGA 32-bit\n0\n0.6\n1.2\n1.8\n2.4\n0 10 20 30 40\n32-bit Full Precision\nXNOR5 Optimal5\n#Epochs\n0\n30\n60\n90\n120\n150\n0 6 12 18 24 30\nUniform 3-bit\nTr ai\nni ng\nL os\ns\n#Epochs\n32-bit Full Precision\nOptimal 3-bit, Uniform 5-bit overlap w/ 32-bit Full Precision\n(a) Linear Model (b) Deep Learning\nTime (seconds) (b) Logistic Regression\n0 25 50 75 100 0\n0.05\n0.1\n0.15\n0.2\n0 25 50 75 100\nTr ai\nni ng\nL os\ns\nTime (seconds) (a) SVM\n0\n.1\nx0.1 Chebyshev 8-bit\n32-bit Full Precision .05 Chebyshev 8-bit\n32-bit Full PrecisionDeterministic Rounding 8-bit overlap w/ 32-bit Full Precision\nDeterministic Rounding 8-bit overlap w/ 32-bit Full Precision\nFigure 1. Overview of theoretical results and highlights of empirical results. See Introduction for details."
  }, {
    "heading": "1. Introduction",
    "text": "The computational cost and power consumption of today’s machine learning systems are often driven by data movement, and by the precision of computation. In our experience, in applications such as tomographic reconstruction, anomaly detection in mobile sensor networks, and compressive sensing, the overhead of transmitting the data samples can be massive, and hence performance can hinge on reducing the precision of data representation and associated computation. A similar trend is observed in deep learning, where impressive progress has been reported with systems using end-to-end reduced-precision representations (Hubara et al., 2016; Rastegari et al., 2016; Zhou et al., 2016; Miyashita et al., 2016). The empirical success of these works inspired this paper, in which we try to provide a theoretical understanding of end-to-end lowprecision training for machine learning models. In this context, the motivating question behind our work is: When\ntraining general machine learning models, can we lower the precision of data representation, communication, and computation, while maintaining provable guarantees?\nIn this paper, we develop ZipML, a general framework to answer this question, and present results obtained in the context of this ZipML framework. Figure 1 encapsulates our results: (a) for linear models, we are able to lower the precision of both computation and communication, including input samples, gradients, and model, by up to 16 times, while still providing rigorous theoretical guarantees; (b) our FPGA implementation of this framework achieves up to 6.5× speedup compared with a 32-bit FPGA implementation, or with a 10-core CPU running Hogwild!; (c) we are able to decrease data movement by 2.7× for tomographic reconstruction, while obtaining a negligible quality decrease. Elements of our framework generalize to (d) model compression for training deep learning models. In the following, we describe our technical contributions in more detail."
  }, {
    "heading": "1.1. Summary of Technical Contributions",
    "text": "We consider the following problem in training generalized linear models:\nmin x\n: 1\n2K K∑ k=1 l(a>k x, bk) 2 +R(x), (1)\nwhere l(·, ·) is a loss function andR is a regularization term that could be `1 norm, `2 norm, or even an indicator function representing the constraint. The gradient at the sample (ak, bk) is:\ngk := ak ∂l(a>k x, bk)\n∂a>k x .\nWe denote the problem dimension by n. We consider the properties of the algorithm when a lossy compression scheme is applied to the data (samples), gradient, and model, to reduce the communication cost of the algorithm—that is, we consider quantization functions Qg , Qm, andQs for gradient, model, and samples, respectively, in the gradient update:\nxt+1 ← proxγR(·) (xt − γQg(gk(Qm(xt), Qs(at)))) , (2)\nwhere the proximal operator is defined as\nproxγR(·)(y) = argmin x\n1 2 ‖x− y‖2 + γR(x).\nOur Results. We summarize our results as follows.\nLinear Models. When l(·, ·) is the least squares loss, we first notice that simply doing stochastic quantization of data\nsamples (i.e., Qs) introduces bias of the gradient estimator and therefore SGD would converge to a different solution. We propose a simple solution to this problem by introducing a double sampling strategy Q̃s that uses multiple samples to eliminate the correlation of samples introduced by the non-linearity of the gradient. We analyze the additional variance introduced by double sampling, and find that its impact is negligible in terms of convergence time as long as the number of bits used to store a quantized sample is at least Θ(log n/σ), where σ2 is the variance of the standard stochastic gradient. This implies that the 32-bit precision may be excessive for many practical scenarios.\nWe build on this result to obtain an end-to-end quantization strategy for linear models, which compresses all data movements. For certain settings of parameters, end-to-end quantization adds as little as a constant factor to the variance of the entire process.\nOptimal Quantization and Extension to Deep Learning. We then focus on reducing the variance of stochastic quantization. We notice that different methods for setting the quantization points have different variances—the standard uniformly-distributed quantization strategy is far from optimal in many settings. We formulate this as an independent optimization problem, and solve it optimally with an efficient dynamic programming algorithm that only needs to scan the data in a single pass. When applied to linear models, this optimal strategy can save up to 1.6× communication compared with the uniform strategy.\nWe perform an analysis of the optimal quantizations for various settings, and observe that the uniform quantization approach popularly used by state-of-the-art end-to-end low-precision deep learning training systems when more than 1 bit is used is suboptimal. We apply optimal quantization to models and show that, with one standard neural network, we outperform the uniform quantization used by XNOR-Net and a range of other recent approaches. This is related, but different, to recent work on model compression for inference (Han et al., 2016). To the best of our knowledge, this is the first time such optimal quantization strategies have been applied to training."
  }, {
    "heading": "2. Linear Models",
    "text": "In this section, we focus on linear models with possibly non-smooth regularization. We have labeled data points (a1, b1), (a2, b2), . . . , (aK , bK) ∈ Rn × R, and our goal is to minimize the function\nF (x) = 1\nK K∑ k=1\n‖a>k x− bk‖22︸ ︷︷ ︸ =:f(x) +R(x) , (3)\ni.e., minimize the empirical least squares loss plus a nonsmooth regularization R(·) (e.g., `1 norm, `2 norm, and constraint indicator function). SGD is a popular approach for solving large-scale machine learning problems. It works as follows: at step xt, given an unbiased gradient estimator gt, that is, E(gt) = ∇f(xt), we update xt+1 by\nxt+1 = proxγtR(·) (xt − γtgt) ,\nwhere γt is the predefined step length. SGD guarantees the following convergence property:\nTheorem 1. [e.g., (Bubeck, 2015), Theorem 6.3] Let the sequence {xt}Tt=1 be bounded. Appropriately choosing the steplength, we have the following convergence rate for (3):\nF\n( 1\nT T∑ t=0 xt\n) −min\nx F (x) ≤ Θ\n( 1\nT + σ√ T\n) (4)\nwhere σ is the upper bound of the mean variance\nσ2 ≥ 1 T T∑ t=1 E‖gt −∇f(xt)‖2.\nThere are three key requirements for SGD to converge:\n1. Computing stochastic gradient gt is cheap; 2. The stochastic gradient gt should be unbiased; 3. The stochastic gradient variance σ dominates the con-\nvergence efficiency, so it needs to be controlled appropriately.\nThe common choice is to uniformly select one sample:\ngt = g (full) t := aπ(t)(a > π(t)x− bπ(t)). (5)\n(π(t) is a uniformly random integer from 1 to K). We abuse the notation and let at = aπ(t). Note that g (full) t is an unbiased estimator E[g(full)t ] = ∇f(xt). Although it has received success in many applications, if the precision of sample at can be further decreased, we can save potentially one order of magnitude bandwidth of reading at (e.g.,\nin sensor networks) and the associated computation (e.g., each register can hold more numbers). This motivates us to use low-precision sample points to train the model. The following will introduce the proposed low-precision SGD framework by meeting all three factors for SGD."
  }, {
    "heading": "2.1. Bandwidth-Efficient Stochastic Quantization",
    "text": "We propose to use stochastic quantization to generate a low-precision version of an arbitrary vector v in the following way. Given a vector v, let M(v) be a scaling factor such that −1 ≤ v/M(v) ≤ 1. Without loss of generality, let M(v) = ||v||2. We partition the interval [−1, 1] using s + 1 separators: −1 = l0 ≤ l1... ≤ ls = 1; for each number v in v/M(v), we quantize it to one of two nearest separators: li ≤ v ≤ li+1. We denote the stochastic quantization function by Q(v, s) and choose the probability of quantizing to different separators such that E[Q(v, s)] = v. We use Q(v) when s is not relevant."
  }, {
    "heading": "2.2. Double Sampling for Unbiased Stochastic Gradient",
    "text": "0 75 150 225 300\n32-bit Full Precision\nDeterministic Rounding\nNaive Stochastic Sampling 7%Our Approach\n#Epochs\n.0013\n.0012\n.0014\nTr ai\nni ng\nL os\ns\nThe naive way to use lowprecision samples ât := Q(at) is\nĝt := âtâ > t x− âtbt.\nHowever, the naive approach does not work (that is, it does not guarantee convergence), because it is biased:\nE[ĝt] := ata>t x− atbt +Dax,\nwhere Da is diagonal and its ith diagonal element is\nE[Q(ai)2]− a2i .\nSince Da is non-zero, we obtain a biased estimator of the gradient, so the iteration is unlikely to converge. The figure on the right illustrates the bias caused by a non-zeroDa. In fact, it is easy to see that in instances where the minimizer x is large and gradients become small, we will simply diverge.\nWe now present a simple method to fix the biased gradient estimator. We generate two independent random quantizations and revise the gradient:\ngt := Q1(at)(Q2(at) >x− bt) . (6)\nThis gives us an unbiased estimator of the gradient.\nOverhead of Storing Samples. The reader may have noticed that one implication of double sampling is the overhead of sending two samples instead of one. We note that\nthis will not introduce 2× overhead in terms of data communication. Instead, we start from the observation that the two samples can differ by at most one bit. For example, to quantize the number 0.7 to either 0 or 1. Our strategy is to first store the smallest number of the interval (here 0), and then for each sample, send out 1 bit to represent whether this sample is at the lower marker (0) or the upper marker (1). Under this procedure, once we store the base quantization level, we will need one extra bit for each additional sample. More generally, since samples are used symmetrically, we only need to send a number representing the number of times the lower quantization level has been chosen among all the sampling trials. Thus, sending k samples only requires log2 k more bits."
  }, {
    "heading": "2.3. Variance Reduction",
    "text": "From Theorem 1, the mean variance 1T ∑ t E‖gt − ∇f(x)‖2 will dominate the convergence efficiency. It is not hard to see that the variance of the double sampling based stochastic gradient in (6) can be decomposed into\nE‖gt −∇f(xt)‖2 ≤ E‖g(full)t −∇f(xt)‖2\n+ E‖gt − g(full)t ‖2. (7)\nThe first term is from the full stochastic gradient, which can be reduced by using strategies such as mini-batch, weight sampling, and so on. Thus, reducing the first term is an orthogonal issue for this paper. Rather, we are interested in the second term, which is the additional cost of using lowprecision samples. All strategies for reducing the variance of the first term can seamlessly combine with the approach of this paper. The additional cost can be bounded by the following lemma.\nLemma 1. The stochastic gradient variance using double sampling in (6) E‖gt − g(full)t ‖2 can be bounded by\nΘ ( T V(at)(T V(at)‖x x‖+ ‖a>t x‖2 + ‖x x‖‖at‖2) ) ,\nwhere T V(at) := E‖Q(at)− at‖2 and denotes the element product.\nThus, minimizing T V(at) is key to reducing variance.\nUniform quantization. It makes intuitive sense that, the more levels of quantization, the lower the variance. The following makes this quantitative dependence precise.\nLemma 2. [(Alistarh et al., 2016)] Assume that quantization levels are uniformly distributed. For any vector v ∈ Rn, we have that E[Q(v, s)] = v. Further, the variance of uniform quantization with s levels is bounded by\nT Vs(v) := E[‖Q(v, s)−v‖22] ≤ min(n/s2, √ n/s))‖v‖22. .\nTogether with other results, it suggests the stochastic gradient variance of using double sampling is bounded by\nE‖gt −∇f(xt)‖2 ≤ σ2(full) + Θ ( n/s2 ) ,\nwhere σ2(full) ≥ E‖g (full) t −∇f(x)‖2 is the upper bound of using the full stochastic gradient, assuming that x and all ak’s are bounded. Because the number of quantization levels s is exponential to the number of bits we use to quantize, to ensure that these two terms are comparable (using a low-precision sample does not degrade the convergence rate), the number of bits only needs to be greater than Θ(log n/σ(full)). Even for linear models with millions of features, 32 bits is likely to be “overkill.”"
  }, {
    "heading": "3. Optimal Quantization Strategy for",
    "text": "Reducing Variance\nIn the previous section, we have assumed uniformly distributed quantization points. We now investigate the choice of quantization points and present an optimal strategy to minimize the quantization variance term T V(at).\nProblem Setting. Assume a set of real numbers Ω = {x1, . . . , xN} with cardinality N . WLOG, assume that all numbers are in [0, 1] and that x1 ≤ . . . ≤ xN .\nThe goal is to partition I = {Ij}sj=1 of [0, 1] into s disjoint intervals, so that if we randomly quantize every x ∈ Ij to an endpoint of Ij , the variance is minimal over all possible partitions of [0, 1] into s intervals. Formally:\nmin I:|I|=s MV(I) := 1 N s∑ j=1 ∑ xi∈Ij err(xi, Ij)\ns.t. s⋃ j=1 Ij = [0, 1], Ij ∩ lk = ∅ for k 6= j, (8)\nwhere err(x, I) = (b− x)(x− a) is the variance for point x ∈ I if we quantize x to an endpoint of I = [a, b]. That is, err(x, I) is the variance of the (unique) distribution D supported on a, b so that EX∼D[X] = x.\nGiven an interval I ⊆ [0, 1], we let ΩI be the set of xj ∈ Ω contained in I . We also define err(Ω, I) =∑ xj∈I err(xj , I). Given a partition I of [0, 1], we let\nerr(Ω, I) = ∑ I∈I err(Ω, I). We let the optimum solution be I∗ = argmin|I|=k err(Ω, I), breaking ties randomly."
  }, {
    "heading": "3.1. Dynamic Programming",
    "text": "We first present a dynamic programming algorithm that solves the above problem in an exact way. In the next subsection, we present a more practical approximation algorithm that only needs to scan all data points once.\nThis optimization problem is non-convex and non-smooth. We start from the observation that there exists an optimal solution that places endpoints at input points.\nLemma 3. There is a I∗ so that all endpoints of any I ∈ I∗ are in Ω ∪ {0, 1}.\nTherefore, to solve the problem in an exact way, we just need to select a subset of data points in Ω as quantization points. Define T (k,m) be the optimal total variance for points in [0, dm] with k quantization levels choosing dm = xm for all m = 1, 2, · · · , N . Our goal is to calculate T (s,N). This problem can be solved by dynamic programing using the following recursion\nT (k,m) = min j∈{k−1,k,··· ,m−1}\nT (k − 1, j) + V (j,m),\nwhere V (j,m) denotes the total variance of points falling in the interval [dj , dm]. The complexity of calculating the matrix V (·, ·) is O(N2 + N) and the complexity of calculating the matrix T (·, ·) is O(kN2). The memory cost is O(kN +N2)."
  }, {
    "heading": "3.2. Heuristics",
    "text": "The exact algorithm has a complexity that is quadratic in the number of data points, which may be impractical. To make our algorithm practical, we develop an approximation algorithm that only needs to scan all data points once and has linear complexity to N .\nDiscretization. We can discretize the range [0, 1] into M intervals, i.e., [0, d1), [d1, d2), · · · , [dM−1, 1] with 0 < d1 < d2 < · · · < dM−1 < 1. We then restrict our algorithms to only choose k quantization points within theseM points, instead of all N points in the exact algorithm. The following result bounds the quality of this approximation.\nTheorem 2. Let the maximal number of data points in each “small interval” (defined by {dm}M−1m=1 ) and the maximal length of small intervals be bounded by bN/M and a/M , respectively. Let I∗ := {l∗j} k−1 k=1 and Î∗ := {l̂∗k} k−1 k=1 be the optimal quantization to (8) and the solution with discretization. Let cM/k be the upper bound of the number of small intervals crossed by any “large interval” (defined by I∗). Then we have the discretization error bounded by\nMV(Î∗)−MV(I∗) ≤ a 2bk 4M3 + a2bc2 Mk .\nTheorem 2 suggests that the mean variance using the discrete variance-optimal quantization will converge to the optimal with the rate O(1/Mk).\nDynamic Programming with Candidate Points. Notice that we can apply the same dynamic programming approach given M candidate points. In this case, the total computational complexity becomes O((k + 1)M2 + N), with memory cost O(kM +M2). Also, to find the optimal quantization, we only need to scan all N numbers once. Figure 3 illustrates an example output for our algorithm.\n2-Approximation in Almost-Linear Time. In the full version of this paper (Zhang et al., 2016), we present an algorithm which, given Ω and k, provides a split using at most 4k intervals, which guarantees a 2-approximation of the optimal variance for k intervals, using O(N logN) time. This is a new variant of the algorithm by (Acharya et al., 2015) for the histogram recovery problem. We can use the 4k intervals given by this algorithm as candidates for the DP solution, to get a general 2-approximation using k intervals in time O(N logN + k3)."
  }, {
    "heading": "3.3. Applications to Deep Learning",
    "text": "In this section, we show that it is possible to apply optimal quantization to training deep neural networks.\nState-of-the-art. We focus on training deep neural networks with a quantized model. Let W be the model and l(W) be the loss function. State-of-the-art quantized networks, such as XNOR-Net and QNN, replace W with the quantized version Q(W), and optimize for\nmin W\nl(Q(W)).\nWith a properly defined ∂Q∂W , we can apply the standard backprop algorithm. Choosing the quantization function Q is an important design decision. For 1-bit quantization, XNOR-Net searches the optimal quantization point. However, for multiple bits, XNOR-Net, as well as other approaches such as QNN, resort to uniform quantization.\nOptimal Model Quantization for Deep Learning. We can apply our optimal quantization strategy and use it as the quantization function Q in XNOR-Net. Empirically, this results in quality improvement over the default multi-bits quantizer in XNOR-Net. In spirit, our approach is similar to the 1-bit quantizer of XNOR-Net, which is equivalent to our approach when the data distribution is symmetric— we extend this to multiple bits in a principled way. Another related work is the uniform quantization strategy in log domain (Miyashita et al., 2016), which is similar to our approach when the data distribution is “log uniform.” However, our approach does not rely on any specific assumption\nof the data distribution. Han et al. (2016) use k-means to compress the model for inference —k-means optimizes for a similar, but different, objective function than ours. In this paper, we develop a dynamic programming algorithm to do optimal stochastic quantization efficiently."
  }, {
    "heading": "4. Experiments",
    "text": "We now provide an empirical validation of our ZipML framework.\nExperimental Setup. Table 1 shows the datasets we use. Unless otherwise noted, we always use diminishing stepsizes α/k, where k is the current number of epoch. We tune α for the full precision implementation, and use the same initial step size for our low-precision implementation. (Theory and experiments imply that the low-precision implementation often favors smaller step size. Thus we do not tune step sizes for the low-precision implementation, as this can only improve the accuracy of our approach.)\nSummary of Experiments. Due to space limitations, we only report on Synthetic 100 for regression, and on gisette for classification. The full version of this paper (Zhang et al., 2016) contains (1) several other datasets, and discusses (2) different factors such as impact of the number of features, and (3) refetching heuristics. The FPGA implementation and design decisions can be found in (Kara et al., 2017)."
  }, {
    "heading": "4.1. Convergence on Linear Models",
    "text": "We validate that (1) with double sampling, SGD with low precision converges—in comparable empirical convergence rates—to the same solution as SGD with full pre-\ncision; and (2) implemented on FPGA, our low-precision prototype achieves significant speedup because of the decrease in bandwidth consumption.\nConvergence. Figure 4 illustrates the result of training linear models: (a) linear regression and (b) least squares SVMs, with end-to-end low-precision and full precision. For low precision, we pick the smallest number of bits that results in a smooth convergence curve. We compare the final training loss in both settings and the convergence rate.\nWe see that, for both linear regression and least squares SVM, using 5- or 6-bit is always enough to converge to the same solution with comparable convergence rate. This validates our prediction that double-sampling provides an unbiased estimator of the gradient. Considering the size of input samples that we need to read, we could potentially save 6–8× memory bandwidth compared to using 32-bit.\nSpeedup. We implemented our low-precision framework on a state-of-the-art FPGA platform. The detailed implementation is described in (Kara et al., 2017). This implementation assumes the input data is already quantized and stored in memory (data can be quantized during the first epoch).\nFigure 5 illustrates the result of (1) our FPGA implementation with quantized data, (2) FPGA implementation with 32-bit data, and (3) Hogwild! running with 10 CPU cores. Observe that all approaches converge to the same solution. FPGA with quantized data converges 6-7× faster than FPGA with full precision or Hogwild!. The FPGA implementation with full precision is memory-bandwidth bound, and by using our framework on quantized data, we save up to 8× memory-bandwidth, which explains the speedup.\nImpact of Mini-Batching. We now validate the“sensitivity” of the algorithm to the precision under batching. Equation 7 suggests that, as we increase batch size, the variance term corresponding to input quantization may start to dominate the variance of the stochastic gradient. However, in practice and for reasonable parameter settings, we found this does not occur: convergence trends for small batch size, e.g. 1, are the\nsame as for larger sizes, e.g. 256. Figure 6 shows that, if we use larger mini-batch size (256), we need more epochs than using smaller mini-batch size (16) to converge, but for the quantized version, actually the one with larger mini-batch size converges faster."
  }, {
    "heading": "4.2. Data-Optimal Quantization Strategy",
    "text": "We validate that, with our data-optimal quantization strategy, we can significantly decrease the number of bits that double-sampling requires to achieve the same convergence. Figure 7(a) illustrates the result of using 3-bit and 5-bit for uniform quantization and optimal quantization on the YearPrediction dataset. Here, we only consider quantization on data, but not on gradient or model, because to compute the data-optimal quantization, we need to have access to all data and assume the data doesn’t change too much, which is not the case for gradient or model. The quantization points are calculated for each feature for both uniform quantization and optimal quantization. We see that, while uniform quantization needs 5-bit to converge smoothly, optimal quantization only needs 3-bit. We save almost 1.7× number of bits by just allocating quantization points carefully.\nComparision with uniform quantization. We validate that, with our data-optimal quantization strategy, we can significantly increase the convergence speed.\nFigure 8 illustrates the result of training linear regression models: with uniform quantization points and optimal quantization points. Here, notice that we only quan-\ntize data, but not gradient or model. We see that, if we use same number of bits, optimal quantization always converges faster than uniform quantization and the loss curve is more stable, because the variance induced by quantization is smaller. As a result, with our data-optimal quantization strategy, we can either (1) get up to 4× faster convergence speed with the same number of bits; or (2) save up to 1.7× bits while getting the same convergence speed.\nWe also see from Figure 8 (a) to (c) that if the dataset has more features, usually we need more bits for quantization, because the variance induced by quantization is higher when the dimensionality is higher."
  }, {
    "heading": "4.3. Extensions to Deep Learning",
    "text": "We validate that our data-optimal quantization strategy can be used in training deep neural networks. We take Caffe’s CIFAR-10 tutorial (Caf) and compare three different quantization strategies: (1) Full Precision, (2) XNOR5, a XNOR-Net implementation that, following the multi-bits strategy in the original paper, quantizes data into five uniform levels, and (3) Optimal5, our quantization strategy with five optimal quantization levels. As shown in Figure 7(b), Optimal5 converges to a significantly lower train-\ning loss compared with XNOR5. Also, Optimal5 achieves >5 points higher testing accuracy over XNOR5. This illustrates the improvement obtainable by training a neural network with a carefully chosen quantization strategy."
  }, {
    "heading": "5. Related Work",
    "text": "There has been significant work on “low-precision SGD” (De Sa et al., 2015; Alistarh et al., 2016). These results provide theoretical guarantees only for quantized gradients. The model and input samples, on the other hand, are much more difficult to analyze because of the non-linearity. We focus on end-to-end quantization, for all components.\nLow-Precision Deep Learning. Low-precision training of deep neural networks has been studied intensively and many heuristics work well for a subset of networks. OneBit SGD (Seide et al., 2014) provides a gradient compression heuristic developed in the context of deep neural networks for speech recognition. There are successful applications of end-to-end quantization to training neural networks that result in little to no quality loss (Hubara et al., 2016; Rastegari et al., 2016; Zhou et al., 2016; Miyashita et al., 2016; Li et al., 2016; Gupta et al., 2015). They quantize weights, activations, and gradients to low precision (e.g., 1-bit) and revise the back-propagation algorithm to be aware of the quantization function. The empirical success of these works inspired this paper, in which we try to provide a theoretical understanding of end-to-end lowprecision training for machine learning models. Another line of research concerns inference and model compression of a pre-trained model (Vanhoucke et al., 2011; Gong et al., 2014; Han et al., 2016; Lin et al., 2016; Kim & Smaragdis, 2016; Kim et al., 2015; Wu et al., 2016). In this paper, we focus on training and leave the study of inference for future work.\nLow-Precision Linear Models. Quantization is a fundamental topic studied by the DSP community, and there has been research on linear regression models in the presence of quantization error or other types of noise. For example, Gopi et al. (2013) studied compressive sensing with binary quantized measurement, and a two-stage algorithm was proposed to recover the sparse high-precision solution up to a scale factor. Also, the classic errors-in-variable model (Hall, 2008) could also be relevant if quantization is treated as a source of “error.” In this paper, we scope ourselves to the context of stochastic gradient descent, and our insights go beyond simple linear models. For SVM the straw man approach can also be seen as a very simple case of kernel approximation (Cortes et al., 2010).\nOther Related Work. Precision of data representation is a key design decision for configurable hardwares such as\nFPGA. There have been attempts to lower the precision when training on such hardware (Kim et al., 2011). These results are mostly empirical; we aim at providing a theoretical understanding, which enables new algorithms."
  }, {
    "heading": "6. Discussion and Future Work",
    "text": "Our motivating question was whether end-to-end lowprecision data representation can enable efficient computation with convergence guarantees. We show that ZipML, a relatively simple stochastic quantization framework can achieve this for linear models. With this setting, as little as two bits per model dimension are sufficient for good accuracy, and can enable a fast FPGA implementation.\nNon-Linear Models. We mainly discussed linear models (e.g. linear regression) in this paper. The natural question is that can we extend our ZipML framework to nonlinear models (e.g. logistic regression or SVM) which are arguably more commonly used. In the full version on this paper, we examine this problem, and find that our framework can be generalized to non-linear settings, and that in practice 8-bit is sufficient to achieve good accuracy on a variety of tasks, such as SVM and logistic regression. However, we notice that a strawman approach, which applies naive stochastic rounding over the input data to just 8-bit precision, converges to similar results, without the added complexity. It is interesting to consider the rationale behind these results. Our framework is based on the idea of unbiased approximation of the original SGD process. For linear models, this is easy to achieve. For non-linear models, this is harder, and we focus on guaranteeing arbitrarily low bias. However, for a variety of interesting functions such as hinge loss, guaranteeing low bias requires complex approximations. In turn, these increase the variance. The complexity of the approximation and the resulting variance increase force us to increase the density of the quantization, in order to achieve good approximation guarantees.\nHardware Selection. We choose to realize our implementation using FPGA because of its flexibility in dealing with low-precision arithmetic, while CPU or GPU can only do at least 8-bit computation efficiently. However, we do observe speed up in other environments – for example, the double sampling techniques are currently being applied to sensor networks with embedded GPUs and CPUs to achieve similar speedup. We are currently conducting an architecture exploration study which aims at understanding the system trade-off between FPGA, CPU, and GPU. This requires us to push the implementation on all three architectures to the extreme. We expect this study will soon provide a full systematic answer to the question that on which hardware can we get the most from the ZipML framework."
  }, {
    "heading": "Acknowledgements",
    "text": "CZ gratefully acknowledges the support from the Swiss National Science Foundation NRP 75 407540 167266, NVIDIA Corporation for its GPU donation, and Microsoft Azure for Research award program."
  }],
  "year": 2017,
  "references": [{
    "title": "Fast and nearoptimal algorithms for approximating distributions by histograms",
    "authors": ["Acharya", "Jayadev", "Diakonikolas", "Ilias", "Hegde", "Chinmay", "Li", "Jerry Zheng", "Schmidt", "Ludwig"],
    "venue": "In PODS,",
    "year": 2015
  }, {
    "title": "QSGD: Randomized Quantization for Communication-Optimal Stochastic Gradient Descent",
    "authors": ["Alistarh", "Dan", "Li", "Jerry", "Tomioka", "Ryota", "Vojnovic", "Milan"],
    "year": 2016
  }, {
    "title": "On the impact of kernel approximation on learning accuracy",
    "authors": ["Cortes", "Corinna", "Mohri", "Mehryar", "Talwalkar", "Ameet"],
    "venue": "In AISTATS,",
    "year": 2010
  }, {
    "title": "Taming the wild: A unified analysis of hogwild-style algorithms",
    "authors": ["De Sa", "Christopher M", "Zhang", "Ce", "Olukotun", "Kunle", "Ré", "Christopher"],
    "venue": "In NIPS,",
    "year": 2015
  }, {
    "title": "Compressing deep convolutional networks using vector quantization",
    "authors": ["Gong", "Yunchao", "Liu", "Yang", "Ming", "Bourdev", "Lubomir"],
    "year": 2014
  }, {
    "title": "One-bit compressed sensing: Provable support and vector recovery",
    "authors": ["Gopi", "Sivakant", "Netrapalli", "Praneeth", "Jain", "Prateek", "Nori", "Aditya"],
    "venue": "In ICML,",
    "year": 2013
  }, {
    "title": "Deep learning with limited numerical precision",
    "authors": ["Gupta", "Suyog", "Agrawal", "Ankur", "Gopalakrishnan", "Kailash", "Narayanan", "Pritish"],
    "venue": "In ICML,",
    "year": 2015
  }, {
    "title": "Measurement error in nonlinear models: A modern perspective (2nd ed.)",
    "authors": ["Hall", "Daniel B"],
    "venue": "Journal of the American Statistical Association,",
    "year": 2008
  }, {
    "title": "Deep compression: Compressing deep neural networks with pruning, trained quantization and huffman coding",
    "authors": ["Han", "Song", "Mao", "Huizi", "Dally", "William J"],
    "venue": "In ICLR,",
    "year": 2016
  }, {
    "title": "Quantized neural networks: Training neural networks with low precision weights and activations",
    "authors": ["Hubara", "Itay", "Courbariaux", "Matthieu", "Soudry", "Daniel", "ElYaniv", "Ran", "Bengio", "Yoshua"],
    "year": 2016
  }, {
    "title": "Fpga accelerated dense linear machine learning: A precision-convergence trade-off",
    "authors": ["Kara", "Kaan", "Alistarh", "Dan", "Zhang", "Ce", "Mutlu", "Onur", "Alonso", "Gustavo"],
    "year": 2017
  }, {
    "title": "Hardware acceleration of iterative image reconstruction for x-ray computed tomography",
    "authors": ["Kim", "Jung Kuk", "Zhang", "Zhengya", "Fessler", "Jeffrey A"],
    "venue": "In ICASSP,",
    "year": 2011
  }, {
    "title": "Compression of deep convolutional neural networks for fast and low power mobile applications",
    "authors": ["Kim", "Yong-Deok", "Park", "Eunhyeok", "Yoo", "Sungjoo", "Choi", "Taelim", "Yang", "Lu", "Shin", "Dongjun"],
    "year": 2015
  }, {
    "title": "Fixed point quantization of deep convolutional networks",
    "authors": ["Lin", "Darryl", "Talathi", "Sachin", "Annapureddy", "Sreekanth"],
    "venue": "In ICML,",
    "year": 2016
  }, {
    "title": "Convolutional neural networks using logarithmic data representation",
    "authors": ["Miyashita", "Daisuke", "Lee", "Edward H", "Murmann", "Boris"],
    "year": 2016
  }, {
    "title": "Xnor-net: Imagenet classification using binary convolutional neural networks",
    "authors": ["Rastegari", "Mohammad", "Ordonez", "Vicente", "Redmon", "Joseph", "Farhadi", "Ali"],
    "venue": "In ECCV,",
    "year": 2016
  }, {
    "title": "1-bit stochastic gradient descent and application to data-parallel distributed training of speech dnns",
    "authors": ["Seide", "Frank", "Fu", "Hao", "Droppo", "Jasha", "Li", "Gang", "Yu", "Dong"],
    "venue": "In Interspeech,",
    "year": 2014
  }, {
    "title": "Improving the speed of neural networks on cpus",
    "authors": ["Vanhoucke", "Vincent", "Senior", "Andrew", "Mao", "Mark Z"],
    "venue": "In NIPS Workshop on Deep Learning and Unsupervised Feature Learning,",
    "year": 2011
  }, {
    "title": "Quantized convolutional neural networks for mobile devices",
    "authors": ["Wu", "Jiaxiang", "Leng", "Cong", "Wang", "Yuhang", "Hu", "Qinghao", "Cheng", "Jian"],
    "year": 2016
  }, {
    "title": "The zipml framework for training models with end-to-end low precision: The cans, the cannots, and a little bit of deep learning",
    "authors": ["Zhang", "Hantian", "Li", "Jerry", "Kara", "Kaan", "Alistarh", "Dan", "Liu", "Ji", "Ce"],
    "year": 2016
  }, {
    "title": "Dorefa-net: Training low bitwidth convolutional neural networks with low bitwidth gradients",
    "authors": ["Zhou", "Shuchang", "Wu", "Yuxin", "Ni", "Zekun", "Xinyu", "Wen", "He", "Zou", "Yuheng"],
    "year": 2016
  }],
  "id": "SP:7f0d3991feb75f6f2fd50d0f2f80d820f20054cc",
  "authors": [{
    "name": "Hantian Zhang",
    "affiliations": []
  }, {
    "name": "Jerry Li",
    "affiliations": []
  }, {
    "name": "Kaan Kara",
    "affiliations": []
  }, {
    "name": "Dan Alistarh",
    "affiliations": []
  }, {
    "name": "Ji Liu",
    "affiliations": []
  }, {
    "name": "Ce Zhang",
    "affiliations": []
  }],
  "abstractText": "Recently there has been significant interest in training machine-learning models at low precision: by reducing precision, one can reduce computation and communication by one order of magnitude. We examine training at reduced precision, both from a theoretical and practical perspective, and ask: is it possible to train models at end-to-end low precision with provable guarantees? Can this lead to consistent order-ofmagnitude speedups? We mainly focus on linear models, and the answer is yes for linear models. We develop a simple framework called ZipML based on one simple but novel strategy called double sampling. Our ZipML framework is able to execute training at low precision with no bias, guaranteeing convergence, whereas naive quantization would introduce significant bias. We validate our framework across a range of applications, and show that it enables an FPGA prototype that is up to 6.5× faster than an implementation using full 32-bit precision. We further develop a variance-optimal stochastic quantization strategy and show that it can make a significant difference in a variety of settings. When applied to linear models together with double sampling, we save up to another 1.7× in data movement compared with uniform quantization. When training deep networks with quantized models, we achieve higher accuracy than the state-of-theart XNOR-Net. ETH Zurich, Switzerland Massachusetts Institute of Technology, USA IST Austria, Austria University of Rochester, USA. Correspondence to: Hantian Zhang <hantian.zhang@inf.ethz.ch>, Ce Zhang <ce.zhang@inf.ethz.ch>. Proceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s). (a) Linear Regression (c) 3D Reconstruction 32Bit 12Bit (b) FPGA Speed Up (d) Deep Learning Machine Learning Models Data Movement Channels Speed up because of our techniques Gradient Input Samples Model Linear Models De Sa et la., Alistarh et al., ... 1. Double Sampling 2. Data-Optimal Encoding Stochastic Rounding Very Significant Speed up (Up to 10x) Deep Learning Courbariaux et al., Rastegari et al., ... Data-Optimal Encoding Significant Speed up 0 25 50 75 100 32-bit Full Precision Double Sampling 4-bit #Epochs Tr ai ni ng L os s #Epochs (a) Linear Regression (b) LS-SVM 0 25 50 75 100 .3",
  "title": "ZipML: Training Linear Models with End-to-End Low Precision, and a Little Bit of Deep Learning"
}