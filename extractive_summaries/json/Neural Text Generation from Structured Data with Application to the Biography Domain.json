{
  "sections": [{
    "text": "Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pages 1203–1213, Austin, Texas, November 1-5, 2016. c©2016 Association for Computational Linguistics\nThis paper introduces a neural model for concept-to-text generation that scales to large, rich domains. It generates biographical sentences from fact tables on a new dataset of biographies from Wikipedia. This set is an order of magnitude larger than existing resources with over 700k samples and a 400k vocabulary. Our model builds on conditional neural language models for text generation. To deal with the large vocabulary, we extend these models to mix a fixed vocabulary with copy actions that transfer sample-specific words from the input database to the generated output sentence. To deal with structured data, we allow the model to embed words differently depending on the data fields in which they occur. Our neural model significantly outperforms a Templated Kneser-Ney language model by nearly 15 BLEU."
  }, {
    "heading": "1 Introduction",
    "text": "Concept-to-text generation renders structured records into natural language (Reiter et al., 2000). A typical application is to generate a weather forecast based on a set of structured meteorological measurements. In contrast to previous work, we scale to the large and very diverse problem of generating biographies based on Wikipedia infoboxes. An infobox is a fact table describing a person, similar to a person subgraph in a knowledge base (Bollacker et al., 2008; Ferrucci, 2012). Similar generation applications include the generation of product descriptions based on a catalog of millions of items with dozens of attributes each.\nPrevious work experimented with datasets that contain only a few tens of thousands of records such as WEATHERGOV or the ROBOCUP dataset, while our dataset contains over 700k biographies from\n∗Rémi performed this work while interning at Facebook.\nWikipedia. Furthermore, these datasets have a limited vocabulary of only about 350 words each, compared to over 400k words in our dataset.\nTo tackle this problem we introduce a statistical generation model conditioned on a Wikipedia infobox. We focus on the generation of the first sentence of a biography which requires the model to select among a large number of possible fields to generate an adequate output. Such diversity makes it difficult for classical count-based models to estimate probabilities of rare events due to data sparsity. We address this issue by parameterizing words and fields as embeddings, along with a neural language model operating on them (Bengio et al., 2003). This factorization allows us to scale to a larger number of words and fields than Liang et al. (2009), or Kim and Mooney (2010) where the number of parameters grows as the product of the number of words and fields.\nMoreover, our approach does not restrict the relations between the field contents and the generated text. This contrasts with less flexible strategies that assume the generation to follow either a hybrid alignment tree (Kim and Mooney, 2010), a probabilistic context-free grammar (Konstas and Lapata, 2013), or a tree adjoining grammar (Gyawali and Gardent, 2014).\nOur model exploits structured data both globally and locally. Global conditioning summarizes all information about a personality to understand highlevel themes such as that the biography is about a scientist or an artist, while as local conditioning describes the previously generated tokens in terms of the their relationship to the infobox. We analyze the effectiveness of each and demonstrate their complementarity."
  }, {
    "heading": "2 Related Work",
    "text": "Traditionally, generation systems relied on rules and hand-crafted specifications (Dale et al., 2003; Reiter et al., 2005; Green, 2006; Galanis and Androut-\n1203\nsopoulos, 2007; Turner et al., 2010). Generation is divided into modular, yet highly interdependent, decisions: (1) content planning defines which parts of the input fields or meaning representations should be selected; (2) sentence planning determines which selected fields are to be dealt with in each output sentence; and (3) surface realization generates those sentences.\nData-driven approaches have been proposed to automatically learn the individual modules. One approach first aligns records and sentences and then learns a content selection model (Duboue and McKeown, 2002; Barzilay and Lapata, 2005). Hierarchical hidden semi-Markov generative models have also been used to first determine which facts to discuss and then to generate words from the predicates and arguments of the chosen facts (Liang et al., 2009). Sentence planning has been formulated as a supervised set partitioning problem over facts where each partition corresponds to a sentence (Barzilay and Lapata, 2006). End-to-end approaches have combined sentence planning and surface realization by using explicitly aligned sentence/meaning pairs as training data (Ratnaparkhi, 2002; Wong and Mooney, 2007; Belz, 2008; Lu and Ng, 2011). More recently, content selection and surface realization have been combined (Angeli et al., 2010; Kim and Mooney, 2010; Konstas and Lapata, 2013).\nAt the intersection of rule-based and statistical methods, hybrid systems aim at leveraging human contributed rules and corpus statistics (Langkilde and Knight, 1998; Soricut and Marcu, 2006; Mairesse and Walker, 2011).\nOur approach is inspired by the recent success of neural language models for image captioning (Kiros et al., 2014; Karpathy and Fei-Fei, 2015; Vinyals et al., 2015; Fang et al., 2015; Xu et al., 2015), machine translation (Devlin et al., 2014; Bahdanau et al., 2015; Luong et al., 2015), and modeling conversations and dialogues (Shang et al., 2015; Wen et al., 2015; Yao et al., 2015).\nOur model is most similar to Mei et al. (2016) who use an encoder-decoder style neural network model to tackle the WEATHERGOV and ROBOCUP tasks. Their architecture relies on LSTM units and an attention mechanism which reduces scalability compared to our simpler design."
  }, {
    "heading": "3 Language Modeling for Constrained Sentence generation",
    "text": "Conditional language models are a popular choice to generate sentences. We introduce a tableconditioned language model for constraining text generation to include elements from fact tables."
  }, {
    "heading": "3.1 Language model",
    "text": "Given a sentence s = w1, . . . , wT with T words from vocabularyW , a language model estimates:\nP (s) =\nT∏\nt=1\nP (wt|w1, . . . , wt−1) . (1)\nLet ct = wt−(n−1), . . . , wt−1 be the sequence of n − 1 context words preceding wt. An n-gram language model makes an order n Markov assumption,\nP (s) ≈ T∏\nt=1\nP (wt|ct) . (2)"
  }, {
    "heading": "3.2 Language model conditioned on tables",
    "text": "A table is a set of field/value pairs, where values are sequences of words. We therefore propose language models that are conditioned on these pairs.\nLocal conditioning refers to the information from the table that is applied to the description of the words which have already generated, i.e. the previous words that constitute the context of the language\n1204\nmodel. The table allows us to describe each word not only by its string (or index in the vocabulary) but also by a descriptor of its occurrence in the table. Let F define the set of all possible fields f . The occurrence of a word w in the table is described by a set of (field, position) pairs.\nzw = { (fi, pi) }m i=1 , (3)\nwhere m is the number of occurrences of w. Each pair (f, p) indicates that w occurs in field f at position p. In this scheme, most words are described by the empty set as they do not occur in the table. For example, the word linguistics in the table of Figure 1 is described as follows:\nzlinguistics = {(fields, 8); (known for, 4)}, (4) assuming words are lower-cased and commas are treated as separate tokens.\nConditioning both on the field type and the position within the field allows the model to encode field-specific regularities, e.g., a number token in a date field is likely followed by a month token; knowing that the number is the first token in the date field makes this even more likely.\nThe (field, position) description scheme of the table does not allow to express that a token terminates a field which can be useful to capture field transitions. For biographies, the last token of the name field is often followed by an introduction of the birth date like ‘(’ or ‘was born’. We hence extend our descriptor to a triplet that includes the position of the\ntoken counted from the end of the field:\nzw = { (fi, p + i , p − i ) }m i=1 , (5)\nwhere our example becomes:\nzlinguistics = {(fields, 8, 4); (known for, 4, 13)}.\nWe extend Equation 2 to use the above information as additional conditioning context when generating a sentence s:\nP (s|z) = T∏\nt=1\nP (wt|ct, zct) , (6)\nwhere zct = zwt−(n−1) , . . . , zwt−1 are referred to as the local conditioning variables since they describe the local context (previous word) relations with the table.\nGlobal conditioning refers to information from all tokens and fields of the table, regardless whether they appear in the previous generated words or not. The set of fields available in a table often impacts the structure of the generation. For biographies, the fields used to describe a politician are different from the ones for an actor or an athlete. We introduce global conditioning on the available fields gf as\nP (s|z, gf ) = T∏\nt=1\nP (wt|ct, zct , gf ). (7)\nSimilarly, global conditioning gw on the available\n1205\nwords occurring in the table is introduced:\nP (s|z, gf , gw) = T∏\nt=1\nP (wt|ct, zct , gf , gw). (8)\nTokens provide information complementary to fields. For example, it may be hard to distinguish a basketball player from a hockey player by looking only at the field names, e.g. teams, league, position, weight and height, etc. However the actual field tokens such as team names, league name, player’s position can help the model to give a better prediction. Here, gf ∈ {0, 1}F and gw ∈ {0, 1}W are binary indicators over fixed field and word vocabularies.\nFigure 2 illustrates the model with a schematic example. For predicting the next word wt after a given context ct, the language model is conditioned on sets of triplets for each word occurring in the table zct , along with all fields and words from this table."
  }, {
    "heading": "3.3 Copy actions",
    "text": "So far we extended the model conditioning with features derived from the fact table. We now turn to using table information when scoring output words. In particular, sentences which express facts from a given table often copy words from the table. We therefore extend our model to also score special field tokens such as name 1 or name 2 which are subsequently added to the score of the corresponding words from the field value.\nOur model reads a table and defines an output domainW∪Q. Q defines all tokens in the table, which might include out of vocabulary words (/∈ W). For instance Park-Rhodes in Figure 1 is not inW . However, Park-Rhodes will be included in Q as name 2 (since it is the second token of the name field) which allows our model to generate it. This mechanism is inspired by recent work on attention based word copying for neural machine translation (Luong et al., 2015) as well as delexicalization for neural dialog systems (Wen et al., 2015). It also builds upon older work such as class-based language models for dialog systems (Oh and Rudnicky, 2000)."
  }, {
    "heading": "4 A Neural Language Model Approach",
    "text": "A feed-forward neural language model (NLM) estimates P (wt|ct) with a parametric function φθ\n(Equation 1), where θ refers to all learnable parameters of the network. This function is a composition of simple differentiable functions or layers."
  }, {
    "heading": "4.1 Mathematical notations and layers",
    "text": "We denote matrices as bold upper case letters (X, Y, Z), and vectors as bold lower-case letters (a, b, c). Ai represents the ith row of matrix A. When A is a 3-d matrix, then Ai,j represents the vector of the ith first dimension and jth second dimension. Unless otherwise stated, vectors are assumed to be column vectors. We use [v1;v2] to denote vector concatenation. Next, we introduce the notation for the different layers used in our approach.\nEmbedding layer. Given a parameter matrix X ∈ RN×d, the embedding layer is a lookup table that performs an array indexing operation:\nψX(xi) = Xi ∈ Rd , (9) where Xi corresponds to the embedding of the element xi at row i. When X is a 3-d matrix, the lookup table takes two arguments:\nψX(xi, xj) = Xi,j ∈ Rd , (10) where Xi,j corresponds to the embedding of the pair (xi, xj) at index (i, j). The lookup table operation can be applied for a sequence of elements s = x1, . . . , xT . A common approach is to concatenate all resulting embeddings:\nψX(s) = [ ψX(x1); . . . ;ψX(xT ) ] ∈ RT×d . (11)\nLinear layer. This layer applies a linear transformation to its inputs x ∈ Rn:\nγθ(x) = Wx+ b (12)\nwhere θ = {W,b} are the trainable parameters with W ∈ Rm×n being the weight matrix, and b ∈ Rm is the bias term.\nSoftmax layer. Given a context input ct, the final layer outputs a score for each word wt ∈ W , φθ(ct) ∈ R|W|. The probability distribution is obtained by applying the softmax activation function:\nP (wt = w|ct) = exp(φθ(ct, w))∑|W| i=1 exp(φθ(ct, wi))\n(13)\n1206"
  }, {
    "heading": "4.2 Embeddings as inputs",
    "text": "A key aspect of neural language models is the use of word embeddings. Similar words tend to have similar embeddings and thus share latent features. The probability estimates of those models are smooth functions of these embeddings, and a small change in the features results in a small change in the probability estimates (Bengio et al., 2003). Therefore, neural language models can achieve better generalization for unseen n-grams. Next, we show how we map fact tables to continuous space in similar spirit.\nWord embeddings. Formally, the embedding layer maps each context word index to a continuous d-dimensional vector. It relies on a parameter matrix E ∈ R|W|×d to convert the input ct into n − 1 vectors of dimension d:\nψE(ct) = [ ψE(wt−(n−1)); . . . ;ψE(wt−1) ] . (14)\nE can be initialized randomly or with pre-trained word embeddings.\nTable embeddings. As described in Section 3.2, the language model is conditioned on elements from the table. Embedding matrices are therefore defined to model both local and global conditioning information. For local conditioning, we denote the maximum length of a sequence of words as l. Each field fj ∈ F is associated with 2 × l vectors of d dimensions, the first l of those vectors embed all possible starting positions 1, . . . , l, and the remaining l vectors embed ending positions. This results in two parameter matrices Z = {Z+,Z−} ∈ R|F|×l×d. For a given triplet (fj , p+i , p − i ), ψZ+(fj , p + i ) and ψZ−(fj , p − i ) refer to the embedding vectors of the start and end position for field fj , respectively. Finally, global conditioning uses two parameter matrices Gf ∈ R|F|×g and Gw ∈ R|W|×g. ψGf (fj) maps a table field fj into a vector of dimension g, while ψGw(wt) maps a word wt into a vector of the same dimension. In general, Gw shares its parameters with E, provided d = g.\nAggregating embeddings. We represent each occurence of a word w as a triplet (field, start, end) where we have embeddings for the start and end position as described above. Often times a particular word w occurs multiple times in a table, e.g., ‘lin-\nguistics’ has two instances in Figure 1. In this case, we perform a component-wise max over the start embeddings of all instances of w to obtain the best features across all occurrences ofw. We do the same for end position embeddings:\nψZ(zwt) =[ max { ψZ+(fj , p + i ), ∀(fj , p+i , p−i ) ∈ zwt } ; max { ψZ−(fj , p − i ), ∀(fj , p+i , p−i ) ∈ zwt }] (15)\nA special no-field embedding is assigned towt when the word is not associated to any fields. An embedding ψZ(zct) for encoding the local conditioning of the input ct is obtained by concatenation.\nFor global conditioning, we define Fq ⊂ F as the set of all the fields in a given table q, andQ as the set of all words in q. We also perform max aggregation. This yields the vectors\nψGf (gf ) = max { ψGf (fj), ∀fj ∈ Fq } , (16)\nand\nψGw(gw) = max { ψGw(wt),∀wt ∈ Q } . (17)\nThe final embedding which encodes the context input with conditioning is then the concatenation of these vectors:\nψα1(ct, zct , gf , gw) = [ ψE(ct); ψZ(zct);\nψGf (gf ); ψGw(gw) ] ∈ Rd1 , (18)\nwith α1 = {E,Z+,Z−,Gf ,Gw} and d1 = (n − 1)× (3× d) + (2× g). For simplification purpose, we define the context input x = {ct, zct , gf , gw} in the following equations. This context embedding is mapped to a latent context representation using a linear operation followed by a hyperbolic tangent:\nh(x) = tanh ( γα2 ( ψα1(x) )) ∈ Rnhu , (19)\nwhere α2 = {W2,b2}, with W2 ∈ Rnhu×d1 and b2 ∈ Rnhu."
  }, {
    "heading": "4.3 In-vocabulary outputs",
    "text": "The hidden representation of the context then goes to another linear layer to produce a real value score for each word in the vocabulary:\nφWα (x) = γα3\n( h(x) ) ∈ R|W| , (20)\n1207\nwhere α3 = {W3,b3}, with W3 ∈ R|W|×nhu and b3 ∈ R|W|, and α = {α1, α2, α3}."
  }, {
    "heading": "4.4 Mixing outputs for better copying",
    "text": "Section 3.3 explains that each word w from the table is also associated with zw, the set of fields in which it occurs, along with the position in that field. Similar to local conditioning, we represent each field and position pair (fj , pi) with an embeddingψF(fj , pi), where F ∈ R|F|×l×d. These embeddings are then projected into the same space as the latent representation of context input h(x) ∈ Rnhu. Using the max operation over the embedding dimension, each word is finally embedded into a unique vector:\nq(w) = max {\ntanh ( γβ ( ψF(fj , pi) )) , ∀(fj , pi) ∈ zw } , (21)\nwhere β = {W4,b4} with W4 ∈ Rnhu×d, and b4 ∈ Rnhu. A dot product with the context vector produces a score for each word w in the table,\nφQβ (x,w) = h(x) · q(w) . (22) Each word w ∈ W ∪ Q receives a final score by\nsumming the vocabulary score and the field score:\nφθ(x,w) = φ W α (x,w) + φ Q β (x,w) , (23)\nwith θ = {α, β}, and where φQβ (x,w) = 0 when w /∈ Q. The softmax function then maps the scores to a distribution overW ∪Q, logP (w|x) = φθ(x,w)−log ∑\nw′∈W∪Q expφθ(x,w\n′) ."
  }, {
    "heading": "4.5 Training",
    "text": "The neural language model is trained to minimize the negative log-likelihood of a training sentence s with stochastic gradient descent (SGD; LeCun et al. 2012) :\nLθ(s) = − T∑\nt=1\nlogP (wt|ct, zct , gf , gw) . (24)"
  }, {
    "heading": "5 Experiments",
    "text": "Our neural network model (Section 4) is designed to generate sentences from tables for large-scale problems, where a diverse set of sentence types need to be generated. Biographies are therefore a good\nframework to evaluate our model, with Wikipedia offering a large and diverse dataset."
  }, {
    "heading": "5.1 Biography dataset",
    "text": "We introduce a new dataset for text generation, WIKIBIO, a corpus of 728,321 articles from English Wikipedia (Sep 2015). It comprises all biography articles listed by WikiProject Biography1 which also have a table (infobox). We extract and tokenize the first sentence of each article with Stanford CoreNLP (Manning et al., 2014). All numbers are mapped to a special token, except for years which are mapped to different special token. Field values from tables are similarly tokenized. All tokens are lower-cased. Table 2 summarizes the dataset statistics: on average, the first sentence is twice as short as the table (26.1 vs 53.1 tokens), about a third of the sentence tokens (9.5) also occur in the table. The final corpus has been divided into three sub-parts to provide training (80%), validation (10%) and test sets (10%). The dataset is available for download2."
  }, {
    "heading": "5.2 Baseline",
    "text": "Our baseline is an interpolated Kneser-Ney (KN) language model and we use the KenLM toolkit to train 5-gram models without pruning (Heafield et al., 2013). We also learn a KN language model over templates. For that purpose, we replace the words occurring in both the table and the training sentences with a special token reflecting its table descriptor zw (Equation 3). The introduction section of the table in Figure 1 looks as follows under this scheme: “name 1 name 2 ( birthdate 1 birthdate 2 birthdate 3 – deathdate 1 deathdate 2 deathdate 3 ) was an english linguist , fields 3 pathologist , fields 10 scientist , mathematician , mystic and mycologist .” During inference, the decoder is constrained to emit words from the regular vocabulary or special tokens occurring in the input table. When picking a special token we copy the corresponding word from the table."
  }, {
    "heading": "5.3 Training setup",
    "text": "For our neural models, we train 11-gram language models (n = 11) with a learning rate set to 0.0025.\n1https://en.wikipedia.org/wiki/ Wikipedia:WikiProject_Biography\n2https://github.com/DavidGrangier/ wikipedia-biography-dataset\n1208\nTable 3 describes the other hyper-parameters. We include all fields occurring at least 100 times in the training data in F , the set of fields. We include the 20, 000 most frequent words in the vocabulary. The other hyperparameters are set through validation, maximizing BLEU over a validation subset of 1, 000 sentences. Similarly, early stopping is applied: training ends when BLEU stops improving on the same validation subset. One should note that the maximum number of tokens in a field l = 10 means that we encode only 10 positions: for longer field values the final tokens are not dropped but their position is capped to 10. We initialize the word embeddingsW from Hellinger PCA computed over the set of training biographies. This representation has\nshown to be helpful for various applications (Lebret and Collobert, 2014)."
  }, {
    "heading": "5.4 Evaluation metrics",
    "text": "We use different metrics to evaluate our models. Performance is first evaluated in terms of perplexity which is the standard metric for language modeling. Generation quality is assessed automatically with BLEU-4, ROUGE-4 (F-measure) and NIST43 (Belz and Reiter, 2006)."
  }, {
    "heading": "6 Results",
    "text": "This section describes our results and discusses the impact of the different conditioning variables."
  }, {
    "heading": "6.1 The more, the better",
    "text": "The results (Table 1) show that more conditioning information helps to improve the performance of our models. The generation metrics BLEU, ROUGE and NIST all gives the same performance ordering over models. We first discuss models without copy actions (the first three results) and then discuss models with copy actions (the remaining results). Note that the factorization of our models results in three different output domains which makes perplexity comparisons less straightforward: models without copy actions operate over a fixed vocabulary. Template KN adds a fixed set of field/position pairs to this vocabulary while Table NLM models a variable set Q depending on the input table, see Section 3.3.\nWithout copy actions. In terms of perplexity the (i) neural language model (NLM) is slightly better\n3We rely on standard software, NIST mteval-v13a.pl (for NIST, BLEU), and MSR rouge-1.5.5 (for ROUGE).\n1209\nthan an interpolated KN language model, and (ii) adding local conditioning on the field start and end position further improves accuracy. Generation metrics are generally very low but there is a clear improvement when using local conditioning since it allows to learn transitions between fields by linking previous predictions to the table unlike KN or plain NLM.\nWith copy actions. For experiments with copy actions we use the full local conditioning (Equation 4) in the neural language models. BLEU, ROUGE and NIST all improves when moving from Template KN to Table NLM and more features successively improve accuracy. Global conditioning on the fields improves the model by over 7 BLEU and adding words gives an additional 1.3 BLEU. This is a total improvement of nearly 15 BLEU over the Template Kneser-Ney baseline. Similar observations are made for ROUGE +15 and NIST +2.8."
  }, {
    "heading": "6.2 Attention mechanism",
    "text": "Our model implements attention over input table fields. For each word w in the table, Equation (23) takes the language model score φWct and adds a bias φQct . The bias is the dot-product between a representation of the table field in which w occurs and a representation of the context, Equation (22) that summarizes the previously generated fields and words.\nna m\ne\nbi rth\nda te\nbi rth\npl ac\ne\nna tio\nna lit y oc cu pa tio n\n1 2 1 2 3 1 2 1 1 2 < s > nellie wong\n(\nborn september\n12 ,\n1934 )\nis an\namerican poet and\nactivist .\nFigure 4: Visualization of attention scores for Nellie Wong’s Wikipedia infobox. Each row represents the probability distribution over (field, position) pairs given the previous words (i.e. the words heading the preceding rows as well as the current row). Darker colors depict higher probabilities.\nFigure 4 shows that this mechanism adds a large bias to continue a field if it has not generated all tokens from the table, e.g., it emits the word occurring in name 2 after generating name 1. It also nicely handles transitions between field types, e.g., the model adds a large bias to the words occurring in the occupation field after emitting the birthdate."
  }, {
    "heading": "6.3 Sentence decoding",
    "text": "We use a standard beam search to explore a larger set of sentences compared to simple greedy search. This allows us to explore K times more paths which comes at a linear increase in the number of forward computation steps for our language model. We compare various beam settings for the baseline Template KN and our Table NLM (Figure 3). The best validation BLEU can be obtained with a beam size of K = 5. Our model is also several times faster than the baseline, requiring only about 200 ms per sentence with K = 5. Beam search generates many ngram lookups for Kneser-Ney which requires many\n1210\nrandom memory accesses; while neural models perform scoring through matrix-matrix products, an operation which is more local and can be performed in a block parallel manner where modern graphic processors shine (Kindratenko, 2014)."
  }, {
    "heading": "6.4 Qualitative analysis",
    "text": "Table 4 shows generations for different variants of our model based on the Wikipedia table in Figure 1. First of all, comparing the reference to the fact table reveals that our training data is not perfect. The birth month mentioned in the fact table and the first sentence of the Wikipedia article are different; this may have been introduced by one contributor editing the article and not keeping the information consistent.\nAll three versions of our model correctly generate the beginning of the sentence by copying the name, the birth date and the death date from the table. The model correctly uses the past tense since the death date in the table indicates that the person has passed away. Frederick Parker-Rhodes was a scientist, but this occupation is not directly mentioned in the table. The model without global conditioning can therefore not predict the right occupation, and it continues the generation with the most common occupation (in Wikipedia) for a person who has died. In contrast, the global conditioning over the fields helps the model to understand that this person was indeed a scientist. However, it is only with the global conditioning on the words that the model can infer the correct occupation, i.e., computer scientist."
  }, {
    "heading": "7 Conclusions",
    "text": "We have shown that our model can generate fluent descriptions of arbitrary people based on structured data. Local and global conditioning improves our model by a large margin and we outperform a Kneser-Ney language model by nearly 15 BLEU. Our task uses an order of magnitude more data than previous work and has a vocabulary that is three orders of magnitude larger.\nIn this paper, we have only focused on generating the first sentence and we will tackle the generation of longer biographies in future work. Also, the encoding of field values can be improved. Currently, we only attach the field type and token position to each word type and perform a max-pooling for local conditioning. One could leverage a richer representation by learning an encoder conditioned on the field type, e.g. a recurrent encoder or a convolutional encoder with different pooling strategies.\nFurthermore, the current training loss function does not explicitly penalize the model for generating incorrect facts, e.g. predicting an incorrect nationality or occupation is currently not considered worse than choosing an incorrect determiner. A loss function that could assess factual accuracy would certainly improve sentence generation by avoiding such mistakes. Also it will be important to define a strategy for evaluating the factual accuracy of a generation, beyond BLEU, ROUGE or NIST.\n1211"
  }],
  "year": 2016,
  "references": [{
    "title": "A simple domain-independent probabilistic approach to generation",
    "authors": ["G. Angeli", "P. Liang", "D. Klein."],
    "venue": "Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing, pages 502–512. Association for Computational Linguistics.",
    "year": 2010
  }, {
    "title": "Neural machine translation by jointly learning to align and translate",
    "authors": ["D. Bahdanau", "K. Cho", "Y. Bengio."],
    "venue": "International Conference on Learning Representations.",
    "year": 2015
  }, {
    "title": "Collective content selection for concept-to-text generation",
    "authors": ["R. Barzilay", "M. Lapata."],
    "venue": "Proceedings of the conference on Human Language Technology and Empirical Methods in Natural Language Processing, pages 331–338.",
    "year": 2005
  }, {
    "title": "Aggregation via set partitioning for natural language generation",
    "authors": ["R. Barzilay", "M. Lapata."],
    "venue": "Proceedings of the main conference on Human Language Technology Conference of the North American Chapter of the Association of Computational Linguistics, pages",
    "year": 2006
  }, {
    "title": "Comparing automatic and human evaluation of nlg systems",
    "authors": ["A. Belz", "E. Reiter."],
    "venue": "In Proc. EACL06, pages 313–320.",
    "year": 2006
  }, {
    "title": "Automatic generation of weather forecast texts using comprehensive probabilistic generationspace models",
    "authors": ["A. Belz."],
    "venue": "Natural Language Engineering, 14(04):431–455.",
    "year": 2008
  }, {
    "title": "A neural probabilistic language model",
    "authors": ["Y. Bengio", "R. Ducharme", "P. Vincent", "C. Jauvin."],
    "venue": "Journal of Machine Learning Research, 3:1137–1155.",
    "year": 2003
  }, {
    "title": "Freebase: a collaboratively created graph database for structuring human knowledge",
    "authors": ["K. Bollacker", "C. Evans", "P. Paritosh", "T. Sturge", "J. Taylor."],
    "venue": "International Conference on Management of Data, pages 1247–1250. ACM.",
    "year": 2008
  }, {
    "title": "Coral: Using natural language generation for navigational assistance",
    "authors": ["R. Dale", "S. Geldof", "J.-P. Prost."],
    "venue": "Proceedings of the 26th Australasian computer science conference-Volume 16, pages 35–44. Australian Computer Society, Inc.",
    "year": 2003
  }, {
    "title": "Fast and robust neural network joint models for statistical machine translation",
    "authors": ["J. Devlin", "R. Zbib", "Z. Huang", "T. Lamar", "R. Schwartz", "J. Makhoul."],
    "venue": "Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics, volume 1, pages",
    "year": 2014
  }, {
    "title": "Content planner construction via evolutionary algorithms and a corpus-based fitness function",
    "authors": ["P.A. Duboue", "K.R. McKeown."],
    "venue": "Proceedings of INLG 2002, pages 89–96.",
    "year": 2002
  }, {
    "title": "From captions to visual concepts and back",
    "authors": ["Zitnick", "G. Zweig."],
    "venue": "The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), June.",
    "year": 2015
  }, {
    "title": "Introduction to this is watson",
    "authors": ["D. Ferrucci."],
    "venue": "IBM Journal of Research and Development, 56(3.4):1–1.",
    "year": 2012
  }, {
    "title": "Generating multilingual descriptions from linguistically annotated owl ontologies: the naturalowl system",
    "authors": ["D. Galanis", "I. Androutsopoulos."],
    "venue": "Proceedings of the Eleventh European Workshop on Natural Language Generation, pages 143–146. Association for",
    "year": 2007
  }, {
    "title": "Generation of biomedical arguments for lay readers",
    "authors": ["N. Green."],
    "venue": "Proceedings of the Fourth International Natural Language Generation Conference, pages 114– 121. Association for Computational Linguistics.",
    "year": 2006
  }, {
    "title": "Surface realisation from knowledge-bases",
    "authors": ["B. Gyawali", "C. Gardent."],
    "venue": "Proc. of ACL.",
    "year": 2014
  }, {
    "title": "Scalable modified Kneser-Ney language model estimation",
    "authors": ["K. Heafield", "I. Pouzyrevsky", "J.H. Clark", "P. Koehn."],
    "venue": "Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 690–696, Sofia, Bulgaria, August.",
    "year": 2013
  }, {
    "title": "Deep visual-semantic alignments for generating image descriptions",
    "authors": ["A. Karpathy", "L. Fei-Fei."],
    "venue": "The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), June.",
    "year": 2015
  }, {
    "title": "Generative alignment and semantic parsing for learning from ambiguous supervision",
    "authors": ["J. Kim", "R.J. Mooney."],
    "venue": "Proceedings of the 23rd International Conference on Computational Linguistics: Posters, pages 543–551. Association for Computational Lin-",
    "year": 2010
  }, {
    "title": "Numerical Computations with GPUs",
    "authors": ["V. Kindratenko."],
    "venue": "Springer.",
    "year": 2014
  }, {
    "title": "Unifying visual-semantic embeddings with multimodal neural language models",
    "authors": ["R. Kiros", "R. Salakhutdinov", "R.S. Zemel."],
    "venue": "arXiv preprint arXiv:1411.2539.",
    "year": 2014
  }, {
    "title": "A global model for concept-to-text generation",
    "authors": ["I. Konstas", "M. Lapata."],
    "venue": "J. Artif. Int. Res., 48(1):305–346, October.",
    "year": 2013
  }, {
    "title": "Generation that exploits corpus-based statistical knowledge",
    "authors": ["I. Langkilde", "K. Knight."],
    "venue": "Proc. ACL, pages 704–710.",
    "year": 1998
  }, {
    "title": "Word embeddings through hellinger pca",
    "authors": ["R. Lebret", "R. Collobert."],
    "venue": "Proceedings of the 14th Conference of the European Chapter of the Association for Computational Linguistics, pages 482–490, Gothenburg, Sweden, April. Association for Computational",
    "year": 2014
  }, {
    "title": "Efficient backprop",
    "authors": ["Y. A LeCun", "L. Bottou", "G.B. Orr", "K.-R. Müller."],
    "venue": "Neural networks: Tricks of the trade, pages 9–48. Springer.",
    "year": 2012
  }, {
    "title": "Learning semantic correspondences with less supervision",
    "authors": ["P. Liang", "M.I. Jordan", "D. Klein."],
    "venue": "Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of",
    "year": 2009
  }, {
    "title": "A probabilistic forestto-string model for language generation from typed lambda calculus expressions",
    "authors": ["W. Lu", "H.T. Ng."],
    "venue": "Proceedings of the Conference on Empirical Methods in Natural Language Processing, pages 1611–1622. Association for",
    "year": 2011
  }, {
    "title": "Addressing the rare word problem in neural machine translation",
    "authors": ["M.-T. Luong", "I. Sutskever", "Q. V Le", "O. Vinyals", "W. Zaremba."],
    "venue": "Proc. ACL, pages 11–19.",
    "year": 2015
  }, {
    "title": "Controlling user perceptions of linguistic style: Trainable generation of personality traits",
    "authors": ["F. Mairesse", "M. Walker."],
    "venue": "Comput. Linguist., 37(3):455–488.",
    "year": 2011
  }, {
    "title": "The Stanford CoreNLP natural language processing toolkit",
    "authors": ["C.D. Manning", "M. Surdeanu", "J. Bauer", "J. Finkel", "S.J. Bethard", "D. McClosky."],
    "venue": "Association for Computational Linguistics (ACL) System Demonstrations, pages 55–60.",
    "year": 2014
  }, {
    "title": "What to talk about and how? selective generation using lstms with coarse-to-fine alignment",
    "authors": ["H. Mei", "M. Bansal", "M.R. Walter."],
    "venue": "Proceedings of Human Language Technologies: The 2016 Annual Conference of the North American Chapter of the Associa-",
    "year": 2016
  }, {
    "title": "Stochastic language generation for spoken dialogue systems",
    "authors": ["A. Oh", "A. Rudnicky."],
    "venue": "ANLP/NAACL Workshop on Conversational Systems, pages 27–32.",
    "year": 2000
  }, {
    "title": "Trainable approaches to surface natural language generation and their application to conversational dialog systems",
    "authors": ["A. Ratnaparkhi."],
    "venue": "Computer Speech & Language, 16(3):435–455.",
    "year": 2002
  }, {
    "title": "Building natural language generation systems, volume 33",
    "authors": ["E. Reiter", "R. Dale", "Z. Feng."],
    "venue": "MIT Press.",
    "year": 2000
  }, {
    "title": "Choosing words in computer-generated weather forecasts",
    "authors": ["E. Reiter", "S. Sripada", "J. Hunter", "J. Yu", "I. Davy."],
    "venue": "Artificial Intelligence, 167(1):137–169.",
    "year": 2005
  }, {
    "title": "Neural responding machine for short-text conversation",
    "authors": ["L. Shang", "Z. Lu", "H. Li."],
    "venue": "arXiv preprint arXiv:1503.02364.",
    "year": 2015
  }, {
    "title": "Stochastic language generation using widl-expressions and its application in machine translation and summarization",
    "authors": ["Radu Soricut", "Daniel Marcu."],
    "venue": "Proc. ACL, pages 1105–1112.",
    "year": 2006
  }, {
    "title": "Generating approximate geographic descriptions",
    "authors": ["R. Turner", "S. Sripada", "E. Reiter."],
    "venue": "Empirical methods in natural language generation, pages 121– 140. Springer.",
    "year": 2010
  }, {
    "title": "Show and tell: A neural image caption generator",
    "authors": ["O. Vinyals", "A. Toshev", "S. Bengio", "D. Erhan."],
    "venue": "The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), June.",
    "year": 2015
  }, {
    "title": "Semantically conditioned lstmbased natural language generation for spoken dialogue systems",
    "authors": ["T. Wen", "M. Gasic", "N. Mrkšić", "P. Su", "D. Vandyke", "S. Young."],
    "venue": "Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing,",
    "year": 2015
  }, {
    "title": "Generation by inverting a semantic parser that uses statistical machine translation",
    "authors": ["Y.W. Wong", "R.J. Mooney."],
    "venue": "HLT-NAACL, pages 172–179.",
    "year": 2007
  }, {
    "title": "Show, attend and tell: Neural image caption generation with visual attention",
    "authors": ["K. Xu", "J. Ba", "R. Kiros", "A. Courville", "R. Salakhutdinov", "R. Zemel", "Y. Bengio."],
    "venue": "Proceedings of The 32nd International Conference on Machine Learning, volume 37, July.",
    "year": 2015
  }, {
    "title": "Attention with intention for a neural network conversation model",
    "authors": ["K. Yao", "G. Zweig", "B. Peng."],
    "venue": "arXiv preprint arXiv:1510.08565.",
    "year": 2015
  }],
  "id": "SP:2019ede61cc0be14859908312e18458a7c79908f",
  "authors": [{
    "name": "Rémi Lebret",
    "affiliations": []
  }, {
    "name": "David Grangier",
    "affiliations": []
  }, {
    "name": "Michael Auli",
    "affiliations": []
  }],
  "abstractText": "This paper introduces a neural model for concept-to-text generation that scales to large, rich domains. It generates biographical sentences from fact tables on a new dataset of biographies from Wikipedia. This set is an order of magnitude larger than existing resources with over 700k samples and a 400k vocabulary. Our model builds on conditional neural language models for text generation. To deal with the large vocabulary, we extend these models to mix a fixed vocabulary with copy actions that transfer sample-specific words from the input database to the generated output sentence. To deal with structured data, we allow the model to embed words differently depending on the data fields in which they occur. Our neural model significantly outperforms a Templated Kneser-Ney language model by nearly 15 BLEU.",
  "title": "Neural Text Generation from Structured Data with Application to the Biography Domain"
}