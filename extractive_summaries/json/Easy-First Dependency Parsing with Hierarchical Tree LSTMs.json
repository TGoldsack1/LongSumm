{
  "sections": [{
    "heading": "1 Introduction",
    "text": "Dependency-based syntactic representations of sentences are central to many language processing tasks (Kübler et al., 2009). Dependency parse-trees encode not only the syntactic structure of a sentence but also many aspects of its semantics.\nA recent trend in NLP is concerned with encoding sentences as vectors (“sentence embeddings”), which can then be used for further prediction tasks. Recurrent neural networks (RNNs) (Elman, 1990), and in particular methods based on the LSTM architecture (Hochreiter and Schmidhuber, 1997), work very well for modeling sequences, and constantly obtain state-of-the-art results on both languagemodeling and prediction tasks (see, e.g. (Mikolov et al., 2010)).\nSeveral works attempt to extend recurrent neural networks to work on trees (see Section 8 for a brief overview), giving rise to the so-called recursive neural networks (Goller and Kuchler, 1996; Socher et al., 2010). However, recursive neural networks\ndo not cope well with trees with arbitrary branching factors – most work require the encoded trees to be binary-branching, or have a fixed maximum arity. Other attempts allow arbitrary branching factors, at the expense of ignoring the order of the modifiers.\nIn contrast, we propose a tree-encoding that naturally supports trees with arbitrary branching factors, making it particularly appealing for dependency trees. Our tree encoder uses recurrent neural networks as a building block: we model the left and right sequences of modifiers using RNNs, which are composed in a recursive manner to form a tree (Section 3). We use our tree representation for encoding the partially-built parse trees in a greedy, bottom-up dependency parser which is based on the easy-first transition-system of Goldberg and Elhadad (2010).\nUsing the Hierarchical Tree LSTM representation, and without using any external embeddings, our parser achieves parsing accuracies of 92.6 UAS and 90.2 LAS on the PTB (Stanford dependencies) and 86.1 UAS and 84.4 LAS on the Chinese treebank, while relying on greedy decoding.\nTo the best of our knowledge, this is the first work to demonstrate competitive parsing accuracies for full-scale parsing while relying solely on recursive, compositional tree representations, and without using a reranking framework. We discuss related work in Section 8.\nWhile the parsing experiments demonstrate the suitability of our representation for capturing the structural elements in the parse tree that are useful for predicting parsing decisions, we are interested in exploring the use of the RNN-based compositional vector representation of parse trees also for seman-\n445\nTransactions of the Association for Computational Linguistics, vol. 4, pp. 445–461, 2016. Action Editor: Noah Smith. Submission batch: 11/2015; Revision batch: 2/2016; Published 8/2016.\nc©2016 Association for Computational Linguistics. Distributed under a CC-BY 4.0 license.\ntic tasks such as sentiment analysis (Socher et al., 2013b; Tai et al., 2015), sentence similarity judgements (Marelli et al., 2014) and textual entailment (Bowman et al., 2015)."
  }, {
    "heading": "2 Background and Notation",
    "text": ""
  }, {
    "heading": "2.1 Dependency-based Representation",
    "text": "A dependency-based syntactic representation is centered around syntactic modification relations between head words and modifier words. The result are trees in which each node is a word in the sentence, and every node except for one designated root node has a parent node. A dependency tree over a sentence with n words w1, . . . , wn can be represented as a list of n pairs of the form (h,m), where 0 ≤ h ≤ n and 1 ≤ m ≤ n. Each such pair represents an edge in the tree in which h is the index of a head word (including the special ROOT node 0), and m is the index of a modifier word. In order for the dependency trees to be useful for actual downstream language processing tasks, each edge is labeled with a syntactic relation. The tree representation then becomes a list of triplets (h,m, `), where 1 ≤ ` ≤ L is the index of a dependency relation out of a designated set of L syntactic relations.\nDependency trees tend to be relatively shallow, with some nodes having many children. Looking at trees in the PTB training set we find that 94% of the trees have a height of at most 10, and 49% of the trees a height of at most 6. In terms of width, 93% of the trees have at least one node with an arity of 4 or more, and 56% of the trees have at least one node with an arity of 6 or more."
  }, {
    "heading": "2.2 Recurrent Networks and LSTMs",
    "text": "Recurrent neural networks (RNNs), first proposed by Elman (1990) are statistical learners for modeling sequential data. In this work, we use the RNN abstraction as a building block, and recursively combine several RNNs to obtain our tree representation. We briefly describe the RNN abstraction below. For further detail on RNNs, the reader is referred to sources such as (Goldberg, 2015; Bengio and Courville, 2016; Cho, 2015).\nThe RNN abstraction is a function RNN that takes in a sequence of inputs vectors x1, . . . , xn (xi ∈ Rdin), and produces a sequence of state vec-\ntors (also called output vectors) y1, . . . , yn (yi ∈ Rdout). Each yi is conditioned on all the inputs x1, . . . , xi preceding it. Ignoring the intermediate outputs y1, . . . , yn−1, the RNN can be thought of as encoding the sequence x1, . . . , xn into a final state yn. Our notation in this paper follows this view.\nThe RNN is defined recursively using two functions:1\nRNN(s0, x1, . . . , xn) = yn = O(sn) si = N(si−1, xi)\nHere, a function N takes as input a vector xi and a state vector si−1 and returns as output a new state si. One can then extract an output vector yi from si using the function O (the function O is usually the identity function, or a function that returns a subset of the elements in si).\nTaking an algorithmic perspective, one can view the RNN as a state object with three operations: s = RNN.initial() returns a new initial state, s.advance(x) takes an input vector and returns a new state, and s.output() returns the output vector for the current state. When clear from the context, we abbreviate and use the state’s name (s) instead of s.output() to refer to the output vector at the state.\nThe functions N and O defining the RNN are parameterized by parameters θ (matrices and vectors), which are trained from data. Specifically, one is usually interested in using some of the outputs yi for making predictions. The RNN is trained such that the encoding yi is good for the prediction task. That is, the RNN learns which aspects of the sequence x1, . . . , xi are informative for the prediction.\nWe use subscripts (i.e. RNNL, RNNR) to indicate different RNNs, that is, RNNs that have different sets of parameters.\nSpecific instantiations of N and O yield different recurrent network mechanisms. In this work we use the Long Short Term Memory (LSTM) variant (Hochreiter and Schmidhuber, 1997) which is shown to be a very capable sequence learner. However, our algorithm and encoding method do not rely on any specific property of the LSTM architecture, and the\n1We follow the notation of Goldberg (2015), with the exception of taking the output of the RNN to be a single vector rather than a sequence, and renaming R to N .\nLSTM can be transparently switched for any other RNN variant."
  }, {
    "heading": "3 Tree Representation",
    "text": "We now describe our method for representing a tree as a d-dimensional vector. We assume trees in which the children are ordered and there are kl ≥ 0 children before the parent node (left children) and kr ≥ 0 children after it (right children). Such trees correspond well to dependency tree structures. We refer to the parent node as a head, and to its children as modifiers. For a node t, we refer to its left modifiers as t.l1, t.l2, . . . , t.lkl and its right modifiers as t.r1, t.r2, . . . , t.rkr The indices of the modifier are always from the parent outward, that is t.l1 is the left modifier closest to the head t:\nt\nt.r1 t.r2 t.r3 t.r4t.l1t.l2t.l3\nThe gist of the idea is to treat the modifiers of a node as a sequence, and encode this sequence using an RNN. We separate left-modifiers from rightmodifiers, and use two RNNs: the first RNN encodes the sequence of left-modifiers from the head outwards, and the second RNN the sequence of right-modifiers from the head outwards. The first input to each RNN is the vector representation of the head word, and the last input is the vector representation of the left-most or the right-most modifier. The node’s representation is then a concatenation of the RNN encoding of the left-modifiers with the RNN encoding of the right-modifiers. The encoding is recursive: the representation for each of the modifier nodes is computed in a similar fashion.\nt\nR\nL\nt.r1\nR\nt.r2\nR\nt.r3\nR\nt.r4\nR\nt t.l1\nL\nt.l2\nL\nt.l3\nL enc(t)\nRNNR\nRNNL concatenate\nand compress\nMore formally, consider a node t. Let i(t) be the sentence index of the word corresponding to the head node t, and let vi be a vector corresponding to the ith word in the sentence (this vector captures information such as the word form and its part of speech tag, and will be discussed shortly). The vec-\ntor encoding of a node enc(t) ∈ Rdenc is then defined as follows:\nenc(t) =g(W e · (el(t) ◦ er(t)) + be) el(t) =RNNL(vi(t), enc(t.l1), . . . , enc(t.lkl))\ner(t) =RNNR(vi(t), enc(t.r1), . . . , enc(t.rkr))\nFirst, the sequences consisting of the head-vector vi(t) followed by left-modifiers and the head-vector followed by right-modifiers are encoded using two RNNs, RNNL andRNNR, resulting in RNN states el(t) ∈ Rdout and er(t) ∈ Rdout . Then, the RNN states are concatenated, resulting in a 2doutdimensional vector (el(t) ◦ er(t)), which is reduced back to d-dimensions using a linear transformation followed by a non-linear activation function g. The recursion stops at leaf nodes, for which:\nenc(leaf) =g(W e · (el(leaf) ◦ er(leaf)) + be) el(leaf) =RNNL(vi(leaf))\ner(leaf) =RNNR(vi(leaf))\nFigure 1 shows the network used for encoding the sentence “the black fox who really likes apples did not jump over a lazy dog yesterday”."
  }, {
    "heading": "3.1 Representing words",
    "text": "In the discussion above we assume a vector representation vi associated with the ith sentence word. What does vi look like? A sensible approach would be to take vi to be a function of the word-form and the part-of-speech (POS) tag of the ith word, that is:\nvi = g(W v · (wi ◦ pi) + bv)\nwhere wi and pi are the embedded vectors of the word-form and POS-tag of the ith word.\nThis encodes each word in isolation, disregarding its context. The context of a word can be very informative regarding its meaning. One way of incorporating context is the Bidirectional RNN (Schuster and Paliwal, 1997). Bidirectional RNNs are shown to be an effective representation for sequence tagging (Irsoy and Cardie, 2014). Bidirectional RNNs represent a word in the sentence using a concatenation of the end-states of two RNNs, one running\nyesterday”. Top: the network structure: boxed nodes represent LSTM cells, where L are cells belonging to the leftmodifiers sequence model RNNL, and R to the right-modifiers sequence model RNNR. Circle nodes represent a concatenation followed by a linear transformation and a non-linearity. Bottom: the dependency parse of the sentence.\nfrom the beginning of the sentence to the word and the other running from the end to the word. The result is a vector representation for each word which captures not only the word but also its context.\nWe adopt the Bidirectional LSTM scheme to enrich our node vector representation, and for an nwords sentence compute the vector representations vi as follows:\nv′i =g(W v · (wi ◦ pi) + bv) fi =LSTMF (v ′ 1, v ′ 2, . . . , v ′ i)\nbi =LSTMB(v ′ n, v ′ n−1, . . . , v′i) vi =(fi ◦ bi)\nWe plug this word representation as word vectors, allowing each word vector vi to capture information regarding the word form and POS-tag, as well as the sentential context it appears in. The BILSTM encoder is trained jointly with the rest of the network towards the parsing objective, using backpropagation.\nEmbedding vectors The word and POS embeddings wi and pi are also trained together with the network. For the word embeddings, we experiment with random initialization, as well as with initialization using pre-trained word embeddings. Our main goal in this work is not to provide top parsing accuracies, but rather to evaluate the ability of the proposed compositional architecture to learn and capture the structural cues that are needed for accurate parsing. Thus, we are most interested in the random initialization setup: what can the network learn from the training corpus alone, without relying on external resources.\nHowever, the ability to perform semi-supervised learning by initializing the word-embeddings with vectors that are pre-trained on large amount of unannotated data is an appealing property of the neuralnetwork approaches, and we evaluate our parser also in this semi-supervised setup. When using pretrained word embeddings, we follow (Dyer et al., 2015) and use embedding vectors which are trained using positional context (Ling et al., 2015), as these\nwere shown to work better than traditional skipgram vectors for syntactic tasks such as part-ofspeech tagging and parsing."
  }, {
    "heading": "3.2 A note on the head-outward generation",
    "text": "Why did we choose to encode the children from the head outward, and not the other way around? The head outward generation order is needed to facilitate incremental tree construction and allow for efficient parsing, as we show in section 4 below. Besides the efficiency considerations, using the headoutward encoding puts more emphasis on the outermost dependants, which are known to be the most informative for predicting parse structure.2 We rely on the RNN capability of extracting information from arbitrary positions in the sequence to incorporate information about the head word itself, which appears in the beginning of the sequence. This seems to work well, which is expected considering that the average maximal number of siblings in one direction in the PTB is 4.1, and LSTMs were demonstrated to capture much longer-range interactions. Still, when using the tree encoding in a situation where the tree is fully specified in advance, i.e. for sentence classification, sentence similarity or translation tasks, using a head-inward generation order (or even a bidirectional RNN) may prove to work better. We leave this line of inquiry to future work.\nThe head-outward modifier generation approach has a long history in the parsing literature, and goes back to at least Eisner (1996) and Collins (1997). In contrast to previous work in which each modifier could condition only on a fixed small number of modifiers preceding it, and in which the left- and right- sequences of modifiers were treated as independent from one another for computational efficiency reasons, our approach allows the model to access information from the entirety of both the left and the right sequences jointly.\n2Features in transition-based dependency parsers often look at the current left-most and right-most dependents of a given node, and almost never look further than the second left-most or second right-most dependents. Second-order graph based dependency parsers (McDonald, 2006; Eisner, 2000) also condition on the current outermost dependent when generating its sibling."
  }, {
    "heading": "4 Parsing Algorithm",
    "text": "We now turn to explain how to parse using the tree encoder defined above. We begin by describing our bottom-up parsing algorithm, and then show how the encoded vector representation can be built and maintained throughout the parsing process."
  }, {
    "heading": "4.1 Bottom-up Parsing",
    "text": "We follow a (projective) bottom-up parsing strategy, similar to the easy-first parsing algorithm of Goldberg and Elhadad (2010).\nThe main data-structure in the parser is a list of partially-built parse trees we call pending. For a sentence with words w1, . . . , wn, the pending list is initialized with n nodes, where pending[i] corresponds to word wi. The algorithm then chooses two neighbouring trees in the pending list pending[i] and pending[i + 1] and either attaches the root of pending[i+1] as the right-most modifier of the root of pending[i], or attaches the root of pending[i] as the left-most modifier of the root of pending[i+ 1]. The tree which was treated as modifier is then removed from the pending list, shortening it by one. The process ends after n−1 steps, when a single tree remains in the pending list, which is taken to be the output parse tree. The parsing process is described in Algorithm 1.\nAlgorithm 1 Parsing 1: Input: Sentence w = w1, . . . , wn 2: for i ∈ 1, . . . , n do 3: pend[i].id← i 4: arcs← [] 5: while |pend| > 1 do 6: A← {(i, d) | 1 ≤ i < |pend|, d ∈ {l, r}} 7: i, d← select(A) 8: if d = l then 9: m,h← pend[i], pend[i+ 1] 10: pend.remove(i) 11: else 12: h,m← pend[i], pend[i+ 1] 13: pend.remove(i+ 1) 14: arcs.append(h.id,m.id) 15: return arcs\nThis parsing algorithm is both sound and complete with respect to the class of projective depen-\ndency trees (Goldberg and Elhadad, 2010). The algorithm depends on non-deterministic choices of an index in the pending list and an attachment direction (line 7). When parsing in practice, the nondeterministic choice will be replaced by using a trained classifier to assign a score to each indexdirection pair, and selecting the highest scoring pair. We discuss the scoring function in Section 4.4, and the training algorithm in Section 5."
  }, {
    "heading": "4.2 Bottom-up Tree-Encoding",
    "text": "We would like the scoring function to condition on the vector encodings of the subtrees it aims to connect. Algorithm 2 shows how to maintain the vector encodings together with the parsing algorithm, so that at every stage in the parsing process each item pending[i] is associated with a vector encoding of the corresponding tree.\nAlgorithm 2 Parsing while maintaining tree representations\n1: Input: Sentence w = w1, . . . , wn 2: Input: Vectors vi corresponding to words wi 3: arcs← [] 4: for i ∈ 1, . . . , n do 5: pend[i].id← i 6: pend[i].el ← RNNL.init().append(vi) 7: pend[i].er ← RNNR.init().append(vi) 8: while |pend| > 1 do 9: A← {(i, d) | 1 ≤ i < |pend|, d ∈ {l, r}}\n10: i, d← select(A) 11: if d = l then 12: m,h← pend[i], pend[i+ 1] 13: m.c = m.el ◦m.er 14: m.enc = g(W (m.c) + b) 15: h.el.append(m.enc) 16: pend.remove(i) 17: else 18: h,m← pend[i], pend[i+ 1] 19: m.c = m.el ◦m.er 20: m.enc = g(W (m.c) + b) 21: h.er.append(m.enc) 22: pend.remove(i+ 1) 23: arcs.add(h.id,m.id) 24: return arcs"
  }, {
    "heading": "4.3 Labeled Tree Representation",
    "text": "The tree representation described above does not account for the relation labels ` the parsing algorithm assigns each edge. In cases the tree is fully specified in advance, the relation of each word to its head can be added to the word representations vi. However, in the context of parsing, the labels become known only when the modifier is attached to its parent. We thus extend the tree representation by concatenating the node vector representation with a vector representation assigned to the label connecting the subtree to its parent. Formally, only the final enc(t) equation changes:\nenc(t) = g(W e · (el ◦ er ◦ `) + be) where ` is a learned embedding vector associated with the given label."
  }, {
    "heading": "4.4 Scoring Function",
    "text": "The parsing algorithm relies on a function select(A) for choosing the action to take at each stage. We model this function as:\nselect(A) = argmax(i,d,`)∈AScore(pend, i, d, `)\nwhere Score(.) is a learned function whose job is to assign scores to possible actions to reflect their quality. Ideally, it will not only score correct actions above incorrect ones, but also more confident (easier) actions above less confident ones, in order to minimize error propagation in the greedy parsing process.\nWhen scoring a possible attachment between a head h and a modifier m with relation `, the scoring function should attempt to reflect the following pieces of information: • Are the head words of h and m compatible un-\nder relation l? • Is the modifier m compatible with the already\nexisting modifiers of h? In other words, is m a good subtree to connect as an outer-most modifier in the subtree h? • Is m complete, in the sense that it already ac-\nquired all of its own modifiers? to this end, the scoring function looks at a window of k subtrees to each side of the head-modifier pair (pend[i− k], . . . , pend[i+1+ k]) where the neighbouring subtrees are used for providing hints regarding possible additional modifiers ofm and h that are\nyet to be acquired. We use k = 2 in our experiments, for a total of 6 subtrees in total. This window approach is also used in the Easy-First parser of Goldberg and Elhadad (Goldberg and Elhadad, 2010) and works that extend it (Tratz and Hovy, 2011; Ma et al., 2012; Ma et al., 2013). However, unlike the previous work, which made use of extensive feature engineering and rich feature functions aiming at extracting the many relevant linguistic sub-structures from the 6 subtrees and their interactions, we provide the scoring function solely with the vector-encoding of the 6 subtrees in the window.\nModeling the labeled attachment score is more difficult than modeling the unlabeled score and is prone to more errors. Moreover, picking the label for an attachment will cause less cascading error in contrast to picking the wrong attachment, which will necessarily preclude the parser from reaching the correct tree structure. In order to partially overcome this issue, our scoring function is a sum of two auxiliary scoring function, one scoring unlabeled and the other scoring labeled attachments. The unlabeled attachment score term in the sum functions as a fallback which makes it easier for a parser to predict the attachment direction even when there is no sufficient certainty as to the label.\nScore(pend, i, d, `) = ScoreU (pend, i, d)\n+ ScoreL(pend, i, d, `)\nEach of ScoreU and ScoreL are modeled as multilayer perceptrons:\nScoreU (pend, i, d) =MLPU (xi)[d]\nScoreL(pend, i, d, `) =MLPL(xi)[(d, `)] xi = pend[i− 2].c ◦ · · · ◦ pend[i+ 3].c\nwhere MLPU and MLPL are standard multilayer perceptron classifiers with one hidden layer (MLPX(x) =W 2g(W 1x+ b1)+ b2) and have output layers with size 2 and 2L respectively, [.] is an indexing operation, and we assume the values of d and (d, `) are mapped to integer values."
  }, {
    "heading": "4.5 Computational Complexity",
    "text": "The Easy-First parsing algorithm works in O(n log n) time (Goldberg and Elhadad, 2010).\nThe parser in this works differ by three aspects: running a BI-LSTM encoder prior to parsing (O(n)); maintaining the tree representation during parsing (lines 11–22 in Algorithm 2) which take a constant time at each parsing step; and local scoring using an MLP rather than a linear classifier (again, a constant-time operation). Thus, the parser maintains the O(n log n) complexity of the Easy-First parser."
  }, {
    "heading": "5 Training Algorithm",
    "text": ""
  }, {
    "heading": "5.1 Loss and Parameter Updates",
    "text": "At each step of the parsing process we select the highest scoring action (i, d, `). The goal of training is to set the Score function such that correct actions are scored above incorrect ones. We use a marginbased objective, aiming to maximize the margin between the highest scoring correct action and the set of incorrect actions. Formally, we define a hinge loss for each parsing step as follows:\nmax{0, 1−max(i,d,`)∈GScore(pend, i, d, `) +max(i′,d′,`′)∈A\\GScore(pend, i, d, `)}\nwhere A is the set of all possible actions and G is the set of correct actions at the current stage.\nAs the scoring function depends on vectorencodings of all trees in the window, and each treeencoding depends on the network’s parameters, each parameter update will invalidate all the vector encodings, requiring a re-computation of the entire network. We thus sum the local losses throughout the parsing process, and update the parameter with respect to the sum of the losses at sentence boundaries. Since we are using hinge loss the gradients will become sparser as the training progresses. Fewer non-zero gradients could translate to unreliable updates. In order to increase gradient stability and training speed, we use a variation of mini-batch in which we update the parameters only after 50 errors were made. This assures us a sufficient number of gradients for every update thus minimizing the effect of gradient instability. The gradients of the entire network with respect to the sum of the losses are calculated using the backpropagation algorithm. Initial experiments with an SGD optimizer showed very instable results. We settled instead on using the ADAM optimizer (Kingma and Ba, 2015) which\nworked well without requiring fiddling with learning rates."
  }, {
    "heading": "5.2 Error-Exploration and Dynamic Oracle Training",
    "text": "At each stage in the training process, the parser assigns scores to all the possible actions (i, d, `) ∈ A. It then selects an action, applies it, and moves to the next step. Which action should be chosen? A sensible option is to defineG as the set of actions that can lead to the gold tree, and following the highest scoring actions in this set. However, using training in this manner tends to suffer from error propagation at test time. The parser sees only states that result from following correct actions. The lack of examples containing errors in the training phase makes it hard for the parser to infer the best action given partly erroneous trees. In order to cope with this, we follow the error exploration training strategy, in which we let the parser follow the highest scoring action in A during training even if this action is incorrect, exposing it to states that result from erroneous decisions. This strategy requires defining the set G such that the correct actions to take are well-defined also for states that cannot lead to the gold tree. Such a set G is called a dynamic oracle. Error-exploration and dynamic-oracles were introduced by Goldberg and Nivre (2012).\nThe Dynamic Oracle A dynamic-oracle for the easy-first parsing system we use is presented in (Goldberg and Nivre, 2013). Briefly, the dynamicoracle version of G defines the set of gold actions as the set of actions which does not increase the number of erroneous attachments more than the minimum possible (given previous erroneous actions). The number of erroneous attachments is increased in three cases: (1) connecting a modifier to its head prematurely. Once the modifier is attached it is removed from the pending list and therefore can no longer acquire any of its own modifiers; (2) connecting a modifier to an erroneous head, when the correct head is still on the pending list; (3) connecting a modifier to a correct head, but an incorrect label.\nDealing with cases (2) and (3) is trivial. To deal with (1), we consider as correct only actions in which the modifier is complete. To efficiently identify complete modifiers we hold a counter for each word which is initialized to the number of modifiers\nthe word has in the gold tree. When applying an attachment the counter of the modifier’s gold head word is decreased. When the counter reaches 0, the sub-tree rooted at that word has no pending modifiers, and is considered complete.\nAggressive Exploration We found that even when using error-exploration, after one iteration the model remembers the training set quite well, and does not make enough errors to make error-exploration effective. In order to expose the parser to more errors, we employ a cost augmentation scheme: we sometimes follow incorrect actions also if they score below correct actions. Specifically, when the score of the correct action is greater than that of the wrong action but the difference is smaller than the margin constant, we chose to follow the wrong action with probability paug (we use paug = 0.1 in our experiments). Pseudocode for the entire training algorithm is given in the supplementary material."
  }, {
    "heading": "5.3 Out-of-vocabulary items and word-dropout",
    "text": "Due to the sparsity of natural language, we are likely to encounter at test time a substantial number of the words that did not appear in the training data (OOV words). OOV words are likely even when pre-training the word representations on a large unannotated corpora. A common approach is to designate a special “unknown-word” symbol, whose associated vector will be used as the word representation whenever an OOV word is encountered at test time. In order to train the unknown-word vector, a possible approach is to replace all the words appearing in the training corpus less than a certain number of times with the unknown-word symbol. This approach gives a good vector representation for unknown words but at the expense of ignoring many of the words from the training corpus.\nWe instead propose a variant of the word-dropout approach (Iyyer et al., 2015). During training, we replace a word with the unknown-word symbol with probability that is inversely proportional to frequency of the word. Formally, we replace a word w appearing #(w) times in the training corpus with the unknown symbol with a probability:\npunk(w) = α\n#(w) + α\nUsing this approach we learn a vector representation for unknown words with minimal impact on the training of sparse words."
  }, {
    "heading": "6 Implementation Details",
    "text": "Our Python implementation will be made available at the first author’s website. We use the PyCNN wrapper of the CNN library3 for building the computation graph of the network, computing the gradients using automatic differentiation, and performing parameter updates. We noticed the error on the development set does not improve after 20 iterations over the training set, therefore, we ran the training for 20 iterations. The sentences where shuffled between iterations. Non-projective sentences were skipped during training. We use the default parameters initialization, step sizes and regularization values provided by the PyCNN toolkit. The hyperparameters of the final networks used for all the reported experiments are detailed in Table 1.\nWeiss et al (2015) stress the importance of careful hyperparameter tuning for achieving top accuracy in neural network based parser. We did not follow this advice and made very few attempts at hyper-parameter tuning, using manual hill climbing until something seemed to work with reasonable accuracy, and then sticking with it for the rest of the experiments.\n3https://github.com/clab/cnn/tree/ master/pycnn"
  }, {
    "heading": "7 Experiments and Results",
    "text": "We evaluated our parsing model to English and Chinese data. For comparison purposes we followed the setup of (Dyer et al., 2015).\nData For English, we used the Stanford Dependency (SD) (de Marneffe and Manning, 2008) conversion of the Penn Treebank (Marcus et al., 1993), using the standard train/dev/test splitswith the same predicted POS-tags as used in (Dyer et al., 2015; Chen and Manning, 2014). This dataset contains a few non-projective trees. Punctuation symbols are excluded from the evaluation.\nFor Chinese, we use the Penn Chinese Treebank 5.1 (CTB5), using the train/test/dev splits of (Zhang and Clark, 2008; Dyer et al., 2015) with gold partof-speech tags, also following (Dyer et al., 2015; Chen and Manning, 2014).\nWhen using external word embeddings, we also use the same data as (Dyer et al., 2015).4\nExperimental configurations We evaluated the parser in several configurations BOTTOMUPPARSER is the baseline parser, not using the tree-encoding, and instead representing each item in pending solely by the vector-representation (word and POS) of its head word. BOTTOMUPPARSER+HTLSTM is using our Hierarchical Tree LSTM representation. BOTTOMUPPARSER+HTLSTM+BI-LSTM is the Hierarchical Tree LSTM where we additionally use a BI-LSTM encoding for the head words. Finally, we added external, pre-trained word embeddings to the BOTTOMUPPARSER+HTLSTM+BI-LSTM setup. We also evaluated the final parsers in a –POS setup, in which we did not feed the parser with any POS-tags.\nResults Results for English and Chinese are presented in Tables 2 and 3 respectively. For comparison, we also show the results of the Stack-LSTM transition-based parser model of Dyer et al (2015), which we consider to be a state-of-the-art greedy model which is also very competitive with searchbased models, with and without pre-trained embeddings, and with and without POS-tags.\n4We thank Dyer et al for sharing their data with us.\nThe trends are consistent across the two languages. The baseline Bottom-Up parser performs very poorly. This is expected, as only the headword of each subtree is used for prediction. When adding the tree-encoding, results jump to near stateof-the-art accuracy, suggesting that the composed vector representation is indeed successful in capturing predictive structural information. Replacing the head-words with their BI-LSTM encodings results in another increase in accuracy for English, outperforming the Dyer et al (S-LSTM no external) models on the test-set. Adding the external pre-trained embeddings further improves the results for both our parser and Dyer et al’s model, closing the gap between them. When POS-tags are not provided as input, the numbers for both parsers drop. The drop is small for English and large for Chinese, and our parser seem to suffer a little less than the Dyer et al model.\nImportance of the dynamic oracle We also evaluate the importance of using the dynamic oracle and error-exploration training, and find that they are indeed important for achieving high parsing accura-\ncies with our model (Table 4).\nWhen training without error-exploration (that is, the parser follows only correct actions during training and not using the dynamic aspect of the oracle), accuracies of unseen sentences drop by between 0.4 and 0.8 accuracy points (average 0.58). This is consistent with previous work on training with error-exploration and dynamic oracles (Goldberg and Nivre, 2013), showing that the technique is not restricted to models trained with sparse linear models.\nComparison to other state-of-the-art parsers Our main point of comparison is the model of Dyer et al, which was chosen because it is (a) a very strong parsing model; and (b) is the closest to ours in the literature: a greedy parsing model making heavy use of LSTMs. To this end, we tried to make the comparison to Dyer et al as controlled as possible, using the same dependency annotation schemes, as well as the same predicted POS-tags and the pre-trained embeddings (when applicable).\nIt is also informative to position our results with respect to other state-of-the-art parsing results reported in the literature, as we do in Table 5. Here, some of the comparisons are less direct: some of the results use different dependency annotation schemes5, as well as different predicted POS-tags, and different pre-trained word embeddings. While the numbers are not directly comparable, they do give a good reference as to the expected range of\n5Our English parsing experiments use the Stanford Dependencies scheme, while other work use less informative dependency relations which are based on the Penn2Malt converter, using the Yamada and Matsumoto head rules. From our experience, this conversion is somewhat easier to parse, resulting in numbers which are about 0.3-0.4 points higher than Stanford Dependencies.\nstate-of-the-art parsing results. Our system’s English parsing results are in range of state-of-the-art and the Chinese parsing results surpass it. These numbers are achieved while using a greedy, bottom up parsing method without any search, and while relying solely on the compositional tree representations."
  }, {
    "heading": "8 Related Work",
    "text": "We survey two lines of related work: methods for encoding trees as vectors, and methods for parsing with vector representations.\nThe popular approach for encoding trees as vectors is using recursive neural networks (Goller and Kuchler, 1996; Socher et al., 2010; Tai et al., 2015). Recursive neural networks represent the vector of a parent node in a tree as a function of its children nodes. However, the functions are usually restricted to having a fixed maximum arity (usually two) (Socher et al., 2010; Tai et al., 2015; Socher, 2014). While trees can be binarized to cope with the arity restriction, doing so results in deep trees which in turn leads to the vanishing gradient problem when training. To cope with the vanishing gradients, (Tai et al., 2015) enrich the composition function with a gating mechanism similar to that of the LSTM, resulting in the so-called Tree-LSTM model. Another approach is to allow arbitrary arities but ignoring the sequential nature of the modifiers, e.g. by using a bag-of-modifiers representation or a convolutional layer (Tai et al., 2015; Zhu et al., 2015). In contrast, our tree encoding method naturally allows for arbitrary branching trees by relying on the well established LSTM sequence model, and using it as a black box. Very recently, Zhang et al. (2015) proposed an RNN-based tree encoding which is similar to ours in encoding the sequence of modifiers as an RNN. Unlike our bottom-up encoder, their method works top-down, and is therefore not readily applicable for parsing. On the other hand the top-down approach is well suited for generation. In future work, it could be interesting to combine the bottomup and top-down approaches in an encoder-decoder framework (Sutskever et al., 2014; Kiros et al., 2015). Work by Dyer et al (2016), that was submitted in parallel to ours, introduces a similar LSTMbased representation of syntactic constituents in the context of phrase-grammar parsing.\nIn terms of parsing with vector representations, there are four dominant approaches: search based parsers that use local features that are fed to a neural-network classifier (Pei et al., 2015; Durrett and Klein, 2015); greedy transition based parsers that use local features that are fed into a neuralnetwork classifier (Chen and Manning, 2014; Weiss et al., 2015), sometimes coupled with a node composition function (Dyer et al., 2015; Watanabe and Sumita, 2015); bottom up parsers that rely solely on recursively combined vector encodings of subtrees (Socher et al., 2010; Stenetorp, 2013; Socher et al., 2013a); and parse-reranking approaches that first produce a k-best list of parses using a traditional parsing technique, and then score the trees based on a recursive vector encoding of each node (Le and Zuidema, 2014; Le and Zuidema, 2015; Zhu et al., 2015).\nOur parser is a greedy, bottom up parser that relies on compositional vector encodings of subtrees as its sole set of features. Unlike the re-ranking approaches, we do not rely on an external parser to provide k-best lists. Unlike the bottom-up parser in (Socher et al., 2010) that only parses sentences of up to 15 words and the parser of (Stenetorp, 2013) that achieves very low parsing accuracies, we parse arbitrary sentences with near state-of-the-art accuracy. Unlike the bottom up parser in (Socher et al., 2013a) we do not make use of a grammar. The parser of (Weiss et al., 2015) obtains exceptionally high results using local features and no composition function. The greedy version of their parser uses extensive tuning of hyper-parameters and network depth in order to squeeze every possible bit of accuracy. Adding beam search on top of that further improves results. Due to our much more limited resources, we did not perform a methodological search over hyper-parameters, and explored only a tiny space of the possible hyper-parameters, and our parser does not perform search. Finally, perhaps closest to our approach is the greedy, transition-based parser of (Dyer et al., 2015) that also works in a bottomup fashion, and incorporates an LSTM encoding of the input tokens and hierarchical vector composition into its scoring mechanism. Indeed, that parser obtains similar scores to ours, although we obtain somewhat better results when not using pre-trained embeddings. We differ from the parser of Dyer et\nal by having a more elaborate vector-composition function, relying solely on the compositional representations, and performing fully bottom-up parsing without being guided by a stack-and-buffer control structure."
  }, {
    "heading": "9 Conclusions and Future Work",
    "text": "We suggest a compositional vector representation of parse trees that relies on a recursive combination of recurrent-neural network encoders, and demonstrate its effectiveness by integrating it in a bottom-up easy-first parser. Future extensions in terms of parsing include the addition of beam search, handling of unknown-words using character-embeddings, and adapting the algorithm to constituency trees. We also plan to establish the effectiveness of our Hierarchical Tree-LSTM encoder by applying it to more semantic vector representation tasks, i.e. training tree representation for capturing sentiment (Socher et al., 2013b; Tai et al., 2015), semantic sentence similarity (Marelli et al., 2014) or textual inference (Bowman et al., 2015).\nAcknowledgements This research is supported by the Intel Collaborative Research Institute for Computational Intelligence (ICRI-CI) and the Israeli Science Foundation (grant number 1555/15)."
  }, {
    "heading": "Appendix: Training Algorithm Pseudocode",
    "text": "Algorithm 3 Training on annotated corpus 1: Input: Sentences w1, . . . , wm 2: Input: Tree annotations T 1, . . . , Tm 3: Input: Number of epochs to train\n4: V ← InitializeV ectors() 5: Loss← []\n6: for epoch ∈ {1, . . . , Epochs} do 7: for S, T ∈ {(w1, T 1), . . . , (wm, Tm)} do 8: Loss← TrainSentence (S, V [w1, . . . , wn], T, Loss)\n9: if |Loss| > 50 then 10: SumLoss← sum(Loss) 11: Call ADAM to minimize SumLoss 12: Loss← []\n(See Algorithm 4, training of a single sentence, on next page.)\nAlgorithm 4 Training on a single sentence with dynamic oracle algorithm 1: function TRAINSENTENCE(w, v, T, Loss) 2: Input: Sentence w = w1, . . . , wn 3: Input: Vectors vi corresponding to inputs wi 4: Input: Annotated tree T in the form of (h,m, rel) triplets 5: Input: List Loss to which loss expressions are added\n6: for i ∈ 1, . . . , n do 7: unassigned[i]← |Children(wi)| 8: pend[i].id← i 9: pend[i].el ← RNNL.init().append(vi)\n10: pend[i].er ← RNNR.init().append(vi)\n11: while |pend| > 1 do 12: G,W ← {} , {}\n13: for (i, d, rel) ∈ {1 ≤ i < |pend|, d ∈ {l, r}, rel ∈ Relations} do 14: if d = l then m,h← pend[i], pend[i+ 1] 15: else m,h← pend[i+ 1], pend[i]\n16: if unassigned[m.id] 6= 0 ∨ ∃`6=rel(h,m, `) ∈ T then 17: W.append((h,m, rel)) 18: else G.append((h,m, rel))\n19: hG,mG, relG ← argmax(i,d,`)∈GScore(pend, i, d, `) 20: hW ,mW , relW ← argmax(i,d,`)∈WScore(pend, i, d, `) 21: scoreG ← Score(hG,mG, relG) 22: scoreW ← Score(hW ,mW , relW )\n23: if scoreG − scoreW < 0 then 24: h,m, rel, score← hW ,mW , relW , scoreW 25: else if scoreG − scoreW > 1 ∨ random() < paug then 26: h,m, rel, score← hG,mG, relG, scoreG 27: else 28: h,m, rel, score← hW ,mW , relW , scoreW 29: if scoreG − score < 1 then 30: Loss.append(1− scoreG + score)\n31: m.c = m.el ◦m.er 32: m.enc = g(W (m.c ◦ rel) + b) 33: if h.id < m.id then h.el.append(m.enc) 34: else h.er.append(m.enc)\n35: unassigned[TParent(m).id]← unassigned[TParent(m).id]− 1 36: pend.remove(m) 37: return Loss"
  }],
  "year": 2016,
  "references": [{
    "title": "Deep learning",
    "authors": ["Ian Goodfellow Yoshua Bengio", "Aaron Courville."],
    "venue": "Book in preparation for MIT Press, http://www.deeplearningbook.org.",
    "year": 2016
  }, {
    "title": "A large annotated corpus for learning natural language inference",
    "authors": ["Samuel R. Bowman", "Gabor Angeli", "Christopher Potts", "Christopher D. Manning."],
    "venue": "Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing, pages 632–642,",
    "year": 2015
  }, {
    "title": "A fast and accurate dependency parser using neural networks",
    "authors": ["Danqi Chen", "Christopher Manning."],
    "venue": "Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 740–750, Doha, Qatar, October. Association for",
    "year": 2014
  }, {
    "title": "Natural language understanding with distributed representation",
    "authors": ["Kyunghyun Cho."],
    "venue": "CoRR, abs/1511.07916.",
    "year": 2015
  }, {
    "title": "Three generative, lexicalised models for statistical parsing",
    "authors": ["Michael Collins."],
    "venue": "Proceedings of the 35th Annual Meeting of the Association for Computational Linguistics, pages 16–23, Madrid, Spain, July. Association for Computational Linguistics.",
    "year": 1997
  }, {
    "title": "Stanford dependencies manual",
    "authors": ["Marie-Catherine de Marneffe", "Christopher D. Manning."],
    "venue": "Technical report, Stanford University.",
    "year": 2008
  }, {
    "title": "Neural crf parsing",
    "authors": ["Greg Durrett", "Dan Klein."],
    "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers), pages 302–312,",
    "year": 2015
  }, {
    "title": "Transitionbased dependency parsing with stack long short-term memory",
    "authors": ["Chris Dyer", "Miguel Ballesteros", "Wang Ling", "Austin Matthews", "Noah A. Smith."],
    "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics",
    "year": 2015
  }, {
    "title": "Recurrent neural network grammars",
    "authors": ["Chris Dyer", "Adhiguna Kuncoro", "Miguel Ballesteros", "Noah A. Smith."],
    "venue": "Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Tech-",
    "year": 2016
  }, {
    "title": "Three new probabilistic models for dependency parsing: An exploration",
    "authors": ["Jason Eisner."],
    "venue": "16th International Conference on Computational Linguistics, Proceedings of the Conference, COLING 1996, Center for Sprogteknologi, Copenhagen, Denmark, August 5-9,",
    "year": 1996
  }, {
    "title": "Bilexical grammars and their cubictime parsing algorithms",
    "authors": ["Jason Eisner."],
    "venue": "Advances in Probabilistic and Other Parsing Technologies.",
    "year": 2000
  }, {
    "title": "Finding structure in time",
    "authors": ["Jeffrey L. Elman."],
    "venue": "Cognitive Science, 14(2):179–211.",
    "year": 1990
  }, {
    "title": "An efficient algorithm for easy-first non-directional dependency parsing",
    "authors": ["Yoav Goldberg", "Michael Elhadad."],
    "venue": "Human Language Technologies: The 2010 Annual Conference of the North American Chapter of the Association for Computational Linguis-",
    "year": 2010
  }, {
    "title": "A dynamic oracle for arc-eager dependency parsing",
    "authors": ["Yoav Goldberg", "Joakim Nivre."],
    "venue": "Proceedings of COLING 2012, pages 959–976, Mumbai, India, December. The COLING 2012 Organizing Committee.",
    "year": 2012
  }, {
    "title": "Training deterministic parsers with non-deterministic oracles",
    "authors": ["Yoav Goldberg", "Joakim Nivre."],
    "venue": "Transactions of the Association for Computational Linguistics, 1:403–414.",
    "year": 2013
  }, {
    "title": "A primer on neural network models for natural language processing",
    "authors": ["Yoav Goldberg."],
    "venue": "CoRR, abs/1510.00726.",
    "year": 2015
  }, {
    "title": "Learning task-dependent distributed representations by backpropagation through structure",
    "authors": ["Christoph Goller", "Andreas Kuchler."],
    "venue": "Neural Networks, 1996., IEEE International Conference on, volume 1, pages 347–352. IEEE.",
    "year": 1996
  }, {
    "title": "Long short-term memory",
    "authors": ["Sepp Hochreiter", "Jürgen Schmidhuber."],
    "venue": "Neural Computation, 9(8):1735– 1780.",
    "year": 1997
  }, {
    "title": "Opinion mining with deep recurrent neural networks",
    "authors": ["Ozan Irsoy", "Claire Cardie."],
    "venue": "Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 720–728, Doha, Qatar, October. Association for Computational",
    "year": 2014
  }, {
    "title": "Deep unordered composition rivals syntactic methods for text classification",
    "authors": ["Mohit Iyyer", "Varun Manjunatha", "Jordan Boyd-Graber", "Hal Daumé III."],
    "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th Inter-",
    "year": 2015
  }, {
    "title": "Adam: A method for stochastic optimization",
    "authors": ["Diederik P. Kingma", "Jimmy Ba."],
    "venue": "Proceedings of the 3rd International Conference for Learning Representations, San Diego, California.",
    "year": 2015
  }, {
    "title": "Skip-thought vectors",
    "authors": ["Ryan Kiros", "Yukun Zhu", "Ruslan Salakhutdinov", "Richard S. Zemel", "Raquel Urtasun", "Antonio Torralba", "Sanja Fidler."],
    "venue": "Advances in Neural Information Processing Systems 28: Annual Conference on Neural Information",
    "year": 2015
  }, {
    "title": "Dependency Parsing",
    "authors": ["Sandra Kübler", "Ryan T. McDonald", "Joakim Nivre."],
    "venue": "Synthesis Lectures on Human Language Technologies. Morgan & Claypool Publishers.",
    "year": 2009
  }, {
    "title": "The insideoutside recursive neural network model for dependency parsing",
    "authors": ["Phong Le", "Willem Zuidema."],
    "venue": "Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 729–739, Doha, Qatar, October.",
    "year": 2014
  }, {
    "title": "The forest convolutional network: Compositional distributional semantics with a neural chart and without binarization",
    "authors": ["Phong Le", "Willem Zuidema."],
    "venue": "Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing, pages",
    "year": 2015
  }, {
    "title": "Two/too simple adaptations of word2vec for syntax problems",
    "authors": ["Wang Ling", "Chris Dyer", "Alan W. Black", "Isabel Trancoso."],
    "venue": "NAACL HLT 2015, The 2015 Conference of the North American Chapter of the Association for Computational Linguistics: Human Lan-",
    "year": 2015
  }, {
    "title": "Easy-first Chinese POS tagging and dependency parsing",
    "authors": ["Ji Ma", "Tong Xiao", "Jingbo Zhu", "Feiliang Ren."],
    "venue": "Proceedings of COLING 2012, pages 1731– 1746, Mumbai, India, December. The COLING 2012 Organizing Committee.",
    "year": 2012
  }, {
    "title": "Easy-first pos tagging and dependency parsing with beam search",
    "authors": ["Ji Ma", "Jingbo Zhu", "Tong Xiao", "Nan Yang."],
    "venue": "Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers), pages 110–114, Sofia, Bul-",
    "year": 2013
  }, {
    "title": "Building a large annotated corpus of English: The Penn Treebank",
    "authors": ["Mitchell P. Marcus", "Beatrice Santorini", "Mary Ann Marcinkiewicz."],
    "venue": "Computational Linguistics, 19(2):313–330.",
    "year": 1993
  }, {
    "title": "Semeval-2014 task 1: Evaluation of compositional distributional semantic models on full sentences through semantic relatedness and textual entail",
    "authors": ["Marco Marelli", "Luisa Bentivogli", "Marco Baroni", "Raffaella Bernardi", "Stefano Menini", "Roberto Zamparelli"],
    "year": 2014
  }, {
    "title": "Turning on the turbo: Fast third-order nonprojective turbo parsers",
    "authors": ["Andre Martins", "Miguel Almeida", "Noah A. Smith."],
    "venue": "Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers), pages 617–622,",
    "year": 2013
  }, {
    "title": "Discriminative Training and Spanning Tree Algorithms for Dependency Parsing",
    "authors": ["Ryan McDonald."],
    "venue": "Ph.D. thesis, University of Pennsylvania.",
    "year": 2006
  }, {
    "title": "Recurrent neural network based language model",
    "authors": ["Tomas Mikolov", "Martin Karafiát", "Lukás Burget", "Jan Cernocký", "Sanjeev Khudanpur."],
    "venue": "INTERSPEECH 2010, 11th Annual Conference of the International Speech Communication Association,",
    "year": 2010
  }, {
    "title": "An effective neural network model for graph-based dependency parsing",
    "authors": ["Wenzhe Pei", "Tao Ge", "Baobao Chang."],
    "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Nat-",
    "year": 2015
  }, {
    "title": "Bidirectional recurrent neural networks",
    "authors": ["Mike Schuster", "Kuldip K. Paliwal."],
    "venue": "IEEE Trans. Signal Processing, 45(11):2673–2681.",
    "year": 1997
  }, {
    "title": "Learning Continuous Phrase Representations and Syntactic Parsing with Recursive Neural Networks",
    "authors": ["Richard Socher", "Christopher Manning", "Andrew Ng."],
    "venue": "Proceedings of the Deep Learning and Unsupervised Feature Learning Workshop of (NIPS)",
    "year": 2010
  }, {
    "title": "Parsing with compositional vector grammars",
    "authors": ["Richard Socher", "John Bauer", "Christopher D. Manning", "Andrew Y. Ng."],
    "venue": "Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, ACL 2013, 4-9 August 2013, Sofia, Bul-",
    "year": 2013
  }, {
    "title": "Recursive deep models for semantic compositionality over a sentiment treebank",
    "authors": ["Richard Socher", "Alex Perelygin", "Jean Wu", "Jason Chuang", "Christopher D. Manning", "Andrew Ng", "Christopher Potts."],
    "venue": "Proceedings of the 2013 Conference on Empirical Meth-",
    "year": 2013
  }, {
    "title": "Recursive Deep Learning For Natural Language Processing and Computer Vision",
    "authors": ["Richard Socher."],
    "venue": "Ph.D. thesis, Stanford University, August.",
    "year": 2014
  }, {
    "title": "Transition-based Dependency Parsing Using Recursive Neural Networks",
    "authors": ["Pontus Stenetorp."],
    "venue": "Deep Learning Workshop at the 2013 Conference on Neural Information Processing Systems (NIPS), Lake Tahoe, Nevada, USA, December.",
    "year": 2013
  }, {
    "title": "Sequence to sequence learning with neural networks",
    "authors": ["Ilya Sutskever", "Oriol Vinyals", "Quoc V. Le."],
    "venue": "Advances in Neural Information Processing Systems 27: Annual Conference on Neural Information Processing Systems 2014, December 8-13 2014, Montreal,",
    "year": 2014
  }, {
    "title": "Improved semantic representations from tree-structured long short-term memory networks",
    "authors": ["Kai Sheng Tai", "Richard Socher", "Christopher D. Manning."],
    "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th Inter-",
    "year": 2015
  }, {
    "title": "A fast, accurate, non-projective, semantically-enriched parser",
    "authors": ["Stephen Tratz", "Eduard Hovy."],
    "venue": "Proceedings of the 2011 Conference on Empirical Methods in Natural Language Processing, pages 1257– 1268, Edinburgh, Scotland, UK., July. Association for",
    "year": 2011
  }, {
    "title": "Transitionbased neural constituent parsing",
    "authors": ["Taro Watanabe", "Eiichiro Sumita."],
    "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume",
    "year": 2015
  }, {
    "title": "Structured training for neural network transition-based parsing",
    "authors": ["David Weiss", "Chris Alberti", "Michael Collins", "Slav Petrov."],
    "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference",
    "year": 2015
  }, {
    "title": "A tale of two parsers: Investigating and combining graph-based and transition-based dependency parsing",
    "authors": ["Yue Zhang", "Stephen Clark."],
    "venue": "Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing, pages 562–571, Honolulu,",
    "year": 2008
  }, {
    "title": "Transition-based dependency parsing with rich non-local features",
    "authors": ["Yue Zhang", "Joakim Nivre."],
    "venue": "Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies, pages 188–193, Portland, Ore-",
    "year": 2011
  }, {
    "title": "Tree recurrent neural networks with application to language modeling",
    "authors": ["Xingxing Zhang", "Liang Lu", "Mirella Lapata."],
    "venue": "CoRR, abs/1511.00060.",
    "year": 2015
  }, {
    "title": "A re-ranking model for dependency parser with recursive convolutional neural network",
    "authors": ["Chenxi Zhu", "Xipeng Qiu", "Xinchi Chen", "Xuanjing Huang."],
    "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th Inter-",
    "year": 2015
  }],
  "id": "SP:5ecc949163486843ae55d1a607f7b4a01d78b00f",
  "authors": [{
    "name": "Eliyahu Kiperwasser",
    "affiliations": []
  }, {
    "name": "Yoav Goldberg",
    "affiliations": []
  }],
  "abstractText": "We suggest a compositional vector representation of parse trees that relies on a recursive combination of recurrent-neural network encoders. To demonstrate its effectiveness, we use the representation as the backbone of a greedy, bottom-up dependency parser, achieving very strong accuracies for English and Chinese, without relying on external word embeddings. The parser’s implementation is available for download at the first author’s webpage.",
  "title": "Easy-First Dependency Parsing with Hierarchical Tree LSTMs"
}