{
  "sections": [{
    "heading": "1. Introduction",
    "text": "This paper describes a framework for learning composable deep subpolicies in a multitask setting, guided only by abstract sketches of high-level behavior. General reinforcement learning algorithms allow agents to solve tasks in complex environments. But tasks featuring extremely\n1University of California, Berkeley. Correspondence to: Jacob Andreas <jda@cs.berkeley.edu>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\ndelayed rewards or other long-term structure are often difficult to solve with flat, monolithic policies, and a long line of prior work has studied methods for learning hierarchical policy representations (Sutton et al., 1999; Dietterich, 2000; Konidaris & Barto, 2007; Hauser et al., 2008). While unsupervised discovery of these hierarchies is possible (Daniel et al., 2012; Bacon & Precup, 2015), practical approaches often require detailed supervision in the form of explicitly specified high-level actions, subgoals, or behavioral primitives (Precup, 2000). These depend on state representations simple or structured enough that suitable reward signals can be effectively engineered by hand.\nBut is such fine-grained supervision actually necessary to achieve the full benefits of hierarchy? Specifically, is it necessary to explicitly ground high-level actions into the representation of the environment? Or is it sufficient to simply inform the learner about the abstract structure of policies, without ever specifying how high-level behaviors should make use of primitive percepts or actions?\nTo answer these questions, we explore a multitask reinforcement learning setting where the learner is pre-\nsented with policy sketches. Policy sketches are short, ungrounded, symbolic representations of a task that describe its component parts, as illustrated in Figure 1. While symbols might be shared across tasks (get wood appears in sketches for both the make planks and make sticks tasks), the learner is told nothing about what these symbols mean, in terms of either observations or intermediate rewards.\nWe present an agent architecture that learns from policy sketches by associating each high-level action with a parameterization of a low-level subpolicy, and jointly optimizes over concatenated task-specific policies by tying parameters across shared subpolicies. We find that this architecture can use the high-level guidance provided by sketches, without any grounding or concrete definition, to dramatically accelerate learning of complex multi-stage behaviors. Our experiments indicate that many of the benefits to learning that come from highly detailed low-level supervision (e.g. from subgoal rewards) can also be obtained from fairly coarse high-level supervision (i.e. from policy sketches). Crucially, sketches are much easier to produce: they require no modifications to the environment dynamics or reward function, and can be easily provided by nonexperts. This makes it possible to extend the benefits of hierarchical RL to challenging environments where it may not be possible to specify by hand the details of relevant subtasks. We show that our approach substantially outperforms purely unsupervised methods that do not provide the learner with any task-specific guidance about how hierarchies should be deployed, and further that the specific use of sketches to parameterize modular subpolicies makes better use of sketches than conditioning on them directly.\nThe present work may be viewed as an extension of recent approaches for learning compositional deep architectures from structured program descriptors (Andreas et al., 2016; Reed & de Freitas, 2016). Here we focus on learning in interactive environments. This extension presents a variety of technical challenges, requiring analogues of these methods that can be trained from sparse, non-differentiable reward signals without demonstrations of desired system behavior.\nOur contributions are:\n• A general paradigm for multitask, hierarchical, deep reinforcement learning guided by abstract sketches of task-specific policies.\n• A concrete recipe for learning from these sketches, built on a general family of modular deep policy representations and a multitask actor–critic training objective.\nThe modular structure of our approach, which associates every high-level action symbol with a discrete subpolicy, naturally induces a library of interpretable policy fragments\nthat are easily recombined. This makes it possible to evaluate our approach under a variety of different data conditions: (1) learning the full collection of tasks jointly via reinforcement, (2) in a zero-shot setting where a policy sketch is available for a held-out task, and (3) in a adaptation setting, where sketches are hidden and the agent must learn to adapt a pretrained policy to reuse high-level actions in a new task. In all cases, our approach substantially outperforms previous approaches based on explicit decomposition of the Q function along subtasks (Parr & Russell, 1998; Vogel & Jurafsky, 2010), unsupervised option discovery (Bacon & Precup, 2015), and several standard policy gradient baselines.\nWe consider three families of tasks: a 2-D Minecraftinspired crafting game (Figure 3a), in which the agent must acquire particular resources by finding raw ingredients, combining them together in the proper order, and in some cases building intermediate tools that enable the agent to alter the environment itself; a 2-D maze navigation task that requires the agent to collect keys and open doors, and a 3-D locomotion task (Figure 3b) in which a quadrupedal robot must actuate its joints to traverse a narrow winding cliff.\nIn all tasks, the agent receives a reward only after the final goal is accomplished. For the most challenging tasks, involving sequences of four or five high-level actions, a taskspecific agent initially following a random policy essentially never discovers the reward signal, so these tasks cannot be solved without considering their hierarchical structure. We have released code at http://github.com/ jacobandreas/psketch."
  }, {
    "heading": "2. Related Work",
    "text": "The agent representation we describe in this paper belongs to the broader family of hierarchical reinforcement learners. As detailed in Section 3, our approach may be viewed as an instantiation of the options framework first described by Sutton et al. (1999). A large body of work describes techniques for learning options and related abstract actions, in both single- and multitask settings. Most techniques for learning options rely on intermediate supervisory signals, e.g. to encourage exploration (Kearns & Singh, 2002) or completion of pre-defined subtasks (Kulkarni et al., 2016). An alternative family of approaches employs post-hoc analysis of demonstrations or pretrained policies to extract reusable sub-components (Stolle & Precup, 2002; Konidaris et al., 2011; Niekum et al., 2015). Techniques for learning options with less guidance than the present work include Bacon & Precup (2015) and Vezhnevets et al. (2016), and other general hierarchical policy learners include Daniel et al. (2012), Bakker & Schmidhuber (2004) and Menache et al. (2002). We will see that the minimal supervision provided by policy sketches re-\nsults in (sometimes dramatic) improvements over fully unsupervised approaches, while being substantially less onerous for humans to provide compared to the grounded supervision (such as explicit subgoals or feature abstraction hierarchies) used in previous work.\nOnce a collection of high-level actions exists, agents are faced with the problem of learning meta-level (typically semi-Markov) policies that invoke appropriate high-level actions in sequence (Precup, 2000). The learning problem we describe in this paper is in some sense the direct dual to the problem of learning these meta-level policies: there, the agent begins with an inventory of complex primitives and must learn to model their behavior and select among them; here we begin knowing the names of appropriate high-level actions but nothing about how they are implemented, and must infer implementations (but not, initially, abstract plans) from context. Our model can be combined with these approaches to support a “mixed” supervision condition where sketches are available for some tasks but not others (Section 4.5).\nAnother closely related line of work is the Hierarchical Abstract Machines (HAM) framework introduced by Parr & Russell (1998). Like our approach, HAMs begin with a representation of a high-level policy as an automaton (or a more general computer program; Andre & Russell, 2001; Marthi et al., 2004) and use reinforcement learning to fill in low-level details. Because these approaches attempt to learn a single representation of the Q function for all subtasks and contexts, they require extremely strong formal assumptions about the form of the reward function and state representation (Andre & Russell, 2002) that the present work avoids by decoupling the policy representation from the value function. They perform less effectively when applied to arbitrary state representations where these assumptions do not hold (Section 4.3). We are additionally unaware of past work showing that HAM automata can be automatically inferred for new tasks given a pre-trained model, while here we show that it is easy to solve the corresponding problem for sketch followers (Section 4.5).\nOur approach is also inspired by a number of recent efforts toward compositional reasoning and interaction with structured deep models. Such models have been previously used for tasks involving question answering (Iyyer et al., 2014; Andreas et al., 2016) and relational reasoning (Socher et al., 2012), and more recently for multi-task, multi-robot transfer problems (Devin et al., 2016). In the present work—as in existing approaches employing dynamically assembled modular networks—task-specific training signals are propagated through a collection of composed discrete structures with tied weights. Here the composed structures specify time-varying policies rather than feedforward computations, and their parameters must be learned via interaction\nrather than direct supervision. Another closely related family of models includes neural programmers (Neelakantan et al., 2015) and programmer–interpreters (Reed & de Freitas, 2016), which generate discrete computational structures but require supervision in the form of output actions or full execution traces.\nWe view the problem of learning from policy sketches as complementary to the instruction following problem studied in the natural language processing literature. Existing work on instruction following focuses on mapping from natural language strings to symbolic action sequences that are then executed by a hard-coded interpreter (Branavan et al., 2009; Chen & Mooney, 2011; Artzi & Zettlemoyer, 2013; Tellex et al., 2011). Here, by contrast, we focus on learning to execute complex actions given symbolic representations as a starting point. Instruction following models may be viewed as joint policies over instructions and environment observations (so their behavior is not defined in the absence of instructions), while the model described in this paper naturally supports adaptation to tasks where no sketches are available. We expect that future work might combine the two lines of research, bootstrapping policy learning directly from natural language hints rather than the semi-structured sketches used here."
  }, {
    "heading": "3. Learning Modular Policies from Sketches",
    "text": "We consider a multitask reinforcement learning problem arising from a family of infinite-horizon discounted Markov decision processes in a shared environment. This environment is specified by a tuple (S, A, P, ), with S a set of states, A a set of low-level actions, P : S⇥A⇥S ! R a transition probability distribution, and a discount factor. Each task ⌧ 2 T is then specified by a pair (R⌧ , ⇢⌧ ), with R⌧ : S ! R a task-specific reward function and ⇢⌧ : S ! R an initial distribution over states. For a fixed sequence {(si, ai)} of states and actions obtained from a rollout of a given policy, we will denote the empirical return starting in state si as qi := P1 j=i+1\nj i 1R(sj). In addition to the components of a standard multitask RL problem, we assume that tasks are annotated with sketches K⌧ , each consisting of a sequence (b⌧1, b⌧2, . . .) of high-level symbolic labels drawn from a fixed vocabulary B."
  }, {
    "heading": "3.1. Model",
    "text": "We exploit the structural information provided by sketches by constructing for each symbol b a corresponding subpolicy ⇡b. By sharing each subpolicy across all tasks annotated with the corresponding symbol, our approach naturally learns the shared abstraction for the corresponding subtask, without requiring any information about the grounding of that task to be explicitly specified by annotation.\nAlgorithm 1 TRAIN-STEP(⇧, curriculum) 1: D ; 2: while |D| < D do 3: // sample task ⌧ from curriculum (Section 3.3) 4: ⌧ ⇠ curriculum(·) 5: // do rollout 6: d = {(si, ai, (bi = K⌧,i), qi, ⌧), . . .} ⇠ ⇧⌧ 7: D D [ d 8: // update parameters 9: for b 2 B, ⌧ 2 T do 10: d = {(si, ai, b0, qi, ⌧ 0) 2 D : b0 = b, ⌧ 0 = ⌧} 11: // update subpolicy 12: ✓b ✓b + ↵D P d r log ⇡b(ai|si) qi c⌧ (si) 13: // update critic 14: ⌘⌧ ⌘⌧ + D P d rc⌧ (si) qi c⌧ (si)\nAt each timestep, a subpolicy may select either a low-level action a 2 A or a special STOP action. We denote the augmented state space A+ := A [ {STOP}. At a high level, this framework is agnostic to the implementation of subpolicies: any function that takes a representation of the current state onto a distribution over A+ will do.\nIn this paper, we focus on the case where each ⇡b is represented as a neural network.1 These subpolicies may be viewed as options of the kind described by Sutton et al. (1999), with the key distinction that they have no initiation semantics, but are instead invokable everywhere, and have no explicit representation as a function from an initial state to a distribution over final states (instead implicitly using the STOP action to terminate).\nGiven a fixed sketch (b1, b2, . . . ), a task-specific policy ⇧⌧ is formed by concatenating its associated subpolicies in sequence. In particular, the high-level policy maintains a subpolicy index i (initially 0), and executes actions from ⇡bi until the STOP symbol is emitted, at which point control is passed to ⇡bi+1 . We may thus think of ⇧⌧ as inducing a Markov chain over the state space S ⇥ B, with transitions:\n(s, bi)! (s0, bi) with pr. P a2A⇡bi(a|s) · P (s 0|s, a)\n! (s, bi+1) with pr. ⇡bi(STOP|s)\nNote that ⇧⌧ is semi-Markov with respect to projection of the augmented state space S ⇥ B onto the underlying state space S . We denote the complete family of task-specific policies ⇧ := S ⌧{⇧⌧}, and let each ⇡b be an arbitrary function of the current environment state parameterized by some weight vector ✓b. The learning problem is to optimize\n1 For ease of presentation, this section assumes that these subpolicy networks are independently parameterized. As described in Section 4.2, it is also possible to share parameters between subpolicies, and introduce discrete subtask structure by way of an embedding of each symbol b.\nAlgorithm 2 TRAIN-LOOP() 1: // initialize subpolicies randomly 2: ⇧ = INIT() 3: `max 1 4: loop 5: rmin 1 6: // initialize `\nmax\n-step curriculum uniformly\n7: T 0 = {⌧ 2 T : |K⌧ |  `max} 8: curriculum(·) = Unif(T 0) 9: while rmin < rgood do\n10: // update parameters (Algorithm 1) 11: TRAIN-STEP(⇧, curriculum) 12: curriculum(⌧) / 1[⌧ 2 T 0](1 ˆEr⌧ ) 8⌧ 2 T 13: rmin min⌧2T 0 ˆEr⌧ 14: `max `max + 1\nover all ✓b to maximize expected discounted reward\nJ(⇧) := X\n⌧\nJ(⇧⌧ ) := X\n⌧\nEsi⇠⇧⌧ ⇥X\ni\niR⌧ (si) ⇤\nacross all tasks ⌧ 2 T ."
  }, {
    "heading": "3.2. Policy Optimization",
    "text": "Here that optimization is accomplished via a simple decoupled actor–critic method. In a standard policy gradient approach, with a single policy ⇡ with parameters ✓, we compute gradient steps of the form (Williams, 1992):\nr✓J(⇡) = X\ni\nr✓ log ⇡(ai|si) qi c(si) , (1)\nwhere the baseline or “critic” c can be chosen independently of the future without introducing bias into the gradient. Recalling our previous definition of qi as the empirical return starting from si, this form of the gradient corresponds to a generalized advantage estimator (Schulman et al., 2015a) with = 1. Here c achieves close to the optimal variance (Greensmith et al., 2004) when it is set\nexactly equal to the state-value function V⇡(si) = E⇡qi for the target policy ⇡ starting in state si.\nThe situation becomes slightly more complicated when generalizing to modular policies built by sequencing subpolicies. In this case, we will have one subpolicy per symbol but one critic per task. This is because subpolicies ⇡b might participate in a number of composed policies ⇧⌧ , each associated with its own reward function R⌧ . Thus individual subpolicies are not uniquely identified with value functions, and the aforementioned subpolicy-specific statevalue estimator is no longer well-defined. We extend the actor–critic method to incorporate the decoupling of policies from value functions by allowing the critic to vary persample (that is, per-task-and-timestep) depending on the reward function with which the sample is associated. Noting that r✓bJ(⇧) = P t:b2K⌧ r✓bJ(⇧⌧ ), i.e. the sum of gradients of expected rewards across all tasks in which ⇡b participates, we have:\nr✓J(⇧) = X\n⌧\nr✓J(⇧⌧ )\n=\nX\n⌧\nX\ni\nr✓b log ⇡b(a⌧i|s⌧i) qi c⌧ (s⌧i) , (2)\nwhere each state-action pair (s⌧i, a⌧i) was selected by the subpolicy ⇡b in the context of the task ⌧ .\nNow minimization of the gradient variance requires that each c⌧ actually depend on the task identity. (This follows immediately by applying the corresponding argument in Greensmith et al. (2004) individually to each term in the sum over ⌧ in Equation 2.) Because the value function is itself unknown, an approximation must be estimated from data. Here we allow these c⌧ to be implemented with an arbitrary function approximator with parameters ⌘⌧ . This is trained to minimize a squared error criterion, with gradients given by\nr⌘⌧  1\n2\nX\ni\n(qi c⌧ (si))2\n=\nX\ni\nr⌘⌧ c⌧ (si) qi c⌧ (si) . (3)\nAlternative forms of the advantage estimator (e.g. the TD residual R⌧ (si)+ V⌧ (si+1) V⌧ (si) or any other member of the generalized advantage estimator family) can be easily substituted by simply maintaining one such estimator per task. Experiments (Section 4.4) show that conditioning on both the state and the task identity results in noticeable performance improvements, suggesting that the variance reduction provided by this objective is important for efficient joint learning of modular policies.\nThe complete procedure for computing a single gradient step is given in Algorithm 1. (The outer training loop over\nthese steps, which is driven by a curriculum learning procedure, is specified in Algorithm 2.) This is an on-policy algorithm. In each step, the agent samples tasks from a task distribution provided by a curriculum (described in the following subsection). The current family of policies ⇧ is used to perform rollouts in each sampled task, accumulating the resulting tuples of (states, low-level actions, highlevel symbols, rewards, and task identities) into a dataset D. Once D reaches a maximum size D, it is used to compute gradients w.r.t. both policy and critic parameters, and the parameter vectors are updated accordingly. The step sizes ↵ and in Algorithm 1 can be chosen adaptively using any first-order method."
  }, {
    "heading": "3.3. Curriculum Learning",
    "text": "For complex tasks, like the one depicted in Figure 3b, it is difficult for the agent to discover any states with positive reward until many subpolicy behaviors have already been learned. It is thus a better use of the learner’s time to focus on “easy” tasks, where many rollouts will result in high reward from which appropriate subpolicy behavior can be inferred. But there is a fundamental tradeoff involved here: if the learner spends too much time on easy tasks before being made aware of the existence of harder ones, it may overfit and learn subpolicies that no longer generalize or exhibit the desired structural properties.\nTo avoid both of these problems, we use a curriculum learning scheme (Bengio et al., 2009) that allows the model to smoothly scale up from easy tasks to more difficult ones while avoiding overfitting. Initially the model is presented with tasks associated with short sketches. Once average reward on all these tasks reaches a certain threshold, the length limit is incremented. We assume that rewards across tasks are normalized with maximum achievable reward 0 < qi < 1. Let ˆEr⌧ denote the empirical estimate of the expected reward for the current policy on task ⌧ . Then at each timestep, tasks are sampled in proportion to 1 ˆEr⌧ , which by assumption must be positive.\nIntuitively, the tasks that provide the strongest learning signal are those in which (1) the agent does not on average achieve reward close to the upper bound, but (2) many episodes result in high reward. The expected reward component of the curriculum addresses condition (1) by ensuring that time is not spent on nearly solved tasks, while the length bound component of the curriculum addresses condition (2) by ensuring that tasks are not attempted until high-reward episodes are likely to be encountered. Experiments show that both components of this curriculum learning scheme improve the rate at which the model converges to a good policy (Section 4.4).\nThe complete curriculum-based training procedure is specified in Algorithm 2. Initially, the maximum sketch length\n`max is set to 1, and the curriculum initialized to sample length-1 tasks uniformly. (Neither of the environments we consider in this paper feature any length-1 tasks; in this case, observe that Algorithm 2 will simply advance to length-2 tasks without any parameter updates.) For each setting of `max, the algorithm uses the current collection of task policies ⇧ to compute and apply the gradient step described in Algorithm 1. The rollouts obtained from the call to TRAIN-STEP can also be used to compute reward estimates ˆEr⌧ ; these estimates determine a new task distribution for the curriculum. The inner loop is repeated until the reward threshold rgood is exceeded, at which point `max is incremented and the process repeated over a (nowexpanded) collection of tasks."
  }, {
    "heading": "4. Experiments",
    "text": "We evaluate the performance of our approach in three environments: a crafting environment, a maze navigation environment, and a cliff traversal environment. These environments involve various kinds of challenging low-level control: agents must learn to avoid obstacles, interact with various kinds of objects, and relate fine-grained joint activation to high-level locomotion goals. They also feature hierarchical structure: most rewards are provided only after the agent has completed two to five high-level actions in the appropriate sequence, without any intermediate goals to indicate progress towards completion."
  }, {
    "heading": "4.1. Implementation",
    "text": "In all our experiments, we implement each subpolicy as a feedforward neural network with ReLU nonlinearities and a hidden layer with 128 hidden units, and each critic as a linear function of the current state. Each subpolicy network receives as input a set of features describing the current state of the environment, and outputs a distribution over actions. The agent acts at every timestep by sampling from this distribution. The gradient steps given in lines 8 and 9 of Algorithm 1 are implemented using RMSPROP (Tieleman, 2012) with a step size of 0.001 and gradient clipping to a unit norm. We take the batch size D in Algorithm 1 to be 2000, and set = 0.9 in both environments. For curriculum learning, the improvement threshold rgood is 0.8."
  }, {
    "heading": "4.2. Environments",
    "text": "The crafting environment (Figure 3a) is inspired by the popular game Minecraft, but is implemented in a discrete 2-D world. The agent may interact with objects in the world by facing them and executing a special USE action. Interacting with raw materials initially scattered around the environment causes them to be added to an inventory. Interacting with different crafting stations causes objects in the agent’s inventory to be combined or transformed. Each task\nin this game corresponds to some crafted object the agent must produce; the most complicated goals require the agent to also craft intermediate ingredients, and in some cases build tools (like a pickaxe and a bridge) to reach ingredients located in initially inaccessible regions of the environment.\nThe maze environment (not pictured) corresponds closely to the the “light world” described by Konidaris & Barto (2007). The agent is placed in a discrete world consisting of a series of rooms, some of which are connected by doors. Some doors require that the agent first pick up a key to open them. For our experiments, each task corresponds to a goal room (always at the same position relative to the agent’s starting position) that the agent must reach by navigating through a sequence of intermediate rooms. The agent has one sensor on each side of its body, which reports the distance to keys, closed doors, and open doors in the corresponding direction. Sketches specify a particular sequence of directions for the agent to traverse between rooms to reach the goal. The sketch always corresponds to a viable traversal from the start to the goal position, but other (possibly shorter) traversals may also exist.\nThe cliff environment (Figure 3b) is intended to demonstrate the applicability of our approach to problems involving high-dimensional continuous control. In this environment, a quadrupedal robot (Schulman et al., 2015b) is placed on a variable-length winding path, and must navi-\ngate to the end without falling off. This task is designed to provide a substantially more challenging RL problem, due to the fact that the walker must learn the low-level walking skill before it can make any progress, but has simpler hierarchical structure than the crafting environment. The agent receives a small reward for making progress toward the goal, and a large positive reward for reaching the goal square, with a negative reward for falling off the path.\nA listing of tasks and sketches is given in Appendix A."
  }, {
    "heading": "4.3. Multitask Learning",
    "text": "The primary experimental question in this paper is whether the extra structure provided by policy sketches alone is enough to enable fast learning of coupled policies across tasks. We aim to explore the differences between the approach described in Section 3 and relevant prior work that performs either unsupervised or weakly supervised multitask learning of hierarchical policy structure. Specifically, we compare our modular to approach to:\n1. Structured hierarchical reinforcement learners:\n(a) the fully unsupervised option–critic algorithm of Bacon & Precup (2015)\n(b) a Q automaton that attempts to explicitly represent the Q function for each task / subtask combination (essentially a HAM (Andre & Russell, 2002) with a deep state abstraction function)\n2. Alternative ways of incorporating sketch data into standard policy gradient methods:\n(c) learning an independent policy for each task (d) learning a joint policy across all tasks, condi-\ntioning directly on both environment features and a representation of the complete sketch\nThe joint and independent models performed best when trained with the same curriculum described in Section 3.3, while the option–critic model performed best with a length–weighted curriculum that has access to all tasks from the beginning of training.\nLearning curves for baselines and the modular model are shown in Figure 4. It can be seen that in all environments, our approach substantially outperforms the baselines: it induces policies with substantially higher average reward and converges more quickly than the policy gradient baselines. It can further be seen in Figure 4c that after policies have been learned on simple tasks, the model is able to rapidly adapt to more complex ones, even when the longer tasks involve high-level actions not required for any of the short tasks (Appendix A).\nHaving demonstrated the overall effectiveness of our approach, our remaining experiments explore (1) the importance of various components of the training procedure, and (2) the learned models’ ability to generalize or adapt to held-out tasks. For compactness, we restrict our consideration on the crafting domain, which features a larger and more diverse range of tasks and high-level actions."
  }, {
    "heading": "4.4. Ablations",
    "text": "In addition to the overall modular parameter-tying structure induced by our sketches, the key components of our training procedure are the decoupled critic and the curriculum. Our next experiments investigate the extent to which these are necessary for good performance.\nTo evaluate the the critic, we consider three ablations: (1) removing the dependence of the model on the environment state, in which case the baseline is a single scalar per task; (2) removing the dependence of the model on the task, in which case the baseline is a conventional generalized advantage estimator; and (3) removing both, in which case\n0.0 0.5 1.0 1.5 2.0 2.5 3.0 Episode ⇥106\n0.0\n0.2\n0.4\n0.6\n0.8\n1.0\nav g.\nre w\nar d\n{task, state} {task} {state}\n{}\nCritics\n0.0 0.5 1.0 1.5 2.0 2.5 3.0 Episode ⇥106\n0.0\n0.2\n0.4\n0.6\n0.8\n1.0\nav g.\nre w\nar d\n{len, wgt} {len} {wgt}\n{}\nCurricula\n(a) (b)\n0.0 0.5 1.0 1.5 2.0 2.5 3.0 Episode ⇥10 6\n0.0\n0.2\n0.4\n0.6\n0.8\n1.0\nav g.\nre w\nar d\nPerformance by task\n(c)\nFigure 5: Training details in the crafting domain. (a) Critics: lines labeled “task” include a baseline that varies with task identity, while lines labeled “state” include a baseline that varies with state identity. Estimating a baseline that depends on both the representation of the current state and the identity of the current task is better than either alone or a constant baseline. (b) Curricula: lines labeled “len” use a curriculum with iteratively increasing sketch lengths, while lines labeled “wgt” sample tasks in inverse proportion to their current reward. Adjusting the sampling distribution based on both task length and performance return improves convergence. (c) Individual task performance. Colors correspond to task length. Sharp steps in the learning curve correspond to increases of `max in the curriculum.\nthe baseline is a single scalar, as in a vanilla policy gradient approach. Results are shown in Figure 5a. Introducing both state and task dependence into the baseline leads to faster convergence of the model: the approach with a constant baseline achieves less than half the overall performance of the full critic after 3 million episodes. Introducing task and state dependence independently improve this performance; combining them gives the best result.\nWe also investigate two aspects of our curriculum learning scheme: starting with short examples and moving to long ones, and sampling tasks in inverse proportion to their accumulated reward. Experiments are shown in Figure 5b. Both components help; prioritization by both length and weight gives the best results."
  }, {
    "heading": "4.5. Zero-shot and Adaptation Learning",
    "text": "In our final experiments, we consider the model’s ability to generalize beyond the standard training condition. We first consider two tests of generalization: a zero-shot setting, in which the model is provided a sketch for the new task and must immediately achieve good performance, and a adaptation setting, in which no sketch is provided and the model must learn the form of a suitable sketch via interaction in the new task.\nModel Multitask 0-shot Adaptation\nJoint .49 .01 – Independent .44 – .01 Option–Critic .47 – .42 Modular (ours) .89 .77 .76\nTable 1: Accuracy and generalization of learned models in the crafting domain. The table shows the task completion rate for each approach after convergence under various training conditions. Multitask is the multitask training condition described in Section 4.3, while 0-Shot and Adaptation are the generalization experiments described in Section 4.5. Our modular approach consistently achieves the best performance.\nWe hold out two length-four tasks from the full inventory used in Section 4.3, and train on the remaining tasks. For zero-shot experiments, we simply form the concatenated policy described by the sketches of the held-out tasks, and repeatedly execute this policy (without learning) in order to obtain an estimate of its effectiveness. For adaptation experiments, we consider ordinary RL over high-level actions B rather than low-level actions A, implementing the highlevel learner with the same agent architecture as described in Section 3.1. Note that the Independent and Option– Critic models cannot be applied to the zero-shot evaluation, while the Joint model cannot be applied to the adaptation baseline (because it depends on pre-specified sketch features). Results are shown in Table 1. The held-out tasks are sufficiently challenging that the baselines are unable to obtain more than negligible reward: in particular, the joint model overfits to the training tasks and cannot generalize to new sketches, while the independent model cannot discover enough of a reward signal to learn in the adaptation setting. The modular model does comparatively well: individual subpolicies succeed in novel zero-shot configurations (suggesting that they have in fact discovered the behavior suggested by the semantics of the sketch) and provide a suitable basis for adaptive discovery of new high-level policies."
  }, {
    "heading": "5. Conclusions",
    "text": "We have described an approach for multitask learning of deep multitask policies guided by symbolic policy sketches. By associating each symbol appearing in a sketch with a modular neural subpolicy, we have shown that it is possible to build agents that share behavior across tasks in order to achieve success in tasks with sparse and delayed rewards. This process induces an inventory of reusable and interpretable subpolicies which can be employed for zeroshot generalization when further sketches are available, and hierarchical reinforcement learning when they are not. Our work suggests that these sketches, which are easy to produce and require no grounding in the environment, provide an effective scaffold for learning hierarchical policies from minimal supervision."
  }, {
    "heading": "Acknowledgments",
    "text": "JA is supported by a Facebook fellowship and a Berkeley AI / Huawei fellowship."
  }],
  "year": 2017,
  "references": [{
    "title": "Programmable reinforcement learning agents",
    "authors": ["Andre", "David", "Russell", "Stuart"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2001
  }, {
    "title": "Weakly supervised learning of semantic parsers for mapping instructions to actions",
    "authors": ["Artzi", "Yoav", "Zettlemoyer", "Luke"],
    "venue": "Transactions of the Association for Computational Linguistics,",
    "year": 2013
  }, {
    "title": "The option-critic architecture",
    "authors": ["Bacon", "Pierre-Luc", "Precup", "Doina"],
    "venue": "In NIPS Deep Reinforcement Learning Workshop,",
    "year": 2015
  }, {
    "title": "Hierarchical reinforcement learning based on subgoal discovery and subpolicy specialization",
    "authors": ["Bakker", "Bram", "Schmidhuber", "Jürgen"],
    "venue": "In Proc. of the 8-th Conf. on Intelligent Autonomous Systems,",
    "year": 2004
  }, {
    "title": "Learning to interpret natural language navigation instructions from observations",
    "authors": ["Chen", "David L", "Mooney", "Raymond J"],
    "venue": "In Proceedings of the Meeting of the Association for the Advancement of Artificial Intelligence,",
    "year": 2011
  }, {
    "title": "Learning modular neural network policies for multi-task and multi-robot transfer",
    "authors": ["Devin", "Coline", "Gupta", "Abhishek", "Darrell", "Trevor", "Abbeel", "Pieter", "Levine", "Sergey"],
    "venue": "arXiv preprint arXiv:1609.07088,",
    "year": 2016
  }, {
    "title": "Hierarchical reinforcement learning with the maxq value function decomposition",
    "authors": ["Dietterich", "Thomas G"],
    "venue": "J. Artif. Intell. Res. (JAIR),",
    "year": 2000
  }, {
    "title": "Variance reduction techniques for gradient estimates in reinforcement learning",
    "authors": ["Greensmith", "Evan", "Bartlett", "Peter L", "Baxter", "Jonathan"],
    "venue": "Journal of Machine Learning Research,",
    "year": 2004
  }, {
    "title": "Using motion primitives in probabilistic sample-based planning for humanoid robots",
    "authors": ["Hauser", "Kris", "Bretl", "Timothy", "Harada", "Kensuke", "Latombe", "Jean-Claude"],
    "venue": "In Algorithmic foundation of robotics,",
    "year": 2008
  }, {
    "title": "Near-optimal reinforcement learning in polynomial time",
    "authors": ["Kearns", "Michael", "Singh", "Satinder"],
    "venue": "Machine Learning,",
    "year": 2002
  }, {
    "title": "Building portable options: Skill transfer in reinforcement learning",
    "authors": ["Konidaris", "George", "Barto", "Andrew G"],
    "venue": "In IJCAI,",
    "year": 2007
  }, {
    "title": "Robot learning from demonstration by constructing skill trees",
    "authors": ["Konidaris", "George", "Kuindersma", "Scott", "Grupen", "Roderic", "Barto", "Andrew"],
    "venue": "The International Journal of Robotics Research,",
    "year": 2011
  }, {
    "title": "Hierarchical deep reinforcement learning: Integrating temporal abstraction and intrinsic motivation",
    "authors": ["Kulkarni", "Tejas D", "Narasimhan", "Karthik R", "Saeedi", "Ardavan", "Tenenbaum", "Joshua B"],
    "venue": "arXiv preprint arXiv:1604.06057,",
    "year": 2016
  }, {
    "title": "Concurrent hierarchical reinforcement learning",
    "authors": ["Marthi", "Bhaskara", "Lantham", "David", "Guestrin", "Carlos", "Russell", "Stuart"],
    "venue": "In Proceedings of the Meeting of the Association for the Advancement of Artificial Intelligence,",
    "year": 2004
  }, {
    "title": "Q-cutdynamic discovery of sub-goals in reinforcement learning",
    "authors": ["Menache", "Ishai", "Mannor", "Shie", "Shimkin", "Nahum"],
    "venue": "In European Conference on Machine Learning,",
    "year": 2002
  }, {
    "title": "Neural programmer: Inducing latent programs with gradient descent",
    "authors": ["Neelakantan", "Arvind", "Le", "Quoc V", "Sutskever", "Ilya"],
    "venue": "arXiv preprint arXiv:1511.04834,",
    "year": 2015
  }, {
    "title": "Learning grounded finite-state representations from unstructured demonstrations",
    "authors": ["Niekum", "Scott", "Osentoski", "Sarah", "Konidaris", "George", "Chitta", "Sachin", "Marthi", "Bhaskara", "Barto", "Andrew G"],
    "venue": "The International Journal of Robotics Research,",
    "year": 2015
  }, {
    "title": "Reinforcement learning with hierarchies of machines",
    "authors": ["Parr", "Ron", "Russell", "Stuart"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 1998
  }, {
    "title": "Temporal abstraction in reinforcement learning",
    "authors": ["Precup", "Doina"],
    "venue": "PhD thesis,",
    "year": 2000
  }, {
    "title": "Neural programmerinterpreters",
    "authors": ["Reed", "Scott", "de Freitas", "Nando"],
    "venue": "Proceedings of the International Conference on Learning Representations,",
    "year": 2016
  }, {
    "title": "High-dimensional continuous control using generalized advantage estimation",
    "authors": ["Schulman", "John", "Moritz", "Philipp", "Levine", "Sergey", "Jordan", "Michael", "Abbeel", "Pieter"],
    "venue": "arXiv preprint arXiv:1506.02438,",
    "year": 2015
  }, {
    "title": "Trust region policy optimization. 2015b",
    "authors": ["Schulman", "John", "Moritz", "Philipp", "Levine", "Sergey", "Jordan", "Michael", "Abbeel", "Pieter"],
    "year": 2015
  }, {
    "title": "Learning options in reinforcement learning",
    "authors": ["Stolle", "Martin", "Precup", "Doina"],
    "venue": "In International Symposium on Abstraction, Reformulation, and Approximation,",
    "year": 2002
  }, {
    "title": "Between MDPs and semi-MDPs: A framework for temporal abstraction in reinforcement learning",
    "authors": ["Sutton", "Richard S", "Precup", "Doina", "Singh", "Satinder"],
    "venue": "Artificial intelligence,",
    "year": 1999
  }, {
    "title": "Strategic attentive writer for learning macro-actions",
    "authors": ["Vezhnevets", "Alexander", "Mnih", "Volodymyr", "Agapiou", "John", "Osindero", "Simon", "Graves", "Alex", "Vinyals", "Oriol", "Kavukcuoglu", "Koray"],
    "venue": "arXiv preprint arXiv:1606.04695,",
    "year": 2016
  }, {
    "title": "Learning to follow navigational directions",
    "authors": ["Vogel", "Adam", "Jurafsky", "Dan"],
    "venue": "In Proceedings of the Annual Meeting of the Association for Computational Linguistics,",
    "year": 2010
  }, {
    "title": "Simple statistical gradient-following algorithms for connectionist reinforcement learning",
    "authors": ["Williams", "Ronald J"],
    "venue": "Machine learning,",
    "year": 1992
  }],
  "id": "SP:3a13f7c43b767b1fb72ef107ef62a4ddd48dd2a7",
  "authors": [{
    "name": "Jacob Andreas",
    "affiliations": []
  }, {
    "name": "Dan Klein",
    "affiliations": []
  }, {
    "name": "Sergey Levine",
    "affiliations": []
  }],
  "abstractText": "We describe a framework for multitask deep reinforcement learning guided by policy sketches. Sketches annotate tasks with sequences of named subtasks, providing information about high-level structural relationships among tasks but not how to implement them—specifically not providing the detailed guidance used by much previous work on learning policy abstractions for RL (e.g. intermediate rewards, subtask completion signals, or intrinsic motivations). To learn from sketches, we present a model that associates every subtask with a modular subpolicy, and jointly maximizes reward over full task-specific policies by tying parameters across shared subpolicies. Optimization is accomplished via a decoupled actor–critic training objective that facilitates learning common behaviors from multiple dissimilar reward functions. We evaluate the effectiveness of our approach in three environments featuring both discrete and continuous control, and with sparse rewards that can be obtained only after completing a number of high-level subgoals. Experiments show that using our approach to learn policies guided by sketches gives better performance than existing techniques for learning task-specific or shared policies, while naturally inducing a library of interpretable primitive behaviors that can be recombined to rapidly adapt to new tasks.",
  "title": "Modular Multitask Reinforcement Learning with Policy Sketches"
}