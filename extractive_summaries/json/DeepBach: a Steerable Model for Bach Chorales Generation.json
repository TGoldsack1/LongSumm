{
  "sections": [{
    "heading": "1. Introduction",
    "text": "The composition of polyphonic chorale music in the style of J.S. Bach has represented a major challenge in automatic music composition over the last decades. The corpus of the chorale harmonizations by Johann Sebastian Bach is remarkable by its homogeneity and its size (389 chorales in (Bach, 1985)). All these short pieces (approximately one minute long) are written for a four-part chorus (soprano, alto, tenor and bass) using similar compositional principles: the composer takes a well-known (at that time) melody from a Lutheran hymn and harmonizes it i.e. the three lower parts (alto, tenor and bass) accompanying the soprano (the highest part) are composed, see Fig.1 for an example.\n1LIP6, Université Pierre et Marie Curie 2Sony CSL, Paris 3Sony CSL, Japan. Correspondence to: Gaëtan Hadjeres <gaetan.hadjeres@etu.upmc.fr>, François Pachet <pachetcsl@gmail.com>, Frank Nielsen <Frank.Nielsen@acm.org>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\nMoreover, since the aim of reharmonizing a melody is to give more power or new insights to its text, the lyrics have to be understood clearly. We say that voices are in homophony, i.e. they articulate syllables simultaneously. This implies characteristic rhythms, variety of harmonic ideas as well as characteristic melodic movements which make the style of these chorale compositions easily distinguishable, even for non experts.\nThe difficulty, from a compositional point of view comes from the intricate interplay between harmony (notes sounding at the same time) and voice movements (how a single voice evolves through time). Furthermore, each voice has its own “style” and its own coherence. Finding a chorale-like reharmonization which combines Bach-like harmonic progressions with musically interesting melodic movements is a problem which often takes years of practice for musicians.\nFrom the point of view of automatic music generation, the first solution to this apparently highly combinatorial problem was proposed by (Ebcioglu, 1988) in 1988. This problem is seen as a constraint satisfaction problem, where the system must fulfill numerous hand-crafted constraints characterizing the style of Bach. It is a rule-based expert system which contains no less than 300 rules and tries to reharmonize a given melody with a generate-and-test method and intelligent backtracking. Among the short examples presented at the end of the paper, some are flawless. The drawbacks of this method are, as stated by the author, the considerable effort to generate the rule base and the fact that the harmonizations produced “do not sound like Bach, except for occasional Bachian patterns and cadence formulas.” In our opinion, the requirement of an expert knowledge implies a lot of subjective choices.\nA neural-network-based solution was later developed by (Hild et al., 1992). This method relies on several neural networks, each one trained for solving a specific task: a harmonic skeleton is first computed then refined and ornamented. A similar approach is adopted in (Allan & Williams, 2005), but uses Hidden Markov Models (HMMs) instead of neural networks. Chords are represented as lists of intervals and form the states of the Markov mod-\n2https://www.youtube.com/watch?v= 73WF0M99vlg\nels. These approaches produce interesting results even if they both use expert knowledge and bias the generation by imposing their compositional process. In (Whorley et al., 2013; Whorley & Conklin, 2016), authors elaborate on those methods by introducing multiple viewpoints and variations on the sampling method (generated sequences which violate “rules of harmony” are put aside for instance). However, this approach does not produce a convincing chorale-like texture, rhythmically as well as harmonically and the resort to hand-crafted criteria to assess the quality of the generated sequences might rule out many musically-interesting solutions.\nRecently, agnostic approaches (requiring no knowledge about harmony, Bach’s style or music) using neural networks have been investigated with promising results. In (Boulanger-Lewandowski et al., 2012), chords are modeled with Restricted Boltzmann Machines (RBMs). Their temporal dependencies are learned using Recurrent Neural Networks (RNNs). Variations of these architectures based on Long Short-Term Memory (LSTM) units ((Hochreiter & Schmidhuber, 1997; Mikolov et al., 2014)) or GRUs (Gated Recurrent Units) have been developed by (Lyu et al., 2015) and (Chung et al., 2014) respectively. However, these models which work on piano roll representations of the music are too general to capture the specificity of Bach chorales. Also, a major drawback is their lack of flexibility. Generation is performed from left to right. A user cannot interact with the system: it is impossible to do reharmonization for instance which is the essentially how the corpus of Bach chorales was composed. Moreover, their invention capacity and non-plagiarism abilities are not demonstrated.\nA method that addresses the rigidity of sequential generation in music was first proposed in (Sakellariou et al., 2015; Sakellariou et al., 2016) for monophonic music and later generalized to polyphony in (Hadjeres et al., 2016). These approaches advocate for the use of Gibbs sampling as a generation process in automatic music composition.\nThe most recent advances in chorale harmonization is arguably the BachBot model (Liang, 2016), a LSTMbased approach specifically designed to deal with Bach\nchorales. This approach relies on little musical knowledge (all chorales are transposed in a common key) and is able to produce high-quality chorale harmonizations. However, compared to our approach, this model is less general (produced chorales are all in the C key for instance) and less flexible (only the soprano can be fixed). Similarly to our work, the authors evaluate their model with an online Turing test to assess the efficiency of their model. They also take into account the fermata symbols (Fig. 2) which are indicators of the structure of the chorales.\nIn this paper we introduce DeepBach, a dependency network (Heckerman et al., 2000) capable of producing musically convincing four-part chorales in the style of Bach by using a Gibbs-like sampling procedure. Contrary to models based on RNNs, we do not sample from left to right which allows us to enforce positional, unary user-defined constraints such as rhythm, notes, parts, chords and cadences. DeepBach is able to generate coherent musical phrases and provides, for instance, varied reharmonizations of melodies without plagiarism. Its core features are its speed, the possible interaction with users and the richness of harmonic ideas it proposes. Its efficiency opens up new ways of composing Bach-like chorales for non experts in an interactive manner similarly to what is proposed in (Papadopoulos et al., 2016) for leadsheets.\nIn Sect. 2 we present the DeepBach model for four-part chorale generation. We discuss in Sect. 3 the results of an experimental study we conducted to assess the quality of our model. Finally, we provide generated examples in Sect. 4.3 and elaborate on the possibilities offered by our interactive music composition editor in Sect. 4. All examples can be heard on the accompanying web page3 and the code of our implementation is available on GitHub4. Even if our presentation focuses on Bach chorales, this model has been successfully applied to other styles and composers including Monteverdi five-voice madrigals to Palestrina masses.\n3https://sites.google.com/site/ deepbachexamples/\n4https://github.com/Ghadjeres/DeepBach"
  }, {
    "heading": "2. DeepBach",
    "text": "In this paper we introduce a generative model which takes into account the distinction between voices. Sect. 2.1 presents the data representation we used. This representation is both fitted for our sampling procedure and more accurate than many data representation commonly used in automatic music composition. Sect. 2.2 presents the model’s architecture and Sect. 2.3 our generation method. Finally, Sect. 2.4 provides implementation details and indicates how we preprocessed the corpus of Bach chorale harmonizations."
  }, {
    "heading": "2.1. Data Representation",
    "text": ""
  }, {
    "heading": "2.1.1. NOTES AND VOICES",
    "text": "We use MIDI pitches to encode notes and choose to model voices separately. We consider that only one note can be sung at a given time and discard chorales with voice divisions.\nSince Bach chorales only contain simple time signatures, we discretize time with sixteenth notes, which means that each beat is subdivided into four equal parts. Since there is no smaller subdivision in Bach chorales, there is no loss of information in this process.\nIn this setting, a voice Vi = {Vti }t is a list of notes indexed by t ∈ [T ]5, where T is the duration piece (in sixteenth notes)."
  }, {
    "heading": "2.1.2. RHYTHM",
    "text": "We choose to model rhythm by simply adding a hold symbol “ ” coding whether or not the preceding note is held to the list of existing notes. This representation is thus unambiguous, compact and well-suited to our sampling method (see Sect. 2.3.4)."
  }, {
    "heading": "2.1.3. METADATA",
    "text": "The music sheet (Fig. 1b) conveys more information than only the notes played. We can cite:\n• the lyrics,\n• the key signature,\n• the time signature,\n• the beat index,\n• an implicit metronome (on which subdivision of the beat the note is played),\n• the fermata symbols (see Fig. 2), 5We adopt the standard notation [N ] to denote the set of inte-\ngers {1, . . . , N} for any integer N .\nIn the following, we will only take into account the fermata symbols, the subdivision indexes and the current key signature. To this end, we introduce:\n• The fermata list F that indicates if there is a fermata symbol, see Fig. 2, over the current note, it is a Boolean value. If a fermata is placed over a note on the music sheet, we consider that it is active for all time indexes within the duration of the note.\n• The subdivision list S that contains the subdivision indexes of the beat. It is an integer between 1 and 4: there is no distinction between beats in a bar so that our model is able to deal with chorales with three and four beats per measure."
  }, {
    "heading": "2.1.4. CHORALE",
    "text": "We represent a chorale as a couple\n(V,M) (1)\ncomposed of voices and metadata. For Bach chorales, V is a list of 4 voices Vi for i ∈ [4] (soprano, alto, tenor and bass) andM a collection of metadata lists (F and S).\nOur choices are very general and do not involve expert knowledge about harmony or scales but are only mere observations of the corpus. The list S acts as a metronome. The list F is added since fermatas in Bach chorales indicate the end of each musical phrase. The use of fermata to this end is a specificity of Bach chorales that we want to take advantage of."
  }, {
    "heading": "2.2. Model Architecture",
    "text": "We choose to consider the metadata sequences in M as given. For clarity, we suppose in this section that our dataset is composed of only one chorale written as in Eq. 1 of size T . We define a dependency network on the finite set of variables V = {V ti } by specifying a set of conditional probability distributions (parametrized by parameter θi,t){\npi,t(V t i |V\\i,t,M, θi,t) } i∈[4],t∈[T ] , (2)\nwhere Vti indicates the note of voice i at time index t and V\\i,t all variables in V except from the variable Vti . As we want our model to be time invariant so that we can apply it to sequences of any size, we share the parameters between all conditional probability distributions on variables lying in the same voice, i.e.\nθi := θi,t, pi := pi,t ∀t ∈ [T ].\nFinally, we fit each of these conditional probability distributions on the data by maximizing the log-likelihood. Due to weight sharing, this amounts to solving four classification problems of the form:\nmax θi ∑ t log pi(Vti |V\\i,t,M, θi), for i ∈ [4], (3)\nwhere the aim is to predict a note knowing the value of its neighboring notes, the subdivision of the beat it is on and the presence of fermatas. The advantage with this formulation is that each classifier has to make predictions within a small range of notes whose ranges correspond to the notes within the usual voice ranges (see 2.4).\nFor accurate predictions and in order to take into account the sequential aspect of the data, each classifier is modeled using four neural networks: two Deep Recurrent Neural Networks (Pascanu et al., 2013), one summing up past information and another summing up information coming from the future together with a non-recurrent neural network for notes occurring at the same time. Only the last output from the uppermost RNN layer is kept. These three outputs are then merged and passed as the input of a fourth neural network whose output is pi(Vti |V\\i,t,M, θ). Figure 4 shows a graphical representation for one of these models. Details are provided in Sect. 2.4. These choices of architecture somehow match real compositional practice on Bach chorales. Indeed, when reharmonizing a given melody, it is often simpler to start from the cadence and write music “backwards.”"
  }, {
    "heading": "2.3. Generation",
    "text": ""
  }, {
    "heading": "2.3.1. ALGORITHM",
    "text": "Generation in dependency networks is performed using the pseudo-Gibbs sampling procedure. This Markov Chain\nMonte Carlo (MCMC) algorithm is described in Alg.1. It is similar to the classical Gibbs sampling procedure (Geman & Geman, 1984) on the difference that the conditional distributions are potentially incompatible (Chen & Ip, 2015). This means that the conditional distributions of Eq. (2) do not necessarily comes from a joint distribution p(V) and that the theoretical guarantees that the MCMC converges to this stationary joint distribution vanish. We experimentally verified that it was indeed the case by checking that the Markov Chain of Alg.1 violates Kolmogorov’s criterion (Kelly, 2011): it is thus not reversible and cannot converge to a joint distribution whose conditional distributions match the ones used for sampling.\nHowever, this Markov chain converges to another stationary distribution and applications on real data demonstrated that this method yielded accurate joint probabilities, especially when the inconsistent probability distributions are learned from data (Heckerman et al., 2000). Furthermore, nonreversible MCMC algorithms can in particular cases be better at sampling that reversible Markov Chains (Vucelja, 2014)."
  }, {
    "heading": "2.3.2. FLEXIBILITY OF THE SAMPLING PROCEDURE",
    "text": "The advantage of this method is that we can enforce userdefined constraints by tweaking Alg. 1:\n• instead of choosing voice i from 1 to 4 we can choose to fix the soprano and only resample voices from 2, 3\nAlgorithm 1 Pseudo-Gibbs sampling 1: Input: Chorale length L, metadataM containing lists\nof length L, probability distributions (p1, p2, p3, p4), maximum number of iterations M 2: Create four lists V = (V1,V2,V3,V4) of length L 3: {The lists are initialized with random notes drawn from\nthe ranges of the corresponding voices (sampled uniformly or from the marginal distributions of the notes)}\n4: for m from 1 to M do 5: Choose voice i uniformly between 1 and 4 6: Choose time t uniformly between 1 and L 7: Re-sample Vti from pi(Vti |V\\i,t,M, θi) 8: end for 9: Output: V = (V1,V2,V3,V4)\nand 4 in step (3) in order to provide reharmonizations of the fixed melody\n• we can choose the fermata list F in order to impose end of musical phrases at some places\n• more generally, we can impose any metadata\n• for any t and any i, we can fix specific subsets Rti of notes within the range of voice i. We then restrict ourselves to some specific chorales by re-sampling Vti from\npi(Vti |V\\i,t,M, θi,Vti ∈ Rti)\nat step (5). This allows us for instance to fix rhythm (since the hold symbol is considered as a note), impose some chords in a soft manner or restrict the vocal ranges."
  }, {
    "heading": "2.3.3. PERFORMANCE",
    "text": "Note that it is possible to make generation faster by making parallel Gibbs updates on GPU. Steps (3) to (5) from Alg. 1 can be run simultaneously to provide significant speedups. Even if it is known that this approach is biased (De Sa et al., 2016) (since we can update simultaneously variables which are not conditionally independent), we experimentally observed that for small batch sizes (16 or 32), DeepBach still generates samples of great musicality while running ten times faster than the sequential version. This allows DeepBach to generate chorales in a few seconds.\nIt is also possible to use the hard-disk-configurations generation algorithm (Alg.2.9 in (Krauth, 2006)) to appropriately choose all the time indexes at which we parallelly resample so that:\n• every time index is at distance at least δ from the other time indexes\n• configurations of time indexes satisfying the relation above are equally sampled.\nThis trick allows to assert that we do not update simultaneously a variable and its local context."
  }, {
    "heading": "2.3.4. IMPORTANCE OF THE DATA REPRESENTATION",
    "text": "We emphasize on this section the importance of our particular choice of data representation with respect to our sampling procedure. The fact that we obtain great results using pseudo-Gibbs sampling relies exclusively on our choice to integrate the hold symbol into the list of notes.\nIndeed, Gibbs sampling fails to sample the true joint distribution p(V|M, θ) when variables are highly correlated, creating isolated regions of high probability states in which the MCMC chain can be trapped. However, many data representations used in music modeling such as\n• the piano-roll representation,\n• the couple (pitch, articulation) representation where articulation is a Boolean value indicating whether or not the note is played or held,\ntend to make the musical data suffer from this drawback.\nAs an example, in the piano-roll representation, a long note is represented as the repetition of the same value over many variables. In order to only change its pitch, one needs to change simultaneously a large number of variables (which is exponentially rare) while this is achievable with only one variable change with our representation."
  }, {
    "heading": "2.4. Implementation Details",
    "text": "We implemented DeepBach using Keras (Chollet, 2015) with the Tensorflow (Abadi et al., 2015) backend. We used the database of chorale harmonizations by J.S. Bach included in the music21 toolkit (Cuthbert & Ariza, 2010). After removing chorales with instrumental parts and chorales containing parts with two simultaneous notes (bass parts sometimes divide for the last chord), we ended up with 352 pieces. Contrary to other approaches which transpose all chorales to the same key (usually in C major or A minor), we choose to augment our dataset by adding all chorale transpositions which fit within the vocal ranges defined by the initial corpus. This gives us a corpus of 2503 chorales and split it between a training set (80%) and a validation set (20%). The vocal ranges contains less than 30 different pitches for each voice (21, 21, 21, 28) for the soprano, alto, tenor and bass parts respectively.\nAs shown in Fig. 4, we model only local interactions between a note Vti and its context (V\\i,t, M) i.e. only elements with time index t between t − ∆t and t + ∆t are\ntaken as inputs of our model for some scope ∆t. This approximation appears to be accurate since musical analysis reveals that Bach chorales do not exhibit clear long-term dependencies.\nThe reported results in Sect. 3 and examples in Sect. 4.3 were obtained with ∆t = 16. We chose as the “neural network brick” in Fig. 4 a neural network with one hidden layer of size 200 and ReLU (Nair & Hinton, 2010) nonlinearity and as the “Deep RNN brick” two stacked LSTMs (Hochreiter & Schmidhuber, 1997; Mikolov et al., 2014), each one being of size 200 (see Fig. 2 (f) in (Li & Wu, 2015)). The “embedding brick” applies the same neural network to each time slice (Vt,Mt). There are 20% dropout on input and 50% dropout after each layer.\nWe experimentally found that sharing weights between the left and right embedding layers improved neither validation accuracy nor the musical quality of our generated chorales."
  }, {
    "heading": "3. Experimental Results",
    "text": "We evaluated the quality of our model with an online test conducted on human listeners."
  }, {
    "heading": "3.1. Setup",
    "text": "For the parameters used in our experiment, see Sect 2.4. We compared our model with two other models: a Maximum Entropy model (MaxEnt) as in (Hadjeres et al., 2016) and a Multilayer Perceptron (MLP) model.\nThe Maximum Entropy model is a neural network with no hidden layer. It is given by:\npi(Vti |V\\i,t,M, Ai, bi) = Softmax(AX + b) (4)\nwhere X is a vector containing the elements in V\\i,t ∪Mt, Ai a (ni,mi) matrix and bi a vector of size mi with mi being the size of X , ni the number of notes in the voice range i and Softmax the softmax function given by\nSoftmax(z)j = ezj∑K k=1 e zk for j ∈ [K],\nfor a vector z = (z1, . . . , zK).\nThe Multilayer Perceptron model we chose takes as input elements in V\\i,t∪M, is a neural network with one hidden layer of size 500 and uses a ReLU (Nair & Hinton, 2010) nonlinearity.\nAll models are local and have the same scope ∆t, see Sect. 2.4.\nSubjects were asked to give information about their musical expertise. They could choose what category fits them best between:\n1. I seldom listen to classical music\n2. Music lover or musician\n3. Student in music composition or professional musician.\nThe musical extracts have been obtained by reharmonizing 50 chorales from the validation set by each of the three models (MaxEnt, MLP, DeepBach). We rendered the MIDI files using the Leeds Town Hall Organ soundfont6 and cut two extracts of 12 seconds from each chorale, which gives us 400 musical extracts for our test: 4 versions for each of the 100 melody chunks. We chose our rendering so that the generated parts (alto, tenor and bass) can be distinctly heard and differentiated from the soprano part (which is fixed and identical for all models): in our mix, dissonances are easily heard, the velocity is the same for all notes as in a real organ performance and the sound does not decay, which is important when evaluating the reharmonization of long notes."
  }, {
    "heading": "3.2. Discrimination Test: “Bach or Computer” experiment",
    "text": "Subjects were presented series of only one musical extract together with the binary choice “Bach” or “Computer”. Fig. 5 shows how the votes are distributed depending on the level of musical expertise of the subjects for each model. For this experiment, 1272 people took this test, 261 with musical expertise 1, 646 with musical expertise 2 and 365 with musical expertise 3.\nThe results are quite clear: the percentage of “Bach” votes augment as the model’s complexity increase. Furthermore, the distinction between computer-generated extracts and Bach’s extracts is more accurate when the level of musical expertise is higher. When presented a DeepBach-generated\n6https://www.samplephonics.com/products/ free/sampler-instruments/the-leeds-townhall-organ\nextract, around 50% of the voters would judge it as composed by Bach. We consider this to be a good score knowing the complexity of Bach’s compositions and the facility to detect badly-sounding chords even for non musicians.\nWe also plotted specific results for each of the 400 extracts. Fig. 6 shows for each reharmonization extract the percentage of Bach votes it collected: more than half of the DeepBach’s automatically-composed extracts has a majority of votes considering them as being composed by J.S. Bach while it is only a third for the MLP model."
  }, {
    "heading": "4. Interactive composition",
    "text": ""
  }, {
    "heading": "4.1. Description",
    "text": "We developed a plugin on top of the MuseScore music editor allowing a user to call DeepBach on any rectangular region. Even if the interface is minimal (see Fig.7), the possibilities are numerous: we can generate a chorale from scratch, reharmonize a melody and regenerate a given chord, bar or part. We believe that this interplay between a user and the system can boost creativity and can interest a wide range of audience."
  }, {
    "heading": "4.2. Adapting the model",
    "text": "We made two major changes between the model we described for the online test and the interactive composition tool."
  }, {
    "heading": "4.2.1. NOTE ENCODING",
    "text": "We changed the MIDI encoding of the notes to a full name encoding of the notes. Indeed, some information is lost when reducing a music sheet to its MIDI representation since we cannot differentiate between two enharmonic\nnotes (notes that sound the same but that are written differently e.g. F# and Gb). This difference in Bach chorales is unambiguous and it is thus natural to consider the full name of the notes, like C#3, Db3 or E#4. From a machine learning point of view, these notes would appear in totally different contexts. This improvement enables the model to generate notes with the correct spelling, which is important when we focus on the music sheet rather than on its audio rendering."
  }, {
    "heading": "4.2.2. STEERING MODULATIONS",
    "text": "We added the current key signature list K to the metadataM. This allows users to impose modulations and key changes. Each element Kt of this list contains the number of sharps of the estimated key for the current bar. It is a integer between -7 and 7. The current key is computed using the key analyzer algorithm from music21."
  }, {
    "heading": "4.3. Generation examples",
    "text": "We now provide and comment on examples of chorales generated using the DeepBach plugin. Our aim is to show the quality of the solutions produced by DeepBach. For these examples, no note was set by hand and we asked DeepBach to generate regions longer than one bar and covering all four voices.\nDespite some compositional errors like parallel octaves, the musical analysis reveals that the DeepBach compositions reproduce typical Bach-like patterns, from characteristic cadences to the expressive use of nonchord tones. As discussed in Sect. 4.2, DeepBach also learned the correct spelling of the notes. Among examples in Fig. 8, examples (a) and (b) share the same metadata (S,F and K). This demonstrates that even with fixed metadata it is possible to generate contrasting chorales.\nSince we aimed at producing music that could not be distinguished from actual Bach compositions, we had all provided extracts sung by the Wishful Singing choir. These audio files can be heard on the accompanying website."
  }, {
    "heading": "5. Discussion and future work",
    "text": "We described DeepBach, a probabilistic model together with a sampling method which is flexible, efficient and provides musically convincing results even to the ears of professionals. The strength of our method is the possibility to let users impose unary constraints, which is a feature often neglected in probabilistic models of music. Through our graphical interface, the composition of polyphonic music becomes accessible to non-specialists. The playful interaction between the user and this system can boost creativity and help explore new ideas quickly. We believe that this approach could form a starting point for a novel com-\npositional process that could be described as a constructive dialogue between a human operator and the computer. This method is general and its implementation simple. It is not only applicable to Bach chorales but embraces a wider range of polyphonic music.\nFuture work aims at refining our interface, speeding up\ngeneration and handling datasets with small corpora."
  }],
  "year": 2017,
  "references": [{
    "title": "Harmonising chorales by probabilistic inference",
    "authors": ["Allan", "Moray", "Williams", "Christopher KI"],
    "venue": "Advances in neural information processing systems,",
    "year": 2005
  }, {
    "title": "Chorales (Choral-Gesange): SATB (German Language Edition)",
    "authors": ["J.S. Bach"],
    "venue": "Kalmus Classic Edition. Alfred Publishing Company,",
    "year": 1985
  }, {
    "title": "Behaviour of the gibbs sampler when conditional distributions are potentially incompatible",
    "authors": ["Chen", "Shyh-Huei", "Ip", "Edward H"],
    "venue": "Journal of Statistical Computation and Simulation,",
    "year": 2015
  }, {
    "title": "Empirical evaluation of gated recurrent neural networks on sequence modeling",
    "authors": ["Chung", "Junyoung", "Gulcehre", "Caglar", "Cho", "KyungHyun", "Bengio", "Yoshua"],
    "venue": "arXiv preprint arXiv:1412.3555,",
    "year": 2014
  }, {
    "title": "music21: A toolkit for computer-aided musicology and symbolic music",
    "authors": ["Cuthbert", "Michael Scott", "Ariza", "Christopher"],
    "year": 2010
  }, {
    "title": "Ensuring rapid mixing and low bias for asynchronous gibbs sampling",
    "authors": ["De Sa", "Christopher", "Olukotun", "Kunle", "Ré"],
    "venue": "arXiv preprint arXiv:1602.07415,",
    "year": 2016
  }, {
    "title": "An expert system for harmonizing fourpart chorales",
    "authors": ["Ebcioglu", "Kemal"],
    "venue": "Computer Music Journal,",
    "year": 1988
  }, {
    "title": "Stochastic relaxation, gibbs distributions, and the bayesian restoration of images",
    "authors": ["Geman", "Stuart", "Donald"],
    "venue": "IEEE Transactions on pattern analysis and machine intelligence,",
    "year": 1984
  }, {
    "title": "Style imitation and chord invention in polyphonic music with exponential families",
    "authors": ["Hadjeres", "Gaëtan", "Sakellariou", "Jason", "Pachet", "François"],
    "venue": "arXiv preprint arXiv:1609.05152,",
    "year": 2016
  }, {
    "title": "Dependency networks for inference, collaborative filtering, and data visualization",
    "authors": ["Heckerman", "David", "Chickering", "David Maxwell", "Meek", "Christopher", "Rounthwaite", "Robert", "Kadie", "Carl"],
    "venue": "Journal of Machine Learning Research,",
    "year": 2000
  }, {
    "title": "Harmonet: A neural net for harmonizing chorales in the style of js bach",
    "authors": ["Hild", "Hermann", "Feulner", "Johannes", "Menzel", "Wolfram"],
    "venue": "In Advances in neural information processing systems,",
    "year": 1992
  }, {
    "title": "Long shortterm memory",
    "authors": ["Hochreiter", "Sepp", "Schmidhuber", "Jürgen"],
    "venue": "Neural computation,",
    "year": 1997
  }, {
    "title": "Reversibility and stochastic networks",
    "authors": ["Kelly", "Frank P"],
    "year": 2011
  }, {
    "title": "Statistical Mechanics: Algorithms and Computations. Oxford Master Series in Physics",
    "authors": ["W. Krauth"],
    "venue": "URL https://books.google.fr/books?id= EnabPPmmS4sC",
    "year": 2006
  }, {
    "title": "Constructing long shortterm memory based deep recurrent neural networks for large vocabulary speech recognition",
    "authors": ["Li", "Xiangang", "Wu", "Xihong"],
    "venue": "In 2015 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP),",
    "year": 2015
  }, {
    "title": "Modelling high-dimensional sequences with lstm-rtrbm: application to polyphonic music generation",
    "authors": ["Lyu", "Qi", "Wu", "Zhiyong", "Zhu", "Jun", "Meng", "Helen"],
    "venue": "In Proceedings of the 24th International Conference on Artificial Intelligence,",
    "year": 2015
  }, {
    "title": "Marc’Aurelio. Learning longer memory in recurrent neural networks",
    "authors": ["Mikolov", "Tomas", "Joulin", "Armand", "Chopra", "Sumit", "Mathieu", "Michael", "Ranzato"],
    "venue": "arXiv preprint arXiv:1412.7753,",
    "year": 2014
  }, {
    "title": "Rectified linear units improve restricted boltzmann machines",
    "authors": ["Nair", "Vinod", "Hinton", "Geoffrey E"],
    "venue": "In Proceedings of the 27th International Conference on Machine Learning",
    "year": 2010
  }, {
    "title": "Assisted Lead Sheet Composition Using FlowComposer, pp. 769–785",
    "authors": ["Papadopoulos", "Alexandre", "Roy", "Pierre", "Pachet", "François"],
    "year": 2016
  }, {
    "title": "How to Construct Deep Recurrent Neural Networks",
    "authors": ["R. Pascanu", "C. Gulcehre", "K. Cho", "Y. Bengio"],
    "venue": "ArXiv e-prints,",
    "year": 2013
  }, {
    "title": "Maximum entropy model for melodic patterns",
    "authors": ["J. Sakellariou", "F. Tria", "V. Loreto", "F. Pachet"],
    "venue": "In ICML Workshop on Constructive Machine Learning, Paris (France),",
    "year": 2015
  }, {
    "title": "Maximum entropy models capture melodic styles",
    "authors": ["J. Sakellariou", "F. Tria", "V. Loreto", "F. Pachet"],
    "venue": "ArXiv eprints,",
    "year": 2016
  }, {
    "title": "Lifting – A nonreversible Markov chain Monte Carlo Algorithm",
    "authors": ["M. Vucelja"],
    "venue": "ArXiv e-prints,",
    "year": 2014
  }, {
    "title": "Music generation from statistical models of harmony",
    "authors": ["Whorley", "Raymond P", "Conklin", "Darrell"],
    "venue": "Journal of New Music Research,",
    "year": 2016
  }],
  "id": "SP:d557fdaa39c0047ac76618d018f1dad4e94aa508",
  "authors": [{
    "name": "Gaëtan Hadjeres",
    "affiliations": []
  }, {
    "name": "François Pachet",
    "affiliations": []
  }, {
    "name": "Frank Nielsen",
    "affiliations": []
  }],
  "abstractText": "This paper introduces DeepBach, a graphical model aimed at modeling polyphonic music and specifically hymn-like pieces. We claim that, after being trained on the chorale harmonizations by Johann Sebastian Bach, our model is capable of generating highly convincing chorales in the style of Bach. DeepBach’s strength comes from the use of pseudo-Gibbs sampling coupled with an adapted representation of musical data. This is in contrast with many automatic music composition approaches which tend to compose music sequentially. Our model is also steerable in the sense that a user can constrain the generation by imposing positional constraints such as notes, rhythms or cadences in the generated score. We also provide a plugin on top of the MuseScore music editor making the interaction with DeepBach easy to use.",
  "title": "DeepBach: a Steerable Model for Bach Chorales Generation "
}