{
  "sections": [{
    "text": "√ N) (N being the total\nnumber of iterations) and it can achieve a linear speedup under certain conditions. We perform several experiments on both synthetic and real datasets. The results support our theory and show that the proposed algorithm provides a significant speedup over the recently proposed synchronous distributed L-BFGS algorithm."
  }, {
    "heading": "1. Introduction",
    "text": "Quasi-Newton (QN) methods are powerful optimization techniques that are able to attain fast convergence rates by incorporating local geometric information through an approximation of the inverse of the Hessian matrix. The L-BFGS algorithm (Nocedal & Wright, 2006) is a wellknown limited-memory QN method that aims at solving the following optimization problem:\nθ? = arg min θ∈Rd\n{ U(θ) , NY∑ i=1 Ui(θ) } , (1)\n1LTCI, Télécom ParisTech, Université Paris-Saclay, 75013, Paris, France 2Department of Computer Science, Aalto University, Espoo, 02150, Finland 3Department of Computer Engineering, Boğaziçi University, 34342, Bebek, Istanbul, Turkey. Correspondence to: Umut Şimşekli <umut.simsekli@telecomparistech.fr>.\nProceedings of the 35 th International Conference on Machine Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018 by the author(s).\nwhereU is a twice continuously differentiable function that can be convex or non-convex, and is often referred to as the empirical risk. In a typical machine learning context, a dataset Y with NY independent and identically distributed (i.i.d.) data points is considered, which renders the function U as a sum of NY different functions {Ui}NYi=1.\nIn large scale applications, the number of data points NY often becomes prohibitively large and therefore using a ‘batch’ L-BFGS algorithm becomes computationally infeasible. As a remedy, stochastic L-BGFS methods have been proposed (Byrd et al., 2016; Schraudolph et al., 2007; Moritz et al., 2016; Zhou et al., 2017; Yousefian et al., 2017; Zhao et al., 2017), which aim to reduce the computational requirements of L-BFGS by replacing ∇U (i.e. the full gradients that are required by L-BFGS) with some stochastic gradients that are computed on small subsets of the dataset. However, using stochastic gradients within LBFGS turns out to be a challenging task since it brings additional technical difficulties, which we will detail in Section 2.\nIn a very recent study, Berahas et al. (2016) proposed a parallel stochastic L-BFGS algorithm, called multi-batch L-BFGS (mb-L-BFGS), which is suitable for synchronous distributed architectures. This work illustrated that carrying out L-BFGS in a distributed setting introduces further theoretical and practical challenges; however, if these challenges are addressed, stochastic L-BFGS can be powerful in a distributed setting as well, and outperform conventional algorithms such as distributed stochastic gradient descent (SGD), as shown by their experimental results.\nDespite the fact that synchronous parallel algorithms have clear advantages over serial optimization algorithms, the computational efficiency of synchronous algorithms is often limited by the overhead induced by the synchronization and coordination among the worker processes. Inspired by asynchronous parallel stochastic optimization techniques (Agarwal & Duchi, 2011; Lian et al., 2015; Zhang et al., 2015; Zhao & Li, 2015; Zheng et al., 2017), in this study, we propose an asynchronous parallel stochastic L-BFGS algorithm for large-scale non-convex optimization problems. The proposed approach aims at speeding up the synchronous algorithm presented in (Berahas et al., 2016) by allowing all the workers work independently from each\nother and circumvent the inefficiencies caused by synchronization and coordination.\nExtending stochastic L-BFGS to asynchronous settings is a highly non-trivial task and brings several challenges. In our strategy, we first reformulate the optimization problem (1) as a sampling problem where the goal becomes drawing random samples from a distribution whose density is concentrated around θ?. We then build our algorithm upon the recent stochastic gradient Markov Chain Monte Carlo (SG-MCMC) techniques (Chen et al., 2015; 2016b) that have close connections with stochastic optimization techniques (Dalalyan, 2017; Raginsky et al., 2017; Zhang et al., 2017), and have proven successful in large-scale Bayesian machine learning. We provide formal theoretical analysis and prove non-asymptotic guarantees for the proposed algorithm. Our theoretical results show that the proposed algorithm achieves an ergodic global convergence with rate O(1/ √ N), whereN denotes the total number of iterations. Our results further imply that the algorithm can achieve a linear speedup under ideal conditions.\nFor evaluating the proposed method, we conduct several experiments on synthetic and real datasets. The experimental results support our theory: our experiments on a large-scale matrix factorization problem show that the proposed algorithm provides a significant speedup over the synchronous parallel L-BFGS algorithm."
  }, {
    "heading": "2. Technical Background",
    "text": "Preliminaries: As opposed to the classical optimization perspective, we look at the optimization problem (1) from a maximum a-posteriori (MAP) estimation point of view, where we consider θ as a random variable in Rd and θ? as the optimum of a Bayesian posterior whose density is given as p(θ|Y ) ∝ exp(−U(θ)), where Y ≡ {Y1, . . . , YNY } is a set of i.i.d. observed data points. Within this context, U(θ) is often called the potential energy and defined as U(θ) = −[log p(θ) + ∑NY i=1 log p(Yi|θ)], where p(Yi|θ) is the likelihood function and p(θ) is the prior density. In a classical optimization context, − log p(Yi|θ) would correspond to the data-loss and− log p(θ) would correspond to a regularization term. Throughout this study, we will assume that the problem (1) has a unique solution in Rd.\nWe define a stochastic gradient ∇Ũ(θ), that is an unbiased estimator of ∇U , as follows: ∇Ũ(θ) = −[∇ log p(θ) + NY NΩ ∑ i∈Ω∇ log p(Yi|θ)], where Ω ⊂ {1, . . . , NY } denotes a random data subsample that is drawn with replacement, NΩ = |Ω| is the cardinality of Ω. In the sequel, we will occasionally use the notation∇Ũn and∇ŨΩ to denote the stochastic gradient computed at iteration n of a given algorithm, or on a specific data subsample Ω, respectively.\nThe L-BFGS algorithm: The L-BFGS algorithm itera-\ntively applies the following equation in order to find the MAP estimate given in (1):\nθn = θn−1 − hHn∇U(θn−1) (2)\nwhere n denotes the iterations. Here, Hn is an approximation to the inverse Hessian at θn−1 and is computed by using the M past values of the ‘iterate differences’ sn , θn − θn−1, and ‘gradient differences’ yn , ∇U(θn) − ∇U(θn−1). The collection of the iterate and gradient differences is called the L-BFGS memory. The matrix-vector product Hn∇U(θn−1) is often implemented by using the two-loop recursion (Nocedal & Wright, 2006), which has linear time and space complexities O(Md).\nIn order to achieve computational scalability, stochastic LBFGS algorithms replace ∇U with ∇Ũ . This turns out to be problematic, since the gradient differences yn would be inconsistent, meaning that the stochastic gradients in different iterations will be computed on different data subsamples, i.e. Ωn−1 and Ωn. On the other hand, in the presence of the stochastic gradients, L-BFGS is no longer guaranteed to produce positive definite approximations even in convex problems, therefore more considerations should be taken in order to make sure that Hn is positive definite.\nStochastic Gradient Markov Chain Monte Carlo: Along with the recent advances in MCMC techniques, diffusion-based algorithms have become increasingly popular due to their applicability in large-scale machine learning applications. These techniques, so called the Stochastic Gradient MCMC (SG-MCMC) algorithms, aim at generating samples from the posterior distribution p(θ|Y ) as opposed to finding the MAP estimate, and have strong connections with stochastic optimization techniques (Dalalyan, 2017). In this line of work, Stochastic Gradient Langevin Dynamics (SGLD) (Welling & Teh, 2011) is one of the pioneering algorithms and generates an approximate sample θn from p(θ|Y ) by iteratively applying the following update equation:\nθn = θn−1 − h∇Ũn(θn−1) + √ 2h/βZn (3)\nwhere h is the step-size and {Zn}Nn=1 is a collection of standard Gaussian random variables in Rd. Here, β is called the inverse temperature: it is fixed to β = 1 in vanilla SGLD and when β 6= 1 the algorithm is called ‘tempered’. In an algorithmic sense, SGLD is identical to SGD, except that it injects a Gaussian noise at each iteration and it coincides with SGD when β goes to infinity.\nSGLD has been extended in several directions (Ma et al., 2015; Chen et al., 2015; Şimşekli et al., 2016b; Şimşekli, 2017). In (Şimşekli et al., 2016a), we proposed an LBFGS-based SGLD algorithm with O(M2d) computational complexity, which aimed to improve the convergence\nspeed of the vanilla SGLD. We showed that a straightforward way of combining L-BFGS in SGLD would incur an undesired bias; however, the remedy to prevent this bias resulted in numerical instability, which would limit the applicability of the algorithm. In other recent studies, SGLD has also been extended to synchronous (Ahn et al., 2014) and asynchronous (Chen et al., 2016b; Springenberg et al., 2016) distributed MCMC settings.\nSGLD can be seen as a discrete-time simulation of a continuous-time Markov process that is the solution of the following stochastic differential equation (SDE):\ndθt = −∇U(θt)dt+ √ 2/βdWt, (4)\nwhere Wt denotes the standard Brownian motion in Rd. Under mild regularity conditions on U , the solution process (θt)t≥0 attains a unique stationary distribution with a density that is proportional to exp(−βU(θ)) (Roberts & Stramer, 2002). An important property of this distribution is that, as β goes to infinity, this density concentrates around the global minimum of U(θ) (Hwang, 1980; Gelfand & Mitter, 1991). Therefore, for large enough β, a random sample that is drawn for the stationary distribution of (θt)t≥0 would be close to θ?. Due to this property, SG-MCMC methods have recently started drawing attention from the non-convex optimization community. Chen et al. (2016a) developed an annealed SG-MCMC algorithm for non-convex optimization and it was recently extended by Ye et al. (2017). Raginsky et al. (2017) and Xu et al. (2017) provided finite-time guarantees for SGLD to find an ‘approximate’ global minimizer that is close to θ?, which imply that the additive Gaussian noise in SGLD can help the algorithm escape from poor local minima. In a complementary study, Zhang et al. (2017) showed that SGLD enters a neighborhood of a local minimum of U(θ) in polynomial time, which shows that even if SGLD fails to find the global optimum, it will still find a point that is close to one of the local optima. Even though these results showed that SG-MCMC is promising for optimization, it is still not clear how an asynchronous stochastic L-BFGS method could be developed within an SG-MCMC framework."
  }, {
    "heading": "3. Asynchronous Stochastic L-BFGS",
    "text": "In this section, we propose a novel asynchronous L-BFGSbased (tempered) SG-MCMC algorithm that aims to provide an approximate optimum that is close to θ? by generating samples from a distribution that has a density that is proportional to exp(−βU(θ)). We call the proposed algorithm asynchronous parallel stochastic L-BFGS (as-LBFGS). Our method is suitable for both distributed and shared-memory settings. We will describe the algorithm only for the distributed setting; the shared-memory version is almost identical to the distributed version as long as the\nupdates are ensured to be atomic.\nWe consider a classical asynchronous optimization architecture, which is composed of a master node, several worker nodes, and a data server. The main task of the master node is to maintain the newest iterate of the algorithm. At each iteration, the master node receives an additive update vector from a worker node, it adds this vector to the current iterate in order to obtain the next iterate, and then it sends the new iterate to the worker node which has sent the update vector. On the other hand, the worker nodes work in a completely asynchronous manner. A worker node receives the iterate from the master node, computes an update vector, and sends the update vector to the master node. However, since the iterate would be possibly modified by another worker node which runs asynchronously in the mean time, the update vector that is sent to the server will thus be computed on an old iterate, which causes both practical and theoretical challenges. Such updates are aptly called ‘delayed’ or ‘stale’. The full data is kept in the data server and we assume that all the workers have access to the data server.\nThe proposed algorithm iteratively applies the following update equations in the master node:\nun+1 = un + ∆un+1, θn+1 = θn + ∆θn+1, (5)\nwhere n is the iteration index, un is called the momentum variable, and ∆un+1 and ∆θn+1 are the update vectors that are computed by the worker nodes. A worker node runs the following equations in order to compute the update vectors:\n∆un+1 ,− h′Hn+1(θn−ln)∇Ũn+1(θn−ln)− γ′un−ln + √ 2h′γ′/βZn+1, (6)\n∆θn+1 ,Hn+1(θn−ln)un−ln , (7)\nwhere h′ is the step-size, γ′ > 0 is the friction parameter that determines the weight of the momentum, β is the inverse temperature, {Zn}n denotes standard Gaussian random variables, and Hn denotes the L-BFGS matrix at iteration n. Here, ln ≥ 0 denotes the ‘staleness’ of a particular update and measures the delay between the current update and the up-to-date iterate that is stored in the master node. We assume that the delays are bounded, i.e. maxn ln ≤ lmax < ∞. Note that the matrix-vector products have O(Md) time-space complexity.\nDue to the asynchrony, the stochastic gradients and the L-BFGS matrices will be computed on the delayed variables θn−ln and un−ln . As opposed to the asynchronous stochastic gradient algorithms, where the main difficulty stems from the delayed gradients, our algorithm faces further challenges since it is not straightforward to obtain the gradient and iterate differences that are required for the LBFGS computations in an asynchronously parallel setting.\nAlgorithm 1: as-L-BFGS: Master node 1 input: θ0, u0 // Global iteration index 2 n← 0 3 Send (θ0, u0) to all the workers w = 1, . . . ,W 4 while n < N do 5 Receive (∆θn+1,∆un+1) from worker w\n// Generate the new iterates\n6 un+1 = un + ∆un+1, θn+1 = θn + ∆θn+1 7 Send the iterates (θn+1, un+1) to worker w 8 Set n← n+ 1\nWe propose the following approach for the computation of the L-BFGS matrices. As opposed to the mb-L-BFGS algorithm, which uses a central L-BFGS memory (i.e. the collection of the gradient and iterate differences) that is stored in the master node, we let each worker have their own local L-BFGS memories since the master node would not be able to keep track of the gradient and iterate differences, which are received in an asynchronous manner. In our strategy, each worker updates its own L-BFGS memory right after sending the update vector to the master node. The overall algorithm is illustrated in Algorithms 1 and 2 (W denotes the number of workers).\nIn order to be able to have consistent gradient differences, each worker applies a multi-batch subsampling strategy that is similar to mb-L-BFGS. We divide the data subsample into two subsets, i.e. Ωn = {Sn, On} with NS , |Sn|, NO , |On|, and NΩ = NS +NO. Here the main idea is to chooseNS NO and useOn as an overlapping subset for the gradient differences. In this manner, in addition to the gradients that are computed on Sn andOn, we also perform an extra gradient computation on the previous overlapping subset, at the end of each iteration. As NO will be small, this extra cost will not be significant. Finally, in order to ensure the L-BFGS matrices are positive definite, we use a ‘cautious’ update mechanism that is useful for non-convex settings (Li & Fukushima, 2001; Zhang & Sutton, 2011; Berahas et al., 2016) as shown in Algorithm 2.\nNote that, in addition to asynchrony, the proposed algorithm also extends the current stochastic L-BFGS methods by introducing momentum. This brings two critical practical features: (i) without the existence of the momentum variables, the injected Gaussian noise must depend on the L-BFGS matrices, as shown in (Şimşekli et al., 2016a), which results in an algorithm withO(M2d) time complexity whereas our algorithm hasO(Md) time complexity, (ii) the use of the momentum significantly repairs the numerical instabilities caused by the asynchronous updates, since un inherently encapsulates a direction for θn, which provides additional information to the algorithm besides the gradients and L-BFGS computations. Furthermore, in a\nAlgorithm 2: as-L-BFGS: Worker node (w) 1 input: M , γ, NS , NO (NΩ = NS +NO) // Local iteration index 2 i← 0 3 while the master node is running do 4 Receive (θn−ln , un−ln) from the master 5 Draw a subsample Ωn+1 = {Sn+1, On+1}\n// Gradient computation\n6 ∇Ũn+1(θn−ln) = NO NΩ ∇ŨOn+1(θn−ln) + NSNΩ∇ŨSn+1(θn−ln)\n7 Compute (∆θn+1,∆un+1) by (6) and (7) 8 Send (∆θn+1,∆un+1) to the master\n// Local variables for L-BFGS\n9 θ̃i = θn−ln , Õi = On+1, g̃i = ∇ŨOn+1(θn−ln) 10 if i ≥ 1 then\n// Compute the overlapping gradient\n11 g′ = ∇ŨÕi−1(θ̃i) // Compute the L-BFGS variables 12 si = θ̃i − θ̃i−1, yi = g′ − g̃i−1 // Cautious memory update 13 Add (si, yi) to the L-BFGS memory only if y>i si ≥ ‖si‖2 for some > 0 14 Set i← i+ 1\nvery recent study (Loizou & Richtárik, 2017) the use of momentum variables has been shown to be useful in other second-order optimization methods. On the other hand, despite their advantages, the momentum variable also drifts apart the proposed algorithm from the original L-BFGS formulation. However, even such approximate approaches have proven useful in various scenarios (Zhang & Sutton, 2011; Fu et al., 2016). Also note that, when β → ∞, lmax = 0, and Hn(θ) = I for all n, the algorithm coincides with SGD with momentum. A more detailed illustration is given in the supplementary document."
  }, {
    "heading": "4. Theoretical Analysis",
    "text": "In this section, we will provide non-asymptotic guarantees for the proposed algorithm. Our analysis strategy is different from the conventional analysis approaches for stochastic optimization and makes use of tools from analysis of SDEs. In particular, we will first develop a continuoustime Markov process whose marginal stationary measure admits a density that is proportional to exp(−βU(θ)). Then we will show that (5)-(7) form an approximate EulerMaruyama integrator that approximately simulates this continuous process in discrete-time. Finally, we will analyze this approximate numerical scheme and provide a non-asymptotic error bound. All the proofs are given in the supplementary document.\nWe start by considering the following stochastic dynamical system:\ndpt= [ 1 β Γt(θt)−Ht(θt)∇θU(θt)− γpt ] dt+ √ 2γ β dWt\ndθt =Ht(θt)ptdt (8)\nwhere pt ∈ Rd is also called the momentum variable,Ht(·) denotes the L-BFGS matrix at time t and Γt(·) is a vector that is defined as follows:[\nΓt(θ) ] i , d∑ j=1 ∂[Ht(θ)]ij ∂[θ]j , (9)\nwhere [v]i denotes the ith component of a vector v and similarly [M ]ij denotes a single element of a matrix M .\nIn order to analyze the invariant measure of the SDE defined in (8), we need certain conditions to hold. First, we have two regularity assumptions on U and Ht:\nH1. The gradient of the potential is Lipschitz continuous, i.e. ‖∇θU(θ)−∇θU(θ′)‖ ≤ L‖θ − θ′‖, ∀θ, θ′ ∈ Rd. H 2. The L-BFGS matrices have bounded second-order derivatives and they are Lipschitz continuous, i.e. ‖Ht(θ)− Ht(θ ′)‖ ≤ LH‖θ − θ′‖, ∀θ, θ′ ∈ Rd, t ≥ 0.\nThe assumptions H1 and H2 are standard conditions in analysis of SDEs (Duan, 2015) and similar assumptions have also been considered in stochastic gradient (Moulines & Bach, 2011) and stochastic L-BFGS algorithms (Zhou et al., 2017). Besides, H2 provides a direct control on the partial derivatives of Ht, which will be useful for analyzing the overall numerical scheme. We now present our first result that establishes the invariant measure of the SDE (8).\nProposition 1. Assume that the conditions H1 and 2 hold. Let Xt = [θ>t , p > t ] > ∈ R2d and (Xt)t≥0 be a Markov process that is a solution of the SDE given in (8). Then (Xt)t≥0 has a unique invariant measure π that admits a density ρ(X) ∝ exp(−E(X)) with respect to the Lebesgue measure, where E is an energy function on the extended state space and is defined as: E(X) , βU(θ) + β2 p >p.\nThis result shows that, if the SDE (8) could be exactly simulated, the marginal distribution of the samples θt would converge to a measure πθ which has a density that is proportional to exp(−βU(θ)). Therefore, for large enough β and t, θt would be close to the global optimum θ?.\nWe note that when β = 1, the SDE (8) shares similarities with the SDEs presented in (Fu et al., 2016; Ma et al., 2015). While the main difference being the usage of the tempering scheme, (Fu et al., 2016) further differs from our approach as it directly discard the term Γt since is in a Metropolis-Hastings framework, which is not adequate for large-scale applications. On the other hand, the stochastic\ngradient Riemannian Hamiltonian Monte Carlo algorithm given in (Ma et al., 2015), chooses Ht as the Fisher information matrix; a quantity that requires O(d2) space-time complexity and is not analytically available in general.\nWe will now show that the proposed algorithm (5)-(7) form an approximate method for simulating (8) in discrete-time. For illustration, we first consider the Euler-Maruyama integrator for (8), given as follows:\npn+1 = pn − hHn(θn)∇θU(θn)− hγpn + h\nβ Γn(θn) + √\n2hγ/βZn+1, (10) θn+1 = θn + hHn(θn)pn. (11)\nHere, the term (1/β)Γn introduces an additional computational burden and its importance is very insignificant (i.e. its magnitude is of order O(1/β) due to H2). Therefore, we discard Γn, define un , hpn, γ′ , hγ, h′ , h2, and use these quantities in (10) and (11). We then obtain the following re-parametrized Euler integrator:\nun+1=un−h′Hn(θn)∇θU(θn)−γ′un+ √ 2h′γ′/βZn+1\nθn+1=θn+Hn(θn)un\nThe detailed derivation is given in the supplementary document. Finally, we replace∇U with the stochastic gradients, replace the variables θn and un with stale variables θn−ln and pn−ln in the update vectors, and obtain the ultimate update equations, given in (5). Note that, due to the negligence of Γn, the proposed approach would require a large β and would not be suitable for classical posterior sampling settings, where β = 1.\nIn this section, we will analyze the ergodic error E[ÛN − U?], where we define ÛN , (1/N) ∑N n=1 U(θn) and U? , U(θ?). This error resembles the bias of a statistical estimator; however, as opposed to the bias, it directly measures the expected discrepancy to the global optimum. Similar ergodic error notions have been considered in the analysis of non-convex optimization methods (Lian et al., 2015; Chen et al., 2016a; Berahas et al., 2016).\nIn our proof strategy, we decompose the error into two terms: E[ÛN −U?] = A1 +A2, whereA1 , E[ÛN − Ūβ ] A2 , [Ūβ−U?] ≥ 0, and Ūβ , ∫ Rd U(θ)πθ(dθ). We then upper-bound these terms separately.\nThe term A1 turns out to be the bias of a statistical estimator, which we can analyze by using ideas from recent SGMCMC studies. However, existing tools cannot be directly used because of the additional difficulties introduced by the L-BFGS matrices. In order to bound A1, we first require the following smoothness and boundedness condition.\nH3. Let ψ be a functional that is the unique solution of a\nPoisson equation that is defined as follows:\nLnψ(Xn) = U(θn)− Ūβ , (12)\nwhere Xn = [θ>n , p > n ] >, Ln is the generator of (8) at t = nh and is formally defined in the supplementary document. The functional ψ and its up to third-order derivatives Dkψ are bounded by a function V (X), such that ‖Dkψ‖ ≤ CkV rk for k = 0, 1, 2, 3 and Ck, rk > 0. Furthermore, supnEV\nr(Xn) <∞ and V is smooth such that sups∈(0,1) V\nr(sX + (1 − s)X ′) ≤ C(V r(X) + V r(X ′)) for all X,X ′ ∈ R2d, r ≤ max 2rk, and C > 0.\nAssumption H3 is also standard in SDE analysis and SGMCMC (Mattingly et al., 2010; Teh et al., 2016; Chen et al., 2015; Durmus et al., 2016) and gives us control over the weak error of the numerical integrator. We further require the following regularity conditions in order to have control over the error induced by the delayed stochastic gradients. H4. The variance of the stochastic gradients is bounded, i.e. E‖∇θU(θ)−∇θŨ(θ)‖2 ≤ σ for some 0 < σ <∞. H5. For a smooth and bounded function f , the remainder rLn,f (·) in the following Taylor expansion is bounded:\nehLnf(X) = f(X) + hLnf(X) + h2rLn,f (X). (13)\nThe following lemma presents an upper-bound for A1. Lemma 1. Assume the conditions H1-5 hold. We have the following bound for the bias:∣∣E[ÛN − Ūβ ]∣∣ = O( 1\nNh + max(lmax, 1)h+\n1\nβ\n) . (14)\nHere, the term 1/β in (14) appears due to the negligence of Γn. In order to bound the second term A2, we follow a similar strategy to (Raginsky et al., 2017), where we use H 1 and the following moment condition on πθ. H6. The second-order moments of πθ are bounded and satisfies the following inequality: ∫ Rd ‖θ‖2πθ(dθ) ≤ Cββ , for some Cβ > max(βd/(2πe), de/L).\nThis assumption is mild since πθ concentrates around θ? as β tends to infinity. The order 1/β is arbitrary, hence the assumption can be further relaxed. The following lemma establishes an upper-bound for A2. Lemma 2. Under assumptions H1 and 6, the following bound holds: Ūβ − U? = O(1/β).\nWe now present our main result, which can be easily proven by combining Lemmas 1 and 2. Theorem 1. Assume that the conditions H1-6 hold. Then the ergodic error of the proposed algorithm is bounded as follows:∣∣EÛN − U?∣∣ = O( 1\nNh + max(1, lmax)h+\n1\nβ\n) . (15)\nMore explicit constants and a discussion on the relation of the theorem to other recent theoretical results are provided in the supplementary document.\nTheorem 1 provides a non-asymptotic guarantee for convergence to a point that is close to the global optimizer θ? even when U is non-convex, thanks to the additive Gaussian noise. The bound suggests an optimal rate of convergence of O(1/ √ N), which is in line with the current rates of the non-convex asynchronous algorithms (Lian et al., 2015). Furthermore, if we assume that the total number of iterations N is a linear function of the number of workers, e.g. N = NWW , where NW is the number of iterations executed by a single worker, Theorem 1 implies that, in the ideal case, the proposed algorithm can achieve a linear speedup with increasing W , provided that lmax = O(1/(Nh2)).\nDespite their nice theoretical properties, it is well-known that tempered sampling approaches also often get stuck near a local minimum. In our case, this behavior would be mainly due to the hidden constant in (14), which can be exponential in dimension d, as illustrated in (Raginsky et al., 2017) for SGLD. On the other hand, Theorem 1 does not guarantee that the proposed algorithm will converge to a neighborhood of a local minimum; however, we believe that we can also prove local convergence guarantees by using the techniques provided in (Zhang et al., 2017; Tzen et al., 2018), which we leave as a future work."
  }, {
    "heading": "5. Experiments",
    "text": "The performance of asynchronous stochastic gradient methods has been evaluated in several studies, where the advantages and limitations have been illustrated in various scenarios, to name a few (Dean et al., 2012; Zhang et al., 2015; Zheng et al., 2017). In this study, we will explore the advantages of using L-BFGS in an asynchronous environment. In order to illustrate the advantages of asynchrony, we will compare as-L-BFGS with mb-L-BFGS (Berahas et al., 2016); and in order to illustrate the advantages that are brought by using higher-order geometric information, we will compare as-L-BFGS to asynchronous SGD (aSGD) (Lian et al., 2015). We will also explore the speedup behavior of as-L-BFGS for increasing W .\nWe conduct experiments on both synthetic and real\ndatasets. For real data experiments, we have implemented all the three algorithms in C++ by using a low-level message passing protocol for parallelism, namely the OpenMPI library. This code can be used both in a distributed environment or a single computer with multiprocessors. For the experiments on synthetic data, we have implemented the algorithms in MATLAB, by developing a realistic discreteevent simulator. This simulated environment is particularly useful for understanding the behaviors of the algorithms in detail since we can explicitly control the computation time that is spent at the master or worker nodes, and the communication time between the nodes. This simulation strategy also enables us to explicitly control the variation among the computational powers of the worker nodes; a feature that is much harder to control in real distributed environments.\nLinear Gaussian model: We conduct our first set of experiments on synthetic data where we consider a rather simple convex quadratic problem whose optimum is analytically available. The problem is formulated as finding the MAP estimate of the following linear Gaussian probabilistic model:\nθ ∼ N (0, I), Yi|θ ∼ N (a>i θ, σ2x), ∀i = 1, . . . , NY .\nWe assume that {an}Nn=1 and σ2x are known and we aim at computing θ?. For these experiments, we develop a parametric discrete event simulator that aims to simulate the algorithms in a controllable yet realistic way. The simulator simulates a distributed optimization algorithm once it is provided four parameters: (i) µm: the average computational time spent by the master node at each iteration, (ii) µw: the average computational time spent by a single worker at each iteration, (iii) σw: the standard deviation of the computational time spent by a single worker per iteration, and (iv) τ : the time spent for communications per iteration. All these parameters are in a generic base time unit. Once these parameters are provided for one of the three algorithms, the simulator simulates the (a)synchronous distributed algorithm by drawing random computation times from a log-normal distribution whose mean and variance is specified by µw and σ2w. Figure 1 illustrates a typical outcome of the real and the simulated implementations of as-L-BFGS, where we observe that the simulator is able to provide realistic simulations that can even very well reflect\nthe fluctuations of the algorithm.\nIn our first experiment, we set d = 100, σ2x = 10, NY = 600, we randomly generate and fix the vectors {an}n in such a way that there will be a strong correlation in the posterior distribution, and we finally generate a true θ and the observations Y by using the generative model.\nFor each algorithm, we fix µm, µs, and τs to realistic values and investigate the effect of the variation among the workers by comparing the running time of the algorithms for achieving ε-accuracy (i.e., (U(θn) − U?)/U? ≤ ε) for different values of σ2w when W = 40. We repeat each experiment 100 times. In all our experiments, we have tried several values for the hyper-parameters of each algorithm and we report the best results. All the hyper-parameters are provided in the supplementary document.\nFigure 2 visualizes the results for the first experiment. We can observe that, for smaller values σ2w as-L-BFGS and mbL-BFGS perform similarly, where a-SGD requires more computational time to achieve ε-accuracy. However, as we increase the value of σ2w, mb-L-BFGS requires more computational time in order to be able to collect sufficient amount of stochastic gradients. The results show that both asynchronous algorithms turn out to be more robust to the variability of the computational power of the workers, where as-L-BFGS shows a better performance.\nIn our second experiment, we investigate the speedup behavior of as-L-BFGS within the simulated setting. In this setting, we consider a highly varying set of workers and set σ2w = 200 and vary the number of workers W . As illustrated in Figure 3, as W increases, lmax increases as well and the algorithm hence requires more iterations in order to achieve ε-accuracy, since a smaller step-size needs to be used. However, this increment in the number of iterations is compensated by the increased number of workers, as we observe that the required computational time gracefully decreases with increasing W . We observe a similar behavior for different values of σ2w, where the speedup is more prominent for smaller σ2w.\nLarge-scale matrix factorization: In our next set of experiments, we consider a large-scale matrix factorization problem (Gemulla et al., 2011; Şimşekli et al., 2015; Şimşekli et al., 2017), where the goal is to obtain the\nMAP solution of the following probabilistic model: Frk ∼ N (0, 1), Gks ∼ N (0, 1), Yrs|F,G ∼ N (∑ k FrkGks, 1 ) . Here, Y ∈ RR×S is the data matrix, and F ∈ RR×K and G ∈ RK×S are the factor matrices to be estimated.\nIn this context, we evaluate the algorithms on three largescale movie ratings datasets, namely MovieLens 1Million (ML-1M), 10Million (ML-10M), and 20Million (ML20M) (grouplens.org). The ML-1M dataset contains 1 million non-zero entries, where R = 3883 (movies) and S = 6040 (users). The ML-10M dataset contains 10 million non-zero entries, resulting in a 10681 × 71567 data matrix. Finally, the ML-20M dataset contains 20 million ratings, resulting in a 27278 × 138493 data matrix. We have conducted these experiments on a cluster of more than 500 interconnected computers, each of which is equipped with variable quality CPUs and memories. In these experiments, we have found that the numerical stability is improved when Hn is replaced with (Hn + ρI) for small ρ > 0. This small modification does not violate our theoretical results. The hyper-parameters are provided in the supplementary document.\nFigure 4 shows the performance of the three algorithms on the MovieLens datasets in terms of the root-mean-squarederror (RMSE), which is a standard metric for recommendation systems, and the norm of the gradients through iterations. In these experiments, we set K = 5 for all the three datasets and we set the number of workers toW = 10. The results show that, in all datasets, as-L-BFGS provides a significant speedup over mb-L-BFGS thanks to asynchrony. We can observe that even when the speed of convergence of mb-L-BFGS is comparable to a-SGD and as-L-BFGS (cf. the plots showing the norm of the gradients), the final RMSE yielded by mb-L-BFGS is poorer than the two other\nmethods, which is an indicator that the asynchronous algorithms are able to find a better local minimum. On the other hand, the asynchrony causes more fluctuations in asL-BFGS when compared to a-SGD.\nAs opposed to the synthetic data experiments, in all the three MovieLens datasets, we observe that as-L-BFGS provides a slight improvement in the convergence speed when compared to a-SGD. This indicates that a-SGD is able to achieve a comparable convergence speed by taking more steps while as-L-BFGS is computing the matrix-vector products. However, this gap can be made larger by considering a more efficient, yet more sophisticated implementation for L-BFGS computations (Chen et al., 2014).\nIn our last experiment, we investigate the speedup properties of as-L-BFGS in the real distributed setting. In this experiment, we only consider the ML-1M dataset and run the as-L-BFGS algorithm for different number of workers. Figure 5 illustrates the results of this experiment. As we increase W from 1 to 10, we obtain a decent speedup that is close to a linear speedup. However, when we set W = 20 the algorithm becomes unstable, since the term lmaxh in (15) dominates. Therefore, for W = 20 we need to decrease the step-size h, which requires the algorithm to be run for a longer amount of time in order to achieve the same error as we achieved when W was smaller. On the other hand, the algorithm achieves a linear speedup in terms of iterations; however, the corresponding result is provided in the supplementary document due to the space constraints."
  }, {
    "heading": "6. Conclusion",
    "text": "In this study, we proposed an asynchronous parallel L-BFGS algorithm for non-convex optimization. We developed the algorithm within the SG-MCMC framework, where we reformulated the problem as sampling from a concentrated probability distribution. We proved non-asymptotic guarantees and showed that as-LBFGS achieves an ergodic global convergence with rate O(1/ √ N) and it can achieve a linear speedup. Our experiments supported our theory and showed that the proposed algorithm provides a significant speedup over the synchronous parallel L-BFGS algorithm."
  }, {
    "heading": "Acknowledgments",
    "text": "The authors would like to thank to Murat A. Erdoğdu for fruitful discussions. This work is partly supported by the French National Research Agency (ANR) as a part of the FBIMATRIX project (ANR-16-CE23-0014), by the Scientific and Technological Research Council of Turkey (TÜBİTAK) grant number 116E580, and by the industrial chair Machine Learning for Big Data from Télécom ParisTech."
  }],
  "year": 2018,
  "references": [{
    "title": "Distributed delayed stochastic optimization",
    "authors": ["A. Agarwal", "J.C. Duchi"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2011
  }, {
    "title": "Distributed stochastic gradient MCMC",
    "authors": ["S. Ahn", "B. Shahbaba", "M. Welling"],
    "venue": "In International conference on machine learning,",
    "year": 2014
  }, {
    "title": "A multi-batch L-BFGS method for machine learning",
    "authors": ["A.S. Berahas", "J. Nocedal", "M. Takác"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2016
  }, {
    "title": "A stochastic quasi-Newton method for large-scale optimization",
    "authors": ["R.H. Byrd", "S.L. Hansen", "J. Nocedal", "Y. Singer"],
    "venue": "SIAM Journal on Optimization,",
    "year": 2016
  }, {
    "title": "On the convergence of stochastic gradient MCMC algorithms with high-order integrators",
    "authors": ["C. Chen", "N. Ding", "L. Carin"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2015
  }, {
    "title": "Bridging the gap between stochastic gradient MCMC and stochastic optimization",
    "authors": ["C. Chen", "D. Carlson", "Z. Gan", "C. Li", "L. Carin"],
    "venue": "In AISTATS,",
    "year": 2016
  }, {
    "title": "Stochastic gradient MCMC with stale gradients",
    "authors": ["C. Chen", "N. Ding", "C. Li", "Y. Zhang", "L. Carin"],
    "venue": "In Advances In Neural Information Processing Systems,",
    "year": 2016
  }, {
    "title": "Large-scale L-BFGS using MapReduce",
    "authors": ["W. Chen", "Z. Wang", "J. Zhou"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2014
  }, {
    "title": "Stochastic quasi-Newton Langevin Monte Carlo",
    "authors": ["U. Şimşekli", "R. Badeau", "A.T. Cemgil", "G. Richard"],
    "venue": "In ICML,",
    "year": 2016
  }, {
    "title": "Stochastic thermodynamic integration: efficient Bayesian model selection via stochastic gradient MCMC",
    "authors": ["U. Şimşekli", "R. Badeau", "G. Richard", "A.T. Cemgil"],
    "venue": "In ICASSP,",
    "year": 2016
  }, {
    "title": "Parallelized stochastic gradient Markov Chain Monte Carlo algorithms for non-negative matrix factorization",
    "authors": ["U. Şimşekli", "A. Durmus", "R. Badeau", "G. Richard", "E. Moulines", "A.T. Cemgil"],
    "year": 2017
  }, {
    "title": "Further and stronger analogy between sampling and optimization: Langevin Monte Carlo and gradient descent",
    "authors": ["A.S. Dalalyan"],
    "venue": "Proceedings of the 2017 Conference on Learning",
    "year": 2017
  }, {
    "title": "Large scale distributed deep networks",
    "authors": ["J. Dean", "G. Corrado", "R. Monga", "K. Chen", "M. Devin", "M. Mao", "A. Senior", "P. Tucker", "K. Yang", "A.Y. Ng"],
    "venue": "In Advances in neural information processing systems,",
    "year": 2012
  }, {
    "title": "An Introduction to Stochastic Dynamics",
    "authors": ["J. Duan"],
    "year": 2015
  }, {
    "title": "Stochastic gradient Richardson-Romberg Markov Chain Monte Carlo",
    "authors": ["A. Durmus", "U. Şimşekli", "E. Moulines", "R. Badeau", "G. Richard"],
    "venue": "In NIPS,",
    "year": 2016
  }, {
    "title": "Quasi-Newton Hamiltonian Monte Carlo",
    "authors": ["T. Fu", "L. Luo", "Z. Zhang"],
    "venue": "In UAI,",
    "year": 2016
  }, {
    "title": "Recursive stochastic algorithms for global optimization in Rˆd",
    "authors": ["S.B. Gelfand", "S.K. Mitter"],
    "venue": "SIAM Journal on Control and Optimization,",
    "year": 1991
  }, {
    "title": "Largescale matrix factorization with distributed stochastic gradient descent",
    "authors": ["R. Gemulla", "E. Nijkamp", "H.P. J", "Y. Sismanis"],
    "venue": "In ACM SIGKDD,",
    "year": 2011
  }, {
    "title": "Laplace’s method revisited: weak convergence of probability measures",
    "authors": ["C. Hwang"],
    "venue": "The Annals of Probability,",
    "year": 1980
  }, {
    "title": "On the global convergence of the BFGS method for nonconvex unconstrained optimization problems",
    "authors": ["Li", "D.-H", "M. Fukushima"],
    "venue": "SIAM Journal on Optimization,",
    "year": 2001
  }, {
    "title": "Asynchronous parallel stochastic gradient for nonconvex optimization",
    "authors": ["X. Lian", "Y. Huang", "Y. Li", "J. Liu"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2015
  }, {
    "title": "Momentum and stochastic momentum for stochastic gradient, Newton, proximal point and subspace descent methods",
    "authors": ["N. Loizou", "P. Richtárik"],
    "venue": "arXiv preprint arXiv:1712.09677,",
    "year": 2017
  }, {
    "title": "A complete recipe for stochastic gradient MCMC",
    "authors": ["Y.A. Ma", "T. Chen", "E. Fox"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2015
  }, {
    "title": "Convergence of numerical time-averaging and stationary measures via Poisson equations",
    "authors": ["J.C. Mattingly", "A.M. Stuart", "M.V. Tretyakov"],
    "venue": "SIAM Journal on Numerical Analysis,",
    "year": 2010
  }, {
    "title": "A linearlyconvergent stochastic L-BFGS algorithm",
    "authors": ["P. Moritz", "R. Nishihara", "M. Jordan"],
    "venue": "In Artificial Intelligence and Statistics,",
    "year": 2016
  }, {
    "title": "Non-asymptotic analysis of stochastic approximation algorithms for machine learning",
    "authors": ["E. Moulines", "F.R. Bach"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2011
  }, {
    "title": "Non-convex learning via stochastic gradient Langevin dynamics: a nonasymptotic analysis",
    "authors": ["M. Raginsky", "A. Rakhlin", "M. Telgarsky"],
    "venue": "In Proceedings of the 2017 Conference on Learning Theory,",
    "year": 2017
  }, {
    "title": "Langevin Diffusions and Metropolis-Hastings Algorithms",
    "authors": ["G.O. Roberts", "O. Stramer"],
    "venue": "Methodology and Computing in Applied Probability,",
    "year": 2002
  }, {
    "title": "A stochastic quasi-Newton method for online convex optimization",
    "authors": ["N.N. Schraudolph", "J. Yu", "S. Günter"],
    "venue": "In Artificial Intelligence and Statistics,",
    "year": 2007
  }, {
    "title": "Fractional Langevin Monte carlo: Exploring Levy driven stochastic differential equations for Markov chain Monte Carlo",
    "authors": ["U. Şimşekli"],
    "venue": "In ICML,",
    "year": 2017
  }, {
    "title": "Parallel stochastic gradient Markov Chain Monte Carlo for matrix factorisation models",
    "authors": ["U. Şimşekli", "H. Koptagel", "H. Güldaş", "A.T. Cemgil", "F. Öztoprak", "Ş.İ. Birbil"],
    "venue": "arXiv preprint arXiv:1506.01418,",
    "year": 2015
  }, {
    "title": "Asynchronous stochastic gradient MCMC with elastic coupling",
    "authors": ["J.T. Springenberg", "A. Klein", "S. Falkner", "F. Hutter"],
    "venue": "arXiv preprint arXiv:1612.00767,",
    "year": 2016
  }, {
    "title": "Consistency and fluctuations for stochastic gradient Langevin dynamics",
    "authors": ["Y.W. Teh", "A.H. Thiery", "S.J. Vollmer"],
    "venue": "Journal of Machine Learning Research,",
    "year": 2016
  }, {
    "title": "Local optimality and generalization guarantees for the langevin algorithm via empirical metastability",
    "authors": ["B. Tzen", "T. Liang", "M. Raginsky"],
    "venue": "In Proceedings of the 2018 Conference on Learning",
    "year": 2018
  }, {
    "title": "Bayesian learning via stochastic gradient Langevin dynamics",
    "authors": ["M. Welling", "Y.W. Teh"],
    "venue": "In International Conference on Machine Learning,",
    "year": 2011
  }, {
    "title": "Global convergence of Langevin dynamics based algorithms for nonconvex optimization",
    "authors": ["P. Xu", "J. Chen", "Q. Gu"],
    "venue": "arXiv preprint arXiv:1707.06618,",
    "year": 2017
  }, {
    "title": "Langevin dynamics with continuous tempering for training deep neural networks",
    "authors": ["N. Ye", "Z. Zhu", "R. Mantiuk"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2017
  }, {
    "title": "On stochastic and deterministic quasi-Newton methods for nonstrongly convex optimization: convergence and rate analysis",
    "authors": ["F. Yousefian", "A. Nedić", "U. Shanbhag"],
    "venue": "arXiv preprint arXiv:1710.05509,",
    "year": 2017
  }, {
    "title": "Deep learning with elastic averaging sgd",
    "authors": ["S. Zhang", "A.E. Choromanska", "Y. LeCun"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2015
  }, {
    "title": "Quasi-Newton methods for Markov Chain Monte Carlo",
    "authors": ["Y. Zhang", "C.A. Sutton"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2011
  }, {
    "title": "A hitting time analysis of stochastic gradient langevin dynamics",
    "authors": ["Y. Zhang", "P. Liang", "M. Charikar"],
    "venue": "In Proceedings of the 2017 Conference on Learning Theory,",
    "year": 2017
  }, {
    "title": "Stochastic LBFGS: Improved convergence rates and practical acceleration strategies",
    "authors": ["R. Zhao", "W.B. Haskell", "V.Y.F. Tan"],
    "venue": "IEEE Transactions on Signal Processing,",
    "year": 2017
  }, {
    "title": "Fast asynchronous parallel stochastic gradient decent",
    "authors": ["Zhao", "S.-Y", "Li", "W.-J"],
    "venue": "arXiv preprint arXiv:1508.05711,",
    "year": 2015
  }, {
    "title": "Asynchronous stochastic gradient descent with delay compensation",
    "authors": ["S. Zheng", "Q. Meng", "T. Wang", "W. Chen", "N. Yu", "Z. Ma", "T. Liu"],
    "venue": "In Proceedings of the 34th International Conference on Machine Learning,",
    "year": 2017
  }, {
    "title": "Stochastic adaptive quasi-Newton methods for minimizing expected values",
    "authors": ["C. Zhou", "W. Gao", "D. Goldfarb"],
    "venue": "In International Conference on Machine Learning,",
    "year": 2017
  }],
  "id": "SP:46ac3f292e211a56408611df7afffb1cb493ea05",
  "authors": [{
    "name": "Umut Şimşekli",
    "affiliations": []
  }, {
    "name": "Çağatay Yıldız",
    "affiliations": []
  }, {
    "name": "Thanh Huy Nguyen",
    "affiliations": []
  }, {
    "name": "Gaël Richard",
    "affiliations": []
  }, {
    "name": "A. Taylan Cemgil",
    "affiliations": []
  }],
  "abstractText": "Recent studies have illustrated that stochastic gradient Markov Chain Monte Carlo techniques have a strong potential in non-convex optimization, where local and global convergence guarantees can be shown under certain conditions. By building up on this recent theory, in this study, we develop an asynchronous-parallel stochastic L-BFGS algorithm for non-convex optimization. The proposed algorithm is suitable for both distributed and shared-memory settings. We provide formal theoretical analysis and show that the proposed method achieves an ergodic convergence rate of O(1/ √ N) (N being the total number of iterations) and it can achieve a linear speedup under certain conditions. We perform several experiments on both synthetic and real datasets. The results support our theory and show that the proposed algorithm provides a significant speedup over the recently proposed synchronous distributed L-BFGS algorithm.",
  "title": "Asynchronous Stochastic Quasi-Newton MCMC for Non-Convex Optimization"
}