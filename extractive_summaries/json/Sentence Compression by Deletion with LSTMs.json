{
  "sections": [{
    "text": "Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing, pages 360–368, Lisbon, Portugal, 17-21 September 2015. c©2015 Association for Computational Linguistics."
  }, {
    "heading": "1 Introduction",
    "text": "Sentence compression is a standard NLP task where the goal is to generate a shorter paraphrase of a sentence. Dozens of systems have been introduced in the past two decades and most of them are deletion-based: generated compressions are token subsequences of the input sentences (Jing, 2000; Knight & Marcu, 2000; McDonald, 2006; Clarke & Lapata, 2008; Berg-Kirkpatrick et al., 2011, to name a few).\nExisting compression systems heavily use syntactic information to minimize chances of introducing grammatical mistakes in the output. A common approach is to use only some syntactic information (Jing, 2000; Clarke & Lapata, 2008,\namong others) or use syntactic features as signals in a statistical model (McDonald, 2006). It is probably even more common to operate on syntactic trees directly (dependency or constituency) and generate compressions by pruning them (Knight & Marcu, 2000; Berg-Kirkpatrick et al., 2011; Filippova & Altun, 2013, among others). Unfortunately, this makes such systems vulnerable to error propagation as there is no way to recover from an incorrect parse tree. With the state-of-the-art parsing systems achieving about 91 points in labeled attachment accuracy (Zhang & McDonald, 2014), the problem is not a negligible one. To our knowledge, there is no competitive compression system so far which does not require any linguistic preprocessing but tokenization.\nIn this paper we research the following question: can a robust compression model be built which only uses tokens and has no access to syntactic or other linguistic information? While phenomena like long-distance relations may seem to make generation of grammatically correct compressions impossible, we are going to present an evidence to the contrary. In particular, we will present a model which benefits from the very recent advances in deep learning and uses word embeddings and Long Short Term Memory models (LSTMs) to output surprisingly readable and informative compressions. Trained on a corpus of less than two million automatically extracted parallel sentences and using a standard tool to obtain word embeddings, in its best and most simple configuration it achieves 4.5 points out of 5 in readability and 3.8 points in informativeness in an extensive evaluation with human judges. We believe that this is an important result as it may suggest a new direction for sentence compression research which is less tied to modeling linguistic\n360\nstructures, especially syntactic ones, than the compression work so far.\nThe paper is organized as follows: Section 3 presents a competitive baseline which implements the system of McDonald (2006) for large training sets. The LSTM model and its three configurations are introduced in Section 4. The evaluation set-up and a discussion on wins and losses with examples are presented in Section 5 which is followed by the conclusions."
  }, {
    "heading": "2 Related Work",
    "text": "The problem formulation we adopt in this paper is very simple: for every token in the input sentence we ask whether it should be kept or dropped, which translates into a sequence labeling problem with just two labels: one and zero. The deletion approach is a standard one in compression research, although the problem is often formulated over the syntactic structure and not the raw token sequence. That is, one usually drops constituents or prunes dependency edges (Jing, 2000; Knight & Marcu, 2000; McDonald, 2006; Clarke & Lapata, 2008; Berg-Kirkpatrick et al., 2011; Filippova & Altun, 2013). Thus, the relation to existing compression work is that we also use the deletion approach.\nRecent advances in machine learning made it possible to escape the typical paradigm of mapping a fixed dimensional input to a fixed dimensional output to mapping an input sequence onto an output sequence. Even though many of these models were proposed more than a decade ago, it is not until recently that they have empirically been shown to perform well. Indeed, core problems in natural language processing such as translation (Cho et al., 2014; Sutskever et al., 2014; Luong et al., 2014), parsing (Vinyals et al., 2014), image captioning (Vinyals et al., 2015; Xu et al., 2015), or learning to execute small programs (Zaremba & Sutskever, 2014) employed virtually the same principles—the use of Recurrent Neural Networks (RNNs). Thus, with regard to this line of research, our work comes closest to the recent machine translation work. An important difference is that we do not aim at building a model that generates compressions directly but rather a model which generates a sequence of deletion decisions.\nA more complex translation model is also conceivable and may significantly advance work on compression by paraphrasing, of which there have\nnot been many examples yet (Cohn & Lapata, 2008). However, in this paper our goal is to demonstrate that a simple but robust deletionbased system can be built without using any linguistic features other than token boundaries. We leave experiments with paraphrasing models to future work."
  }, {
    "heading": "3 Baseline",
    "text": "We compare our model against the system of McDonald (2006) which also formulates sentence compression as a binary sequence labeling problem. In contrast to our proposal, it makes use of a large set of syntactic features which are treated as soft evidence. The presence or absence of these features is treated as signals which do not condition the output that the model can produce. Therefore the model is robust against noise present in the precomputed syntactic structures of the input sentences.\nThe system was implemented based on the description by McDonald (2006) with two changes which were necessary due to the large size of the training data set used for model fitting. The first change was related to the learning procedure and the second one to the family of features used.\nRegarding the learning procedure, the original model uses a large-margin learning framework, namely MIRA (Crammer & Singer, 2003), but with some minor changes as presented by McDonald et al. (2005). In this set-up, online learning is performed, and at each step an optimization procedure is made where K constraints are included, which correspond to the top-K solutions for a given training observation. This optimization step is equivalent to a Quadratic Programming problem if K > 1, which is time-costly to solve, and therefore not adequate for the large amount of data we used for training the model. Furthermore, in his publication McDonald states clearly that different values of K did not actually have a major impact on the final performance of the model. Consequently, and for the sake of being able to successfully train the model with largescale data, the learning procedure is implemented as a distributed structured perceptron with iterative parameter mixing (McDonald et al., 2010), where each shard is processed with MIRA and K is set to 1.\nSetting K = 1 will only affect the weight update described on line 4 of Figure 3 of McDonald\n(2006), which is now expressed as:\nw(i+1) ← w(i) + τ × eyt,y′ where τ = max ( 0, L(yt,y′)−w · eyt,y′ ||eyt,y′ ||2 )\neyt,y′ = F (xt,yt)− F (xt,y′) y′ = best(x; w(i)) F (x,y) = |y|∑ j=2 f(x, I(yj−1), I(yj))\nThe second change concerns the feature set used. While McDonald’s original model contains deep syntactic features coming from both dependency and constituency parse trees, we use only dependency-based features. Additionally, and to better compare the baseline with the LSTM models, we have included as an optional feature a 256-dimension embedding-vector representation of each input word and its syntactic parent. The vectors are pre-trained using the Skipgram model1 (Mikolov et al., 2013). Ultimately, our implementation of McDonald’s model contained 463,614 individual features, summarized in three categories: • PoS features: Joint PoS tags of selected to-\nkens. Unigram, bigram and trigram PoS context of selected and dropped tokens. All the previous features conjoined with one indicating if the last two selected tokens are adjacent. • Deep syntactic features: Dependency labels\nof taken and dropped tokens and their parent dependencies. Boolean features indicating syntactic relations between selected tokens (i.e., siblings, parents, leaves, etc.). Dependency label of the least common ancestor in the dependency tree between a batch of dropped tokens. All the previous features conjoined with the PoS tag of the involved tokens. • Word features: Boolean features indicating\nif a group of dropped nodes contain a complete or incomplete parenthesization. Wordembedding vectors of selected and dropped tokens and their syntactic parents. The model is fitted over ten epochs on the whole training data, and for model selection a small development set consisting of 5,000 previously unseen sentences is used (none of them belonging to\n1https://code.google.com/p/word2vec/\nthe evaluation set). The automated metric used for this selection was accuracy@1 which is the proportion of golden compressions which could be fully reproduced. The performance on the development set plateaus when getting close to the last epoch."
  }, {
    "heading": "4 The LSTM model",
    "text": "Our approach is largely based on the sequence to sequence paradigm proposed in Sutskever et al. (2014). We train a model that maximizes the probability of the correct output given the input sentence. Concretely, for each training pair (X,Y ), we will learn a parametric model (with parameters θ), by solving the following optimization problem:\nθ∗ = arg max θ ∑ X,Y log p(Y |X; θ) (1)\nwhere the sum is assumed to be over all training examples. To model the probability p, we use the same architecture described by Sutskever et al. (2014). In particular, we use a RNN based on the Long Short Term Memory (LSTM) unit (Hochreiter & Schmidhuber, 1997), designed to avoid vanishing gradients and to remember some long-distance dependences from the input sequence. Figure 1 shows a basic LSTM architecture. The RNN is fed with input words Xi (one at a time), until we feed a special symbol “GO”. It is now a common practice (Sutskever et al., 2014; Li & Jurafsky, 2015) to start feeding the input in reversed order, as it has been shown to perform better empirically. During the first pass over the input, the network is expected to learn a compact, distributed representation of the input sentence, which will allow it to start generating the right predictions when the second pass starts, after the “GO” symbol is read.\nWe can apply the chain rule to decompose Equation (1) as follows:\np(Y |X; θ) = T∏ t=1 p(Yt|Y1, . . . , Yt−1, X; θ) (2)\nnoting that we made no independence assumptions. Once we find the optimal θ∗, we construct our estimated compression Ŷ as:\nŶ = arg max Y\np(Y |X; θ∗) (3)\nLSTM cell: Let us review the sequence-tosequence LSTM model. The Long Short Term Memory model of Hochreiter & Schmidhuber (1997) is defined as follows. Let xt, ht, and mt be the input, control state, and memory state at timestep t. Then, given a sequence of inputs (x1, . . . , xT ), the LSTM computes the h-sequence (h1, . . . , hT ) and the m-sequence (m1, . . . ,mT ) as follows\nit = sigm(W1xt +W2ht−1) i′t = tanh(W3xt +W4ht−1) ft = sigm(W5xt +W6ht−1) ot = sigm(W7xt +W8ht−1) mt = mt−1 ft + it i′t ht = mt ot\nThe operator denotes element-wise multiplication, the matrices W1, . . . ,W8 and the vector h0 are the parameters of the model, and all the nonlinearities are computed element-wise.\nStochastic gradient descent is used to maximize the training objective (Eq. (1)) w.r.t. all the LSTM parameters.\nNetwork architecture: In these experiments we have used the architecture depicted in Figure 3. Following Vinyals et al. (2014), we have used three stacked LSTM layers to allow the upper layers to learn higher-order representations of the input, interleaved with dropout layers to prevent overfitting (Srivastava et al., 2014). The output layer is a SoftMax classifier that predicts, after the “GO” symbol is read, one of the following three\nlabels: 1, if a word is to be retained in the compression, 0 if a word is to be deleted, or EOS, which is the output label used for the “GO” input and the end-of-sentence final period.\nInput representation: In the simplest implementation, that we call LSTM, the input layer has 259 dimensions. The first 256 contain the embedding-vector representation of the current in-\nput word, pre-trained using the Skipgram model2 (Mikolov et al., 2013). The final three dimensions contain a one-hot-spot representation of the goldstandard label of the previous word (during training), or the generated label of the previous word (during decoding).\nFor the LSTM+PAR architecture we first parse the input sentence, and then we provide as input, for each input word, the embedding-vector representation of that word and its parent word in the dependency tree. If the current input is the root node, then a special parent embedding is constructed with all nodes set to zero except for one node. In these settings we want to test the hypothesis whether knowledge about the parent node can be useful to decide if the current constituent is relevant or not for the compression. The dimensionality of the input layer in this case is 515. Similarly to McDonald (2006), syntax is used here as a soft feature in the model.\nFor the LSTM+PAR+PRES architecture, we again parse the input sentence, and use a 518-sized embedding vector, that includes: • The embedding vector for the current word\n(256 dimensions). • The embedding vector for the parent word\n(256 dimensions). • The label predicted for the last word (3 di-\nmensions). • A bit indicating whether the parent word has 2https://code.google.com/p/word2vec/\nalready been seen and kept in the compression (1 dimension). • A bit indicating whether the parent word has\nalready been seen but discarded (1 dimension). • A bit indicating whether the parent word\ncomes later in the input (1 dimension).\nDecoding: Eq. (3) involves searching through all possible output sequences (given X). Contrary to the baseline, in the case of LSTMs the complete previous history is taken into account for each prediction and we cannot simplify Eq. (2) with a Markov assumption. Therefore, the search space at decoding time is exponential on the length of the input, and we have used a beam-search procedure as described in Figure 2.\nFixed parameters: For training, we unfold the network 120 times and make sure that none of our training instances is longer than that. The learning rate is initialized at 2, with a decay factor of 0.96 every 300,000 traning steps. The dropping probability for the dropout layers is 0.2. The number of nodes in each LSTM layer is always identical to the number of nodes in the input layer. We have not tuned these parameters nor the number of stacked layers."
  }, {
    "heading": "5 Evaluation",
    "text": ""
  }, {
    "heading": "5.1 Data",
    "text": "Both the LSTM systems we introduced and the baseline require a training set of a considerable size. In particular, the LSTM model uses 256- dimensional embeddings of token sequences and cannot be expected to perform well if trained on a thousand parallel sentences, which is the size of the commonly used data sets (Knight & Marcu, 2000; Clarke & Lapata, 2006). Following the method of Filippova & Altun (2013), we collect a much larger corpus of about two million parallel sentence-compression instances from the news where every compression is a subsequence of tokens from the input. For testing, we use the publicly released set of 10,000 sentence-compression pairs3. We take the first 200 sentences from this set for the manual evaluation with human raters, and the first 1,000 sentences for the automatic evaluation."
  }, {
    "heading": "5.2 Experiments",
    "text": "We evaluate the baseline and our systems on the 200-sentence test set in an experiment with human raters. The raters were asked to rate readability and informativeness of compressions given the input which are the standard evaluation metrics for compression. The former covers the grammatical correctness, comprehensibility and fluency of the output while the latter measures the amount of important content preserved in the compression.\nAdditionally, for experiments on the development set, we used two metrics for automatic evaluation: per-sentence accuracy (i.e., how many compressions could be fully reproduced) and word-based F1-score. The latter differs from the RASP-based relation F-score by Riezler et al. (2003) in that we simply compute the recall and precision in terms of tokens kept in the golden and the generated compressions. We report these results for completeness although it is the results of the human evaluation from which we draw our conclusions.\nCompression ratio: The three versions of our system (LSTM*) and the baseline (MIRA) have comparable compression ratios (CR) which are defined as the length of the compression in characters divided over the sentence length. Since the\n3http://storage.googleapis.com/ sentencecomp/compressiondata.json\nratios are very close, a comparison of the systems’ scores is justified (Napoles et al., 2011).\nAutomatic evaluation: A total of 1,000 sentence pairs from the test set4 were used in the automatic evaluation. The results are summarized in Table 1.\nThere is a significant difference in performance of the MIRA baseline and the LSTM models, both in terms of F1-score and in accuracy. More than 30% of golden compressions could be fully regenerated by the LSTM systems which is in sharp contrast with the 20% of MIRA. The differences in F-score between the three versions of LSTM are not significant, all scores are close to 0.81.\nEvaluation with humans: The first 200 sentences from the set of 1,000 used in the automatic evaluation were compressed by each of the four systems. Every sentence-compression pair was rated by three raters who were asked to select a rating on a five-point Likert scale, ranging from one to five. In very few cases (around 1%) the ratings were inconclusive (i.e., 1, 3, 5 were given to the same pair) and had to be skipped. Table 2 summarizes the results.\nThe results indicate that the LSTM models produce more readable and more informative compressions. Interestingly, there is no benefit in using the syntactic information, at least not with\n4We used the very first 1,000 instances.\nthe amount of parallel data we had at our disposal. The simple LSTM model which only uses token embeddings to generate a sequence of deletion decisions significantly outperforms the baseline which was given not only embeddings but also syntactic and other features.\nDiscussion: What are the wins and losses of the LSTM systems? Figure 4 presents some of the evaluated sentence-compression pairs. In terms of readability, the basic LSTM system performed surprisingly well. Only in a few cases (out of 200) did it get an average score of two or three. Sentences which pose difficulty to the model are the ones with quotes, intervening commas, or other uncommon punctuation patterns. For example, in the second sentence in Figure 4, if one removes from the input the age modifiers and the preceding commas, the words and Chris Martin are not\ndropped and the output compression is grammatical, preserving both conjoined elements.\nWith regard to informativeness, the difficult cases are those where there is very little to be removed and where the model still removed more than a half to achieve the compression ratio it observed in the training data. For example, the only part that can be removed from the fourth sentence in Figure 4 is the modifier of police, everything else being important content. Similarly, in the fifth sentence the context of the event must be retained in the compression for the event to be interpreted correctly.\nArguably, such cases would also be difficult for other systems. In particular, recognizing when the context is crucial is a problem that can be solved only by including deep semantic and discourse features which has not been attempted yet. And\nsentences with quotes (direct speech, a song or a book title, etc.) are challenging for parsers which in turn provide important signals for most compression systems.\nThe bottom of Figure 4 contains examples of good compressions. Even though for a significant number of input sentences the compression was a continuous subsequence of tokens, there are many discontinuous compressions. In particular, the LSTM model learned to drop appositions, no matter how long they are, temporal expressions, optional modifiers, introductory clauses, etc.\nOur understanding of why the extended model (LSTM+PAR+PRES) performed worse in the human evlauation than the base model is that, in the absence of syntactic features, the basic LSTM learned a model of syntax useful for compression, while LSTM++, which was given syntactic information, learned to optimize for the particular way the ”golden” set was created (tree pruning). While the automatic evaluation penalized all deviations from the single golden variant, in human evals there was no penalty for readable alternatives."
  }, {
    "heading": "6 Conclusions",
    "text": "We presented, to our knowledge, a first attempt at building a competitive compression system which is given no linguistic features from the input. The two important components of the system are (1) word embeddings, which can be obtained by anyone either pre-trained, or by running word2vec on a large corpus, and (2) an LSTM model which draws on the very recent advances in research on RNNs. The training data of about two million sentence-compression pairs was collected automatically from the Internet.\nOur results clearly indicate that a compression model which is not given syntactic information explicitly in the form of features may still achieve competitive performance. The high readability and informativeness scores assigned by human raters support this claim. In the future, we are planning to experiment with more “interesting” paraphrasing models which translate the input not into a zero-one sequence but into words."
  }],
  "year": 2015,
  "references": [{
    "title": "Jointly learning to extract and compress",
    "authors": ["T. Berg-Kirkpatrick", "D. Gillick", "D. Klein"],
    "venue": "In Proc. of ACL-11",
    "year": 2011
  }, {
    "title": "Learning phrase representations using rnn encoder-decoder for statistical machine translation",
    "authors": ["K. Cho", "B. van Merrienboer", "C. Gulcehre", "D. Bahdanau", "F. Bougares", "H. Schwenk", "Y. Bengio"],
    "venue": "In Proceedings of the 2014 Con-",
    "year": 2014
  }, {
    "title": "Models for sentence compression: A comparison across domains, training requirements and evaluation measures",
    "authors": ["J. Clarke", "M. Lapata"],
    "venue": "In Proc. of COLING-ACL-06,",
    "year": 2006
  }, {
    "title": "Global inference for sentence compression: An integer linear programming approach",
    "authors": ["J. Clarke", "M. Lapata"],
    "venue": "Journal of Artificial Intelligence Research,",
    "year": 2008
  }, {
    "title": "Sentence compression beyond word deletion",
    "authors": ["T. Cohn", "M. Lapata"],
    "venue": "In Proc. of COLING-08,",
    "year": 2008
  }, {
    "title": "Ultraconservative online algorithms for multiclass problems",
    "authors": ["K. Crammer", "Y. Singer"],
    "venue": "Journal of Machine Learning Research,",
    "year": 2003
  }, {
    "title": "Overcoming the lack of parallel data in sentence compression",
    "authors": ["K. Filippova", "Y. Altun"],
    "venue": "In Proc. of EMNLP-13,",
    "year": 2013
  }, {
    "title": "Long short-term memory",
    "authors": ["S. Hochreiter", "J. Schmidhuber"],
    "venue": "Neural computation,",
    "year": 1997
  }, {
    "title": "Sentence reduction for automatic text summarization",
    "authors": ["H. Jing"],
    "venue": "In Proc. of ANLP-00,",
    "year": 2000
  }, {
    "title": "Statistics-based summarization – step one: Sentence compression",
    "authors": ["K. Knight", "D. Marcu"],
    "venue": "In Proc. of AAAI-00,",
    "year": 2000
  }, {
    "title": "A hierarchical LSTM autoencoder for paragraphs and documents",
    "authors": ["J. Li", "D. Jurafsky"],
    "venue": "In Proc. of ACL-15",
    "year": 2015
  }, {
    "title": "Addressing the rare word problem in neural machine translation. CoRR, abs/1410.8206",
    "authors": ["Luong", "M.-T", "I. Sutskever", "Q.V. Le", "O. Vinyals", "W. Zaremba"],
    "year": 2014
  }, {
    "title": "Discriminative sentence compression with soft syntactic evidence",
    "authors": ["R. McDonald"],
    "venue": "In Proc. of EACL-06,",
    "year": 2006
  }, {
    "title": "Online large-margin training of dependency parsers",
    "authors": ["R. McDonald", "K. Crammer", "F. Pereira"],
    "venue": "In Proc. of ACL-05,",
    "year": 2005
  }, {
    "title": "Distributed training strategies for the structured perceptron",
    "authors": ["R. McDonald", "K. Hall", "G. Mann"],
    "venue": "In Proc. of NAACL-HLT-10,",
    "year": 2010
  }, {
    "title": "Distributed representations of words and phrases and their compositionality",
    "authors": ["T. Mikolov", "I. Sutskever", "K. Chen", "G.S. Corrado", "J. Dean"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2013
  }, {
    "title": "Evaluating sentence compression: Pitfalls and suggested remedies",
    "authors": ["C. Napoles", "C. Callison-Burch", "B. Van Durme"],
    "venue": "In Proceedings of the Workshop on Monolingual Text-to-text Generation,",
    "year": 2011
  }, {
    "title": "Statistical sentence condensation using ambiguity packing and stochastic disambiguation methods for Lexical-Functional Grammar",
    "authors": ["S. Riezler", "T.H. King", "R. Crouch", "A. Zaenen"],
    "venue": "In Proc. of HLT-NAACL-03,",
    "year": 2003
  }, {
    "title": "Dropout: A simple way to prevent neural networks from overfitting",
    "authors": ["N. Srivastava", "G. Hinton", "A. Krizhevsky", "I. Sutskever", "R. Salakhutdinov"],
    "venue": "Journal of Machine Learning Research,",
    "year": 2014
  }, {
    "title": "Show and tell: A neural image caption generator",
    "authors": ["O. Vinyals", "A. Toshev", "S. Bengio", "D. Erhan"],
    "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
    "year": 2015
  }, {
    "title": "Show, attend and tell: Neural image caption generation with visual attention",
    "authors": ["K. Xu", "J. Ba", "R. Kiros", "K. Cho", "A. Courville", "R. Salakhutdinov", "R. Zemel", "Y. Bengio"],
    "venue": "Proceedings of ICML-2015",
    "year": 2015
  }, {
    "title": "Enforcing structural diversity in cube-pruned dependency parsing",
    "authors": ["H. Zhang", "R. McDonald"],
    "venue": "In Proc. of ACL-14,",
    "year": 2014
  }],
  "id": "SP:e2463961550e02725e77f5d0fc9109db9a8f95b5",
  "authors": [{
    "name": "Katja Filippova",
    "affiliations": []
  }, {
    "name": "Enrique Alfonseca",
    "affiliations": []
  }, {
    "name": "Carlos A. Colmenares",
    "affiliations": []
  }, {
    "name": "Lukasz Kaiser",
    "affiliations": []
  }, {
    "name": "Oriol Vinyals",
    "affiliations": []
  }],
  "abstractText": "We present an LSTM approach to deletion-based sentence compression where the task is to translate a sentence into a sequence of zeros and ones, corresponding to token deletion decisions. We demonstrate that even the most basic version of the system, which is given no syntactic information (no PoS or NE tags, or dependencies) or desired compression length, performs surprisingly well: around 30% of the compressions from a large test set could be regenerated. We compare the LSTM system with a competitive baseline which is trained on the same amount of data but is additionally provided with all kinds of linguistic features. In an experiment with human raters the LSTMbased model outperforms the baseline achieving 4.5 in readability and 3.8 in informativeness.",
  "title": "Sentence Compression by Deletion with LSTMs"
}