{
  "sections": [{
    "text": "Sequential LSTMs have been extended to model tree structures, giving competitive results for a number of tasks. Existing methods model constituent trees by bottom-up combinations of constituent nodes, making direct use of input word information only for leaf nodes. This is different from sequential LSTMs, which contain references to input words for each node. In this paper, we propose a method for automatic head-lexicalization for tree-structure LSTMs, propagating head words from leaf nodes to every constituent node. In addition, enabled by head lexicalization, we build a tree LSTM in the top-down direction, which corresponds to bidirectional sequential LSTMs in structure. Experiments show that both extensions give better representations of tree structures. Our final model gives the best results on the Stanford Sentiment Treebank and highly competitive results on the TREC question type classification task."
  }, {
    "heading": "1 Introduction",
    "text": "Both sequence structured and tree structured neural models have been applied to NLP problems. Seminal work uses convolutional neural networks (Collobert and Weston, 2008), recurrent neural networks (Elman, 1990; Mikolov et al., 2010) and recursive neural networks (Socher et al., 2011) for sequence and tree modeling. Long short-term memory (LSTM) networks have significantly improved accuracies in a variety of sequence tasks (Sutskever et al., 2014; Bahdanau et al., 2015) compared to\nvanilla recurrent neural networks. Addressing diminishing gradients effectively, they have been extended to tree structures, achieving promising results for tasks such as syntactic language modeling (Zhang et al., 2016), sentiment analysis (Li et al., 2015; Zhu et al., 2015; Le and Zuidema, 2015; Tai et al., 2015; Teng et al., 2016) and relation extraction (Miwa and Bansal, 2016).\nDepending on the node type, typical tree structures in NLP can be categorized to constituent trees and dependency trees. A salient difference between the two types of tree structures is in the node. While dependency tree nodes are input words themselves, constituent tree nodes represent syntactic constituents. Only leaf nodes in constituent trees correspond to words. Though LSTM structures have been developed for both types of trees above, we investigate constituent trees in this paper. There are three existing methods for constituent tree LSTMs (Zhu et al., 2015; Tai et al., 2015; Le and Zuidema, 2015), which make essentially the same extension from sequence structured LSTMs. We take the method of Zhu et al. (2015) as our baseline.\nFigure 1 shows the sequence structured LSTM of Hochreiter and Schmidhuber (1997) and the treestructured LSTM of Zhu et al. (2015), illustrating the input (x), cell (c) and hidden (h) nodes at a certain time step t. The most important difference between Figure 1(a) and Figure 1(b) is the branching factor. While a cell in the sequence structure LSTM depends on the single previous hidden node, a cell in the tree-structured LSTM depends on a left hidden node and a right hidden node. Such tree-structured extensions of the sequence structured LSTM assume\n163\nTransactions of the Association for Computational Linguistics, vol. 5, pp. 163–177, 2017. Action Editor: Scott Yih. Submission batch: 5/2016; Revision batch: 12/2016; Published 6/2017.\nc©2017 Association for Computational Linguistics. Distributed under a CC-BY 4.0 license.\nthat the constituent tree is binarized, building hidden nodes from the input words in the bottom-up direction. The leaf node structure is shown in Figure 1(c).\nA second salient difference between the two types of LSTMs is the modeling of input words. While each cell in the sequence structure LSTM directly depends on its corresponding input word (Figure 1(a)), only leaf cells in the tree structure LSTM directly depend on corresponding input words (Figure 1(c)). This corresponds well to the constituent tree structure, where there is no direct association between non-leaf constituent nodes and input words. However, it leaves the tree structure a degraded version of a perfect binary-branching variation of the sequence-structure LSTM, with one important source of information (i.e. words) missing in forming a cell (Figure 1(b)).\nWe fill this gap by proposing an extension to the tree LSTM model, injecting lexical information into every node in the tree. Our method takes inspiration from work on head-lexicalization, which shows that each node in a constituent tree structure is governed by a head word. As shown in Figure 2, the head word for the verb phrase “visited Mary” is “visited”, and the head word of the adverb phrase “this afternoon” is “afternoon”. Research has shown that head word information can significantly improve the performance of syntactic parsing (Collins, 2003; Clark and Curran, 2004). Correspondingly, we use the head lexical information of each constituent word as the input node x for calculating the corresponding cell c in Figure 1(b).\nTraditional head-lexicalization relies on specific rules (Collins, 2003; Zhang and Clark, 2009), typically extracting heads from constituent treebanks according to certain grammar formalisms. For better generalization, we use a neural attention mechanism to derive head lexical information automatically, rather than relying on linguistic head rules to find the head lexicon of each constituent, which is language- and formalism-dependent.\nBased on such head lexicalization, we further make a bidirectional extension of the tree structured LSTM, propagating information in the top-down direction as well as the bottom-up direction. This is analogous to the bidirectional extension of sequence structured LSTMs, which are commonly used for NLP tasks such as speech recognition (Graves et al., 2013), sentiment analysis (Tai et al., 2015; Li et al., 2015) and machine translation (Sutskever et al., 2014; Bahdanau et al., 2015) tasks.\nResults on a standard sentiment classification benchmark and a question type classification benchmark show that our tree LSTM structure gives significantly better accuracies compared with the method of Zhu et al. (2015). We achieve the best reported results for sentiment classification. Interestingly, the head lexical information that is learned automatically from the sentiment treebank consists of both syntactic head information and key sentiment word information. This shows the advantage of automatic head-finding as compared with rule-based head lexicalization. We make our code available under GPL at https://github.com/ zeeeyang/lexicalized_bitreelstm."
  }, {
    "heading": "2 Related Work",
    "text": "LSTM Recurrent neural network (RNN) (Elman, 1990; Mikolov et al., 2010) achieves success on\nmodeling linear structures due to its ability to preserve history over arbitrary length sequences. At each step, RNN decides its hidden state based on both the current input and the previous hidden state. In theory, it can carry over unbounded history. Long Short-Term Memory (LSTM) (Hochreiter and Schmidhuber, 1997) is a special type of RNN that leverages multiple gate vectors and a memory cell vector to solve the vanishing and exploding gradient problems of training RNNs. It has been successfully applied to parsing (Vinyals et al., 2015a), sentiment classification (Tai et al., 2015; Li et al., 2015), speech recognition (Graves et al., 2013), machine translation (Sutskever et al., 2014; Bahdanau et al., 2015) and image captioning (Vinyals et al., 2015b). There are many variants of sequential LSTMs, such as simple Gated Recurrent Neural Networks (Cho et al., 2014). Greff et al. (2017) compared various architectures of LSTM. In this paper, we take the standard LSTM with peephole connections (Gers and Schmidhuber, 2000) as a baseline.\nStructured LSTM There has been a line of research that extends the standard sequential LSTM in order to model more complex structures. Kalchbrenner et al. (2016) proposed Grid LSTMs to process multi-dimensional data. Theis and Bethge (2015) proposed Spatial LSTMs to handle image data. Dyer et al. (2015) designed Stack LSTMs by adding a top pointer to sequential LSTMs to deal with push and pop sequences of a stack. Tai et al. (2015), Zhu et al. (2015) and Le and Zuidema (2015) extended sequential LSTMs to Tree-Structured LSTMs (Tree LSTMs) by adding branching factors. Experiments demonstrated that Tree LSTMs can outperform competitive LSTM baselines on several tasks, such as semantic relatedness prediction and sentiment classification. Li et al. (2015) further investigated the effectiveness of Tree LSTMs on various tasks and discussed when Tree LSTMs are necessary. In addition, Li et al. (2016) employed graph gated units to model graph-based structures.\nTree LSTM The idea of extending linear recurrent structures to tree recurrent structures is reminiscent of extending Recurrent Neural Network to Recursive Neural Network (ReNN) (Socher et al., 2013b; Le and Zuidema, 2014) to support information flow over trees. In addition to Tai et al. (2015), Zhu et al. (2015) and Le and Zuidema (2015), who\nexplicitly named their models as Tree LSTMs, Cho et al. (2014) designed gated recurrent units over tree structures, and Chen et al. (2015) introduced gate mechanisms to recursive neural networks. These can also be regarded as variants of Tree LSTMs.\nBoth Zhu et al. (2015) and Le and Zuidema (2015) proposed Binary Tree LSTM models, which can be applied to situations where there are exactly two children of each internal node in a tree. The difference between Zhu et al. (2015) and Le and Zuidema (2015) is that besides using two forget gates, Le and Zuidema (2015) also make use of two input gates to let a node know its sibling. Tai et al. (2015) introduced Child-Sum Tree LSTM and Nary Tree LSTM. Child-Sum Tree LSTMs can support multiple children, while N-ary Tree LSTMs work for trees with a branching factor of at most N . In this perspective, Binary Tree LSTM is a special case of N-ary Tree LSTM with N = 2.\nWhen a Child-Sum Tree LSTM is applied to a dependency tree, it is referred to as a Dependency Tree LSTM. A Binary Tree LSTM is also referred to as a Constituent Tree LSTM. Based on Tai et al. (2015), Miwa and Bansal (2016) introduced a Tree LSTM model that can handle different types of children. A dependency tree naturally contains lexical information at every node, while only leaf nodes contain lexical information in a constituent tree. None of these methods (Tai et al., 2015; Zhu et al., 2015; Le and Zuidema, 2015) make direct use of lexical input for internal nodes when using constituent Tree LSTMs.\nBi-LSTM Another common extension to sequential LSTM is to include bidirectional information (Graves et al., 2013), which can model history both left-to-right and right-to-left. The aforementioned Tree LSTM models (Tai et al., 2015; Zhu et al., 2015; Le and Zuidema, 2015) propagate the history of children to their parent in the bottom-up direction only, while ignoring the top-down information flow from parents to children. Zhang et al. (2016) proposed a top-down Tree LSTM to estimate the generation probability of a dependency tree. However, no corresponding bottom-up Tree LSTM is incorporated into their model.\nPaulus et al. (2014) leveraged bidirectional information over recursive binary trees by propagating global belief down from the tree root to leaf nodes. However, their model is based on recursive neural\nnetwork rather than LSTM. Miwa and Bansal (2016) adopted a bidirectional Tree LSTM model to jointly extract named entities and relations under a dependency tree structure. For constituent tree structures, however, their model does not work due to lack of word inputs on non-leaf constituent nodes, and in particular the root node. Our head lexicalization allows us to investigate the top-down constituent Tree LSTM. To our knowledge, we are the first to report a bidirectional constituent Tree LSTM."
  }, {
    "heading": "3 Baselines",
    "text": "A sequence-structure LSTM estimates a sequence of hidden state vectors given a sequence of input vectors, through the calculation of a sequence of hidden cell vectors using a gate mechanism. For NLP, the input vectors are typically word embeddings (Mikolov et al., 2013), but can also include partof-speech (POS) embeddings, character embeddings or other types of information. For notational convenience, we refer to the input vectors as lexical vectors.\nFormally, given an input vector sequence x1, x2, . . . , xn, each state vector ht is estimated from the Hadamard product of a cell vector ct and a corresponding output gate vector ot\nht = ot ⊗ tanh(ct) (1)\nHere the cell vector depends on both the previous cell vector ct, and a combination of the previous state vector ht−1; the current input vector xt:\nct = ft ⊗ ct−1 + it ⊗ gt gt = tanh(Wxgxt +Whght−1 + bg)\n(2)\nThe combination of ct−1 and gt is controlled by the Hadamard product between a forget gate vector ft and an input gate vector it, respectively. The gates ot, ft and it are defined as follows\nit = σ(Wxixt +Whiht−1 +Wcict−1 + bi)\nft = σ(Wxfxt +Whfht−1 +Wcfct−1 + bf )\not = σ(Wxoxt +Whoht−1 +Wcoct + bo),\n(3)\nwhere σ is the sigmoid function. Wxg, Whg, bg, Wxi, Whi, Wci, bi, Wxf , Whf , Wcf , bf , Wxo, Who, Wco and bo are model parameters.\nThe bottom-up Tree LSTM of Zhu et al. (2015) extends the left-to-right sequence LSTM by splitting\nthe previous state vector ht−1 into a left child state vector hLt−1 and a right child state vector h R t−1, and the previous cell vector ct−1 into a left child cell vector cLt−1 and a right child cell vector c R t−1, calculating ct as\nct = f L t ⊗ cLt−1 + fRt ⊗ cRt−1 + it ⊗ gt, (4)\nand the input/output gates it/ot as\nit = σ ( ∑\nN∈{L,R} (WNhih N t−1 +W N ci c N t−1) + bi\n)\not = σ ( ∑\nN∈{L,R} WNhoh N t−1 +Wcoct + bo\n) (5)\nThe forget gate ft is split into fLt and f R t for regulating cLt−1 and c R t−1, respectively:\nfLt = σ ( ∑\nN∈{L,R} (WNhflh N t−1 +W N cfl cNt−1) + bfl\n)\nfRt = σ ( ∑\nN∈{L,R} (WNhfrh N t−1 +W N cfrc N t−1) + bfr\n)\n(6)\ngt depends on both hLt−1 and h R t−1, but as shown in Figure 1 (b), it does not depend on xt\ngt = tanh ( ∑\nN∈{L,R} WNhgh N t−1 + bg\n) (7)\nFinally, the hidden state vector ht is calculated in the same way as in the sequential LSTM model shown in Equation 1. WLhi, W R hi, W L ci , W R ci , bi, W L ho, WRho, Wco, bo, W L hfl , WRhfl , W L cfl , WRcfl , bfl , W L hfr\n, WRhfr , W L cfr , WRcfr , bfr , W L hg, W R hg and bg are model parameters."
  }, {
    "heading": "4 Our Model",
    "text": ""
  }, {
    "heading": "4.1 Head Lexicalization",
    "text": "We introduce an input lexical vector xt to the calculation of each cell vector ct via a bottom-up head propagation mechanism. As shown in the shaded nodes in Figure 3 (b), the head propagation mechanism is parallel to the cell propagation mechanism. In contrast, the method of Zhu et al. (2015) in Figure 3 (a) does not have the input vector xt for non-leaf constituents.\nThere are multiple ways to choose a head lexicon for a given binary-branching constituent. One\nsimple method is to choose the head lexicon of the left child as the head (left-headedness). Correspondingly, an alternative is to use the right child for head lexicon. There is less consistency in the governing head lexicons across variations of the same type of constituents with slightly different typologies. Hence, simple baselines can be less effective compared to linguistically motivated head findings.\nRather than selecting head lexicons using manually-defined head-finding rules, which are language- and formalism-dependent (Collins, 2003), we cast head finding as a part of the neural network model, learning the head lexicon of each constituent by a gated combination of the head lexicons of its two children1. Formally,\nxt = zt ⊗ xLt−1 + (1− zt)⊗ xRt−1, (8)\nwhere xt represents the head lexicon vector of the current constituent, xLt−1 represents the head lexicon of its left child constituent, and xRt−1 represents the head lexicon of its right child constituent. The gate zt is calculated based on xLt−1 and x R t−1,\nzt = σ(W L zxx L t−1 +W R zxx R t−1 + bz) (9)\nHere WLzx, W R zx and bz are model parameters."
  }, {
    "heading": "4.2 Lexicalized Tree LSTM",
    "text": "Given head lexicon vectors for nodes, the Tree LSTM of Zhu et al. (2015) can be extended by leveraging xt in calculating the corresponding ct. In particular, xt is used to estimate the input (it), output\n1In this paper, we work on binary trees only, which is a common form for CKY and shift-reduce parsing. Typical binarization methods, such as head binarization (Klein and Manning, 2003) , also rely on specific head-finding rules.\n(ot) and forget (fRt and f L t ) gates:\nit = σ ( Wxixt+\n∑\nN∈{L,R} (WNhih N t−1 +W N ci c N t−1) + bi\n)\nfLt = σ ( Wxfxt+\n∑\nN∈{L,R} (WNhflh N t−1 +W N cfl cNt−1) + bfl\n)\nfRt = σ ( Wxfxt+\n∑\nN∈{L,R} (WNhfrh N t−1 +W N cfrc N t−1) + bfr\n)\not = σ ( Wxoxt+\n∑\nN∈{L,R} WNhoh N t−1 +Wcoct + bo\n)\n(10)\nIn addition, xt is also used in computing gt,\ngt = tanh ( Wxgxt + ∑\nN∈{L,R} WNhgh N t−1 + bg\n) (11)\nWith the new definition of it, fRt , f L t and gt, the computing of ct remains the same as the baseline Tree LSTM model as shown in Equation 4. Similarly, ht remains the Hadamard product of ct and the new ot as shown in Equation 1.\nIn this model, Wxi, Wxf , Wxg and Wxo are newly-introduced model parameters. The use of xt in computing the gate and cell values are consistent with those in the baseline sequential LSTM."
  }, {
    "heading": "4.3 Bidirectional Extensions",
    "text": "Given a sequence of input vectors [x1, x2, . . . , xn], a bidirectional sequential LSTM (Graves et al., 2013) computes two sets of hidden state vectors, [h̃1, h̃2, . . . , h̃n] and [h̃′n, h̃ ′ n−1, . . . , h̃ ′ 1] in the left-to-right and the right-to-left directions, respectively. The final hidden state hi of the input xi is the concatenation of the corresponding state vectors in the two LSTMs, hi = h̃i ⊕ h̃′n−i+1 (12) The two LSTMs can share the same model parameters or use different parameters. We choose the latter in our baseline experiments.\nWe make a bidirectional extension to the Lexicalized Tree LSTM in Section 4.2 by following the sequential LSTMs in Section 3, adding an additional\nset of hidden state vectors in the top-down direction. Different from the bottom-up direction, each hidden state in the top-down LSTM has exactly one predecessor. In fact, the path from the root of a tree down to any node forms a sequential LSTM.\nNote, however, that two different sets of model parameters are used when the current node is the left and the right child of its predecessor. Denoting the two sets of parameters as UL and UR, respectively, the hidden state vector h7 in Figure 4 is calculated from the hidden state vector h1 using the parameter set sequence [UL,UL,UR]. Similarly, h8 is calculated from h1 using [UL,UR,UL]. At each step t, the computing of ht follows the sequential LSTM model:\nht = ot ⊗ tanh(ct−1) ct = ft ⊗ ct−1 + it ⊗ gt gt = tanh(W N xg↓xt−1 +W N hg↓ht−1 + b N g↓)\n(13)\nWith the gate values being defined as:\nit = σ(W N xi↓xt +W N hi↓ht−1 +W N ci↓ct−1 + b N i↓) ft = σ(W N xf↓xt +W N hf↓ht−1 +W N cf↓ct−1 + b N f↓) ot = σ(W N xo↓xt +W N ho↓ht−1 +W N co↓ct + b N o↓)\n(14)\nHere N ∈ {L,R} and UN = {WNxg↓,WNhg↓, bNg↓,W N xi↓,W N hi↓,W N ci↓, b N i↓ ,W N xf↓,W N hf↓,W N cf↓, b N f↓, WNxo↓,W N ho↓,W N co↓, b N o↓}. UL and UR are model parameters in the top-down Tree LSTM. One final note is that the top-down Tree LSTM is enabled by the head propagation mechanism, which allows a head lexicon node to be made available for the root constituent node. Without such information, it would be difficult to build top-down LSTM for constituent trees."
  }, {
    "heading": "5 Usage for Classification",
    "text": "We apply the bidirectional Tree LSTM to classification tasks, where the input is a sentence with its binarized constituent tree, and the output is a discrete label. We denote the bottom-up hidden state vector of the root as h̃ROOT↑, the top-down hidden state vector of the root as h̃ROOT↓ and the top-down hidden state vectors of the input words x1, x2, . . . , xn as h̃′1, h̃ ′ 2, . . . , h̃ ′ n. We take the concatenation of h̃ROOT↑, h̃ROOT↓ and the average of h̃′1, h̃ ′ 2, . . . , h̃ ′ n as the final representation h of the sentence:\nh = h̃ROOT↑ ⊕ h̃ROOT↓ ⊕ 1\nn\nn∑\ni=1\nh̃′i (15)\nA softmax classifier is used to predict the probability pj of sentiment label j from h by\nhl = ReLU(Whlh+ bhl) P = softmax(Wlphl + blp)\npj = P [j],\n(16)\nwhere Whl, bhl, Wlp and blp are model parameters, and ReLU is the rectifier function f(x) = max(0, x). During prediction, the largest probability component of P will be taken as the answer."
  }, {
    "heading": "6 Training",
    "text": "We train our classifier to maximize the conditional log-likelihood of gold labels of training samples. Formally, given a training set of size |D|, the training objective is defined by\nL(Θ) = − |D|∑\ni=1\nlog pyi + λ\n2 ||Θ||2, (17)\nwhere Θ is the set of model parameters, λ is a regularization parameter, yi is the gold label of the ith training sample and pyi is obtained according to Equation 16. For sequential LSTM models, we collect errors over each sequence. For Tree LSTMs, we sum up errors at every node.\nThe model parameters are optimized using ADAM (Kingma and Ba, 2015) without gradient clipping, with the default hyper-parameters of the AdamTrainer in the Dynet toolkits.2 We also use dropout (Srivastava et al., 2014) at lexical input\n2https://github.com/clab/dynet\nembeddings with a fixed probability pdrop to avoid overfitting. pdrop is set to 0.5 for all tasks.\nFollowing Tai et al. (2015), Li et al. (2015), Zhu et al. (2015) and Le and Zuidema (2015), we use Glove-300d word embeddings3 to train our model. The pretrained word embeddings are fine-tuned for all tasks. Unknown words are handled in two steps. First, if a word is not contained in the pretrained word embeddings, but its lowercased form exists in the embedding table, we use the lowercase as a replacement. Second, if both the original word and its lowercased form cannot be found, we treat the word as unk. The embedding vector of the UNK token is initialized as the average of all embedding vectors.\nWe use one hidden layer and the same dimensionality settings for both sequential and Tree LSTMs. LSTM hidden states are of size 150. The output hidden size is 128 and 64 for the sentiment classification task and the question type classification task, respectively. Each model is trained for 30 iterations. The same training procedure repeats five times using different random seeds, with parameters being evaluated at the end of every iteration on the development set. The model that gives the best development result is used for final tests."
  }, {
    "heading": "7 Experiments",
    "text": "The effectiveness of our model is tested mainly on a sentiment classification task and a question type classification task."
  }, {
    "heading": "7.1 Tasks",
    "text": "Sentiment Classification. For sentiment classification, we use the same data settings as Zhu et al. (2015). Specifically, we use the Stanford Sentiment Treebank (Socher et al., 2013b). Each sentence is annotated with a constituent tree. Every internal node corresponds to a phrase. Each node is manually assigned an integer sentiment label from 0 to 4, that correspond to five sentiment classes: very negative, negative, neutral, positive and very positive, respectively. The root label represents the sentiment label of the whole sentence.\nWe perform both binary classification and finegrained classification. Following previous work, we use labels of all phrases for training. Gold-standard\n3http://nlp.stanford.edu/data/glove.840B.300d.zip\ntree structures are used for training and testing (Le and Zuidema, 2015; Li et al., 2015; Zhu et al., 2015; Tai et al., 2015). Accuracies are evaluated for both the sentence root labels and phrase labels.\nQuestion Type Classification. For the question type classification task, we use the TREC data (Li and Roth, 2002). Each training sample in this dataset contains a question sentence and its corresponding question type. We work on the sixway coarse classification task, where the six question types are ENTY, HUM, LOC, DESC, NUM and ABBR, corresponding to ENTITY, HUMAN, LOCATION, DESCRIPTION, NUMERIC VALUE and ABBREVIATION, respectively. For example, the type for the sentence “What year did the Titanic sink?” is NUM. The training set consists of 5,452 examples and the test set contains 500 examples. Since there is no development set, we follow Zhou et al. (2015), randomly extracting 500 examples from the training set as a development set. Unlike the sentiment treebank, there is no annotated tree for each sentence. Instead, we obtain an automatically parsed tree for each sentence using ZPar4 off-the-shelf (Zhang and Clark, 2011). Another difference between the TREC data and the sentiment treebank is that there is only one label, at the root node, rather than a label for each phrase."
  }, {
    "heading": "7.2 Baselines",
    "text": "We consider two models for our baselines. The first is bidirectional LSTM (BiLSTM) (Hochreiter and Schmidhuber, 1997; Graves et al., 2013). Our bidirectional constituency Tree LSTM (BiConTree) is compared against BiLSTM to investigate the effectiveness of tree structures. For the sentiment task, following Tai et al. (2015) and Li et al. (2015), we convert the treebank into sequences to allow the bidirectional LSTM model to make use of every phrase span as a training example. The second baseline model is the bottom-up Tree LSTM model of Zhu et al. (2015). We compare this model with our lexicalized bidirectional models to show the effects of adding head lexicalization and top-down information flow.\n4https://github.com/SUTDNLP/ZPar, version 7.5"
  }, {
    "heading": "7.3 Main Results",
    "text": "Table 1 shows the main results for the sentiment classification task, where RNTN is the recursive neural tensor model of Socher et al. (2013b), ConTree and DepTree denote constituency Tree LSTMs and dependency Tree LSTMs, respectively. Our reimplementations of sequential bidirectional LSTM and constituent Tree LSTM (Zhu et al., 2015) give comparable results to the original implementations.\nAfter incorporating head lexicalization into our constituent Tree LSTM, the fine-grained sentiment classification accuracy increases from 51.2 to 52.8, and the binary sentiment classification accuracy increases from 88.5 to 89.2, which demonstrates the effectiveness of the head lexicalization mechanism.\nTable 1 also shows that a vanilla top-down ConTree LSTM by head-lexicalization (i.e. the topdown half of the final bidirectional model) alone obtains comparable accuracies to the bottom-up ConTree LSTM model. The BiConTree model can further improve the classification accuracies by 0.7 points (fine-grained) and 1.3 points (binary) compared to the unidirectional bottom-up lexicalized ConTree LSTM model, respectively.\nTable 1 includes 5 class accuracies for all nodes. There is no significant difference between different models, consistent with the observation of Li et al. (2015). To our knowledge, these are the best reported results for this sentiment classification task.\nTable 2 shows the question type classification results. Our final model gives better results compared\nto the BiLSTM model and the bottom-up ConTree model, achieving comparable results to the state-ofthe-art SVM classifier with carefully designed features."
  }, {
    "heading": "7.4 Training Time and Model Size",
    "text": "Introducing head lexicalization and bidirectional extension to the model increases the model complexity. In this section, we analyze training time and model size with the fine-grained sentiment classification task.\nWe run all the models using an i7-4790 3.60GHz CPU with a single thread. Table 3 shows the average running time for different models over 30 iterations. The baseline ConTree model takes about 1.3 hours to finish the training procedure. ConTree+Lex takes about 1.5 times longer than ConTree. BiConTree takes about 3.2 hours, which is about 2.5 times longer than that of ConTree.\nTable 4 compares the model sizes. We did not count the number of parameters in the lookup table since these parameters are the same for all models. Because the size of LSTM models mainly depends on the dimensionality of the state vector h, we change the size of h to study the effect of model size. When |h| = 150, the model size of the baseline model ConTree is the smallest, which consists of about 538K parameters. The model size of ConTree+Lex is about 1.4 times as large as that of the baseline model. The bidirectional model BiConTree is the largest, about 1.7 times as large as that of the ConTree+Lex model. However, this parameter set is not very large compared to the modern memory capacity, even for a computer with 16GB RAM. In conclusion, in terms of both time, number of parameters and accuracy, head lexicalization method is\na good choice. Table 4 also helps to clarify whether the gain of the BiConTree model over the ConTree+Lex model is from the top-down information flow or more parameters. For the same model, increasing the model size can improve the performance to some extent. For example, doubling the size of |h| (75 → 150) increases the performance from 51.5 to 52.8 for the ConTree+Lex model. Similarly, we boost the performance of the BiConTree model when doubling the size of |h| from 75 to 150. However, doubling the size of |h| from 150 to 300 empirically decreases the performance of the ConTree+Lex model. The size of the BiConTree model with |h| = 75 is much smaller than that of the ConTree+Lex model with |h| = 150. However the performance of these two models is quite close, which indicates that top-down information is useful even for a small model. A ConTree+Lex model with |h| = 215 and a BiConTree model with |h| = 150 are of similar size. The performance of the ConTree+Lex model is again worse than that of the BiConTree model (52.5 v.s. 53.5), which shows the effectiveness of top-down information."
  }, {
    "heading": "7.5 Head Lexicalization Methods",
    "text": "In this experiment, we investigate the effect of our head lexicalization method over heuristic baselines. We consider three baseline methods, namely left branching (L), right branching (R) and averaging (A). For L, a parent node accepts lexical information of its left child while ignoring the right child. Correspondingly, for R, a parent node accepts lexical information of its right child while ignoring the left child. For A, a parent node takes the average of the lexical vectors of its children.\nTable 5 shows the accuracies on the test set, where G denotes our gated head lexicalization method de-\nscribed in Section 4.1. R gives better results compared to L due to relatively more right-branching structures in this treebank. A simple average yields similar results compared with right branching. In contrast, G outperforms A method by considering the relative weights of each branch according to treelevel contexts.\nWe then investigate what lexical heads can be learned by G. Interestingly, the lexical heads contain both syntactic and sentiment information. Some heads correspond well to syntactic rules (Collins, 2003), others are driven by subjective words. Compared to Collins’ rules, our method found 30.68% and 25.72% overlapping heads on the development and test sets, respectively.\nBased on the cosine similarity between the head lexical vector and its children, we visualize the head of a node by choosing the head of the child that gives the largest similarity value. Figure 5 shows some examples, where <> indicates head words, sentiment labels (e.g. 2, 3) are also included. In Figure 5a, “Emerges” is the syntactic head word of the whole phrase, which is consistent with Collins-style head finding. However, “rare” is the head word of the phrase “something rare”, which is different from the syntactic head. Similar observations are found in Figure 5b, where “good” is the head word of the whole phrase, rather than the syntactic head “place”. The sentiment label of “good” and the sentiment label of the whole phrase are both 3. Figure 5c shows more complex interactions between syntax and sentiment for deciding the head word."
  }, {
    "heading": "7.6 Error Analysis",
    "text": "Table 6 shows some example sentences incorrectly predicted by the baseline bottom-up tree model, but correctly labeled by our final model. The head word of sentence #1 by our model is “Gloriously”, which is consistent with the sentiment of the whole sentence. This shows how head lexicalization can affect sentiment classification results. Sentences #2 and #3 show the usefulness of top-down informa-\ntion for complex semantic structures, where compositionality has subtle effects. Our final model improves the results for the ‘very negative’ and ‘very positive’ classes by 10% and 11%, respectively. It also boosts the accuracies for sentences with negation (e.g. “not”, “no”, and “none”) by 4.4%.\nFigure 6 shows the accuracy distribution accord-\ning to the sentence length. We find that our model can improve the classification accuracy for longer sentences (>30 words) by 3.5 absolute points compared to the baseline ConTree LSTM of Zhu et al. (2015), which demonstrates the strength of our model for handling long range information. By considering bidirectional information over tree structures, our model is aware of more contexts for making better predictions."
  }, {
    "heading": "8 Applications",
    "text": "Our main results are obtained on semanticdriven sentence classification tasks, where the automatically-learned head words contain mixed syntactic and semantic information. To further investigate the effectiveness of automatically learned head information on a pure syntactic task, we additionally conduct a simple parser reranking experiment. Further, we discuss findings in language modeling by Kuncoro et al. (2017) on the model of recurrent neural network grammars (Dyer et al., 2016). Finally, we show potential future work leveraging our idea for more tasks."
  }, {
    "heading": "8.1 Syntactic Parsing",
    "text": "We use our tree LSTM models to rerank the 10 best outputs of the Charniak (2000) parser. Given a sentence x, suppose that Y (x) is a set of parse tree candidates generated by a baseline parser for x, the goal of a syntactic reranker is to choose the best parsing hypothesis ŷ according to a score function f(x, y; Θ). Formally,\nŷ = arg maxy∈Y (x){f(x, y; Θ)} (18)\nFor each tree y of sentence x, we follow Socher et al. (2013a) and define the score f(x, y; Θ) as the sum of scores of each constituent node,\nf(x, y; Θ) = ∑\nr∈node(x,y) Score(r; Θ) (19)\nWithout loss of generality, we take a binary node as an example. Given a node A, suppose that its two children are B and C. Let the learned composition state vectors of A, B and C by our proposed TreeLSTM model be nA, nB and nC , respectively. The head word vector of node A is hA. Score(A; Θ) is defined as:\noBCA = ReLU(W L s nB +W R s nC +W H s hA + b s) ScoreBCA = log(softmax(o BC A ))[A],\n(20)\nwhere WLs , W R s and b s are model parameters. Training. Given a training instance 〈xi, Y (xi)〉 in the training set D, we use a max-margin loss function to train our reranking model. Suppose that the oracle parse tree in Y (xi) is yi, the loss function L(Θ) is\nL(Θ) = 1\n|D|\n|D|∑\ni=1\nri(Θ) + λ\n2 ||Θ||2 (21)\nHere λ is a regularization parameter and ri(Θ) is the margin loss between yi and the highest score tree ŷi predicted by the reranking model. ri(Θ) is given by\nri(Θ) = max ŷi∈Y (xi) (0, f(xi, ŷi; Θ)+\n∆(yi, ŷi)− f(xi, yi; Θ)), (22)\nwhere ∆(yi, ŷi) is the structure loss between yi and ŷi by counting the number of incorrect nodes in the oracle tree:\n∆(yi, ŷi) = ∑\nnode∈ŷi κ1{node /∈ yi}. (23)\nκ is a scalar. With this loss function, we require the score of the oracle tree to be higher than the other candidates by a score margin. Intuitively, the score of the yi will increase and the score of ŷi will decrease during training.\nResults. We experiment on the WSJ portion of the Penn Treebank, following the standard split (Collins, 2003). Sections 2-21 are used for training, Section 24 and Section 23 are the development\nset and test set, respectively. The Charniak parser (Charniak, 2000; Charniak and Johnson, 2005) is adopted for our baseline by following the settings of Choe and Charniak (2016).\nTo obtain N-best lists on the development set and test set, we first train a baseline parser on the training set. To obtain N-best lists on the training data, we split the training data into 20 folds and trained 20 parsers. Each parser was trained on 19 folds data and used to produce the n-best list of the remaining fold. For the neural reranking model, we use the pretrained word vectors from Collobert et al. (2011). The input dimension is 50. The dimension of state vectors in Tree-LSTM model is 60. These parameters are trained with ADAM (Kingma and Ba, 2015) with a batch size of 20. We set κ = 0.1 for all experiments. For practical reasons, we use the ConTree+Lex model to learn the node representations and define Y (xi) to be the 10-best parsing trees of xi.\nTable 7 shows the reranking results on WSJ test set. The baseline F1 score is 89.7. Our ConTree improves the baseline model to 90.6. Using ConTree+Lex model can further improve the performance (90.6 → 90.9). This suggests that automatic heads can also be useful for a syntactic task. Among neural rerankers, our model outperforms Socher et al. (2013a), but underperforms current state-of-theart models, including sequence-to-sequence based LSTM language models (Vinyals et al., 2015a; Choe and Charniak, 2016) and recurrent neural network grammars (Dyer et al., 2016). This is likely due to our simple reranking configurations and settings5. Nevertheless, it serves our goal of contrasting the tree LSTM models."
  }, {
    "heading": "8.2 Language Modeling",
    "text": "Kuncoro et al. (2017) investigate composition functions in recurrent neural network grammars (RNNG) (Dyer et al., 2016), finding that syntactic head information can be automatically learned. Their observa-\n5Dyer et al. (2016) employs 2-layerd LSTMs with input and hidden dimensions of size 256 and 128. Choe and Charniak (2016) use 3-layered LSTMs with both the input and hidden dimensions of size 1500. In addition, we only use the tree LSTM for scoring candidate parses in order to isolate the effect of tree LSTMs. In contrast, the previous works use the complex feature combinations in order to achieve high accuracies, which is different from our goal.\ntion is consistent with ours. Formally, an RNNG is a tuple 〈N,Σ, R, S,Θ〉, where N is the set of nonterminals, Σ is the set of terminals, R is a set of top-down transition-based rules, S is the start symbol and Θ is the set of model parameters. Given S, the derivation process resembles transition-based parsing, which is performed incrementally from left to right. Unlike surface language models, RNNGs model sentences with explicit grammar. Comparing naive sequence-to-sequence models of syntax (Vinyals et al., 2015a), RNNGs have the advantage of explicitly modeling syntactic composition between constituents, by combining the vector representation of child constituents into a single vector representation of their parent using a neural network. Kuncoro et al. (2017) show that such compositions are the key to the success, and further investigate several alternatives neural network structures. In particular, they compare vanilla LSTMs to attention networks when composing child constituents. Interestingly, the attention values represent syntactic heads among the child constituents to some extent. In addition, the vector constituent representation implicitly reflects constituent types. Their finding is consistent with ours in that a neural network can learn pure syntactic head information from constituent vectors."
  }, {
    "heading": "8.3 Relation Extraction",
    "text": "Our head-lexicalized tree model can be used for all tasks that require representation learning for sentences, given their constituent syntax. One example of future work is relation extraction. For example, given the sentence “John is from Google Inc.”, a relation ‘works in’ can be extracted between ‘John’ and ‘Google Inc.’.\nMiwa and Bansal (2016) solve this task by using the Child-Sum tree representation of Tai et al. (2015) to represent the input sentence, extracting features for the two entities according to their related nodes in the dependency tree, and then conducting rela-\ntion classification based on these features. Headlexicalization and top-down information can potentially be useful for improving relation extraction in the framework of Miwa and Bansal (2016)."
  }, {
    "heading": "9 Conclusion",
    "text": "We proposed lexicalized variants for constituent tree LSTMs. Learning the heads of constituents automatically using a neural model, our lexicalized tree LSTM is applicable to arbitrary binary branching trees in CFG, and is formalism-independent. In addition, lexical information on the root further allows a top-down extension to the model, resulting in a bidirectional constituent Tree LSTM. Experiments on two well-known datasets show that head-lexicalization improves the unidirectional Tree LSTM model. In addition, the bidirectional Tree LSTM gives superior labeling results compared to both unidirectional Tree LSTMs and bidirectional sequential LSTMs."
  }, {
    "heading": "Acknowledgments",
    "text": "We thank the anonymous reviewers for their detailed and constructive comments. Yue Zhang is the corresponding author."
  }],
  "year": 2017,
  "references": [{
    "title": "Neural machine translation by jointly learning to align and translate",
    "authors": ["Dzmitry Bahdanau", "Kyunghyun Cho", "Yoshua Bengio."],
    "venue": "Proceedings of the 2016 International Conference on Learning Representations, San Diego, California, USA, May.",
    "year": 2015
  }, {
    "title": "Coarse-tofine n-best parsing and MaxEnt discriminative reranking",
    "authors": ["Eugene Charniak", "Mark Johnson."],
    "venue": "Proceedings of the 43rd Annual Meeting of the Association for Computational Linguistics, pages 173–180, Ann Arbor, Michigan, USA, June. Associa-",
    "year": 2005
  }, {
    "title": "A maximum-entropy-inspired parser",
    "authors": ["Eugene Charniak."],
    "venue": "Proceedings of the 1st North American chapter of the Association for Computational Linguistics conference, pages 132–139, Seattle, Washington, April. Association for Computational Linguistics.",
    "year": 2000
  }, {
    "title": "Sentence modeling with gated recursive neural network",
    "authors": ["Xinchi Chen", "Xipeng Qiu", "Chenxi Zhu", "Shiyu Wu", "Xuanjing Huang."],
    "venue": "Proceedings of the 2015 Conference on Empirical Methods in Natural 174",
    "year": 2015
  }, {
    "title": "On the properties of neural machine translation: Encoder–Decoder approaches",
    "authors": ["Kyunghyun Cho", "Bart van Merrienboer", "Dzmitry Bahdanau", "Yoshua Bengio."],
    "venue": "Proceedings of SSST-8, Eighth Workshop on Syntax, Semantics and Structure in Statisti-",
    "year": 2014
  }, {
    "title": "Parsing as language modeling",
    "authors": ["Do Kook Choe", "Eugene Charniak."],
    "venue": "Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pages 2331–2336, Austin, Texas, USA, November. Association for Computational Lin-",
    "year": 2016
  }, {
    "title": "Parsing the WSJ using CCG and Log-Linear models",
    "authors": ["Stephen Clark", "James R. Curran."],
    "venue": "Proceedings of the 42nd Meeting of the Association for Computational Linguistics, pages 103–110, Barcelona, Spain, July. Association for Computational",
    "year": 2004
  }, {
    "title": "Head-driven statistical models for natural language parsing",
    "authors": ["Michael Collins."],
    "venue": "Computational linguistics, 29(4):589–637.",
    "year": 2003
  }, {
    "title": "A unified architecture for natural language processing: Deep neural networks with multitask learning",
    "authors": ["Ronan Collobert", "Jason Weston."],
    "venue": "Proceedings of the 25th international conference on Machine learning, pages 160–167, New York, NY, USA, July. ACM.",
    "year": 2008
  }, {
    "title": "Transitionbased dependency parsing with stack long short-term memory",
    "authors": ["Chris Dyer", "Miguel Ballesteros", "Wang Ling", "Austin Matthews", "Noah A. Smith."],
    "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics",
    "year": 2015
  }, {
    "title": "Recurrent neural network grammars",
    "authors": ["Chris Dyer", "Adhiguna Kuncoro", "Miguel Ballesteros", "Noah A. Smith."],
    "venue": "Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Tech-",
    "year": 2016
  }, {
    "title": "Finding structure in time",
    "authors": ["Jeffrey L. Elman."],
    "venue": "Cognitive science, 14(2):179–211.",
    "year": 1990
  }, {
    "title": "Recurrent nets that time and count",
    "authors": ["Felix A. Gers", "Jürgen Schmidhuber."],
    "venue": "Proceedings of the 2000 International Joint Conference on Neural Networks, pages 189–194, Como, Italy, July. IEEE.",
    "year": 2000
  }, {
    "title": "Hybrid speech recognition with deep",
    "authors": ["Alex Graves", "Navdeep Jaitly", "Abdel-rahman Mohamed"],
    "year": 2013
  }, {
    "title": "LSTM: A search space odyssey",
    "authors": ["Klaus Greff", "Rupesh Kumar Srivastava", "Jan Koutnı́k", "Bas R. Steunebrink", "Jürgen Schmidhuber"],
    "venue": "IEEE Transactions on Neural Networks and Learning Systems,",
    "year": 2017
  }, {
    "title": "Long short-term memory",
    "authors": ["Sepp Hochreiter", "Jürgen Schmidhuber."],
    "venue": "Neural computation, 9(8):1735– 1780.",
    "year": 1997
  }, {
    "title": "Grid long short-term memory",
    "authors": ["Nal Kalchbrenner", "Ivo Danihelka", "Alex Graves."],
    "venue": "Proceedings of the 2016 International Conference on Learning Representations, San Juan, Puerto Rico, May.",
    "year": 2016
  }, {
    "title": "Adam: A method for stochastic optimization",
    "authors": ["Diederik Kingma", "Jimmy Ba."],
    "venue": "Proceedings of the 2015 International Conference on Learning Representations, San Diego, USA, May.",
    "year": 2015
  }, {
    "title": "Accurate unlexicalized parsing",
    "authors": ["Dan Klein", "Christopher D. Manning."],
    "venue": "Proceedings of the 41st Annual Meeting of the Association for Computational Linguistics, pages 423–430, Sapporo, Japan, July. Association for Computational Linguistics.",
    "year": 2003
  }, {
    "title": "What do recurrent neural network grammars learn about syntax",
    "authors": ["Adhiguna Kuncoro", "Miguel Ballesteros", "Lingpeng Kong", "Chris Dyer", "Graham Neubig", "Noah A. Smith"],
    "venue": "In Proceedings of the 15th Conference of the European Chapter of the Association",
    "year": 2017
  }, {
    "title": "The insideoutside recursive neural network model for dependency parsing",
    "authors": ["Phong Le", "Willem Zuidema."],
    "venue": "Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing, pages 729–739, Doha, Qatar, October. Associa-",
    "year": 2014
  }, {
    "title": "Compositional distributional semantics with long short term memory",
    "authors": ["Phong Le", "Willem Zuidema."],
    "venue": "Proceedings of the Fourth Joint Conference on Lexical and Computational Semantics, pages 10–19, Denver, Colorado, USA, June. Association for Computa-",
    "year": 2015
  }, {
    "title": "Learning question classifiers",
    "authors": ["Xin Li", "Dan Roth."],
    "venue": "Proceedings of the 19th International Conference on Computational linguistics, pages 1–7, Taipei, Taiwan, August. Association for Computational Linguistics.",
    "year": 2002
  }, {
    "title": "When are tree structures necessary for deep learning of representations",
    "authors": ["Jiwei Li", "Thang Luong", "Dan Jurafsky", "Eduard Hovy"],
    "venue": "In Proceedings of the 2015 Conference on Empirical Methods in Natural",
    "year": 2015
  }, {
    "title": "Gated graph sequence neural networks",
    "authors": ["Yujia Li", "Daniel Tarlow", "Marc Brockschmidt", "Richard S. Zemel."],
    "venue": "Proceedings of the 2016 International Conference on Learning Representations, San Juan, Puerto Rico, May.",
    "year": 2016
  }, {
    "title": "Recurrent neural network based language model",
    "authors": ["Tomas Mikolov", "Martin Karafiát", "Lukas Burget", "Jan Cernockỳ", "Sanjeev Khudanpur."],
    "venue": "Proceedings of the 11th Annual Conference of the International Speech Communication Association, pages",
    "year": 2010
  }, {
    "title": "Efficient estimation of word representations in vector space",
    "authors": ["Tomas Mikolov", "Kai Chen", "Greg Corrado", "Jeffrey Dean."],
    "venue": "Workshop Proceedings of the 2013 International Conference on Learning Representations, Scottsdale, Arizona, USA, May.",
    "year": 2013
  }, {
    "title": "End-to-End relation extraction using LSTMs on sequences and tree structures",
    "authors": ["Makoto Miwa", "Mohit Bansal."],
    "venue": "Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics, pages 1105–1116, Berlin, Germany, August. Associa-",
    "year": 2016
  }, {
    "title": "Global belief recursive neural networks",
    "authors": ["Romain Paulus", "Richard Socher", "Christopher D. Manning."],
    "venue": "Advances in Neural Information Processing Systems, pages 2888–2896, Montreal, Quebec, Canada, December.",
    "year": 2014
  }, {
    "title": "From symbolic to sub-symbolic information in question classification",
    "authors": ["Joao Silva", "Luı́sa Coheur", "Ana Cristina Mendes", "Andreas Wichert"],
    "venue": "Artificial Intelligence Review,",
    "year": 2011
  }, {
    "title": "Parsing natural scenes and natural language with recursive neural networks",
    "authors": ["Richard Socher", "Cliff C. Lin", "Andrew Y. Ng", "Christopher D. Manning."],
    "venue": "Proceedings of the 26th International Conference on Machine Learning, pages 129–136, Bellevue, Wash-",
    "year": 2011
  }, {
    "title": "Parsing with compositional vector grammars",
    "authors": ["Richard Socher", "John Bauer", "Christopher D. Manning", "Andrew Y. Ng."],
    "venue": "Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics, pages 455–465, Sofia, Bulgaria, August.",
    "year": 2013
  }, {
    "title": "Recursive deep models for semantic compositionality over a sentiment treebank",
    "authors": ["Richard Socher", "Alex Perelygin", "Jean Wu", "Jason Chuang", "Christopher D. Manning", "Andrew Y. Ng", "Christopher Potts."],
    "venue": "Proceedings of the 2013 Conference on Empirical Meth-",
    "year": 2013
  }, {
    "title": "Dropout: A simple way to prevent neural networks from overfitting",
    "authors": ["Nitish Srivastava", "Geoffrey Hinton", "Alex Krizhevsky", "Ilya Sutskever", "Ruslan Salakhutdinov."],
    "venue": "The Journal of Machine Learning Research, 15(1):1929–1958.",
    "year": 2014
  }, {
    "title": "Sequence to sequence learning with neural networks",
    "authors": ["Ilya Sutskever", "Oriol Vinyals", "Quoc V. Le."],
    "venue": "Advances in Neural Information Processing Systems, pages 3104–3112, Montreal, Quebec, Canada, December.",
    "year": 2014
  }, {
    "title": "Improved semantic representations from tree-structured long short-term memory networks",
    "authors": ["Kai Sheng Tai", "Richard Socher", "Christopher D. Manning."],
    "venue": "Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th Inter-",
    "year": 2015
  }, {
    "title": "Context-sensitive lexicon features for neural sentiment analysis",
    "authors": ["Zhiyang Teng", "Vo Duy-Tin", "Yue Zhang."],
    "venue": "Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pages 1629–1638, Austin, Texas, USA, November.",
    "year": 2016
  }, {
    "title": "Generative image modeling using spatial LSTMs",
    "authors": ["Lucas Theis", "Matthias Bethge."],
    "venue": "Advances in Neural Information Processing Systems, pages 1918– 1926, Montreal, Quebec, Canada, December.",
    "year": 2015
  }, {
    "title": "Grammar as a foreign language",
    "authors": ["Oriol Vinyals", "Łukasz Kaiser", "Terry Koo", "Slav Petrov", "Ilya Sutskever", "Geoffrey Hinton."],
    "venue": "Advances in Neural Information Processing Systems, pages 2755–2763, Montreal, Quebec, Canada, December.",
    "year": 2015
  }, {
    "title": "Show and tell: A neural image caption generator",
    "authors": ["Oriol Vinyals", "Alexander Toshev", "Samy Bengio", "Dumitru Erhan."],
    "venue": "Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 3156–3164, Boston, MA, USA, June.",
    "year": 2015
  }, {
    "title": "Transitionbased parsing of the chinese treebank using a global discriminative model",
    "authors": ["Yue Zhang", "Stephen Clark."],
    "venue": "Proceedings of the 11th International Conference on Parsing Technologies, pages 162–171, Paris, France, October. Association",
    "year": 2009
  }, {
    "title": "Syntactic processing using the generalized perceptron and beam search",
    "authors": ["Yue Zhang", "Stephen Clark."],
    "venue": "Computational linguistics, 37(1):105–151.",
    "year": 2011
  }, {
    "title": "Top-down tree long short-term memory networks",
    "authors": ["Xingxing Zhang", "Liang Lu", "Mirella Lapata."],
    "venue": "Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies,",
    "year": 2016
  }, {
    "title": "A C-LSTM neural network for text classification",
    "authors": ["Chunting Zhou", "Chonglin Sun", "Zhiyuan Liu", "Francis C.M. Lau."],
    "venue": "arXiv preprint arXiv:1301.3781.",
    "year": 2015
  }, {
    "title": "Long short-term memory over recursive structures",
    "authors": ["Xiaodan Zhu", "Parinaz Sobhani", "Hongyu Guo."],
    "venue": "Proceedings of the 32nd International Conference on Machine Learning, pages 1604–1612, Lille, France, July.",
    "year": 2015
  }],
  "id": "SP:c485b7e7b3f3c7cac63133722b76744db88fa4a9",
  "authors": [{
    "name": "Zhiyang Teng",
    "affiliations": []
  }, {
    "name": "Yue Zhang",
    "affiliations": []
  }],
  "abstractText": "Sequential LSTMs have been extended to model tree structures, giving competitive results for a number of tasks. Existing methods model constituent trees by bottom-up combinations of constituent nodes, making direct use of input word information only for leaf nodes. This is different from sequential LSTMs, which contain references to input words for each node. In this paper, we propose a method for automatic head-lexicalization for tree-structure LSTMs, propagating head words from leaf nodes to every constituent node. In addition, enabled by head lexicalization, we build a tree LSTM in the top-down direction, which corresponds to bidirectional sequential LSTMs in structure. Experiments show that both extensions give better representations of tree structures. Our final model gives the best results on the Stanford Sentiment Treebank and highly competitive results on the TREC question type classification task.",
  "title": "Head-Lexicalized Bidirectional Tree LSTMs"
}