{
  "sections": [{
    "text": "Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 1173–1182 Brussels, Belgium, October 31 - November 4, 2018. c©2018 Association for Computational Linguistics\n1173"
  }, {
    "heading": "1 Introduction",
    "text": "Conditional neural sequence modeling has become a de facto standard in a variety of tasks (see, e.g., Cho et al., 2015, and references therein). Much of this recent success is built on top of autoregressive sequence models in which the probability of a target sequence is factorized as a product of conditional probabilities of next symbols given all the preceding ones. Despite its success, neural autoregressive modeling has its weakness in decoding, i.e., finding the most likely sequence. Because of intractability, we must resort to suboptimal approximate decoding, and due to its sequential nature, decoding cannot be easily parallelized and results in a large latency (see, e.g., Cho, 2016). This has motivated the recent investigation into non-autoregressive neural sequence modeling by Gu et al. (2017) in the context of machine translation and Oord et al. (2017) in the context of speech synthesis.\nIn this paper, we propose a non-autoregressive neural sequence model based on iterative refinement, which is generally applicable to any sequence generation task beyond machine translation. The proposed model can be viewed as both\n⇤ Equal Contribution\na latent variable model and a conditional denoising autoencoder. We thus propose a learning algorithm that is hybrid of lowerbound maximization and reconstruction error minimization. We further design an iterative inference strategy with an adaptive number of steps to minimize the generation latency without sacrificing the generation quality.\nWe extensively evaluate the proposed conditional non-autoregressive sequence model and compare it against the autoregressive counterpart, using the state-of-the-art Transformer (Vaswani et al., 2017), on machine translation and image caption generation. In the case of machine translation, the proposed deterministic nonautoregressive models are able to decode approximately 2 3⇥ faster than beam search from the autoregressive counterparts on both GPU and CPU, while maintaining 90-95% of translation quality on IWSLT’16 En$De, WMT’16 En$Ro and WMT’14 En$De. On image caption generation, we observe approximately 3⇥ and 5⇥ faster decoding on GPU and CPU, respectively, while maintaining 85% of caption quality.1"
  }, {
    "heading": "2 Non-Autoregressive Sequence Models",
    "text": "Sequence modeling in deep learning has largely focused on autoregressive modeling. That is, given a sequence Y = (y1, . . . , yT ), we use some form of a neural network to parametrize the conditional distribution over each variable yt given all the preceding variables, i.e.,\nlog p(yt|y<t) = f✓(y<t),\nwhere f✓ is for instance a recurrent neural network. This approach has become a de facto standard in language modeling (Mikolov et al.,\n1 We release the implementation, preprocessed datasets as well as trained models online at https://github.com/ nyu-dl/dl4mt-nonauto.\n2010). When this is conditioned on an extra variable X , it becomes a conditional sequence model log p(Y |X) which serves as a basis on which many recent advances in, e.g., machine translation (Bahdanau et al., 2014; Sutskever et al., 2014; Kalchbrenner and Blunsom, 2013) and speech recognition (Chorowski et al., 2015; Chiu et al., 2017) have been made.\nDespite the recent success, autoregressive sequence modeling has a weakness due to its nature of sequential processing. This weakness shows itself especially when we try to decode the most likely sequence from a trained model, i.e.,\nˆ Y = argmax Y log p(Y |X).\nThere is no known polynomial algorithm for solving it exactly, and practitioners have relied on approximate decoding algorithms (see, e.g., Cho, 2016; Hoang et al., 2017). Among these, beam search has become the method of choice, due to its superior performance over greedy decoding, which however comes with a substantial computational overhead (Cho, 2016).\nAs a solution to this issue of slow decoding, two recent works have attempted non-autoregressive sequence modeling. Gu et al. (2017) have modified the Transformer (Vaswani et al., 2017) for non-autoregressive machine translation, and Oord et al. (2017) a convolutional network (Oord et al., 2016) for non-autoregressive modeling of waveform. Non-autoregressive modeling factorizes the distribution over a target sequence given a source into a product of conditionally independent perstep distributions:\np(Y |X) = TY\nt=1\np(yt|X),\nbreaking the dependency among the target variables across time. This allows us to trivially find the most likely target sequence by taking argmaxyt p(yt|X) for each t, effectively bypassing the computational overhead and suboptimality of decoding from an autoregressive sequence model.\nThis desirable property of exact and parallel decoding however comes at the expense of potential performance degradation (Kaiser and Bengio, 2016). The potential modeling gap, which is the gap between the underlying, true model and the neural sequence model, could be larger with the\nnon-autogressive model compared to the autoregressive one due to challenge of modeling the factorized conditional distribution above."
  }, {
    "heading": "3 Iterative Refinement for Deterministic Non-Autoregressive Sequence Models",
    "text": ""
  }, {
    "heading": "3.1 Latent variable model",
    "text": "Similarly to two recent works (Oord et al., 2017; Gu et al., 2017), we introduce latent variables to implicitly capture the dependencies among target variables. We however remove any stochastic behavior by interpreting this latent variable model, introduced immediately below, as a process of iterative refinement.\nOur goal is to capture the dependencies among target symbols given a source sentence without auto-regression by introducing L intermediate random variables and marginalizing them out:\np(Y |X) = X\nY 0,...,Y L\nTY\nt=1\np(yt|Y L, X) !\n(1)\nTY\nt=1\np(y L t |Y L 1, X)\n! · · · TY\nt=1\np(y 0 t |X)\n! .\nEach product term inside the summation is modelled by a deep neural network that takes as input a source sentence and outputs the conditional distribution over the target vocabulary V for each t.\nDeterministic Approximation The marginalization in Eq. (1) is intractable. In order to avoid this issue, we consider two approximation strategies; deterministic and stochastic approximation. Without loss of generality, let us consider the case of single intermediate latent variable, that is L = 1. In the deterministic case, we set ŷ0t to the most likely value according to its distribution p(y0t |X), that is ŷ0t = argmaxy0t p(y 0 t |X). The entire lower bound can then be written as:\nlog p(Y |X)\nTX\nt=1\nlog p(yt| ˆY L, X) ! + · · ·\n+\nTX\nt=1\nlog p(y 1 t | ˆY 0, X)\n! + TX\nt=1\nlog p(ŷ 0 t |X)\n! .\nStochastic Approximation In the case of stochastic approximation, we instead sample ŷ0t from the distribution p(y0t |X). This results in the unbiased estimate of the marginal log-probability log p(Y |X). Other than the difference in whether\nmost likely values or samples are used, the remaining steps are identical.\nLatent Variables Although the intermediate random variables could be anonymous, we constrain them to be of the same type as the output Y is, in order to share an underlying neural network. This constraint allows us to view each conditional p(Y\nl| ˆY l 1, X) as a single-step of refinement of a rough target sequence ˆY l 1. The entire chain of L conditionals is then the L-step iterative refinement. Furthermore, sharing the parameters across these refinement steps enables us to dynamically adapt the number of iterations per input X . This is important as it substantially reduces the amount of time required for decoding, as we see later in the experiments.\nTraining For each training pair (X,Y ⇤), we first approximate the marginal log-probability. We then minimize\nJLVM(✓) = L+1X\nl=0\nTX\nt=1\nlog p✓(y ⇤ t | ˆY l 1, X)\n! ,\n(2)\nwhere ˆY l 1 = (ŷl 11 , . . . , ŷ l 1 T ), and ✓ is a set of parameters. We initialize ŷ0t (t-th target word in the first iteration) as xt0 , where t0 = (T 0/T ) · t. T 0 and T are the lengths of the source X and target Y ⇤, respectively."
  }, {
    "heading": "3.2 Denoising Autoencoder",
    "text": "The proposed approach could instead be viewed as learning a conditional denoising autoencoder which is known to capture the gradient of the logdensity. That is, we implicitly learn to find a direction Y in the output space that maximizes the underlying true, data-generating distribution logP (Y |X). Because the output space is discrete, much of the theoretical analysis by Alain and Bengio (2014) are not strictly applicable. We however find this view attractive as it serves as an alternative foundation for designing a learning algorithm.\nTraining We start with a corruption process C(Y |Y ⇤), which introduces noise to the correct output Y ⇤. Given the reference translation Y ⇤, we sample ˜Y ⇠ C(Y |Y ⇤) which becomes as an input to each conditional in Eq. (1). Then, the goal of learning is to maximize the log-probability of the original reference Y ⇤ given the corrupted version. That is, to minimize\nJDAE(✓) = TX\nt=1\nlog p✓(y ⇤ t | ˜Y ,X). (3)\nOnce this cost JDAE is minimized, we can recursively perform the maximum-a-posterior inference, i.e., ˆY = argmaxY log p✓(Y |X), to find ˆY that (approximately) maximizes log p(Y |X).\nCorruption Process C There is little consensus on the best corruption process for a sequence, especially of discrete tokens. In this work, we use a corruption process proposed by Hill et al. (2016), which has recently become more widely adopted (see, e.g., Artetxe et al., 2017; Lample et al., 2017). Each y⇤t in a reference target Y ⇤ = (y\n⇤ 1, . . . , y ⇤ T ) is corrupted with a probability\n2 [0, 1]. If decided to corrupt, we either (1) replace y⇤t+1 with this token y⇤t , (2) replace y⇤t with a token uniformly selected from a vocabulary of all unique tokens at random, or (3) swap y⇤t and y⇤t+1. This is done sequentially from y⇤1 until y⇤T ."
  }, {
    "heading": "3.3 Learning",
    "text": "Cost function Although it is possible to train the proposed non-autoregressive sequence model using either of the cost functions above (JLVM or JDAE,) we propose to stochastically mix these two cost functions. We do so by randomly replacing each term ˆY l 1 in Eq. (2) with ˜Y in Eq. (3):\nJ(✓) = L+1X\nl=0\n↵l\nTX\nt=1\nlog p✓(y ⇤ t | ˆY l 1, X) (4)\n+(1 ↵l) TX\nt=1\nlog p✓(y ⇤ t | ˜Y ,X)\n! ,\nwhere ˜Y ⇠ C(Y |Y ⇤), and ↵l is a sample from a Bernoulli distribution with the probability pDAE. pDAE is a hyperparameter. As the first conditional p(Y\n0|X) in Eq. (1) does not take as input any target Y , we set ↵0 = 1 always.\nDistillation Gu et al. (2017), in the context of machine translation, and Oord et al. (2017), in the context of speech generation, have recently discovered that it is important to use knowledge distillation (Hinton et al., 2015; Kim and Rush, 2016) to successfully train a non-autoregressive sequence model. Following Gu et al. (2017), we also use knowledge distillation by replacing the reference target Y ⇤ of each training example\n(X,Y ⇤ ) with a target Y AR generated from a welltrained autoregressive counterpart. Other than this replacement, the cost function in Eq (4) and the model architecture remain unchanged.\nTarget Length Prediction One difference between the autoregressive and non-autoregressive models is that the former naturally models the length of a target sequence without any arbitrary upper-bound, while the latter does not. It is hence necessary to separately model p(T |X), where T is the length of a target sequence, although during training, we simply use the length of each reference target sequence."
  }, {
    "heading": "3.4 Inference: Decoding",
    "text": "Inference in the proposed approach is entirely deterministic. We start from the input X and first predict the length of the target sequence ˆT = argmaxT log p(T |X). Then, given X and ˆT we generate the initial target sequence by ŷ0t = argmaxyt log p(y0t |X), for t = 1, . . . , T We continue refining the target sequence by ŷlt = argmaxyt log p(ylt| ˆY l 1, X), for t = 1, . . . , T .\nBecause these conditionals, except for the initial one, are modeled by a single, shared neural network, this refinement can be performed as many iterations as necessary until a predefined stopping criterion is met. A criterion can be based either on the amount of change in a target sequence after each iteration (i.e., D( ˆY l 1, ˆY l)  ✏), or on the amount of change in the conditional log-probabilities (i.e., | log p( ˆY l 1|X) log p( ˆY l 1|X)|  ✏) or on the computational budget. In our experiments, we use the first criterion and use Jaccard distance as our distance function D."
  }, {
    "heading": "4 Related Work",
    "text": "Non-Autoregressive Neural Machine Translation Schwenk (2012) proposed a continuousspace translation model to estimate the conditional distribution over a target phrase given a source phrase, while dropping the conditional dependencies among target tokens. The evaluation was however limited to reranking and to short phrase pairs (up to 7 words on each side) only. Kaiser and Bengio (2016) investigated neural GPU (Kaiser and Sutskever, 2015), for machine translation. They evaluated both non-autoregressive and autoregressive approaches, and found that the non-\nautoregressive approach significantly lags behind the autoregressive variants. It however differs from our approach that each iteration does not output a refined version from the previous iteration. The recent paper by Gu et al. (2017) is most relevant to the proposed work. They similarly introduced a sequence of discrete latent variables. They however use supervised learning for inference, using the word alignment tool (Dyer et al., 2013). To achieve the best result, Gu et al. (2017) stochastically sample the latent variables and rerank the corresponding target sequences with an external, autoregressive model. This is in contrast to the proposed approach which is fully deterministic during decoding and does not rely on any extra reranking mechanism.\nParallel WaveNet Simultaneously with Gu et al. (2017), Oord et al. (2017) presented a nonautoregressive sequence model for speech generation. They use inverse autoregressive flow (IAF, Kingma et al., 2016) to map a sequence of independent random variables to a target sequence. They apply the IAF multiple times, similarly to our iterative refinement strategy. Their approach is however restricted to continuous target variables, while the proposed approach in principle could be applied to both discrete and continuous variables.\nPost-Editing for Machine Translation Novak et al. (2016) proposed a convolutional neural network that iteratively predicts and applies token substitutions given a translation from a phasebased translation system. Unlike their system, our approach can edit an intermediate translation with a higher degree of freedom. QuickEdit (Grangier and Auli, 2017) and deliberation network (Xia et al., 2017) incorporate the idea of refinement into neural machine translation. Both systems consist of two autoregressive decoders. The second decoder takes into account the translation generated by the first decoder. We extend these earlier efforts by incorporating more than one refinement steps without necessitating extra annotations.\nInfusion Training Bordes et al. (2017) proposed an unconditional generative model for images based on iterative refinement. At each step l of iterative refinement, the model is trained to maximize the log-likelihood of target Y given the weighted mixture of generated samples from the previous iteration ˆY l 1 and a corrupted target ˜Y . That is, the corrupted version of target is “infused”\n(a) (b)\n10\n2). The x-axis is in the logarithmic scale. (b) the decoding latencies (sec/sentence) of different approaches on IWSLT’16 En!De. The y-axis is in the logarithmic scale.\nSrc Attention\nPos Attention\nSelf Attention\nSource\nLinear\nSoftmax\nFeedforward\nSrc Attention\nPos Attention\nSelf Attention\nPrev Output\nLinear\nSoftmax\nLoss\nx N\nEncoder Decoder 1 Decoder 2\nLoss\ncopy\nargmax embed\nx K Self Attention\nFeedforward\nSource\nFeedforward\npositional encoding\nx N x N\nargmax embed\nSoftmax\nLoss (target length)\nstop gradient\nFigure 2: We compose three transformer blocks (“Encoder”, “Decoder 1” and “Decoder 2”) to implement the proposed non-autoregressive sequence model.\ninto generated samples during training. In the domain of text, however, computing a weighted mixture of two sequences of discrete tokens is not well defined, and we propose to stochastically mix denoising and lowerbound maximization objectives."
  }, {
    "heading": "5 Network Architecture",
    "text": "We use three transformer-based network blocks to implement our model. The first block (“Encoder”) encodes the input X , the second block (“Decoder 1”) models the first conditional log p(Y\n0|X), and the final block (“Decoder 2”) is shared across iterative refinement steps, modeling log p(Y l| ˆY l 1, X). These blocks are depicted side-by-side in Fig. 2. The encoder is identical to that from the original Transformer (Vaswani et al., 2017). We however use the decoders from Gu et al. (2017) with additional positional attention and use the highway layer (Srivastava et al., 2015) instead of the residual layer (He et al., 2016).\nThe original input X is padded or shortned to fit the length of the reference target sequence before being fed to Decoder 1. At each refinement step l, Decoder 2 takes as input the predicted target sequence ˆY l 1 and the sequence of final activation vectors from the previous step."
  }, {
    "heading": "6 Experimental Setting",
    "text": "We evaluate the proposed approach on two sequence modeling tasks: machine translation and image caption generation. We compare the proposed non-autoregressive model against the autoregressive counterpart both in terms of generation quality, measured in terms of BLEU (Papineni et al., 2002), and generation efficiency, measured in terms of (source) tokens and images per second for translation and image captioning, respectively.\nMachine Translation We choose three tasks of different sizes: IWSLT’16 En$De (196k pairs), WMT’16 En$Ro (610k pairs) and WMT’14 En$De (4.5M pairs). We tokenize each sentence using a script from Moses (Koehn et al., 2007) and segment each word into subword units using BPE (Sennrich et al., 2016). We use 40k tokens from both source and target for all the tasks. For WMT’14 En-De, we use newstest-2013 and newstest-2014 as development and test sets. For WMT’16 En-Ro, we use newsdev-2016 and newstest-2016 as development and test sets. For IWSLT’16 En-De, we use test2013 for validation.\nWe closely follow the setting by Gu et al. (2017). In the case of IWSLT’16 En-De, we use the small model (dmodel = 278, dhidden = 507, pdropout = 0.1, nlayer = 5 and nhead = 2).2 For WMT’14 En-De and WMT’16 En-Ro, we use the base transformer by Vaswani et al. (2017) (dmodel = 512, dhidden = 512, pdropout = 0.1, nlayer = 6 and nhead = 8). We use the warm-up learning rate scheduling (Vaswani et al., 2017) for the WMT tasks, while using linear annealing (from 3 ⇥ 10 4 to 10 5) for the IWSLT task. We do not use label smoothing nor average multiple check-pointed models. These decisions were made based on the preliminary experiments. We train each model either on a single\n2 Due to the space constraint, we refer readers to (Vaswani et al., 2017; Gu et al., 2017) for more details.\nP40 (WMT’14 En-De and WMT’16 En-Ro) or on a single P100 (IWSLT’16 En-De) with each minibatch consisting of approximately 2k tokens. We use four P100’s to train non-autoregressive models on WMT’14 En-De.\nImage Caption Generation: MS COCO We use MS COCO (Lin et al., 2014). We use the publicly available splits (Karpathy and Li, 2015), consisting of 113,287 training images, 5k validation images and 5k test images. We extract 49 512-dimensional feature vectors for each image, using a ResNet-18 (He et al., 2016) pretrained on ImageNet (Deng et al., 2009). The average of these vectors is copied as many times to match the length of the target sentence (reference during training and predicted during evaluation) to form the initial input to Decoder 1. We use the base transformer (Vaswani et al., 2017) except that nlayer is set to 4. We train each model on a single 1080ti with each minibatch consisting of approximately 1,024 tokens.\nTarget Length Prediction We formulate the target length prediction as classification, predicting the difference between the target and source lengths for translation and the target length for image captioning. All the hidden vectors from the nlayer layers of the encoder are summed and fed to a softmax classifier after affine transformation. We however do not tune the encoder’s parameters for target length prediction. We use this length predictor only during test time. We find it important to accurately predict the target length for good overall performance. See Appendix A for an analysis on our length prediction model.\nTraining and Inference We use Adam (Kingma and Ba, 2014) and use L = 3 in Eq. (1) during training (itrain = 4 from hereon.) We use pDAE = 0.5. We use the deterministic strategy for IWSLT’16 En-De, WMT’16 En-Ro and MS COCO, while the stochastic strategy is used for WMT’14 En-De. These decisions were made based on the validation set performance. After both the non-autogressive sequence model and target length predictor are trained, we decode by first predicting the target length and then running iterative refinement steps until the outputs of consecutive iterations are the same (or Jaccard distance between consecutive decoded sequences is 1). To assess the effectiveness of this adaptive scheme, we also test a fixed number of steps (idec). In machine translation, we remove any repetition by collapsing multiple consecutive occurrences of a token."
  }, {
    "heading": "7 Results and Analysis",
    "text": "We make some important observations in Table 1. First, the generation quality improves across all the tasks as we run more refinement steps idec even beyond that used in training (itrain = 4), which supports our interpretation as a conditional denoising autoencoder in Sec. 3.2. To further verify this, we run decoding on WMT’14 (both directions) up to 100 iterations. As shown in Fig. 1 (a), the quality improves well beyond the number of refinement steps used during training.\nSecond, the generation efficiency decreases as more refinements are made. We plot the average seconds per sentence in Fig. 1 (b), measured on GPU while sequentially decoding one sentence at a time. As expected, decoding from the autoregressive model linearly slows down as the sen-\ntence length grows, while decoding from the nonautoregressive model with a fixed number of iterations has the constant complexity. However, the generation efficiency of non-autoregressive model decreases as more refinements are made. To make a smooth trade-off between the quality and speed, the adaptive decoding scheme allows us to achieve near-best generation quality with a significantly lower computational overhead. Moreover, the adaptive decoding scheme automatically increases the number of refinement steps as the sentence length increases, suggesting that this scheme captures the amount of information in the input well. The increase in latency is however less severe than that of the autoregressive model.\nWe also observe that the speedup in decoding is much clearer on GPU than on CPU. This is a consequence of highly parallel computation of the proposed non-autoregressive model, which is better suited to GPUs, showcasing the potential of using the non-autoregressive model with a specialized hardware for parallel computation, such as Google’s TPUs (Jouppi et al., 2017). The results of our model decoded with adaptive decoding scheme are comparable to the results from (Gu et al., 2017), without relying on any external tool. On WMT’14 En-De, the proposed model outperforms the best model from (Gu et al., 2017) by two points.\nLastly, it is encouraging to observe that the proposed non-autoregressive model works well on image caption generation. This result confirms the generality of our approach beyond machine translation, unlike that by Gu et al. (2017) which was for machine translation or by Oord et al. (2017) which was for speech synthesis.\nAblation Study We use IWSLT’16 En-De to investigate the impact of different number of refinement steps during training (denoted as itrain) as well as probability of using denoising autoencoder objective during training (denoted as pDAE). The\nresults are presented in Table 2. First, we observe that it is beneficial to use multiple iterations of refinement during training. By using four iterations (one step of decoder 1, followed by three steps of decoder 2), the BLEU score improved by approximately 1.5 points in both directions. We also notice that it is necessary to use the proposed hybrid learning strategy to maximize the improvement from more iterations during training (itrain = 4 vs. itrain = 4, pDAE = 1.0 vs. itrain = 4, pDAE = 0.5.) Knowledge distillation was crucial to close the gap between the proposed deterministic non-autoregressive sequence model and its autoregressive counterpart, echoing the observations by Gu et al. (2017) and Oord et al. (2017). Finally, we see that removing repeating consecutive symbols improves the quality of the best trained models (itrain = 4, pDAE = 0.5) by approximately +1 BLEU. This suggests that the proposed iterative refinement is not enough to remove repetitions on its own. Further investigation is necessary to properly tackle this issue, which we leave as a future work.\nWe then compare the deterministic and stochastic approximation strategies on IWSLT’16 En!De and WMT’14 En!De. According to the results in Table 3, the stochastic strategy is crucial with a large corpus (WMT’14), while the deterministic strategy works as well or better with a small corpus (IWSLT’16). Both of the strategies benefit from knowledge distillation, but the gap between the two strategies when the dataset is large is much more apparent without knowledge distillation."
  }, {
    "heading": "7.1 Qualitative Analysis",
    "text": "Machine Translation In Table 4, we present three sample translations and their iterative refinement steps from the development set of IWSLT’16 (De!En). As expected, the sequence generated from the first iteration is a rough version of translation and is iteratively refined over multiple steps. By inspecting the underlined sub-sequences, we see that each iteration does not monotonically improve the translation, but overall modifies the\nSrc seitdem habe ich sieben Häuser in der Nachbarschaft mit den Lichtern versorgt und sie funktionierenen wirklich gut . Iter 1 and I ’ve been seven homes since in neighborhood with the lights and they ’re really functional . Iter 2 and I ’ve been seven homes in the neighborhood with the lights , and they ’re a really functional . Iter 4 and I ’ve been seven homes in neighborhood with the lights , and they ’re a really functional . Iter 8 and I ’ve been providing seven homes in the neighborhood with the lights and they ’re a really functional . Iter 20 and I ’ve been providing seven homes in the neighborhood with the lights , and they ’re a very good functional . Ref since now , I ’ve set up seven homes around my community , and they ’re really working .\nSrc er sah sehr glücklich aus , was damals ziemlich ungewöhnlich war , da ihn die Nachrichten meistens deprimierten . Iter 1 he looked very happy , which was pretty unusual the , because the news was were usually depressing . Iter 2 he looked very happy , which was pretty unusual at the , because the news was s depressing . Iter 4 he looked very happy , which was pretty unusual at the , because news was mostly depressing . Iter 8 he looked very happy , which was pretty unusual at the time because the news was mostly depressing . Iter 20 he looked very happy , which was pretty unusual at the time , because the news was mostly depressing . Ref there was a big smile on his face which was unusual then , because the news mostly depressed him .\nSrc furchtlos zu sein heißt für mich , heute ehrlich zu sein . Iter 1 to be , for me , to be honest today . Iter 2 to be fearless , me , is to be honest today . Iter 4 to be fearless for me , is to be honest today . Iter 8 to be fearless for me , me to be honest today . Iter 20 to be fearless for me , is to be honest today . Ref so today , for me , being fearless means being honest .\nTable 4: Three sample De!En translations from the non-autoregressive sequence model. Source sentences are from the dev set of IWSLT’16. The first iteration corresponds to Decoder 1, and from thereon, Decoder 2 is repeatedly applied. Sub-sequences with changes across the refinement steps are underlined.\ntranslation towards the reference sentence. Missing words are added, while unnecessary words are dropped. For instance, see the second example. The second iteration removes the unnecessary “were”, and the fourth iteration inserts a new word “mostly”. The phrase “at the time” is gradually added one word at a time.\nImage Caption Generation Table 5 shows two examples of image caption generation. We observe that each iteration captures more and more details of the input image. In the first example (left), the bus was described only as a “yellow bus” in the first iteration, but the subsequent iterations refine it into “yellow and black bus”. Similarly, “road” is refined into “lot”. We notice this behavior in the second example (right) as well. The first iteration does not specify the place in which “a woman” is “standing on”, which is fixed immediately in the second iteration: “standing on a tennis court”. In the final and fourth iteration, the proposed model captures the fact that the “woman” is “holding” a racquet."
  }, {
    "heading": "8 Conclusion",
    "text": "Following on the exciting, recent success of nonautoregressive neural sequence modeling by Gu et al. (2017) and Oord et al. (2017), we proposed a deterministic non-autoregressive neural sequence model based on the idea of iterative refinement. We designed a learning algorithm specialized to the proposed approach by interpreting the entire\nmodel as a latent variable model and each refinement step as denoising.\nWe implemented our approach using the Transformer and evaluated it on two tasks: machine translation and image caption generation. On both tasks, we were able to show that the proposed nonautoregressive model performs closely to the autoregressive counterpart with significant speedup in decoding. Qualitative analysis revealed that the iterative refinement indeed refines a target sequence gradually over multiple steps.\nDespite these promising results, we observed that proposed non-autoregressive neural sequence model is outperformed by its autoregressive counterpart in terms of the generation quality. The following directions should be pursued in the future to narrow this gap. First, we should investigate better approximation to the marginal logprobability. Second, the impact of the corruption process on the generation quality must be studied. Lastly, further work on sequence-to-sequence model architectures could yield better results in non-autoregressive sequence modeling."
  }, {
    "heading": "Acknowledgement",
    "text": "We thank support by AdeptMind, eBay, TenCent and NVIDIA. This work was partly supported by Samsung Advanced Institute of Technology (Next Generation Deep Learning: from pattern recognition to AI) and Samsung Electronics (Improving Deep Learning using Latent Structure). We also thank Jiatao Gu for valuable feedback."
  }],
  "year": 2018,
  "references": [{
    "title": "What regularized auto-encoders learn from the datagenerating distribution",
    "authors": ["Guillaume Alain", "Yoshua Bengio."],
    "venue": "The Journal of Machine Learning Research, 15(1).",
    "year": 2014
  }, {
    "title": "Unsupervised neural machine translation",
    "authors": ["Mikel Artetxe", "Gorka Labaka", "Eneko Agirre", "Kyunghyun Cho."],
    "venue": "arXiv preprint arXiv:1710.11041.",
    "year": 2017
  }, {
    "title": "Neural machine translation by jointly learning to align and translate",
    "authors": ["Dzmitry Bahdanau", "Kyunghyun Cho", "Yoshua Bengio."],
    "venue": "arXiv preprint arXiv:1409.0473.",
    "year": 2014
  }, {
    "title": "Learning to generate samples from noise through infusion training",
    "authors": ["Florian Bordes", "Sina Honari", "Pascal Vincent."],
    "venue": "ICLR.",
    "year": 2017
  }, {
    "title": "State-of-the-art speech recognition with sequence-to-sequence models",
    "authors": ["Chung-Cheng Chiu", "Tara N Sainath", "Yonghui Wu", "Rohit Prabhavalkar", "Patrick Nguyen", "Zhifeng Chen", "Anjuli Kannan", "Ron J Weiss", "Kanishka Rao", "Katya Gonina"],
    "year": 2017
  }, {
    "title": "Noisy parallel approximate decoding for conditional recurrent language model",
    "authors": ["Kyunghyun Cho."],
    "venue": "arXiv preprint arXiv:1605.03835.",
    "year": 2016
  }, {
    "title": "Describing multimedia content using attention-based encoder-decoder networks",
    "authors": ["Kyunghyun Cho", "Aaron Courville", "Yoshua Bengio."],
    "venue": "IEEE Transactions on Multimedia, 17(11).",
    "year": 2015
  }, {
    "title": "Attention-based models for speech recognition",
    "authors": ["Jan K Chorowski", "Dzmitry Bahdanau", "Dmitriy Serdyuk", "Kyunghyun Cho", "Yoshua Bengio."],
    "venue": "NIPS.",
    "year": 2015
  }, {
    "title": "Imagenet: A large-scale hierarchical image database",
    "authors": ["Jia Deng", "Wei Dong", "Richard Socher", "Li-Jia Li", "Kai Li", "Li Fei-Fei."],
    "venue": "CVPR.",
    "year": 2009
  }, {
    "title": "A simple, fast, and effective reparameterization of ibm model 2",
    "authors": ["Chris Dyer", "Victor Chahuneau", "Noah A Smith."],
    "venue": "ACL.",
    "year": 2013
  }, {
    "title": "Quickedit: Editing text & translations via simple delete actions",
    "authors": ["David Grangier", "Michael Auli."],
    "venue": "arXiv preprint arXiv:1711.04805.",
    "year": 2017
  }, {
    "title": "Nonautoregressive neural machine translation",
    "authors": ["Jiatao Gu", "James Bradbury", "Caiming Xiong", "Victor OK Li", "Richard Socher."],
    "venue": "arXiv preprint arXiv:1711.02281.",
    "year": 2017
  }, {
    "title": "Deep residual learning for image recognition",
    "authors": ["Kaiming He", "Xiangyu Zhang", "Shaoqing Ren", "Jian Sun."],
    "venue": "CVPR.",
    "year": 2016
  }, {
    "title": "Learning distributed representations of sentences from unlabelled data",
    "authors": ["Felix Hill", "Kyunghyun Cho", "Anna Korhonen."],
    "venue": "NAACL.",
    "year": 2016
  }, {
    "title": "Distilling the knowledge in a neural network",
    "authors": ["Geoffrey Hinton", "Oriol Vinyals", "Jeff Dean."],
    "venue": "arXiv preprint arXiv:1503.02531.",
    "year": 2015
  }, {
    "title": "Decoding as continuous optimization in neural machine translation",
    "authors": ["Cong Duy Vu Hoang", "Gholamreza Haffari", "Trevor Cohn."],
    "venue": "arXiv preprint arXiv:1701.02854.",
    "year": 2017
  }, {
    "title": "In-datacenter performance analysis of a tensor processing unit",
    "authors": ["Norman P Jouppi", "Cliff Young", "Nishant Patil", "David Patterson", "Gaurav Agrawal", "Raminder Bajwa", "Sarah Bates", "Suresh Bhatia", "Nan Boden", "Al Borchers"],
    "year": 2017
  }, {
    "title": "Can active memory replace attention",
    "authors": ["Łukasz Kaiser", "Samy Bengio"],
    "venue": "In NIPS",
    "year": 2016
  }, {
    "title": "Neural GPUs learn algorithms",
    "authors": ["Łukasz Kaiser", "Ilya Sutskever."],
    "venue": "arXiv preprint arXiv:1511.08228.",
    "year": 2015
  }, {
    "title": "Recurrent continuous translation models",
    "authors": ["Nal Kalchbrenner", "Phil Blunsom."],
    "venue": "EMNLP.",
    "year": 2013
  }, {
    "title": "Deep visualsemantic alignments for generating image descriptions",
    "authors": ["Andrej Karpathy", "Fei-Fei Li."],
    "venue": "CVPR.",
    "year": 2015
  }, {
    "title": "Sequencelevel knowledge distillation",
    "authors": ["Yoon Kim", "Alexander M Rush."],
    "venue": "arXiv preprint arXiv:1606.07947.",
    "year": 2016
  }, {
    "title": "Adam: A method for stochastic optimization",
    "authors": ["Diederik P Kingma", "Jimmy Ba."],
    "venue": "arXiv preprint arXiv:1412.6980.",
    "year": 2014
  }, {
    "title": "Improved variational inference with inverse autoregressive flow",
    "authors": ["Diederik P Kingma", "Tim Salimans", "Rafal Jozefowicz", "Xi Chen", "Ilya Sutskever", "Max Welling."],
    "venue": "NIPS.",
    "year": 2016
  }, {
    "title": "Moses: Open source toolkit for statistical machine translation",
    "authors": ["Philipp Koehn", "Hieu Hoang", "Alexandra Birch", "Chris Callison-Burch", "Marcello Federico", "Nicola Bertoldi", "Brooke Cowan", "Wade Shen", "Christine Moran", "Richard Zens"],
    "year": 2007
  }, {
    "title": "Unsupervised machine translation using monolingual corpora only",
    "authors": ["Guillaume Lample", "Ludovic Denoyer", "Marc’Aurelio Ranzato"],
    "venue": "arXiv preprint arXiv:1711.00043",
    "year": 2017
  }, {
    "title": "Microsoft COCO: Common objects in context",
    "authors": ["T.Y. Lin", "M. Maire", "S. Belongie", "J. Hays", "P. Perona", "D. Ramanan", "P. Dollár", "C.L. Zitnick."],
    "venue": "ECCV.",
    "year": 2014
  }, {
    "title": "Recurrent neural network based language model",
    "authors": ["Tomáš Mikolov", "Martin Karafiát", "Lukáš Burget", "Jan Černockỳ", "Sanjeev Khudanpur."],
    "venue": "Eleventh Annual Conference of the International Speech Communication Association.",
    "year": 2010
  }, {
    "title": "Iterative refinement for machine translation",
    "authors": ["Roman Novak", "Michael Auli", "David Grangier."],
    "venue": "arXiv preprint arXiv:1610.06602.",
    "year": 2016
  }, {
    "title": "Wavenet: A generative model for raw audio",
    "authors": ["Aaron van den Oord", "Sander Dieleman", "Heiga Zen", "Karen Simonyan", "Oriol Vinyals", "Alex Graves", "Nal Kalchbrenner", "Andrew Senior", "Koray Kavukcuoglu."],
    "venue": "arXiv preprint arXiv:1609.03499.",
    "year": 2016
  }, {
    "title": "Parallel wavenet: Fast high-fidelity speech synthesis",
    "authors": ["Aaron van den Oord", "Yazhe Li", "Igor Babuschkin", "Karen Simonyan", "Oriol Vinyals", "Koray Kavukcuoglu", "George van den Driessche", "Edward Lockhart", "Luis C Cobo", "Florian Stimberg"],
    "year": 2017
  }, {
    "title": "Bleu: a method for automatic evaluation of machine translation",
    "authors": ["Kishore Papineni", "Salim Roukos", "Todd Ward", "WeiJing Zhu."],
    "venue": "ACL.",
    "year": 2002
  }, {
    "title": "Continuous space translation models for phrase-based statistical machine translation",
    "authors": ["Holger Schwenk."],
    "venue": "Proceedings of COLING 2012: Posters. Rico Sennrich, Barry Haddow, and Alexandra Birch. 2016. Neural machine translation of rare words with",
    "year": 2012
  }, {
    "title": "Highway networks",
    "authors": ["Rupesh Kumar Srivastava", "Klaus Greff", "Jürgen Schmidhuber."],
    "venue": "arXiv preprint arXiv:1505.00387.",
    "year": 2015
  }, {
    "title": "Sequence to sequence learning with neural networks",
    "authors": ["Ilya Sutskever", "Oriol Vinyals", "Quoc V Le."],
    "venue": "NIPS.",
    "year": 2014
  }, {
    "title": "Attention is all you need",
    "authors": ["Ashish Vaswani", "Noam Shazeer", "Niki Parmar", "Jakob Uszkoreit", "Llion Jones", "Aidan N Gomez", "Łukasz Kaiser", "Illia Polosukhin."],
    "venue": "NIPS.",
    "year": 2017
  }, {
    "title": "Deliberation networks: Sequence generation beyond one-pass decoding",
    "authors": ["Yingce Xia", "Fei Tian", "Lijun Wu", "Jianxin Lin", "Tao Qin", "Nenghai Yu", "Tie-Yan Liu."],
    "venue": "NIPS.",
    "year": 2017
  }],
  "id": "SP:1251e48847fb9243bbe9c1b903e04ca72f8a9668",
  "authors": [{
    "name": "Jason Lee",
    "affiliations": []
  }, {
    "name": "Kyunghyun Cho",
    "affiliations": []
  }],
  "abstractText": "We propose a conditional non-autoregressive neural sequence model based on iterative refinement. The proposed model is designed based on the principles of latent variable models and denoising autoencoders, and is generally applicable to any sequence generation task. We extensively evaluate the proposed model on machine translation (En$De and En$Ro) and image caption generation, and observe that it significantly speeds up decoding while maintaining the generation quality comparable to the autoregressive counterpart.",
  "title": "Deterministic Non-Autoregressive Neural Sequence Modeling by Iterative Refinement"
}