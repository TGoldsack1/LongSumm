{
  "sections": [{
    "text": "Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Short Papers), pages 700–705 Melbourne, Australia, July 15 - 20, 2018. c©2018 Association for Computational Linguistics\n700"
  }, {
    "heading": "1 Introduction",
    "text": "Query auto-completion (QAC) is a feature used by search engines that provides a list of suggested queries for the user as they are typing. For instance, if the user types the prefix “mete” then the system might suggest “meters” or “meteorite” as completions. This feature can save the user time and reduce cognitive load (Cai et al., 2016).\nMost approaches to QAC are extensions of the Most Popular Completion (MPC) algorithm (BarYossef and Kraus, 2011). MPC suggests completions based on the most popular queries in the training data that match the specified prefix. One way to improve MPC is to consider additional signals such as temporal information (Shokouhi and Radinsky, 2012; Whiting and Jose, 2014) or information gleaned from a users’ past queries (Shokouhi, 2013). This paper deals with the latter of those two signals, i.e. personalization. Personalization relies on the fact that query likelihoods are drastically different among different people depending on their needs and interests.\nRecently, Park and Chiba (2017) suggested a significantly different approach to QAC. In their\nwork, completions are generated from a character LSTM language model instead of by ranking completions retrieved from a database, as in the MPC algorithm. This approach is able to complete queries whose prefixes were not seen during training and has significant memory savings over having to store a large query database.\nBuilding on this work, we consider the task of personalized QAC, advancing current methods by combining the obvious advantages of personalization with the effectiveness of a language model in handling rare and previously unseen prefixes. The model must learn how to extract information from a user’s past queries and use it to adapt the generative model for that person’s future queries. To do this, we leverage recent advances in contextadaptive neural language modeling. In particular, we make use of the recently introduced FactorCell model that uses an embedding vector to additively transform the weights of the language model’s recurrent layer with a low-rank matrix (Jaech and Ostendorf, 2017). By allowing a greater fraction of the weights to change during personalization, the FactorCell model has advantages over the traditional approach to adaptation of concatenating a context vector to the input of the LSTM (Mikolov and Zweig, 2012).\nTable 1 provides an anecdotal example from\nthe trained FactorCell model to demonstrate the intended behavior. The table shows the top five completions for the prefix “ba” in a cold start scenario and again after the user has completed five sports related queries. In the warm start scenario, the “baby names” and “babiesrus” completions no longer appear in the top five and have been replaced with “basketball” and “baseball”.\nThe novel aspects of this work are the application of an adaptive language model to the task of QAC personalization and the demonstration of how RNN language models can be adapted to contexts (users) not seen during training. An additional contribution is showing that a richer adaptation framework gives added gains with added data."
  }, {
    "heading": "2 Model",
    "text": "Adaptation depends on learning an embedding for each user, which we discuss in Section 2.1, and then using that embedding to adjust the weights of the recurrent layer, discussed in Section 2.2."
  }, {
    "heading": "2.1 Learning User Embeddings",
    "text": "During training, we learn an embedding for each of the users. We think of these embeddings as holding latent demographic factors for each user. Users who have less than 15 queries in the training data (around half the users but less than 13% of the queries) are grouped together as a single entity, user1, leaving k users. The user embeddings matrix Uk×m, wherem is the user embedding size, is learned via back-propagation as part of the end-toend model. The embedding for an individual user is the ith row of U and is denoted by ui.\nIt is important to be able to apply the model to users that are not seen during training. This is done by online updating of the user embeddings during evaluation. When a new person, userk+1 is seen, a new row is added to U and initialized to u1. Each person’s user embedding is updated via back-propagation every time they select a query. When doing online updating of the user embeddings, the rest of the model parameters (everything except U) are frozen."
  }, {
    "heading": "2.2 Recurrent Layer Adaptation",
    "text": "We consider three model architectures which differ only in the method for adapting the recurrent layer. First is the unadapted LM, analogous to the model from Park and Chiba (2017), which does no personalization. The second architecture was\nintroduced by Mikolov and Zweig (2012) and has been used multiple times for LM personalization (Wen et al., 2013; Huang et al., 2014; Li et al., 2016). It works by concatenating a user embedding to the character embedding at every step of the input to the recurrent layer. Jaech and Ostendorf (2017) refer to this model as the ConcatCell and show that it is equivalent to adding a term Vu to adjust the bias of the recurrent layer. The hidden state of a ConcatCell with embedding size e and hidden state size h is given in Equation 1 where σ is the activation function, wt is the character embedding, ht−1 is the previous hidden state, and W ∈ Re+h×h and b ∈ Rh are the recurrent layer weight matrix and bias vector.\nht = σ([wt, ht−1]W + b+Vu) (1)\nAdapting just the bias vector is a significant limitation. The FactorCell model, (Jaech and Ostendorf, 2017), remedies this by letting the user embedding transform the weights of the recurrent layer via the use of a low-rank adaptation matrix. The FactorCell uses a weight matrix W′ = W +A that has been additively transformed by a personalized low-rank matrix A. Because the FactorCell weight matrix W′ is different for each user (See Equation 2), it allows for a much stronger adaptation than what is possible using the more standard ConcatCell model.1\nht = σ([wt, ht−1]W ′ + b) (2)\nThe low-rank adaptation matrix A is generated by taking the product between a user’s m dimensional embedding and left and right bases tensors, ZL ∈ Rm×e+h×r and ZR ∈ Rr×h×m as so,\nA = (ui ×1 ZL)(ZR ×3 ui) (3)\nwhere ×i denotes the mode-i tensor product. The above product selects a user specific adaptation matrix by taking a weighted combination of the m rank r matrices held between ZL and ZR. The rank, r, is a hyperparameter which controls the degree of personalization."
  }, {
    "heading": "3 Data",
    "text": "Our experiments make use of the AOL Query data collected over three months in 2006 (Pass et al., 2006). The first six of the ten files were used for\n1In the case of an LSTM, W′ is extended to incorporate all of the gates.\ntraining. This contains approximately 12 million queries from 173,000 users for an average of 70 queries per user (median 15). A set of 240,000 queries from those same users (2% of the data) was reserved for tuning and validation. From the remaining files, one million queries from 30,000 users are used to test the models on a disjoint set of users."
  }, {
    "heading": "4 Experiments",
    "text": ""
  }, {
    "heading": "4.1 Implementation Details",
    "text": "The vocabulary consists of 79 characters including special start and stop tokens. Models were trained for six epochs. The Adam optimizer is used during training with a learning rate of 10−3 (Kingma and Ba, 2014). When updating the user embeddings during evaluation, we found that it is easier to use an optimizer without momentum. We use Adadelta (Zeiler, 2012) and tune the online learning rate to give the best perplexity on a held-out set of 12,000 queries, having previously verified that perplexity is a good indicator of performance on the QAC task.2\nThe language model is a single-layer characterlevel LSTM with coupled input and forget gates and layer normalization (Melis et al., 2018; Ba et al., 2016). We do experiments on two model configurations: small and large. The small models use an LSTM hidden state size of 300 and 20 dimensional user embeddings. The large models use a hidden state size of 600 and 40 dimensional user embeddings. Both sizes use 24 dimensional character embeddings. For the small sized models, we experimented with different values of the FactorCell rank hyperparameter between 30 and 50 dimensions finding that bigger rank is better. The large sized models used a fixed value of 60 for the rank hyperparemeter. During training only and due to limited computational resources, queries are truncated to a length of 40 characters.\nPrefixes are selected uniformly at random with the constraint that they contain at least two characters in the prefix and that there is at least one character in the completion. To generate completions using beam search, we use a beam width of 100 and a branching factor of 4. Results are reported using mean reciprocal rank (MRR), the standard method of evaluating QAC systems. It is the mean of the reciprocal rank of the true completion in the\n2Code at http://github.com/ajaech/query completion\ntop ten proposed completions. The reciprocal rank is zero if the true completion is not in the top ten.\nNeural models are compared against an MPC baseline. Following Park and Chiba (2017), we remove queries seen less than three times from the MPC training data."
  }, {
    "heading": "4.2 Results",
    "text": "Table 2 compares the performance of the different models against the MPC baseline on a test set of one million queries from a user population that is disjoint with the training set. Results are presented separately for prefixes that are seen or unseen in the training data. Consistent with prior work, the neural models do better than the MPC baseline. The personalized models are both better than the unadapted one. The FactorCell model is the best overall in both the big and small sized experiments, but the gain is mainly for the seen prefixes.\nFigure 1 shows the relative improvement in MRR over an unpersonalized model versus the number of queries seen per user. Both the Factor-\nCell and the ConcatCell show continued improvement as more queries from each user are seen, and the FactorCell outperforms the ConcatCell by an increasing margin over time. In the long run, we expect that the system will have seen many queries from most users. Therefore, the right side of Figure 1, where the relative gain of FactorCell is up to 2% better than that of the ConcatCell, is more indicative of the potential of these models for active users. Since the data was collected over a limited time frame and half of all users have fifteen or fewer queries, the results in Table 2 do not reflect the full benefit of personalization.\nFigure 2 shows the MRR for different prefix and query lengths. We find that longer prefixes help the model make longer completions and (more obviously) shorter completions have higher MRR. Comparing the personalized model against the unpersonalized baseline, we see that the biggest gains are for short queries and prefixes of length one or two.\nWe found that one reason why the FactorCell outperforms the ConcatCell is that it is able to pick up sooner on the repetitive search behaviors that some users have. This commonly happens for navigational queries where someone searches for the name of their favorite website once or more per day. At the extreme tail there are users who search for nothing but free online poker. Both models do well on these highly predictable users but the FactorCell is generally a bit quicker to adapt.\nWe conducted case studies to better understand what information is represented in the user embeddings and what makes the FactorCell different from the ConcatCell. From a cold start user embedding we ran two queries and allowed the model to update the user embedding. Then, we ranked\nthe most frequent 1,500 queries based on the ratio of their likelihood from before and after updating the user embeddings.\nTables 3 and 4 show the queries with the highest relative likelihood of the adapted vs. unadapted models after two related search queries: “high school softball” and “math homework help” for Table 3, and “Prada handbags” and “Versace eyewear” for Table 4. In both cases, the FactorCell model examples are more semantically coherent than the ConcatCell examples. In the first case, the FactorCell model identifies queries that a high school student might make, including entertainment sources and a celebrity entertainer popular with that demographic. In the second case, the FactorCell model chooses retailers that carry woman’s apparel and those that sell home goods. While these companies’ brands are not as luxurious as Prada or Versace, most of the top luxury brand names do not appear in the top 1,500 queries and our model may not be capable of being that specific. There is no obvious semantic connection between the highest likelihood ratio phrases for the ConcatCell; it seems to be focusing more on orthography than semantics (e.g. “home” in the first example).. Not shown are the queries which experienced the greatest decrease in likelihood. For the “high school” case, these included searches for travel agencies and airline tickets— websites not targeted towards the high school age demographic."
  }, {
    "heading": "5 Related Work",
    "text": "While the standard implementation of MPC can not handle unseen prefixes, there are variants which do have that ability. Park and Chiba (2017) find that the neural LM outperforms MPC even when MPC has been augmented with the approach from Mitra and Craswell (2015) for handling rare\nprefixes. There has also been work on personalizing MPC (Shokouhi, 2013; Cai et al., 2014). We did not compare against these specific models because our goal was to show how personalization can improve the already-proven generative neural model approach. RNN’s have also previously been used for the related task of next query suggestion (Sordoni et al., 2015).\nOur results are not directly comparable to Park and Chiba (2017) or Mitra and Craswell (2015) due to differences in the partitioning of the data and the method for selecting random prefixes. Prior work partitions the data by time instead of by user. Splitting by users is necessary in order to properly test personalization over longer time ranges.\nWang et al. (2018) show how spelling correction can be integrated into an RNN language model query auto-completion system and how the completions can be generated in real time using a GPU. Our method of updating the model during evaluation resembles work on dynamic evaluation for language modeling (Krause et al., 2017), but differs in that only the user embeddings (latent demographic factors) are updated."
  }, {
    "heading": "6 Conclusion and Future Work",
    "text": "Our experiments show that the LSTM model can be improved using personalization. The method of adapting the recurrent layer clearly matters and we obtained an advantage by using the FactorCell model. The reason the FactorCell does better is in part attributable to having two to three times as many parameters in the recurrent layer as either the ConcatCell or the unadapted models. By design, the adapted weight matrix W′ only needs to be computed at most once per query and is reused many thousands of times during beam search. As a result, for a given latency budget, the FactorCell\nmodel outperforms the Mikolov and Zweig (2012) model for LSTM adaptation.\nThe cost for updating the user embeddings is similar to the cost of the forward pass and depends on the size of the user embedding, hidden state size, FactorCell rank, and query length. In most cases there will be time between queries for updates, but updates can be less frequent to reduce computational costs.\nWe also showed that language model personalization can be effective even on users who are not seen during training. The benefits of personalization are immediate and increase over time as the system continues to leverage the incoming data to build better user representations. The approach can easily be extended to include time as an additional conditioning factor. We leave the question of whether the results can be improved by combining the language model with MPC for future work."
  }],
  "year": 2018,
  "references": [{
    "title": "Layer normalization",
    "authors": ["Jimmy Lei Ba", "Jamie Ryan Kiros", "Geoffrey E Hinton."],
    "venue": "arXiv preprint arXiv:1607.06450.",
    "year": 2016
  }, {
    "title": "Contextsensitive query auto-completion",
    "authors": ["Ziv Bar-Yossef", "Naama Kraus."],
    "venue": "WWW, pages 107–116. ACM.",
    "year": 2011
  }, {
    "title": "A survey of query auto completion in information retrieval. Foundations and Trends in Information Retrieval, 10(4):273–363",
    "authors": ["Fei Cai", "Maarten De Rijke"],
    "year": 2016
  }, {
    "title": "Time-sensitive personalized query autocompletion",
    "authors": ["Fei Cai", "Shangsong Liang", "Maarten De Rijke."],
    "venue": "CIKM, pages 1599–1608. ACM.",
    "year": 2014
  }, {
    "title": "Enriching cold start personalized language model using social network information",
    "authors": ["Yu-Yang Huang", "Rui Yan", "Tsung-Ting Kuo", "ShouDe Lin."],
    "venue": "ACL, pages 611–617.",
    "year": 2014
  }, {
    "title": "Low-rank RNN adaptation for context-aware language modeling",
    "authors": ["Aaron Jaech", "Mari Ostendorf."],
    "venue": "arXiv preprint arXiv:1710.02603.",
    "year": 2017
  }, {
    "title": "Adam: A method for stochastic optimization",
    "authors": ["Diederik P Kingma", "Jimmy Ba."],
    "venue": "arXiv preprint arXiv:1412.6980.",
    "year": 2014
  }, {
    "title": "Dynamic evaluation of neural sequence models",
    "authors": ["Ben Krause", "Emmanuel Kahembwe", "Iain Murray", "Steve Renals."],
    "venue": "arXiv preprint arXiv:1709.07432.",
    "year": 2017
  }, {
    "title": "A persona-based neural conversation model",
    "authors": ["Jiwei Li", "Michel Galley", "Chris Brockett", "Jianfeng Gao", "Bill Dolan."],
    "venue": "ACL.",
    "year": 2016
  }, {
    "title": "On the state of the art of evaluation in neural language models",
    "authors": ["Gábor Melis", "Chris Dyer", "Phil Blunsom."],
    "venue": "ICLR.",
    "year": 2018
  }, {
    "title": "Context dependent recurrent neural network language model",
    "authors": ["Tomas Mikolov", "Geoffrey Zweig."],
    "venue": "SLT, pages 234–239.",
    "year": 2012
  }, {
    "title": "Query autocompletion for rare prefixes",
    "authors": ["Bhaskar Mitra", "Nick Craswell."],
    "venue": "CIKM, pages 1755– 1758. ACM.",
    "year": 2015
  }, {
    "title": "A neural language model for query auto-completion",
    "authors": ["Dae Hoon Park", "Rikio Chiba."],
    "venue": "SIGIR, pages 1189–1192. ACM.",
    "year": 2017
  }, {
    "title": "A picture of search",
    "authors": ["Greg Pass", "Abdur Chowdhury", "Cayley Torgeson."],
    "venue": "InfoScale, volume 152, page 1.",
    "year": 2006
  }, {
    "title": "Learning to personalize query auto-completion",
    "authors": ["Milad Shokouhi."],
    "venue": "SIGIR, pages 103–112. ACM.",
    "year": 2013
  }, {
    "title": "Timesensitive query auto-completion",
    "authors": ["Milad Shokouhi", "Kira Radinsky."],
    "venue": "SIGIR, pages 601–610. ACM.",
    "year": 2012
  }, {
    "title": "A hierarchical recurrent encoderdecoder for generative context-aware query suggestion",
    "authors": ["Alessandro Sordoni", "Yoshua Bengio", "Hossein Vahabi", "Christina Lioma", "Jakob Grue Simonsen", "JianYun Nie."],
    "venue": "CIKM, pages 553–562. ACM.",
    "year": 2015
  }, {
    "title": "Realtime query completion via deep language models",
    "authors": ["Po-Wei Wang", "J. Zico Kolter", "Vijai Mohan", "Inderjit S. Dhillon."],
    "venue": "ICLR.",
    "year": 2018
  }, {
    "title": "Recurrent neural network based language model personalization by social network crowdsourcing",
    "authors": ["Tsung-Hsien Wen", "Aaron Heidel", "Hung-yi Lee", "Yu Tsao", "Lin-Shan Lee."],
    "venue": "INTERSPEECH, pages 2703–2707.",
    "year": 2013
  }, {
    "title": "Recent and robust query auto-completion",
    "authors": ["Stewart Whiting", "Joemon M Jose."],
    "venue": "WWW, pages 971–982. ACM.",
    "year": 2014
  }, {
    "title": "ADADELTA: an adaptive learning rate method",
    "authors": ["Matthew D. Zeiler."],
    "venue": "CoRR, abs/1212.5701.",
    "year": 2012
  }],
  "id": "SP:7c962945f74fa4e8c30e5c32c02d7f412981fb64",
  "authors": [{
    "name": "Aaron Jaech",
    "affiliations": []
  }, {
    "name": "Mari Ostendorf",
    "affiliations": []
  }],
  "abstractText": "Query auto-completion is a search engine feature whereby the system suggests completed queries as the user types. Recently, the use of a recurrent neural network language model was suggested as a method of generating query completions. We show how an adaptable language model can be used to generate personalized completions and how the model can use online updating to make predictions for users not seen during training. The personalized predictions are significantly better than a baseline that uses no user information.",
  "title": "Personalized Language Model for Query Auto-Completion"
}