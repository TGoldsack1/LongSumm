{
  "sections": [{
    "text": "Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Long Papers), pages 2737–2746 Melbourne, Australia, July 15 - 20, 2018. c©2018 Association for Computational Linguistics\n2737"
  }, {
    "heading": "1 Introduction",
    "text": "A principle goal of asking questions is to fill information gaps, typically through clarification questions.1 We take the perspective that a good question is the one whose likely answer will be useful. Consider the exchange in Figure 1, in which an initial poster (who we call “Terry”) asks for help configuring environment variables. This post is underspecified and a responder (“Parker”) asks a clarifying question (a) below, but could alternatively have asked (b) or (c):\n(a) What version of Ubuntu do you have?\n1We define ‘clarification question’ as a question that asks for some information that is currently missing from the given context.\n(b) What is the make of your wifi card? (c) Are you running Ubuntu 14.10 kernel 4.4.0-59-\ngeneric on an x86 64 architecture? Parker should not ask (b) because an answer is unlikely to be useful; they should not ask (c) because it is too specific and an answer like “No” or “I do not know” gives little help. Parker’s question (a) is much better: it is both likely to be useful, and is plausibly answerable by Terry.\nIn this work, we design a model to rank a candidate set of clarification questions by their usefulness to the given post. We imagine a use case (more discussion in §7) in which, while Terry is writing their post, a system suggests a shortlist of questions asking for information that it thinks people like Parker might need to provide a solution, thus enabling Terry to immediately clarify their post, potentially leading to a much quicker resolution. Our model is based on the decision theoretic framework of the Expected Value of Perfect Information (EVPI) (Avriel and Williams, 1970), a measure of the value of gathering additional information. In our setting, we use EVPI to calculate which questions are most likely to elicit an answer that would make the post more informative.\nOur work has two main contributions: 1. A novel neural-network model for address-\ning the task of ranking clarification question built on the framework of expected value of perfect information (§2). 2. A novel dataset, derived from StackExchange2, that enables us to learn a model to ask clarifying questions by looking at the types of questions people ask (§3).\nWe formulate this task as a ranking problem on a set of potential clarification questions. We evaluate models both on the task of returning the original clarification question and also on the task of picking any of the candidate clarification questions marked as good by experts (§4). We find that our EVPI model outperforms the baseline models when evaluated against expert human annotations. We include a few examples of human annotations along with our model performance on them in the supplementary material. We have released our dataset of∼77K (p, q, a) triples and the expert annotations on 500 triples to help facilitate further research in this task.3"
  }, {
    "heading": "2 Model description",
    "text": "We build a neural network model inspired by the theory of expected value of perfect information (EVPI). EVPI is a measurement of: if I were to acquire information X, how useful would that be to\n2We use data from StackExchange; per license cc-by-sa 3.0, the data is “intended to be shared and remixed” (with attribution).\n3https://github.com/raosudha89/ ranking_clarification_questions\nme? However, because we haven’t acquired X yet, we have to take this quantity in expectation over all possible X, weighted by each X’s likelihood. In our setting, for any given question qi that we can ask, there is a set A of possible answers that could be given. For each possible answer aj ∈ A, there is some probability of getting that answer, and some utility if that were the answer we got. The value of this question qi is the expected utility, over all possible answers:\nEVPI(qi|p) = ∑ aj∈A P[aj |p, qi]U(p+ aj) (1)\nIn Eq 1, p is the post, qi is a potential question from a set of candidate questionsQ and aj is a potential answer from a set of candidate answers A. Here, P[aj |p, qi] measures the probability of getting an answer aj given an initial post p and a clarifying question qi, and U(p + aj) is a utility function that measures how much more complete p would be if it were augmented with answer aj . The modeling question then is how to model:\n1. The probability distribution P[aj |p, qi] and 2. The utility function U(p+ aj).\nIn our work, we represent both using neural networks over the appropriate inputs. We train the parameters of the two models jointly to minimize a joint loss defined such that an answer that has a higher potential of increasing the utility of a post gets a higher probability.\nFigure 2 describes the behavior of our model during test time. Given a post p, we generate a set of candidate questions and a set of candidate\nanswers (§2.1). Given a post p and a question candidate qi, we calculate how likely is this question to be answered using one of our answer candidates aj (§2.2). Given a post p and an answer candidate aj , we calculate the utility of the updated post i.e. U(p+ aj) (§2.3). We compose these modules into a joint neural network that we optimize end-to-end over our data (§2.4)."
  }, {
    "heading": "2.1 Question & answer candidate generator",
    "text": "Given a post p, our first step is to generate a set of question and answer candidates. One way that humans learn to ask questions is by looking at how others ask questions in a similar situation. Using this intuition we generate question candidates for a given post by identifying posts similar to the given post and then looking at the questions asked to those posts. For identifying similar posts, we use Lucene4, a software extensively used in information retrieval for extracting documents relevant to a given query from a pool of documents. Lucene implements a variant of the term frequency-inverse document frequency (TF-IDF) model to score the extracted documents according to their relevance to the query. We use Lucene to find the top 10 posts most similar to a given post from our dataset (§3). We consider the questions asked to these 10 posts as our set of question candidates Q and the edits made to the posts in response to the questions as our set of answer candidates A. Since the top-most similar candidate extracted by Lucene is always the original post itself, the original question and answer paired with the post is always one of the candidates in Q and A. §3 describes in detail the process of extracting the\n4https://lucene.apache.org/\n(post, question, answer) triples from the StackExchange datadump."
  }, {
    "heading": "2.2 Answer modeling",
    "text": "Given a post p and a question candidate qi, our second step is to calculate how likely is this question to be answered using one of our answer candidates aj . We first generate an answer representation by combining the neural representations of the post and the question using a function Fans(p̄, q̄i) (details in §2.4). Given such a representation, we measure the distance between this answer representation and one of the answer candidates aj using the function below:\ndist(Fans(p̄, q̄i), âj) = 1− cos sim(Fans(p̄, q̄i), âj)\nThe likelihood of an answer candidate aj being the answer to a question qi on post p is finally calculated by combining this distance with the cosine similarity between the question qi and the question qj paired with the answer candidate aj :\nP[aj |p, qi] = exp−dist(Fans(p̄, q̄i), âj) ∗cos sim(q̂i, q̂j) (2)\nwhere âj , q̂i and q̂j are the average word vector of aj , qi and qj respectively (details in §2.4) and cos sim is the cosine similarity between the two input vectors.\nWe model our answer generator using the following intuition: a question can be asked in several different ways. For e.g. in Figure 1, the question “What version of Ubuntu do you have?” can be asked in other ways like “What version of operating system are you using?”, “Version of OS?”, etc. Additionally, for a given post and a question, there can be\nseveral different answers to that question. For instance, “Ubuntu 14.04 LTS”, “Ubuntu 12.0”, “Ubuntu 9.0”, are all valid answers. To generate an answer representation capturing these generalizations, we train our answer generator on our triples dataset (§3) using the loss function below:\nlossans(pi, qi, ai, Qi) = dist(Fans(p̄i, q̄i), âi) (3) + ∑ j∈Q ( dist(Fans(p̄i, q̄i), âj) ∗ cos sim(q̂i, q̂j) )\nwhere, â and q̂ is the average word vectors of a and q respectively (details in §2.4), cos sim is the cosine similarity between the two input vectors.\nThis loss function can be explained using the example in Figure 3. Question qi is the question paired with the given post pi. In Eq 3, the first term forces the function Fans(p̄i, q̄i) to generate an answer representation as close as possible to the correct answer ai. Now, a question can be asked in several different ways. Let Qi be the set of candidate questions for post pi, retrieved from the dataset using Lucene (§ 2.1). Suppose a question candidate qj is very similar to the correct question qi ( i.e. cos sim(q̂i, q̂j) is near zero). Then the second term forces the answer representation Fans(p̄i, q̄i) to be close to the answer aj corresponding to the question qj as well. Thus in Figure 3, the answer representation will be close to aj (since qj is similar to qi), but may not be necessarily close to ak (since qk is dissimilar to qi)."
  }, {
    "heading": "2.3 Utility calculator",
    "text": "Given a post p and an answer candidate aj , the third step is to calculate the utility of the updated post i.e. U(p+aj). As expressed in Eq 1, this utility function measures how useful it would be if a given post p were augmented with an answer aj paired with a different question qj in the candidate set. Although theoretically, the utility of the updated post can be calculated only using the given post (p) and the candidate answer (aj), empirically we find that our neural EVPI model performs better when the candidate question (qj) paired with the candidate answer is a part of the utility function. We attribute this to the fact that much information about whether an answer increases the utility of a post is also contained in the question asked to the post. We train our utility calculator using our dataset of (p, q, a) triples (§3). We label all the (pi, qi, ai) pairs from our triples dataset with label y = 1. To get negative samples, we make use of\nthe answer candidates generated using Lucene as described in §2.1. For each aj ∈ Ai, where Ai is the set of answer candidates for post pi, we label the pair (pi, qj , aj) with label y = 0, except for when aj = ai. Thus, for each post pi in our triples dataset, we have one positive sample and nine negative samples. It should be noted that this is a noisy labelling scheme since a question not paired with the original question in our dataset can often times be a good question to ask to the post (§4). However, since we do not have annotations for such other good questions at train time, we assume such a labelling.\nGiven a post pi and an answer aj paired with the question qj , we combine their neural representations using a function Futil(p̄i, q̄j , āj) (details in §2.4). The utility of the updated post is then defined as U(pi + aj) = σ(Futil(p̄i, q̄j , āj))5. We want this utility to be close to 1 for all the positively labelled (p, q, a) triples and close to 0 for all the negatively labelled (p, q, a) triples. We therefore define our loss using the binary cross-entropy formulation below:\nlossutil(yi, p̄i, q̄j , āj) = yi log(σ(Futil(p̄i, q̄j , āj))) (4)"
  }, {
    "heading": "2.4 Our joint neural network model",
    "text": "Our fundamental representation is based on recurrent neural networks over word embeddings. We obtain the word embeddings using the GloVe (Pennington et al., 2014) model trained on the entire datadump of StackExchange.6. In Eq 2 and Eq 3, the average word vector representations q̂ and â are obtained by averaging the GloVe word embeddings for all words in the question and the answer respectively. Given an initial post p, we generate a post neural representation p̄ using a post LSTM (long short-term memory architecture) (Hochreiter and Schmidhuber, 1997). The input layer consists of word embeddings of the words in the post which is fed into a single hidden layer. The output of each of the hidden states is averaged together to get our neural representation p̄. Similarly, given a question q and an answer a, we generate the neural representations q̄ and ā using a question LSTM and an answer LSTM respectively. We define the function Fans in our answer model as a feedforward neural network with five hidden layers on the inputs p̄ and q̄. Likewise, we\n5σ is the sigmoid function. 6Details in the supplementary material.\ndefine the function Futil in our utility calculator as a feedforward neural network with five hidden layers on the inputs p̄, q̄ and ā. We train the parameters of the three LSTMs corresponding to p, q and a, and the parameters of the two feedforward neural networks jointly to minimize the sum of the loss of our answer model (Eq 3) and our utility calculator (Eq 4) over our entire dataset:∑ i ∑ j lossans(p̄i, q̄i, āi, Qi) + lossutil(yi, p̄i, q̄j , āj)\n(5)\nGiven such an estimate P[aj |p, qi] of an answer and a utility U(p + aj) of the updated post, we rank the candidate questions by their value as calculated using Eq 1. The remaining question, then, is how to get data that enables us to train our answer model and our utility calculator. Given data, the training becomes a multitask learning problem, where we learn simultaneously to predict utility and to estimate the probability of answers."
  }, {
    "heading": "3 Dataset creation",
    "text": "StackExchange is a network of online question answering websites about varied topics like academia, ubuntu operating system, latex, etc. The data dump of StackExchange contains timestamped information about the posts, comments on the post and the history of the revisions made to the post. We use this data dump to create our dataset of (post, question, answer) triples: where the post is the initial unedited post, the question is the comment containing a question and the answer is either the edit made to the post after the question or the author’s response to the question in the comments section.\nExtract posts: We use the post histories to identify posts that have been updated by its author. We use the timestamp information to retrieve the initial unedited version of the post.\nExtract questions: For each such initial version of the post, we use the timestamp information of its comments to identify the first question comment made to the post. We truncate the comment till its question mark ’?’ to retrieve the question part of the comment. We find that about 7% of these are rhetoric questions that indirectly suggest a solution to the post. For e.g. “have you considered installing X?”. We do a manual analysis of\nthese non-clarification questions and hand-crafted a few rules to remove them. 7\nExtract answers: We extract the answer to a clarification question in the following two ways: (a) Edited post: Authors tend to respond to a clarification question by editing their original post and adding the missing information. In order to account for edits made for other reasons like stylistic updates and grammatical corrections, we consider only those edits that are longer than four words. Authors can make multiple edits to a post in response to multiple clarification questions.8 To identify the edit made corresponding to the given question comment, we choose the edit closest in time following the question. (b) Response to the question: Authors also respond to clarification questions as subsequent comments in the comment section. We extract the first comment by the author following the clarification question as the answer to the question.\nIn cases where both the methods above yield an answer, we pick the one that is the most semantically similar to the question, where the measure of similarity is the cosine distance between the average word embeddings of the question and the answer.\nWe extract a total of 77,097 (post, question, answer) triples across three domains in StackExchange (Table 1). We will release this dataset along with the the nine question and answer candidates per triple that we generate using lucene (§ 2.1). We include an analysis of our dataset in the supplementary material."
  }, {
    "heading": "4 Evaluation design",
    "text": "We define our task as given a post p, and a set of candidate clarification questions Q, rank the questions according to their usefulness to the post.\n7Details in the supplementary material. 8On analysis, we find that 35%-40% of the posts get asked multiple clarification questions. We include only the first clarification question to a post in our dataset since identifying if the following questions are clarifications or a part of a dialogue is non-trivial.\nSince the candidate set includes the original question q that was asked to the post p, one possible approach to evaluation would be to look at how often the original question is ranked higher up in the ranking predicted by a model. However, there are two problems to this approach: 1) Our dataset creation process is noisy. The original question paired with the post may not be a useful question. For e.g. “are you seriously asking this question?”, “do you mind making that an answer?”9. 2) The nine other questions in the candidate set are obtained by looking at questions asked to posts that are similar to the given post.10 This greatly increases the possibility of some other question(s) being more useful than the original question paired with the post. This motivates an evaluation design that does not rely solely on the original question but also uses human judgments. We randomly choose a total of 500 examples from the test sets of the three domains proportional to their train set sizes (askubuntu:160, unix:90 and superuser:250) to construct our evaluation set."
  }, {
    "heading": "4.1 Annotation scheme",
    "text": "Due to the technical nature of the posts in our dataset, identifying useful questions requires technical experts. We recruit 10 such experts on Upwork11 who have prior experience in unix based operating system administration.12 We provide the annotators with a post and a randomized list of the ten question candidates obtained using Lucene (§2.1) and ask them to select a single “best” (B) question to ask, and additionally mark as “valid” (V ) other questions that they thought would be okay to ask in the context of the original post. We enforce that the “best” question be always marked as a “valid” question. We group the 10 annotators into 5 pairs and assign the same 100 examples to the two annotators in a pair."
  }, {
    "heading": "4.2 Annotation analysis",
    "text": "We calculate the inter-annotator agreement on the “best” and the “valid” annotations using Cohen’s Kappa measurement. When calculating the agreement on the “best” in the strict sense, we get a low\n9Data analysis included in the supplementary material suggests 9% of the questions are not useful.\n10Note that this setting is different from the distractorbased setting popularly used in dialogue (Lowe et al., 2015) where the distractor candidates are chosen randomly from the corpus.\n11https://upwork.com 12Details in the supplementary material.\nagreement of 0.15. However, when we relax this to a case where the question marked as“best” by one annotator is marked as “valid” by another, we get an agreement of 0.87. The agreement on the “valid” annotations, on the other hand, was higher: 0.58. We calculate this agreement on the binary judgment of whether a question was marked as valid by the annotator.\nGiven these annotations, we calculate how often is the original question marked as “best” or “valid” by the two annotators. We find that 72% of the time one of the annotators mark the original as the “best”, whereas only 20% of the time both annotators mark it as the “best” suggesting against an evaluation solely based on the original question. On the other hand, 88% of the time one of the two annotators mark it as a “valid” question confirming the noise in our training data.13\nFigure 4 shows the distribution of the counts of questions in the intersection of “valid” annotations (blue legend). We see that about 85% of the posts have more than 2 valid questions and 50% have more than 3 valid questions. The figure also shows the distribution of the counts when the original question is removed from the intersection (red legend). Even in this set, we find that about 60% of the posts have more than two valid questions. These numbers suggests that the candidate set of questions retrieved using Lucene (§2.1) very often contains useful clarification questions."
  }, {
    "heading": "5 Experimental results",
    "text": "Our primary research questions that we evaluate experimentally are:\n1. Does a neural network architecture improve upon non-neural baselines?\n1376% of the time both the annotators mark it as a “valid”.\n2. Does the EVPI formalism provide leverage over a similarly expressive feedforward network? 3. Are answers useful in identifying the right question? 4. How do the models perform when evaluated on the candidate questions excluding the original?"
  }, {
    "heading": "5.1 Baseline methods",
    "text": "We compare our model with following baselines:\nRandom: Given a post, we randomly permute its set of 10 candidate questions uniformly.14\nBag-of-ngrams: Given a post and a set of 10 question and answer candidates, we construct a bag-of-ngrams representation for the post, question and answer. We train the baseline on all the positive and negative candidate triples (same as in our utility calculator (§2.3)) to minimize hinge loss on misclassification error using cross-product features between each of (p, q), (q, a) and (p, a). We tune the ngram length and choose n=3 which performs best on the tune set. The question candidates are finally ranked according to their predictions for the positive label.\nCommunity QA: The recent SemEval2017 Community Question-Answering (CQA) (Nakov et al., 2017) included a subtask for ranking a set of comments according to their relevance to a given post in the Qatar Living15 forum. Nandi et al. (2017), winners of this subtask, developed a logistic regression model using features based on\n14We take the average over 1000 random permutations. 15http://www.qatarliving.com/forum\nstring similarity, word embeddings, etc. We train this model on all the positively and negatively labelled (p, q) pairs in our dataset (same as in our utility calculator (§2.3), but without a). We use a subset of their features relevant to our task.16\nNeural baselines: We construct the following neural baselines based on the LSTM representation of their inputs (as described in §2.4): 1. Neural(p, q): Input is concatenation of p̄ and q̄. 2. Neural(p, a): Input is concatenation of p̄ and ā. 3. Neural(p, q, a): Input is concatenation of p̄, q̄ and ā.\nGiven these inputs, we construct a fully connected feedforward neural network with 10 hidden layers and train it to minimize the binary cross entropy across all positive and negative candidate triples (same as in our utility calculator (§ 2.3)). The major difference between the neural baselines and our EVPI model is in the loss function: the EVPI model is trained to minimize the joint loss between the answer model (defined on Fans(p, q) in Eq 3) and the utility calculator (defined on Futil(p, q, a) in Eq 4) whereas the neural baselines are trained to minimize the loss directly on F (p, q), F (p, a) or F (p, q, a). We include the implementation details of all our neural models in the supplementary material."
  }, {
    "heading": "5.2 Results",
    "text": ""
  }, {
    "heading": "5.2.1 Evaluating against expert annotations",
    "text": "We first describe the results of the different models when evaluated against the expert annotations we collect on 500 samples (§4). Since the annotators\n16Details in the supplementary material.\nhad a low agreement on a single best, we evaluate against the union of the “best” annotations (B1 ∪ B2 in Table 2) and against the intersection of the “valid” annotations (V 1 ∩ V 2 in Table 2).\nAmong non-neural baselines, we find that the bag-of-ngrams baseline performs slightly better than random but worse than all the other models. The Community QA baseline, on the other hand, performs better than the neural baseline (Neural (p, q)), both of which are trained without using the answers. The neural baselines with answers (Neural(p, q, a) and Neural(p, a)) outperform the neural baseline without answers (Neural(p, q)), showing that answer helps in selecting the right question.\nMore importantly, EVPI outperforms the Neural (p, q, a) baseline across most metrics. Both models use the same information regarding the true question and answer and are trained using the same number of model parameters.17 However, the EVPI model, unlike the neural baseline, additionally makes use of alternate question and answer candidates to compute its loss function. This shows that when the candidate set consists of questions similar to the original question, summing over their utilities gives us a boost."
  }, {
    "heading": "5.2.2 Evaluating against the original question",
    "text": "The last column in Table 2 shows the results when evaluated against the original question paired with the post. The bag-of-ngrams baseline performs similar to random, unlike when evaluated against human judgments. The Community QA baseline again outperforms Neural(p, q) model and comes very close to the Neural (p, a) model.\nAs before, the neural baselines that make use of the answer outperform the one that does not use the answer and the EVPI model performs significantly better than Neural(p, q, a)."
  }, {
    "heading": "5.2.3 Excluding the original question",
    "text": "In the preceding analysis, we considered a setting in which the “ground truth” original question was in the candidate set Q. While this is a common evaluation framework in dialog response selection (Lowe et al., 2015), it is overly optimistic. We, therefore, evaluate against the “best” and the “valid” annotations on the nine other question candidates. We find that the neural models beat the\n17We use 10 hidden layers in the feedforward network of the neural baseline and five hidden layers each in the two feedforward networks Fans and Futil of the EVPI model.\nnon-neural baselines. However, the differences between all the neural models are statistically insignificant.18"
  }, {
    "heading": "6 Related work",
    "text": "Most prior work on question generation has focused on generating reading comprehension questions: given text, write questions that one might find on a standardized test (Vanderwende, 2008; Heilman, 2011; Rus et al., 2011; Olney et al., 2012). Comprehension questions, by definition, are answerable from the provided text. Clarification questions–our interest–are not.\nOutside reading comprehension questions, Labutov et al. (2015) generate high-level question templates by crowdsourcing which leads to significantly less data than we collect using our method. Liu et al. (2010) use template question generation to help authors write better related work sections. Mostafazadeh et al. (2016) introduce a Visual Question Generation task where the goal is to generate natural questions that are not about what is present in the image rather about what can be inferred given the image, somewhat analogous to clarification questions. Penas and Hovy (2010) identify the notion of missing information similar to us, but they fill the knowledge gaps in a text with the help of external knowledge bases, whereas we instead ask clarification questions. Artzi and Zettlemoyer (2011) use human-generated clarification questions to drive a semantic parser where the clarification questions are aimed towards simplifying a user query; whereas we generate clarification questions aimed at identifying missing information in a text.\nAmong works that use community question answer forums, the keywords to questions (K2Q) system (Zheng et al., 2011) generates a list of candidate questions and refinement words, given a set of input keywords, to help a user ask a better question. Figueroa and Neumann (2013) rank different paraphrases of query for effective search on forums. (Romeo et al., 2016) develop a neural network based model for ranking questions on forums with the intent of retrieving similar other question. The recent SemEval-2017 Community QuestionAnswering (CQA) (Nakov et al., 2017) task included a subtask to rank the comments according to their relevance to the post. Our task primarily differs from this task in that we want to identify a\n18Results included in the supplementary material.\nquestion comment which is not only relevant to the post but will also elicit useful information missing from the post. Hoogeveen et al. (2015) created the CQADupStack dataset using StackExchange forums for the task of duplicate question retrieval. Our dataset, on the other hand, is designed for the task of ranking clarification questions asked as comments to a post."
  }, {
    "heading": "7 Conclusion",
    "text": "We have constructed a new dataset for learning to rank clarification questions, and proposed a novel model for solving this task. Our model integrates well-known deep network architectures with the classic notion of expected value of perfect information, which effectively models a pragmatic choice on the part of the questioner: how do I imagine the other party would answer if I were to ask this question. Such pragmatic principles have recently been shown to be useful in other tasks as well (Golland et al., 2010; Smith et al., 2013; Orita et al., 2015; Andreas and Klein, 2016). One can naturally extend our EVPI approach to a full reinforcement learning approach to handle multi-turn conversations.\nOur results shows that the EVPI model is a promising formalism for the question generation task. In order to move to a full system that can help users like Terry write better posts, there are three interesting lines of future work. First, we need it to be able to generalize: for instance by constructing templates of the form “What version of are you running?” into which the system would need to fill a variable. Second, in order to move from question ranking to question generation, one could consider sequence-to-sequence based neural network models that have recently proven to be effective for several language generation tasks (Sutskever et al., 2014; Serban et al., 2016; Yin et al., 2016). Third is in evaluation: given that this task requires expert human annotations and also given that there are multiple possible good questions to ask, how can we automatically measure performance at this task?, a question faced in dialog and generation more broadly (Paek, 2001; Lowe et al., 2015; Liu et al., 2016)."
  }, {
    "heading": "Acknowledgments",
    "text": "The authors thank the three anonymous reviewers of this paper, and the anonymous reviewers of the previous versions for their helpful comments and\nsuggestions. They also thank the members of the Computational Linguistics and Information Processing (CLIP) lab at University of Maryland for helpful discussions.\nThis work was supported by NSF grant IIS1618193. Any opinions, findings, conclusions, or recommendations expressed here are those of the authors and do not necessarily reflect the view of the sponsors."
  }],
  "year": 2018,
  "references": [{
    "title": "Reasoning about pragmatics with neural listeners and speakers",
    "authors": ["Jacob Andreas", "Dan Klein."],
    "venue": "Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing. pages 1173–1182.",
    "year": 2016
  }, {
    "title": "Bootstrapping semantic parsers from conversations",
    "authors": ["Yoav Artzi", "Luke Zettlemoyer."],
    "venue": "Proceedings of the conference on empirical methods in natural language processing. Association for Computational Linguistics, pages 421–432.",
    "year": 2011
  }, {
    "title": "The value of information and stochastic programming",
    "authors": ["Mordecai Avriel", "AC Williams."],
    "venue": "Operations Research 18(5):947–954.",
    "year": 1970
  }, {
    "title": "Learning to rank effective paraphrases from query logs for community question answering",
    "authors": ["Alejandro Figueroa", "Günter Neumann."],
    "venue": "AAAI. volume 13, pages 1099–1105.",
    "year": 2013
  }, {
    "title": "A game-theoretic approach to generating spatial descriptions",
    "authors": ["Dave Golland", "Percy Liang", "Dan Klein."],
    "venue": "Proceedings of the 2010 conference on empirical methods in natural language processing. Association for Computational Linguistics, pages",
    "year": 2010
  }, {
    "title": "Automatic factual question generation from text",
    "authors": ["Michael Heilman."],
    "venue": "Ph.D. thesis, Carnegie Mellon University.",
    "year": 2011
  }, {
    "title": "Long short-term memory",
    "authors": ["Sepp Hochreiter", "Jürgen Schmidhuber."],
    "venue": "Neural computation 9(8):1735–1780.",
    "year": 1997
  }, {
    "title": "Cqadupstack: A benchmark data set for community question-answering research",
    "authors": ["Doris Hoogeveen", "Karin M Verspoor", "Timothy Baldwin."],
    "venue": "Proceedings of the 20th Australasian Document Computing Symposium. ACM, page 3.",
    "year": 2015
  }, {
    "title": "Deep questions without deep understanding",
    "authors": ["Igor Labutov", "Sumit Basu", "Lucy Vanderwende."],
    "venue": "ACL (1). pages 889–898.",
    "year": 2015
  }, {
    "title": "How not to evaluate your dialogue system: An empirical study of unsupervised evaluation metrics for dialogue response generation",
    "authors": ["Chia-Wei Liu", "Ryan Lowe", "Iulian Serban", "Mike Noseworthy", "Laurent Charlin", "Joelle Pineau."],
    "venue": "Proceedings of the",
    "year": 2016
  }, {
    "title": "Automatic question generation for literature review writing support",
    "authors": ["Ming Liu", "Rafael A Calvo", "Vasile Rus."],
    "venue": "International Conference on Intelligent Tutoring Systems. Springer, pages 45–54.",
    "year": 2010
  }, {
    "title": "The ubuntu dialogue corpus: A large dataset for research in unstructured multi-turn dialogue systems",
    "authors": ["Ryan Lowe", "Nissan Pow", "Iulian V Serban", "Joelle Pineau."],
    "venue": "16th Annual Meeting of the Special Interest Group on Discourse and Dialogue. page",
    "year": 2015
  }, {
    "title": "Generating natural questions about an image",
    "authors": ["Nasrin Mostafazadeh", "Ishan Misra", "Jacob Devlin", "Margaret Mitchell", "Xiaodong He", "Lucy Vanderwende."],
    "venue": "Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics",
    "year": 2016
  }, {
    "title": "Semeval-2017 task 3: Community question answering",
    "authors": ["Preslav Nakov", "Doris Hoogeveen", "Lluı́s Màrquez", "Alessandro Moschitti", "Hamdy Mubarak", "Timothy Baldwin", "Karin Verspoor"],
    "venue": "In Proceedings of the 11th International Workshop on Semantic",
    "year": 2017
  }, {
    "title": "Iit-uhh at semeval-2017 task 3: Exploring multiple features for community question answering and implicit dialogue",
    "authors": ["Titas Nandi", "Chris Biemann", "Seid Muhie Yimam", "Deepak Gupta", "Sarah Kohail", "Asif Ekbal", "Pushpak Bhattacharyya"],
    "year": 2017
  }, {
    "title": "Question generation from concept maps",
    "authors": ["Andrew McGregor Olney", "Arthur C Graesser", "Natalie K Person."],
    "venue": "D&D 3(2):75–99.",
    "year": 2012
  }, {
    "title": "Why discourse affects speakers’ choice of referring expressions",
    "authors": ["Naho Orita", "Eliana Vornov", "Naomi Feldman", "Hal Daumé III."],
    "venue": "ACL (1). pages 1639–1649.",
    "year": 2015
  }, {
    "title": "Empirical methods for evaluating dialog systems",
    "authors": ["Tim Paek."],
    "venue": "Proceedings of the workshop on Evaluation for Language and Dialogue SystemsVolume 9. Association for Computational Linguistics, page 2.",
    "year": 2001
  }, {
    "title": "Filling knowledge gaps in text for machine reading",
    "authors": ["Anselmo Penas", "Eduard Hovy."],
    "venue": "Proceedings of the 23rd International Conference on Computational Linguistics: Posters. Association for Computational Linguistics, pages 979–987.",
    "year": 2010
  }, {
    "title": "Glove: Global vectors for word representation",
    "authors": ["Jeffrey Pennington", "Richard Socher", "Christopher Manning."],
    "venue": "Proceedings of the 2014 conference on empirical methods in natural language processing (EMNLP). pages 1532–1543.",
    "year": 2014
  }, {
    "title": "Neural attention for learning to rank questions in community",
    "authors": ["Salvatore Romeo", "Giovanni Da San Martino", "Alberto Barrón-Cedeno", "Alessandro Moschitti", "Yonatan Belinkov", "Wei-Ning Hsu", "Yu Zhang", "Mitra Mohtarami", "James Glass"],
    "year": 2016
  }, {
    "title": "Question generation shared task and evaluation challenge: Status report",
    "authors": ["Vasile Rus", "Paul Piwek", "Svetlana Stoyanchev", "Brendan Wyse", "Mihai Lintean", "Cristian Moldovan."],
    "venue": "Proceedings of the 13th European Workshop on Natural Language",
    "year": 2011
  }, {
    "title": "Building end-to-end dialogue systems using generative hierarchical neural network models",
    "authors": ["Iulian Vlad Serban", "Alessandro Sordoni", "Yoshua Bengio", "Aaron C Courville", "Joelle Pineau."],
    "venue": "AAAI. pages 3776–3784.",
    "year": 2016
  }, {
    "title": "Learning and using language via recursive pragmatic reasoning about other agents",
    "authors": ["Nathaniel J Smith", "Noah Goodman", "Michael Frank."],
    "venue": "Advances in neural information processing systems. pages 3039–3047.",
    "year": 2013
  }, {
    "title": "Sequence to sequence learning with neural networks",
    "authors": ["Ilya Sutskever", "Oriol Vinyals", "Quoc V Le."],
    "venue": "Advances in neural information processing systems. pages 3104–3112.",
    "year": 2014
  }, {
    "title": "The importance of being important: Question generation",
    "authors": ["Lucy Vanderwende."],
    "venue": "Proceedings of the 1st Workshop on the Question Generation Shared Task Evaluation Challenge, Arlington, VA.",
    "year": 2008
  }, {
    "title": "Neural generative question answering",
    "authors": ["Jun Yin", "Xin Jiang", "Zhengdong Lu", "Lifeng Shang", "Hang Li", "Xiaoming Li."],
    "venue": "Proceedings of the TwentyFifth International Joint Conference on Artificial Intelligence. AAAI Press, pages 2972–2978.",
    "year": 2016
  }, {
    "title": "K2q: Generating natural language questions from keywords with user refinements",
    "authors": ["Zhicheng Zheng", "Xiance Si", "Edward Chang", "Xiaoyan Zhu."],
    "venue": "Proceedings of 5th International Joint Conference on Natural Language Processing. pages 947–955.",
    "year": 2011
  }],
  "id": "SP:8ab39df4ea76bda0afa38c11708ebcce25882937",
  "authors": [{
    "name": "Sudha Rao",
    "affiliations": []
  }],
  "abstractText": "Inquiry is fundamental to communication, and machines cannot effectively collaborate with humans unless they can ask questions. In this work, we build a neural network model for the task of ranking clarification questions. Our model is inspired by the idea of expected value of perfect information: a good question is one whose expected answer will be useful. We study this problem using data from StackExchange, a plentiful online resource in which people routinely ask clarifying questions to posts so that they can better offer assistance to the original poster. We create a dataset of clarification questions consisting of ∼77K posts paired with a clarification question (and answer) from three domains of StackExchange: askubuntu, unix and superuser. We evaluate our model on 500 samples of this dataset against expert human judgments and demonstrate significant improvements over controlled baselines.",
  "title": "Learning to Ask Good Questions: Ranking Clarification Questions using Neural Expected Value of Perfect Information"
}