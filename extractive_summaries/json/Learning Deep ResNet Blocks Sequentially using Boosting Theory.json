{
  "sections": [{
    "heading": "1. Introduction",
    "text": "Why do residual neural networks (ResNets) (He et al., 2016) and the related highway networks (Srivastava et al., 2015) work? And if we study closely why they work, can we come up with new understandings of how to train them and how to define working algorithms?\nDeep neural networks have elicited breakthrough successes in machine learning, especially in image classification and object recognition (Krizhevsky et al., 2012; Sermanet et al., 2013; Simonyan & Zisserman, 2014; Zeiler & Fergus, 2014) in recent years. As the number of layers increases, the nonlinear network becomes more powerful, deriving richer features from input data. Empirical studies suggest that challenging tasks in image classification (He et al., 2015; Ioffe\n1Department of Computer Science, University of Maryland; 2Department of Computer Science, Princeton University; 3Microsoft Research. Correspondence to: Furong Huang <furongh@cs.umd.edu>.\nProceedings of the 35 th International Conference on Machine Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018 by the author(s).\n& Szegedy, 2015; Simonyan & Zisserman, 2014; Szegedy et al., 2015) and object recognition (Girshick, 2015; Girshick et al., 2014; He et al., 2014; Long et al., 2015; Ren et al., 2015) often require “deep” networks, consisting of tens or hundreds of layers. Theoretical analyses have further justified the power of deep networks (Mhaskar & Poggio, 2016) compared to shallow networks.\nHowever, deep neural networks are difficult to train despite their intrinsic representational power. Stochastic gradient descent with back-propagation (BP) (LeCun et al., 1989) and its variants are commonly used to solve the non-convex optimization problems. A major challenge that exists for training both shallow and deep networks is vanishing or exploding gradients (Bengio et al., 1994; Glorot & Bengio, 2010). Recent works have proposed normalization techniques (Glorot & Bengio, 2010; LeCun et al., 2012; Ioffe & Szegedy, 2015; Saxe et al., 2013) to effectively ease the problem and achieve convergence. In training deep networks, however, a surprising training performance degradation is observed (He & Sun, 2015; Srivastava et al., 2015; He et al., 2016): the training performance degrades rapidly with increased network depth after some saturation point. This training performance degradation is representationally surprising as one can easily construct a deep network identical to a shallow network by forcing any part of the deep network to be the same as the shallow network with the remaining layers functioning as identity maps. He et al. (He et al., 2016) presented a residual network (ResNet) learning framework to ease the training of networks that are substantially deeper than those used previously. And they explicitly reformulate the layers as learning residual functions with reference to the layer inputs by adding identity loops to the layers. It is shown in (Hardt & Ma, 2016) that identity loops ease the problem of spurious local optima in shallow networks. Srivastava et al. (Srivastava et al., 2015) introduce a novel architecture that enables the optimization of networks with virtually arbitrary depth through the use of a learned gating mechanism for regulating information flow.\nEmpirical evidence overwhelmingly shows that these deep residual networks are easier to optimize than non-residual ones. Can we develop a theoretical justification for this observation? And does that justification point us towards new algorithms with better characteristics?"
  }, {
    "heading": "1.1. Summary of Results",
    "text": "We propose a new framework, multi-channel telescoping sum boosting (defined in Section 4), to characterize a feed forward ResNet in Section 3. We show that the top level (final) output of a ResNet can be thought of as a layer-bylayer boosting method (defined in Section 2). Traditional boosting, which ensembles “estimated score functions” or “estimated labels” from weak learners, does not work in the ResNet setting because of two reasons: (1) ResNet is a telescoping sum boosting of weak learners, not a naive (weighted) ensemble; (2) ResNet boosts over “representations”, not “estimated labels”. We provide the first error bound for telescoping sum boosting over features. Boosting over features and boosting over labels are different. There is no existing work that proves a boosting theory (guaranteed 0 training error) for boosting features. Moreover, the special structure of a ResNet entails more complicated analysis: telescoping sum boosting, which has never been introduced before in the existing literature.\nWe introduce a learning algorithm (BoostResNet) guaranteed to reduce error exponentially as depth increases so long as a weak learning assumption is obeyed. BoostResNet adaptively selects training samples or changes the cost function (Section 4 Theorem 4.2). In Section 4.4, we analyze the generalization error of BoostResNet and provide advice to avoid overfitting. The procedure trains each residual block sequentially, only requiring that each provides a better-than-a-weak-baseline in predicting labels.\nBoostResNet requires radically lower computational complexity for training than end-to-end back propagation (e2eBP). The number of gradient updates required by BoostResNet is much smaller than e2eBP as discussed in Section 4.3. Memorywise, BoostResNet requires only individual layers of the network to be in the graphics processing unit (GPU) while e2eBP inevitably keeps all layers in the GPU. For example, in a state-of-the-art deep ResNet, this might reduce the RAM requirements for GPU by a factor of the depth of the network. Similar improvements in computation are observed since each e2eBP step involves back propagating through the entire deep network.\nExperimentally, we compare BoostResNet with e2eBP over two types of feed-forward ResNets, multilayer perceptron residual network (MLP-ResNet) and convolutional neural network residual network (CNN-ResNet), on multiple datasets. BoostResNet shows substantial computational performance improvements and accuracy improvement under the MLP-ResNet architecture. Under CNN-ResNet, a faster convergence for BoostResNet is observed.\nOne of the hallmarks of our approach is to make an explicit distinction between the classes of the multiclass learning problem and channels that are constructed by the learning\nprocedure. A channel here is essentially a scalar value modified by the rounds of boosting so as to implicitly minimize the multiclass error rate. Our multi-channel telescoping sum boosting learning framework is not limited to ResNet and can be extended to other, even non-differentiable, nonlinear hypothesis units, such as decision trees or tensor decompositions. Our contribution does not limit to explaining ResNet in the boosting framework, we have also developed a new boosting framework for other relevant tasks that require multi-channel telescoping sum structure."
  }, {
    "heading": "1.2. Related Works",
    "text": "Training deep neural networks has been an active research area in the past few years. The main optimization challenge lies in the highly non-convex nature of the loss function. There are two main ways to address this optimization problem: one is to select a loss function and network architecture that have better geometric properties (details refer to appendix A.1), and the other is to improve the network’s learning procedure (details refer to appendix A.2).\nMany authors have previously looked into neural networks and boosting, each in a different way. Bengio et al. (2006) introduce single hidden layer convex neural networks, and propose a gradient boosting algorithm to learn the weights of the linear classifier. The approach has not been generalized to deep networks with more than one hidden layer. ShalevShwartz (2014) proposes a selfieBoost algorithm which boosts the accuracy of an entire network. Our algorithm is different as we instead construct ensembles of classifiers. Veit et al. (2016) interpret residual networks as a collection of many paths of differing length. Their empirical study shows that residual networks avoid the vanishing gradient problem by introducing short paths which can carry gradient throughout the extent of very deep networks.\nComparison with AdaNet The authors of AdaNet (Cortes et al., 2016) consider ensembles of neural layers with a boosting-style algorithm and provide a method for structural learning of neural networks by optimizing over the generalization bound, which consists of the training error and the complexity of the AdaNet architecture. AdaNet uses the traditional boosting framework where weak classifiers are being boosted. Therefore, to obtain low training error guarantee, AdaNet maps the feature vectors (hidden layer representations) to a classifier space and boosts the weak classifiers. In AdaNet, features (representations) from each lower layer have to be fed into a classifier (in other words, be transferred to score function in the label space). This is because AdaNet uses traditional boosting, which ensembles score functions or labels. As a result, the top classifier in AdaNet has to be connected to all lower layers, making the structure bushy. Therefore AdaNet chooses its own structure during learning, and its boosting theory does not\nnecessarily work for a ResNet structure. Our BoostResNet, instead, boosts features (representations) over multiple channels, and thus produces a less “bushy” architecture. We are able to boost features by developing this new “telescopingsum boosting” framework, one of our main contributions. We come up with the new weak learning condition for the telescoping-sum boosting framework. The algorithm is also very different from AdaNet and is explained in details in section 3 and 4.\nBoostResNet focuses on a ResNet architecture, provides a new training algorithm for ResNet, and proves a training error guarantee for deep ResNet architecture. A ResNetstyle architecture is a special case of AdaNet, so AdaNet generalization guarantee applies here and our generalization analysis is built upon their work."
  }, {
    "heading": "2. Preliminaries",
    "text": "A residual neural network (ResNet) is composed of stacked entities referred to as residual blocks. Each residual block consists of a neural network module and an identity loop (shortcut). Commonly used modules include MLP and CNN. Throughout this paper, we consider training and test examples generated i.i.d. from some distribution D over X × Y , where X is the input space and Y is the label space. We denote by S = ((x1, y1), (x2, y2), . . . , (xm, ym)) a training set of m examples drawn according to Dm.\nA Residual Block of ResNet ResNet consists of residual blocks. Each residual block contains a module and an identity loop. Let each module map its input x̃ to ft(x̃) where t denotes the level of the modules. Each module ft is a nonlinear unit with n channels, i.e., ft(·) ∈ Rn. In multilayer perceptron residual network (MLP-ResNet), ft is a shallow MLP, for instance, ft(x̃) = Ṽ >t σ(W̃ > t x̃) where W̃t ∈ Rn×k, Ṽt ∈ Rk×n and σ is a nonlinear operator such as sigmoidal function or relu function. Similarly, in convo-\nlutional neural network residual network (CNN-ResNet), ft(·) represents the t-th convolutional module. Then the t-th residual block outputs gt+1(x)\ngt+1(x) = ft(gt(x)) + gt(x), (1)\nwhere x is the input fed to the ResNet. See Figure 1 for an illustration of a ResNet, which consists of stacked residual blocks (each residual block contains a nonlinear module and an identity loop).\nOutput of ResNet Due to the recursive relation specified in Equation (1), the output of the T -th residual block is equal to the summation over lower module outputs, i.e., gT+1(x) = ∑T t=0 ft(gt(x)), where g0(x) = 0 and f0(g0(x)) = x. For binary classification tasks, the final output of a ResNet given input x is rendered after a linear classifier w ∈ Rn on representation gT+1(x) (In the multiclass setting, let C be the number of classes; the linear classifier W ∈ Rn×C is a matrix instead of a vector.):\nŷ = σ̃ (F (x)) = σ̃(w>gT+1(x)) = σ̃ ( w>\nT∑ t=0 ft(gt(x)) ) (2)\nwhere F (x) = w>gT+1(x) and σ̃(·) denotes a map from classifier outputs (scores) to labels. For instance σ̃(z) = sign(z) for binary classification (σ̃(z) = arg max\ni zi for\nmulticlass classification). The parameters of a depthT ResNet are {w, {ft(·),∀t ∈ T}}. A ResNet training involves training the classifier w and the weights of modules ft(·) ∀t ∈ [T ] when training examples (x1, y1), (x2, y2), . . . , (xm, ym) are available.\nBoosting Boosting (Freund & Schapire, 1995) assumes the availability of a weak learning algorithm which, given labeled training examples, produces a weak classifier (a.k.a. base classifier). The goal of boosting is to improve the performance of the weak learning algorithm. The key idea behind boosting is to choose training sets for the weak classifier in such a fashion as to force it to infer something new about the data each time it is called. The weak learning algorithm will finally combine many weak classifiers into a single strong classifier whose prediction power is strong.\nFrom empirical experience, ResNet remedies the problem of training error degradation (instability of solving nonconvex optimization problem using SGD) in deeper neural networks. We are curious about whether there is a theoretical justification that identity loops help in training. More importantly, we are interested in proposing a new algorithm that avoids end-to-end back-propagation (e2eBP) through the deep network and thus is immune to the instability of SGD for non-convex optimization of deep neural networks."
  }, {
    "heading": "3. ResNet in Telescoping Sum Boosting Framework",
    "text": "As we recall from Equation (2), ResNet indeed has a similar form as the strong classifier in boosting. The key difference is that boosting is an ensemble of estimated hypotheses whereas ResNet is an ensemble of estimated feature representations ∑T t=0 ft(gt(x)). To solve this problem, we introduce an auxiliary linear classifier wt on top of each residual block to construct a hypothesis module. Formally, a hypothesis module is defined as\not(x) def = w>t gt(x) ∈ R (3)\nin the binary classification setting. Therefore ot+1(x) = w>t+1[ft(gt(x)) + gt(x)] as gt+1(x) = ft(gt(x)) + gt(x). We emphasize that given gt(x), we only need to train ft and wt+1 to train ot+1(x). In other words, we feed the output of previous residual block (gt(x)) to the current module and train the weights of current module ft(·) and the auxiliary classifier wt+1.\nNow the input, gt+1(x), of the t + 1-th residual block is the output, ft(gt(x)) + gt(x), of the t-th residual block. As a result, ot(x) = ∑t−1 t′=0 w > t ft′(gt′(x)). In other words, the auxiliary linear classifier is common for all modules underneath. It would not be realistic to assume a common auxiliary linear classifier, as such an assumption prevents us from training the T hypothesis module sequentially. We design a weak module classifier using the idea of telescoping sum as follows.\nDefinition 3.1. A weak module classifier is defined as\nht(x) def = αt+1ot+1(x)− αtot(x) (4)\nwhere ot(x) def = w>t gt(x) is a hypothesis module, and αt is a scalar. We call it a “telescoping sum boosting” framework if the weak learners are restricted to the form of the weak module classifier.\nResNet: Ensemble of Weak Module Classifiers Recall that the T -th residual block of a ResNet outputs gT+1(x), which is fed to the top/final linear classifier for the final classification. We show that an ensemble of the weak module classifiers is equivalent to a ResNet’s final output. We state it formally in Lemma 3.2. For purposes of exposition, we will call F (x) the output of ResNet although a σ̃ function is applied on top of F (x), mapping the output to the label space Y . Lemma 3.2. Let the input gt(x) of the t-th module be the output of the previous module, i.e., gt+1(x) = ft(gt(x)) + gt(x). Then the summation of T weak module classifiers divided by αT+1 is identical to the output, F (x), of the\ndepth-T ResNet,\nF (x) = w>gT+1(x) ≡ 1\nαT+1 T∑ t=0 ht(x), (5)\nwhere the weak module classifier ht(x) is defined in Equation (4).\nSee Appendix B for the proof. Overall, our proposed ensemble of weak module classifiers is a new framework that allows for sequential training of ResNet. Note that traditional boosting algorithm results do not apply here. We now analyze our telescoping sum boosting framework in Section 4. Our analysis applies to both binary and multiclass, but we will focus on the binary class for simplicity in the main text and defer the multiclass analysis to the Appendix F."
  }, {
    "heading": "4. Telescoping Sum Boosting for Binary Classification",
    "text": "Below, we propose a learning algorithm whose training error decays exponentially with the number of weak module classifiers T under a weak learning condition. We restrict to bounded hypothesis modules, i.e., |ot(x)| ≤ 1."
  }, {
    "heading": "4.1. Weak Learning Condition",
    "text": "The weak module classifier involves the difference between (scaled version of) ot+1(x) and ot(x). Let γ̃t def = Ei∼Dt−1 [yiot(xi)] > 0 be the edge of the hypothesis module ot(x), where Dt−1 is the weight of the examples. As the hypothesis module ot(x) is bounded by 1, we obtain |γ̃t| ≤ 1. So γ̃t characterizes the performance of the hypothesis module ot(x). A natural requirement would be that ot+1(x) improves slightly upon ot(x), and thus γ̃t+1 − γ̃t ≥ γ′ > 0 could serve as a weak learning condition. However this weak learning condition is too strong: even when current hypothesis module is performing almost ideally (γ̃t is close to 1), we still seek a hypothesis module which performs consistently better than the previous one by γ′. Instead, we consider a much weaker learning condition, inspired by training error analysis, as follows.\nDefinition 4.1 (γ-Weak Learning Condition). A weak module classifier ht(x) = αt+1ot+1−αtot satisfies the γ-weak learning condition if γ̃ 2 t+1−γ̃ 2 t\n1−γ̃2t ≥ γ2 > 0 and the covariance\nbetween exp(−yot+1(x)) and exp(yot(x)) is non-positive.\nThe weak learning condition is motivated by the learning theory and it is met in practice (refer to Figure 4).\nInterpretation of weak learning condition For each weak\nmodule classifier ht(x), γt def = √ γ̃2t+1−γ̃2t 1−γ̃2t characterizes the normalized improvement of the correlation between the true\nAlgorithm 1 BoostResNet: telescoping sum boosting for binary-class classification Input: m labeled samples [(xi, yi)]m where yi ∈ {−1,+1} and a threshold γ Output: {ft(·),∀t} and wT+1 . Discard wt+1, ∀t 6= T\n1: Initialize t← 0, γ̃0 ← 0, α0 ← 0, o0(x)← 0 2: Initialize sample weights at round 0: D0(i)← 1/m, ∀i ∈ [m] 3: while γt > γ do 4: ft(·), αt+1,wt+1, ot+1(x)← Algorithm 2(gt(x), Dt, ot(x), αt)\n5: Compute γt ← √\nγ̃2t+1−γ̃2t 1−γ̃2t\n. where γ̃t+1 ← Ei∼Dt [yiot+1(xi)]\n6: Update Dt+1(i)← Dt(i) exp(−yiht(xi))m∑ i=1 Dt(i) exp[−yiht(xi)] . where ht(x) = αt+1ot+1(x)− αtot(x) 7: t← t+ 1 8: end while 9: T ← t− 1\nAlgorithm 2 BoostResNet: oracle implementation for training a ResNet block Input: gt(x),Dt,ot(x) and αt Output: ft(·), αt+1, wt+1 and ot+1(x)\n1: (ft, αt+1,wt+1)← arg min (f,α,v) m∑ i=1 Dt(i) exp ( −yiαv> [f(gt(xi)) + gt(xi)] + yiαtot(xi) ) 2: ot+1(x)← w>t+1 [ft(gt(x)) + gt(x)]\nlabels y and the hypothesis modules ot+1(x) over the correlation between the true labels y and the hypothesis modules ot(x). The condition specified in Definition 4.1 is mild as it requires the hypothesis module ot+1(x) to perform only slightly better than the previous hypothesis module ot(x). In residual network, since ot+1(x) represents a depth-(t+1) residual network which is a deeper counterpart of the depth-t residual network ot(x), it is natural to assume that the deeper residual network improves slightly upon the shallower residual network. When γ̃t is close to 1, γ̃2t+1 only needs to be slightly better than γ̃2t as the denominator 1− γ̃2t is small. The assumption of the covariance between exp(−yot+1(x)) and exp(yot(x)) being non-positive is suggesting that the weak module classifiers should not be adversarial, which may be a reasonable assumption for ResNet."
  }, {
    "heading": "4.2. BoostResNet",
    "text": "We now propose a novel training algorithm for telescoping sum boosting under binary-class classification as in Algorithm 1. In particular, we introduce a training procedure for deep ResNet in Algorithm 1 & 2, BoostResNet, which only requires sequential training of shallow ResNets.\nThe training algorithm is a module-by-module procedure following a bottom-up fashion as the outputs of the t-th module gt+1(x) are fed as the training examples to the next t+ 1-th module. Each of the shallow ResNet ft(gt(x)) + gt(x) is combined with an auxiliary linear classifier wt+1 to form a hypothesis module ot+1(x). The weights of the ResNet are trained on these shallow ResNets. The telescoping sum con-\nstruction is the key for successful interpretation of ResNet as ensembles of weak module classifiers. The innovative introduction of the auxiliary linear classifiers (wt+1) is the key solution for successful multi-channel representation boosting with theoretical guarantees. Auxiliary linear classifiers are only used to guide training, and they are not included in the model (proved in Lemma 3.2). This is the fundamental difference between BoostResNet and AdaNet. AdaNet (Cortes et al., 2016) maps the feature vectors (hidden layer representations) to a classifier space and boosts the weak classifiers. Our framework is a multi-channel representation (or information) boosting rather than a traditional classifier boosting. Traditional boosting theory does not apply in our setting. Theorem 4.2. [ Training error bound ] The training error of a T -module telescoping sum boosting framework using Algorithms 1 and 2 decays exponentially with the number of modules T ,\nPr i∼S\n( σ̃ (∑ t ht (xi) ) 6= yi ) ≤ e− 12Tγ 2\nif ∀t ∈ [T ] the weak module classifier ht(x) satisfies the γ-weak learning condition defined in Definition 4.1.\nThe training error of Algorithms 1 and 2 is guaranteed to decay exponentially with the ResNet depth even when each hypothesis module ot+1(x) performs slightly better than its previous hypothesis module ot(x) (i.e., γ > 0). Refer to Appendix F for the algorithm and theoretical guarantees for multiclass classification."
  }, {
    "heading": "4.3. Oracle Implementation for ResNet",
    "text": "In Algorithm 2, the implementation of the oracle at line 1 is equivalent to\n(ft, αt+1,wt+1) =\narg min (f,α,v)\n1\nm m∑ i=1 exp ( −yiαv> [f(gt(xi)) + gt(xi)] ) (6)\nThe minimization problem over f corresponds to finding the weights of the t-th nonlinear module of the residual network. Auxiliary classifier wt+1 is used to help solve this minimization problem with the guidance of training labels yi. However, the final neural network model includes none of the auxiliary classifiers, and still follows a standard ResNet structure (proved in Lemma 3.2). In practice, there are various ways to implement Equation (6). For instance, Janzamin et. al. (Janzamin et al., 2015) propose a tensor decomposition technique which decomposes a tensor formed by some transformation of the features x combined with labels y and recovers the weights of a one-hidden layer neural network with guarantees. One can also use backpropagation as numerous works have shown that gradient based training are relatively stable on shallow networks with identity loops (Hardt & Ma, 2016; He et al., 2016).\nComputational & Memory Efficiency BoostResNet training is memory efficient as the training process only requires parameters of two consecutive residual blocks to be in memory. Given that the limited GPU memory being one of the main bottlenecks for computational efficiency, BoostResNet requires significantly less training time than e2eBP in deep networks as a result of reduced communication overhead and the speed-up in shallow gradient forwarding and back-propagation. Let M1 be the memory required for one module, and M2 be the memory required for one linear classifier, the memory consumption is M1 +M2 by BoostResNet and M1T +M2 by e2eBP. Let the flops needed for gradient update over one module and one linear classifier be C1 and C2 respectively, the computation cost is C1 +C2 by BoostResNet and C1T + C2 by e2eBP."
  }, {
    "heading": "4.4. Generalization Error Analysis",
    "text": "In this section, we analyze the generalization error to understand the possibility of overfitting under Algorithm 1. The strong classifier or the ResNet is F (x) = ∑ t ht(x)\nαT+1 .\nNow we define the margin for example (x, y) as yF (x). For simplicity, we consider MLP-ResNet with n multiple channels and assume that the weight vector connecting a neuron at layer t with its preceding layer neurons is l1 norm bounded by Λt,t−1. Recall that there exists a linear classifier w on top, and we restrict to l1 norm bounded classifiers, i.e., ‖w‖1 ≤ C0 <∞. The expected training examples are l∞ norm bounded r∞ def = ES∼D [ maxi∈[m]‖xi‖∞ ] < ∞. We introduce Corollary 4.3 which follows directly from Lemma\n2 of (Cortes et al., 2016). Corollary 4.3. (Cortes et al., 2016) LetD be a distribution over X × Y and S be a sample of m examples chosen independently at random according to D. With probability at least 1− δ, for θ > 0, the strong classifier F (x) (ResNet) satisfies that\nPr D (yF (x) ≤ 0) ≤ Pr S (yF (x) ≤ θ) +\n4C0r∞ θ\n√ log(2n)\n2m T∑ t=0 Λt + 2 θ\n√ log T\nm + β(θ,m, T, δ) (7)\nwhere Λt def = ∏t t′=0 2Λt′,t′−1 and β(θ,m, T, δ)\ndef =√⌈\n4 θ2 log ( θ2m log T )⌉ log T m + log 2δ 2m .\nFrom Corollary 4.3, we obtain a generalization error bound in terms of margin bound PrS (yF (x) ≤ θ) and network complexity 4C0r∞θ √ log(2n) 2m ∑T t=0 Λt + 2 θ √ log T m + β(θ,m, T, δ). Larger margin bound (larger θ) contributes positively to generalization accuracy, and l1 norm bounded weights (smaller ∑T t=0 Λt ) are beneficial to control network complexity and to avoid overfitting. The dominant term in\nthe network complexity is 4C0r∞θ\n√ log(2n)\n2m ∑T t=0 Λt which\nscales as least linearly with the depth T . See Appendix D for the proof.\nThis corollary suggests that stronger weak module classifiers which produce higher accuracy predictions and larger edges, will yield larger margins and suffer less from overfitting. The larger the value of θ, the smaller the term 4C0r∞ θ √ log(2n) 2m ∑T t=0 Λt + 2 θ √ log T m + β(θ,m, T, δ) is. With larger edges on the training set and when γ̃T+1 < 1, we are able to choose larger values of θ while keeping the error term zero or close to zero."
  }, {
    "heading": "5. Experiments",
    "text": "We compare our proposed BoostResNet algorithm with e2eBP training a ResNet on the MNIST (LeCun et al., 1998), street view house numbers (SVHN) (Netzer et al., 2011), and CIFAR-10 (Krizhevsky & Hinton, 2009) benchmark datasets. Two different types of architectures are tested: a ResNet where each module is a fully-connected multi-layer perceptron (MLP-ResNet) and a more common, convolutional neural network residual network (CNN-ResNet). In each experiment the architecture of both algorithms is identical, and they are both initialized with the same random seed. As a baseline, we also experiment with standard boosting (AdaBoost.MM (Mukherjee & Schapire, 2013)) of convolutional modules for SVHN and CIFAR-10 datasets. Our experiments are programmed in the Torch deep learning framework for Lua and executed on NVIDIA Tesla P100 GPUs. All models are trained using the Adam variant of SGD (Kingma & Ba, 2014)."
  }, {
    "heading": "107 108 109 1010",
    "text": "Hyperparameters are selected via random search for highest accuracy on a validation set. They are specified in Appendix H. In BoostResNet, the most important hyperparameters, according to our experiments, are those that govern when the algorithm stops training the current module and begins training its successor.\nMLP-ResNet on MNISTThe MNIST database (LeCun et al., 1998) of handwritten digits has a training set of 60,000 examples, and a test set of 10,000 examples. The data contains ten classes. We test the performance of BoostResNet on MLP-ResNet using MNIST dataset, and compare it with e2eBP baseline. Each residual block is composed of an MLP with a single, 1024-dimensional hidden layer. The training and test error between BoostResNet and e2eBP is in Figure 2 as a function of depth. Surprisingly, we find that training error degrades for e2eBP, although the ResNet’s identity loop is supposed to alleviate this problem. Our pro-\nposed sequential training procedure, BoostResNet, relieves gradient instability issues, and continues to perform well as depth increases.\nCNN-ResNet on SVHN SVHN (Netzer et al., 2011) is a real-world image dataset, obtained from house numbers in Google Street View images. The dataset contains over 600,000 training images, and about 20,000 test images. We fit a 50-layer, 25-residual-block CNN-ResNet using both BoostResNet and e2eBP (figure 3a). Each residual block is composed of a CNN using 15 3 × 3 filters. We refine the result of BoostResNet by initializing the weights using the result of BoostResNet and run end-to-end back propagation (e2eBP). From figure 3a, our BoostResNet converges much faster (requires much fewer gradient updates) than e2eBP. The test accuracy of BoostResNet is comparable with e2eBP.\nCNN-ResNet on CIFAR-10 The CIFAR-10 dataset is a benchmark dataset composed of 10 classes of small images,\nsuch as animals and vehicles. It consists of 50,000 training images and 10,000 test images. We again fit a 50-layer, 25- residual-block CNN-ResNet using both BoostResNet and e2eBP (figure 3b). BoostResNet training converges to the optimal solution faster than e2eBP. Unlike in the previous two datasets, the efficiency of BoostResNet comes at a cost when training with CIFAR-10. We find that the test accuracy of the e2eBP refined BoostResNet to be slightly lower than that produced by e2eBP.\nWeak Learning Condition Check The weak learning condition (Definition 4.1) inspired by learning theory is checked in Figure 4. The required better than random guessing edge γt is depicted in Figure 4a, it is always greater than 0 and our weak learning condition is thus non-vacuous. In Figure 4b, the representations we learned using BoostResNet is increasingly better (for this classification task) as the depth increases.\nComparison of BoostResNet, e2eBP and AdaBoost Besides e2eBP, we also experiment with standard boosting (AdaBoost.MM (Mukherjee & Schapire, 2013)), as another baseline, of convolutional modules. In this experiment, each weak learner is a residual block of the ResNet, paired with a classification layer. We do 25 rounds of AdaBoost.MM and train each weak learner to convergence. Table 1 and table 2 exhibit a comparison of BoostResNet, e2eBP and AdaBoost performance on SVHN and CIFAR-10 dataset respectively.\nOn SVHN dataset, the advantage of BoostResNet over e2eBP is obvious. Using 3 × 108 number of gradient updates, BoostResNet achieves 93.8% test accuracy whereas e2eBP obtains a test accuracy of 83%. The training and test accuracies of SVHN are listed in Table 1. BoostResNet training allows the model to train much faster than end-toend training, and still achieves the same test accuracy when refined with e2eBP. To list the hyperparameters we use in our BoostResNet training after searching over candidate hyperparamters, we optimize learning rate to be 0.004 with a 9 × 10−5 learning rate decay. The gamma threshold is optimized to be 0.001 and the initial gamma value on SVHN is 0.75. On CIFAR-10 dataset, the main advantage of BoostResNet over e2eBP is the speed of training. BoostResNet refined with e2eBP obtains comparable results with e2eBP.\nThis is because we are using a suboptimal architecture of ResNet which overfits the CIFAR-10 dataset. AdaBoost, on the other hand, is known to be resistant to overfitting. In BoostResNet training, we optimize learning rate to be 0.014 with a 3.46× 10−5 learning rate decay. The gamma threshold is optimized to be 0.007 and the initial gamma value on CIFAR-10 is 0.93. We find that a standard ResNet, to its credit, is quite robust to hyperparameters, namely learning rate and learning rate decay, provided that we use an optimization procedure that automatically modulates these values."
  }, {
    "heading": "6. Conclusions and Future Works",
    "text": "Our proposed BoostResNet algorithm achieves exponentially decaying (with the depth T ) training error under the weak learning condition. BoostResNet is much more computationally efficient compared to end-to-end backpropagation in deep ResNet. More importantly, the memory required by BoostResNet is trivial compared to end-to-end back-propagation. It is particularly beneficial given the limited GPU memory and large network depth. Our learning framework is natural for non-differentiable data. For instance, our learning framework is amenable to take weak learning oracles using tensor decomposition techniques. Tensor decomposition, a spectral learning framework with theoretical guarantees, is applied to learning one layer MLP in (Janzamin et al., 2015). We plan to extend our learning framework to non-differentiable data using general weak learning oracles."
  }],
  "year": 2018,
  "references": [{
    "title": "Learning long-term dependencies with gradient descent is difficult",
    "authors": ["Y. Bengio", "P. Simard", "P. Frasconi"],
    "venue": "IEEE transactions on neural networks,",
    "year": 1994
  }, {
    "title": "Adanet: Adaptive structural learning of artificial neural networks",
    "authors": ["C. Cortes", "X. Gonzalvo", "V. Kuznetsov", "M. Mohri", "S. Yang"],
    "venue": "arXiv preprint arXiv:1607.01097,",
    "year": 2016
  }, {
    "title": "A desicion-theoretic generalization of on-line learning and an application to boosting",
    "authors": ["Y. Freund", "R.E. Schapire"],
    "venue": "In European conference on computational learning theory,",
    "year": 1995
  }, {
    "title": "Fast r-cnn",
    "authors": ["R. Girshick"],
    "venue": "In Proceedings of the IEEE International Conference on Computer Vision, pp",
    "year": 2015
  }, {
    "title": "Rich feature hierarchies for accurate object detection and semantic segmentation",
    "authors": ["R. Girshick", "J. Donahue", "T. Darrell", "J. Malik"],
    "venue": "In Proceedings of the IEEE conference on computer vision and pattern recognition,",
    "year": 2014
  }, {
    "title": "Understanding the difficulty of training deep feedforward neural networks",
    "authors": ["X. Glorot", "Y. Bengio"],
    "venue": "In Aistats,",
    "year": 2010
  }, {
    "title": "Identity matters in deep learning",
    "authors": ["M. Hardt", "T. Ma"],
    "venue": "arXiv preprint arXiv:1611.04231,",
    "year": 2016
  }, {
    "title": "Convolutional neural networks at constrained time cost",
    "authors": ["K. He", "J. Sun"],
    "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
    "year": 2015
  }, {
    "title": "Spatial pyramid pooling in deep convolutional networks for visual recognition",
    "authors": ["K. He", "X. Zhang", "S. Ren", "J. Sun"],
    "venue": "In European Conference on Computer Vision,",
    "year": 2014
  }, {
    "title": "Delving deep into rectifiers: Surpassing human-level performance on imagenet classification",
    "authors": ["K. He", "X. Zhang", "S. Ren", "J. Sun"],
    "venue": "In Proceedings of the IEEE international conference on computer vision,",
    "year": 2015
  }, {
    "title": "Deep residual learning for image recognition",
    "authors": ["K. He", "X. Zhang", "S. Ren", "J. Sun"],
    "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
    "year": 2016
  }, {
    "title": "Batch normalization: Accelerating deep network training by reducing internal covariate shift",
    "authors": ["S. Ioffe", "C. Szegedy"],
    "venue": "arXiv preprint arXiv:1502.03167,",
    "year": 2015
  }, {
    "title": "Beating the perils of non-convexity: Guaranteed training of neural networks using tensor methods",
    "authors": ["M. Janzamin", "H. Sedghi", "A. Anandkumar"],
    "venue": "arXiv preprint arXiv:1506.08473,",
    "year": 2015
  }, {
    "title": "Adam: A method for stochastic optimization",
    "authors": ["D. Kingma", "J. Ba"],
    "venue": "arXiv preprint arXiv:1412.6980,",
    "year": 2014
  }, {
    "title": "Learning multiple layers of features from tiny images",
    "authors": ["A. Krizhevsky", "G. Hinton"],
    "year": 2009
  }, {
    "title": "Imagenet classification with deep convolutional neural networks. In Advances in neural information processing",
    "authors": ["A. Krizhevsky", "I. Sutskever", "G.E. Hinton"],
    "year": 2012
  }, {
    "title": "Backpropagation applied to handwritten zip code recognition",
    "authors": ["Y. LeCun", "B. Boser", "J.S. Denker", "D. Henderson", "R.E. Howard", "W. Hubbard", "L.D. Jackel"],
    "venue": "Neural computation,",
    "year": 1989
  }, {
    "title": "Gradientbased learning applied to document recognition",
    "authors": ["Y. LeCun", "L. Bottou", "Y. Bengio", "P. Haffner"],
    "venue": "Proceedings of the IEEE,",
    "year": 1998
  }, {
    "title": "Efficient backprop",
    "authors": ["Y.A. LeCun", "L. Bottou", "G.B. Orr", "Müller", "K.-R"],
    "venue": "In Neural networks: Tricks of the trade,",
    "year": 2012
  }, {
    "title": "Fully convolutional networks for semantic segmentation",
    "authors": ["J. Long", "E. Shelhamer", "T. Darrell"],
    "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
    "year": 2015
  }, {
    "title": "Deep vs. shallow networks: An approximation theory perspective",
    "authors": ["H.N. Mhaskar", "T. Poggio"],
    "venue": "Analysis and Applications,",
    "year": 2016
  }, {
    "title": "A theory of multiclass boosting",
    "authors": ["I. Mukherjee", "R.E. Schapire"],
    "venue": "Journal of Machine Learning Research,",
    "year": 2013
  }, {
    "title": "Reading digits in natural images with unsupervised feature learning",
    "authors": ["Y. Netzer", "T. Wang", "A. Coates", "A. Bissacco", "B. Wu", "A.Y. Ng"],
    "venue": "In NIPS workshop on deep learning and unsupervised feature learning,",
    "year": 2011
  }, {
    "title": "Faster r-cnn: Towards real-time object detection with region proposal networks. In Advances in neural information processing",
    "authors": ["S. Ren", "K. He", "R. Girshick", "J. Sun"],
    "year": 2015
  }, {
    "title": "Exact solutions to the nonlinear dynamics of learning in deep linear neural networks",
    "authors": ["A.M. Saxe", "J.L. McClelland", "S. Ganguli"],
    "venue": "arXiv preprint arXiv:1312.6120,",
    "year": 2013
  }, {
    "title": "Overfeat: Integrated recognition, localization and detection using convolutional networks",
    "authors": ["P. Sermanet", "D. Eigen", "X. Zhang", "M. Mathieu", "R. Fergus", "Y. LeCun"],
    "venue": "arXiv preprint arXiv:1312.6229,",
    "year": 2013
  }, {
    "title": "Selfieboost: A boosting algorithm for deep learning",
    "authors": ["S. Shalev-Shwartz"],
    "venue": "arXiv preprint arXiv:1411.3436,",
    "year": 2014
  }, {
    "title": "Very deep convolutional networks for large-scale image recognition",
    "authors": ["K. Simonyan", "A. Zisserman"],
    "venue": "arXiv preprint arXiv:1409.1556,",
    "year": 2014
  }, {
    "title": "Going deeper with convolutions",
    "authors": ["C. Szegedy", "W. Liu", "Y. Jia", "P. Sermanet", "S. Reed", "D. Anguelov", "D. Erhan", "V. Vanhoucke", "A. Rabinovich"],
    "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
    "year": 2015
  }, {
    "title": "Residual networks behave like ensembles of relatively shallow networks",
    "authors": ["A. Veit", "M.J. Wilber", "S. Belongie"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2016
  }, {
    "title": "Visualizing and understanding convolutional networks",
    "authors": ["M.D. Zeiler", "R. Fergus"],
    "venue": "In European conference on computer vision,",
    "year": 2014
  }],
  "id": "SP:7aae124ac468da6ade08e814246fea918e34c2eb",
  "authors": [{
    "name": "Furong Huang",
    "affiliations": []
  }, {
    "name": "Jordan T. Ash",
    "affiliations": []
  }, {
    "name": "John Langford",
    "affiliations": []
  }, {
    "name": "Robert E. Schapire",
    "affiliations": []
  }],
  "abstractText": "We prove a multi-channel telescoping sum boosting theory for the ResNet architectures which simultaneously creates a new technique for boosting over features (in contrast to labels) and provides a new algorithm for ResNet-style architectures. Our proposed training algorithm, BoostResNet, is particularly suitable in non-differentiable architectures. Our method only requires the relatively inexpensive sequential training of T “shallow ResNets”. We prove that the training error decays exponentially with the depth T if the weak module classifiers that we train perform slightly better than some weak baseline. In other words, we propose a weak learning condition and prove a boosting theory for ResNet under the weak learning condition. A generalization error bound based on margin theory is proved and suggests that ResNet could be resistant to overfitting using a network with l1 norm bounded weights.",
  "title": "Learning Deep ResNet Blocks Sequentially using Boosting Theory"
}