{
  "sections": [{
    "heading": "1 Introduction",
    "text": "Descriptive linguists often characterize a human language by its typological properties. For instance, English is an SVO-type language because its basic clause order is Subject-Verb-Object (SVO), and also a prepositional-type language because its adpositions normally precede the noun. Identifying basic word order must happen early in the acquisition of syntax, and presumably guides the initial interpretation of sentences and the acquisition of a finer-grained grammar. In this paper, we propose a method for doing this. While we focus on word order, one could try similar methods for other typological classifications (syntactic, morphological, or phonological).\nThe problem is challenging because the language’s true word order statistics are computed from syntax trees, whereas our method has access only to a POS-tagged corpus. Based on these POS sequences alone, we predict the directionality of each type of dependency relation. We define the directionality to be a real number in [0, 1]: the fraction of tokens of this relation that are “right-directed,” in the sense that the child (modifier) falls to the right of its parent (head). For example, the dobj relation points from a verb to its direct object (if any), so a directionality of 0.9—meaning that 90% of dobj dependencies are right-directed—indicates a dominant verb-object order. (See Table 1 for more such examples.) Our system is trained to predict the relative frequency of rightward dependencies for each of 57 dependency types from the Universal Dependencies project (UD). We assume that all languages draw on the same set of POS tags and dependency relations that is proposed by the UD project (see §3), so that our predictor works across languages.\nWhy do this? Liu (2010) has argued for using these directionality numbers in [0, 1] as fine-grained and robust typological descriptors. We believe that these directionalities could also be used to help define an initializer, prior, or regularizer for tasks like grammar induction or syntax-based machine translation. Finally, the vector of directionalities—or the feature vector that our method extracts in order to predict the directionalities—can be regarded as a language embedding computed from the POStagged corpus. This language embedding may be useful as an input to multilingual NLP systems, such as the cross-linguistic neural dependency parser of Ammar et al. (2016). In fact, some multilingual NLP systems already condition on typological properties looked up in the World Atlas of Language Structures, or WALS (Dryer and Haspelmath, 2013), as\n147\nTransactions of the Association for Computational Linguistics, vol. 5, pp. 147–161, 2017. Action Editor: Mark Steedman. Submission batch: 11/2016; Revision batch: 2/2017; Published 6/2017.\nc©2017 Association for Computational Linguistics. Distributed under a CC-BY 4.0 license.\nwe review in §8. However, WALS does not list all properties of all languages, and may be somewhat inconsistent since it collects work by many linguists. Our system provides an automatic alternative as well as a methodology for generalizing to new properties.\nMore broadly, we are motivated by the challenge of determining the structure of a language from its superficial features. Principles & Parameters theory (Chomsky, 1981; Chomsky and Lasnik, 1993) famously—if controversially—hypothesized that human babies are born with an evolutionarily tuned system that is specifically adapted to natural language, which can predict typological properties (“parameters”) by spotting telltale configurations in purely linguistic input. Here we investigate whether such a system can be tuned by gradient descent. It is at least plausible that useful superficial features do exist: e.g., if nouns often precede verbs but rarely follow verbs, then the language may be verb-final."
  }, {
    "heading": "2 Approach",
    "text": "We depart from the traditional approach to latent structure discovery, namely unsupervised learning. Unsupervised syntax learners in NLP tend to be rather inaccurate—partly because they are failing to maximize an objective that has many local optima, and partly because that objective does not capture all the factors that linguists consider when assigning\nsyntactic structure. Our remedy in this paper is a supervised approach. We simply imitate how linguists have analyzed other languages. This supervised objective goes beyond the log-likelihood of a PCFGlike model given the corpus, because linguists do not merely try to predict the surface corpus. Their dependency annotations may reflect a cross-linguistic theory that considers semantic interpretability and equivalence, rare but informative phenomena, consistency across languages, a prior across languages, and linguistic conventions (including the choice of latent labels such as dobj). Our learner does not consider these factors explicitly, but we hope it will identify correlates (e.g., using deep learning) that can make similar predictions. Being supervised, our objective should also suffer less from local optima. Indeed, we could even set up our problem with a convex objective, such as (kernel) logistic regression, to predict each directionality separately.\nWhy hasn’t this been done before? Our setting presents unusually sparse data for supervised learning, since each training example is an entire language. The world presumably does not offer enough natural languages—particularly with machine-readable corpora—to train a good classifier to detect, say, Object-Verb-Subject (OVS) languages, especially given the class imbalance problem that OVS languages are empirically rare, and the non-IID problem that the available OVS languages may be evolutionarily related.1 We mitigate this issue by training on the Galactic Dependencies treebanks (Wang and Eisner, 2016), a collection of more than 50,000 human-like synthetic languages. The treebank of each synthetic language is generated by stochastically permuting the subtrees in a given real treebank to match the word order of other real languages. Thus, we have many synthetic languages that are Object-Verb like Hindi but also Noun-Adjective like French. We know the true directionality of each synthetic language and we would like our classifier to predict that directionality, just as it would for a real language. We will show that our system’s accuracy benefits from fleshing out the training set in this way, which can be seen as a form of regularization.\n1Properties shared within an OVS language family may appear to be consistently predictive of OVS, but are actually confounds that will not generalize to other families in test data.\nA possible criticism of our work is that obtaining the input POS sequences requires human annotators, and perhaps these annotators could have answered the typological classification questions as well. Indeed, this criticism also applies to most work on grammar induction. We will show that our system is at least robust to noise in the input POS sequences (§7.4). In the future, we hope to devise similar methods that operate on raw word sequences."
  }, {
    "heading": "3 Data",
    "text": "We use two datasets in our experiment:\nUD: Universal Dependencies version 1.2 (et al., 2015) A collection of dependency treebanks for 37 languages, annotated in a consistent style with POS tags and dependency relations.\nGD: Galactic Dependencies version 1.0 (Wang and Eisner, 2016) A collection of projective dependency treebanks for 53,428 synthetic languages, using the same format as UD. The treebank of each synthetic language is generated from the UD treebank of some real language by stochastically permuting the dependents of all nouns and/or verbs to match the dependent orders of other real UD languages. Using this “mix-and-match” procedure, the GD collection fills in gaps in the UD collection— which covers only a few possible human languages."
  }, {
    "heading": "4 Task Formulation",
    "text": "We now formalize the setup of the fine-grained typological prediction task. LetR be the set of universal relation types, with N = |R|. We use r→ to denote a rightward dependency token with label r ∈ R.\nInput for language L: A POS-tagged corpus u. (“u” stands for “unparsed.”)\nOutput for language L: Our system predicts p(→| r, L), the probability that a token in language L of an r-labeled dependency will be right-oriented. It predicts this for each dependency relation type r ∈ R, such as r = dobj. Thus, the output is a vector of predicted probabilities p̂ ∈ [0, 1]N .\nTraining: We set the parameters of our system using a collection of training pairs (u,p∗), each of which corresponds to some UD or GD training language L. Here p∗ denotes the true vector of probabilities as empirically estimated from L’s treebank.\nEvaluation: Over pairs (u,p∗) that correspond to held-out real languages, we evaluate the expected loss of the predictions p̂. We use ε-insensitive loss2 with ε = 0.1, so our evaluation metric is ∑\nr∈R p∗(r | L) · lossε(p̂(→| r, L), p∗(→| r, L)) (1)\nwhere\n• lossε(p̂, p∗) ≡ max(|p̂− p∗| − ε, 0) • p∗(→| r, L) = countL(\nr→) countL(r)\nis the empirical estimate of p(→| r, L). • p̂(→| r, L) is the system’s prediction of p∗\nThe aggregate metric (1) is an expected loss that is weighted by p∗(r | L) = countL(r)∑\nr′∈R countL(r′) , to empha-\nsize relation types that are more frequent in L. Why this loss function? We chose an L1-style loss, rather than L2 loss or log-loss, so that the aggregate metric is not dominated by outliers. We took ε > 0 in order to forgive small errors: if some predicted directionality is already “in the ballpark,” we prefer to focus on getting other predictions right, rather than fine-tuning this one. Our intuition is that errors < ε in p̂’s elements will not greatly harm downstream tasks that analyze individual sentences, and might even be easy to correct by grammar reestimation (e.g., EM) that uses p̂ as a starting point.\nIn short, we have the intuition that if our predicted p̂ achieves small lossε on the frequent relation types, then p̂ will be helpful for downstream tasks, although testing that intuition is beyond the scope of this paper. One could tune ε on a downstream task."
  }, {
    "heading": "5 Simple “Expected Count” Baseline",
    "text": "Before launching into our full models, we warm up with a simple baseline heuristic called expected count (EC), which is reminiscent of Principles & Parameters. The idea is that if ADJs tend to precede nearby NOUNs in the sentences of language L, then amod probably tends to point leftward in L. After all, the training languages show that when ADJ and NOUN are nearby, they are usually linked by amod.\nFleshing this out, EC estimates directionalities as\np̂(→| r, L) = ecountL( r→)\necountL( r→) + ecountL( r←)\n(2)\n2Proposed by V. Vapnik for support vector regression.\nwhere we estimate the expected r← and r→ counts by\necountL( r→) =\n∑\nu∈u\n∑\n1≤i<j≤|u| j−i<w\np( r→| ui, uj) (3)\necountL( r←) =\n∑\nu∈u\n∑\n1≤i<j≤|u| j−i<w\np( r←| ui, uj) (4)\nHere u ranges over tag sequences (sentences) of u, and w is a window size that characterizes “nearby.”3\nIn other words, we ask: given that ui and uj are nearby tag tokens in the test corpus u, are they likely to be linked? Formulas (3)–(4) count such a pair as a “soft vote” for r→ if such pairs tended to be linked by r→ in the treebanks of the training languages,4 and a “soft vote” for r← if they tended to be linked by r←. Training: For any two tag types t, t′ in the universal POS tagset T , we simply use the training treebanks to get empirical estimates of p(· | t, t′), taking\np( r→| t, t′) =\n∑ L sL · countL(t\nr→ t′)∑ L sL · countL(t, t′)\n(5)\nand similarly for p( r←| t, t′). This can be interpreted as the (unsmoothed) fraction of (t, t′) within a wword window where t is the r-type parent of t′, computed by micro-averaging over languages. To get a fair average over languages, equation (5) downweights the languages that have larger treebanks, yielding a weighted micro-average in which we define the weight sL = 1/ ∑ t∈T ,t′∈T countL(t, t\n′). As we report later in Table 5, even this simple supervised heuristic performs significantly better than state-of-the-art grammar induction systems. However, it is not a trained heuristic: it has no free parameters that we can tune to optimize our evaluation metric. For example, it can pay too much attention to tag pairs that are not discriminative. We therefore proceed to build a trainable, feature-based system."
  }, {
    "heading": "6 Proposed Model Architecture",
    "text": "To train our model, we will try to minimize the evaluation objective (1) averaged over the training lan-\n3In our experiment, we chose w = 8 by cross-validation over w = 2, 4, 8, 16,∞.\n4Thus, the EC heuristic examines the correlation between relations and tags in the training treebanks. But our methods in the next section will follow the formalization of §4: they do not examine a training treebank beyond its directionality vector p∗.\nguages, plus a regularization term given in §6.4.5"
  }, {
    "heading": "6.1 Directionality predictions from scores",
    "text": "Our predicted directionality for relation r will be\np̂(→| r, L) = 1/(1 + exp(−s(u)r)) (6)\ns(u) is a parametric function (see §6.2 below) that maps u to a score vector in RN . Relation type r should get positive or negative score according to whether it usually points right or left. The formula above converts each score to a directionality— a probability in (0, 1)—using a logistic transform.\n6.2 Design of the scoring function s(u) To score all dependency relation types given the corpus u, we use a feed-forward neural network with one hidden layer (Figure 1):\ns(u) = V ψ(Wπ(u) + bW ) + bV (7)\nπ(u) extracts a d-dimensional feature vector from the corpus u (see §6.3 below). W is a h × d matrix that maps π(u) into a h-dimensional space and bW is a h-dimensional bias vector. ψ is an elementwise activation function. V is aN ×hmatrix whose rows can be regarded as learned embeddings of the dependency relation types. bV is a N -dimensional bias vector that determines the default rightwardness of each relation type. We give details in §7.5.\nThe hidden layer ψ(Wπ(u) + bW ) can be regarded as a latent representation of the language’s word order properties, from which potentially correlated predictions p̂ are extracted.\n5We gave all training languages the same weight. In principle, we could have downweighted the synthetic languages as out-of-domain, using cross-validation to tune the weighting."
  }, {
    "heading": "6.3 Design of the featurization function π(u)",
    "text": "Our current feature vector π(u) considers only the POS tag sequences for the sentences in the unparsed corpus u. Each sentence is augmented with a special boundary tag # at the start and end. We explore both hand-engineered features and neural features.\nHand-engineered features. Recall that §5 considered which tags appeared near one another in a given order. We now devise a slew of features to measure such co-occurrences in a variety of ways. By training the weights of these many features, our system will discover which ones are actually predictive.\nLet g(t | j) ∈ [0, 1] be some measure (to be defined shortly) of the prevalence of tag t near token j of corpus u. We can then measure the prevalence of t, both overall and just near tokens of tag s:6\nπt = mean j\ng(t | j) (8)\nπt|s = mean j:Tj=s\ng(t | j) (9)\nwhere Tj denotes the tag of token j. We now define versions of these quantities for particular prevalence measures g.\nGivenw > 0, let the right windowWj denote the sequence of tags Tj+1, . . . , Tj+w (padding this sequence with additional # symbols if it runs past the end of j’s sentence). We define quantities πwt|s and πwt via (8)–(9), using a version of g(t | j) that measures the fraction of tags in Wj that equal t. Also, for b ∈ {1, 2}, we define πw,bt|s and π w,b t using a version of g(t | j) that is 1 if Wj contains at least b tokens of t, and 0 otherwise.\nFor each of these quantities, we also define a corresponding mirror-image quantity (denoted by negating w > 0) by computing the same feature on a reversed version of the corpus.\nWe also define “truncated” versions of all quantities above, denoted by writing ˆ over the w. In these, we use a truncated window Ŵj , obtained from Wj by removing any suffix that starts with #\n6In practice, we do backoff smoothing of these means. This avoids subsequent division-by-0 errors if tag t or s has count 0 in the corpus, and it regularizes πt|s/πt toward 1 if t or s is rare. Specifically, we augment the denominators by adding λ, while augmenting the numerator in (8) by adding λ ·meanj,t g(t | j) (unsmoothed) and the numerator in (9) by adding λ times the smoothed πt from (8). λ > 0 is a hyperparameter (see §7.5).\nor with a copy of tag Tj (that is, s).7 As an example, π8̂,2N|V asks how often a verb is followed by at least 2 nouns, within the next 8 words of the sentence and before the next verb. A high value of this is a plausible indicator of a VSO-type or VOS-type language.\nWe include the following features for each tag pair s, t and each w ∈ {1, 3, 8, 100, −1,−3,−8,−100, 1̂, 3̂, 8̂, ˆ100,−1̂,−3̂,−8̂,− ˆ100}:8\nπwt , π w t|s, π w t|s · πws , πwt|s//πwt , πwt //πwt|s, πwt|s//π−wt|s\nwhere we define x//y = min(x/y, 1) to prevent unbounded feature values, which can result in poor generalization. Notice that for w = 1, πwt|s is bigram conditional probability, πwt|s·πws is bigram joint probability, the log of πwt|s/π w t is bigram pointwise mutual information, and πwt|s/π −w t|s measures how much more prevalent t is to the right of s than to the left. By also allowing other values of w, we generalize these features. Finally, our model also uses versions of these features for each b ∈ 1, 2.\nNeural features. As an alternative to the manually designedπ function above, we consider a neural approach to detect predictive configurations in the sentences of u, potentially including complex longdistance configurations. Linguists working with Principles & Parameters theory have supposed that a single telltale sentence—a trigger—may be enough\n7In the “fraction of tags” features, g(t | j) is undefined ( 0 0 ) when Ŵj is empty. We omit undefined values from the means.\n8The reason we don’t include π−wt|s //π w t|s is that it is in-\ncluded when computing features for −w.\nto determine a typological parameter, at least given the settings of other parameters (Gibson and Wexler, 1994; Frank and Kapur, 1996).\nWe map each corpus sentence ui to a finitedimensional real vector f i by using a gated recurrent unit (GRU) network (Cho et al., 2014), a type of recurrent neural network that is a simplified variant of an LSTM network (Hochreiter and Schmidhuber, 1997). The GRU reads the sequence of one-hot embeddings of the tags in ui (including the boundary symbols #). We omit the part of the GRU that computes an output sequence, simply taking f i to be the final hidden state vector. The parameters are trained jointly with the rest of our typology prediction system, so the training procedure attempts to discover predictively useful configurations.\nThe various elements of f i attempt to detect various interesting configurations in sentence ui. Some might be triggers (which call for max-pooling over sentences); others might provide softer evidence (which calls for mean-pooling). For generality, therefore, we define our feature vector π(u) by softpooling of the sentence vectors f i (Figure 2). The tanh gate in the GRU implies fik ∈ (−1, 1) and we transform this to the positive quantity f ′ik = fik+1 2 ∈ (0, 1). Given an “inverse temperature” β, define9\nπβk =\n( mean\ni (f ′ik) β\n)1/β (10)\nThis πβk is a pooled version of f ′ ik, ranging from max-pooling as β → −∞ (i.e., does f ′ik fire strongly on any sentence i?) to min-pooling as β → −∞. It passes through arithmetic mean at β = 1 (i.e., how strongly does f ′ik fire on the average sentence i?), geometric mean as β → 0 (this may be regarded as an arithmetic mean in log space), and harmonic mean at β = −1 (an arithmetic mean in reciprocal space).\nOur final π is a concatenation of the πβ vectors for β ∈ {−4,−2,−1, 0, 1, 2, 4}. We chose these β values experimentally, using cross-validation.\nCombined model. We also consider a model\ns(u) = α sH(u) + (1− α) sN(u) (11) where sH(u) is the score assigned by the handfeature system, sN(u) is the score assigned by the\n9For efficiency, we restrict the mean to i ≤ 1e4 (the first 10,000 sentences).\nneural-feature system, and α ∈ [0, 1] is a hyperparameter to balance the two. sH(u) and sN(u) were trained separately. At test time, we use (11) to combine them linearly before the logistic transform (6). This yields a weighted-product-of-experts model."
  }, {
    "heading": "6.4 Training procedure",
    "text": "Length thresholding. By default, our feature vector π(u) is extracted from those sentences in u with length ≤ 40 tokens. In §7.3, however, we try concatenating this feature vector with one that is extracted in the same way from just sentences with length ≤ 10. The intuition (Spitkovsky et al., 2010) is that the basic word order of the language can be most easily discerned from short, simple sentences.\nInitialization. We initialize the model of (6)–(7) so that the estimated directionality p̂(→| r, L), regardless of L, is initially a weighted mean of r’s directionalities in the training languages, namely\np̄r ≡ ∑\nL\nwL(r) p ∗(→| r, L) (12)\nwhere wL(r) ≡ p ∗(r|L)∑\nL′ p ∗(r|L′) (13)\nThis is done by setting V = 0 and the bias (bV )r = log p̄r1−p̄r , clipped to the range [−10, 10]. As a result, we make sensible initial predictions even for rare relations r, which allows us to converge reasonably quickly even though we do not update the parameters for rare relations as often.\nWe initialize the recurrent connections in the GRU to random orthogonal matrices. All other weight matrices in Figure 1 and the GRU use “Xavier initialization” (Glorot and Bengio, 2010). All other bias weight vectors are initialized to 0.\nRegularization. We add an L2 regularizer to the objective. When training the neural network, we use dropout as well. All hyperparameters (regularization coefficient, dropout rate, etc.) are tuned via crossvalidation; see §7.5.\nOptimization. We use different algorithms in different feature settings. With scoring functions that use only hand features, we adjust the feature weights by stochastic gradient descent (SGD). With scoring functions that include neural features, we use RMSProp (Tieleman and Hinton, 2012)."
  }, {
    "heading": "7 Experiments",
    "text": ""
  }, {
    "heading": "7.1 Data splits",
    "text": "We hold out 17 UD languages for testing (Table 2). For training, we use the remaining 20 UD languages and tune the hyperparameters with 5-fold crossvalidation. That is, for each fold, we train the system on 16 real languages and evaluate on the remaining 4. When augmenting the 16 real languages with GD languages, we include only GD languages that are generated by “mixing-and-matching” those 16 languages, which means that we add 16 × 17 × 17 = 4624 synthetic languages.10\nEach GD treebank u provides a standard split into train/dev/test portions. In this paper, we primarily restrict ourselves to the train portions (saving the gold trees from the dev and test portions to tune and evaluate some future grammar induction system that consults our typological predictions). For example, we write utrain for the POS-tagged sentences in the “train” portion, and p∗train for the empirical probabilities derived from their gold trees. We always train the model to predict p∗train from utrain on each training language. To evaluate on a held-out language during cross-validation, we can measure how well the model predicts p∗train given utrain. 11 For our fi-\n10Why 16×17×17? As Wang and Eisner (2016, §5) explain, each GD treebank is obtained from the UD treebank of some substrate language S by stochastically permuting the dependents of verbs and nouns to respect typical orders in the superstrate languages RV and RN respectively. There are 16 choices for S. There are 17 choices for RV (respectively RN), including RV = S (“self-permutation”) and RV = ∅ (“no permutation”).\n11In actuality, we measured how well it predicts p∗dev given udev. That was a slightly less sensible choice. It may have harmed our choice of hyperparameters, since dev is smaller than train and therefore p∗dev tends to have greater sampling error. Another concern is that our typology system, having been specifically tuned to predict p∗dev, might provide an unrealistically accurate estimate of p∗dev to some future grammar induction system that is being cross-validated against the same dev set, harming that system’s choice of hyperparameters as well.\nnal test, we evaluate on the 17 test languages using a model trained on all training languages (20 treebanks for UD, plus 20 × 21 × 21 = 8840 when adding GD) with the chosen hyperparameters. To evaluate on a test language, we again measure how well the model predicts p∗train from utrain."
  }, {
    "heading": "7.2 Comparison of architectures",
    "text": "Table 3 shows the cross-validation losses (equation (1)) that are achieved by different scoring architectures. We compare the results when the model is trained on real languages (the “UD” column) versus on real languages plus synthetic languages (the “+GD” column).\nThe sH models here use a subset of the handengineered features, selected by the experiments in §7.3 below and corresponding to Table 4 line 8.\nAlthough Figure 1 and equation (7) presented an “depth-1” scoring network with one hidden layer, Table 3 also evaluates “depth-d” architectures with d hidden layers. The depth-0 architecture simply predicts each directionality separately using logistic regression (although our training objective is not the usual convex log-likelihood objective).\nSome architectures are better than others. We note that the hand-engineered features outperform the neural features—though not significantly, since they make complementary errors—and that combining them is best. However, the biggest benefit comes from augmenting the training data with GD languages; this consistently helps more than changing the architecture."
  }, {
    "heading": "7.3 Contribution of different feature classes",
    "text": "To understand the contribution of different handengineered features, we performed forward selection tests on the depth-1 system, including only some of the features. In all cases, we trained in the “+GD” condition. The results are shown in Table 4. Any class of features is substantially better than baseline, but we observe that most of the total benefit can be obtained with just PMI or asymmetry features. Those features indicate, for example, whether a verb tends to attract nouns to its right or left. We did not see a gain from length thresholding."
  }, {
    "heading": "7.4 Robustness to noisy input",
    "text": "We also tested our directionality prediction system on noisy input (without retraining it on noisy input). Specifically, we tested the depth-1 sH system. This time, when evaluating on the dev split of a held-out language, we provided a noisy version of that input corpus that had been retagged by an automatic POS tagger (Nguyen et al., 2014), which was trained on just 100 gold-tagged sentences from the train split of that language. The average tagging accuracy over the 20 languages was only 77.26%. Nonetheless, the “UD”-trained and “+GD”-trained systems got respective losses of 0.052 and 0.041—nearly as good as in Table 3, which used gold POS tags."
  }, {
    "heading": "7.5 Hyperparameter settings",
    "text": "For each result in Tables 3–4, the hyperparameters were chosen by grid search on the cross-validation objective (and the table reports the best result). For the remaining experiments, we select the depth-1 combined models (11) for both “UD” and “+GD,” as they are the best models according to Table 3.\nThe hyperparameters for the selected models are as follows: When training with “UD,” we took α = 1 (which ignores sN), with hidden layer size h = 256, ψ = sigmoid, L2 coeff = 0 (no L2 regularization), and dropout = 0.2. When training with “+GD,” we took α = 0.7, with different hyperparameters for the two interpolated models: sH uses h = 128, ψ = sigmoid, L2 coeff = 0, and dropout = 0.4, while sN uses h = 128, emb size = 128, rnn size = 32, ψ = relu, L2 coeff = 0, and dropout = 0.2. For both “UD” and “+GD”, we use λ = 1 for the smoothing in footnote 6."
  }, {
    "heading": "7.6 Comparison with grammar induction",
    "text": "Grammar induction is an alternative way to predict word order typology. Given a corpus of a language, we can first use grammar induction to parse it into dependency trees, and then estimate the directionality of each dependency relation type based on these (approximate) trees.\nHowever, what are the dependency relation types? Current grammar induction systems produce unlabeled dependency edges. Rather than try to obtain\na UD label like r = amod for each edge, we label the edge deterministically with a POS pair such as r = (parent = NOUN, child = ADJ). Thus, we will attempt to predict the directionality of each POS-pair relation type. For comparison, we retrain our supervised system to do the same thing.\nFor the grammar induction system, we try the implementation of DMV with stop-probability estimation by Mareček and Straka (2013), which is a common baseline for grammar induction (Le and Zuidema, 2015) because it is language-independent, reasonably accurate, fast, and convenient to use. We also try the grammar induction system of Naseem et al. (2010), which is the state-of-the-art system on UD (Noji et al., 2016). Naseem et al. (2010)’s method, like ours, has prior knowledge of what typical human languages look like.\nTable 5 shows the results. Compared to Mareček and Straka (2013), Naseem et al. (2010) gets only a small (insignificant) improvement—whereas our “UD” system halves the loss, and the “+GD” system halves it again. Even our baseline systems are significantly more accurate than the grammar induction systems, showing the effectiveness of casting the problem as supervised prediction."
  }, {
    "heading": "7.7 Fine-grained analysis",
    "text": "Beyond reporting the aggregate cross-validation loss over the 20 training languages, we break down the cross-validation predictions by relation type. Figure 3 shows that the frequent relations are all quite\npredictable. Figure 4 shows that our success is not just because the task is easy—on relations whose directionality varies by language, so that a baseline method does poorly, our system usually does well.\nTo show that our system is behaving well across languages and not just on average, we zoom in on 5 relation types that are particularly common or of particular interest to linguistic typologists. These 5 relations together account for 46% of all relation tokens in the average language: nmod = noun-nominal modifier order, nsubj = subject-verb order (feature 82A in the World Atlas of Language Structures), dobj = object-verb order (83A), amod = adjectivenoun order (87A), and case = placement of both adpositions and case markers (85A).\nAs shown in Figure 5, most points in the first five plots fall in or quite near the desired region. We are pleased to see that the predictions are robust when the training data is unbalanced. For example, the case relation points leftward in most real languages, yet our system can still predict the right directionality of “hi”, “et” and “fi.” The credit goes to the diversity of our training set, which contains various synthetic case-right languages: the system fails on these three languages if we train on real languages only. That said, apparently our training set is still not diverse enough to do well on the outlier “ar” (Arabic); see Figure 4 in Wang and Eisner (2016)."
  }, {
    "heading": "7.8 Binary classification accuracy",
    "text": "Besides ε-insensitive loss, we also measured how the systems perform on the coarser task of binary classification of relation direction. We say that relation r is dominantly “rightward” in language L iff p∗(→| r, L) > 0.5. We say that a system predicts “rightward” according to whether p̂(→| r, L) > 0.5.\nWe evaluate whether this binary prediction is correct for each of the 20 most frequent relations r, for each held-out language L, using 5-fold crossvalidation over the 20 training languages L as in the previous experiment. Tables 6 and 7 respectively summarize these results by relation (equal average\nover languages) and by language (equal average over relations). Keep in mind that these systems had not been specifically trained to place relations on the correct side of the artificial 0.5 boundary.\nBinary classification is an easier task. It is easy because, as the ∅ column in Table 6 indicates, most relations have a clear directionality preference shared by most of the UD languages. As a result, the better models with more features have less opportunity to help. Nonetheless, they do perform better, and the EC heuristic continues to perform worse.\nIn particular, EC fails significantly on dobj and iobj. This is because nsubj, dobj, and iobj often have different directionalities (e.g., in SVO languages), but the EC heuristic will tend to predict the same direction for all of them, according to whether NOUNs tend to precede nearby VERBs."
  }, {
    "heading": "7.9 Final evaluation on test data",
    "text": "All previous experiments were conducted by crossvalidation on the 20 training languages. We now train the system on all 20, and report results on the 17 blind test languages (Table 8). In our evaluation metric (1), R includes all 57 relation types that appear in training data, plus a special UNK type for\nrelations that appear only in test data. The results range from good to excellent, with synthetic data providing consistent and often large improvements.\nThese results could potentially be boosted in the future by using an even larger and more diverse training set. In principle, when evaluating on any one of our 37 real languages, one could train a system on all of the other 36 (plus the galactic languages derived from them), not just 20. Moreover, the Universal Dependencies collection has continued to grow beyond the 37 languages used here (§3). Finally, our current setup extracts only one training example from each (real or synthetic) language. One could easily generate a variant of this example each time the language is visited during stochastic optimization, by bootstrap-resampling its training corpus (to add “natural” variation) or subsampling it (to train the predictor to work on smaller corpora). In the case of a synthetic language, one could also generate a corpus of new trees each time the language is visited (by re-running the stochastic permutation procedure, instead of reusing the particular permutation released by the Galactic Dependencies project)."
  }, {
    "heading": "8 Related Work",
    "text": "Typological properties can usefully boost the performance of cross-linguistic systems (Bender, 2009; O’Horan et al., 2016). These systems mainly aim to annotate low-resource languages with help from models trained on similar high-resource languages. Naseem et al. (2012) introduce a “selective sharing” technique for generative parsing, in which a Subject-Verb language will use parameters shared with other Subject-Verb languages. Täckström et al. (2013) and Zhang and Barzilay (2015) extend this idea to discriminative parsing and gain further improvements by conjoining regular parsing features with typological features. The cross-linguistic neural parser of Ammar et al. (2016) conditions on typological features by supplying a “language embedding” as input. Zhang et al. (2012) use typological properties to convert language-specific POS tags to UD POS tags, based on their ordering in a corpus.\nMoving from engineering to science, lin-\nguists seek typological universals of human language (Greenberg, 1963; Croft, 2002; Song, 2014; Hawkins, 2014), e.g., “languages with dominant Verb-Subject-Object order are always prepositional.” Dryer and Haspelmath (2013) characterize 2679 world languages with 192 typological properties. Their WALS database can supply features to NLP systems (see previous paragraph) or gold standard labels for typological classifiers. Daumé III and Campbell (2007) take WALS as input and propose a Bayesian approach to discover new universals. Georgi et al. (2010) impute missing properties of a language, not by using universals, but by backing off to the language’s typological cluster. Murawaki (2015) use WALS to help recover the evolutionary tree of human languages; Daumé III (2009) considers the geographic distribution of WALS properties.\nAttempts at automatic typological classification are relatively recent. Lewis and Xia (2008) predict typological properties from induced trees, but guess those trees from aligned bitexts, not by monolingual grammar induction as in §7.6. Liu (2010) and Futrell et al. (2015) show that the directionality of (gold) dependencies is indicative of “basic” word order and freeness of word order. Those papers predict typological properties from trees that are automatically (noisily) annotated or manually (expensively) annotated. An alternative is to predict the typology directly from raw or POS-tagged text, as we do. Saha Roy et al. (2014) first explored this idea, building a system that correctly predicts adposition typology on 19/23 languages with only word cooccurrence statistics. Zhang et al. (2016) evaluate semi-supervised POS tagging by asking whether the induced tag sequences can predict typological properties. Their prediction approach is supervised like ours, although developed separately and trained on different data. They more simply predict 6 binaryvalued WALS properties, using 6 independent binary classifiers based on POS bigram and trigrams.\nOur task is rather close to grammar induction, which likewise predicts a set of real numbers giving the relative probabilities of competing syntactic configurations. Most previous work on grammar induction begins with maximum likelihood estimation of some generative model—such as a PCFG (Lari and Young, 1990; Carroll and Charniak, 1992) or dependency grammar (Klein and Manning, 2004)—\nthough it may add linguistically-informed inductive bias (Ganchev et al., 2010; Naseem et al., 2010). Most such methods use local search and must wrestle with local optima (Spitkovsky et al., 2013). Finegrained typological classification might supplement this approach, by cutting through the initial combinatorial challenge of establishing the basic wordorder properties of the language. In this paper we only quantify the directionality of each relation type, ignoring how tokens of these relations interact locally to give coherent parse trees. Grammar induction methods like EM could naturally consider those local interactions for a more refined analysis, when guided by our predicted global directionalities."
  }, {
    "heading": "9 Conclusions and Future Work",
    "text": "We introduced a typological classification task, which attempts to extract quantitative knowledge about a language’s syntactic structure from its surface forms (POS tag sequences). We applied supervised learning to this apparently unsupervised problem. As far as we know, we are the first to utilize synthetic languages to train a learner for real languages: this move yielded substantial benefits.12\nFigure 5 shows that we rank held-out languages rather accurately along a spectrum of directionality, for several common dependency relations. Table 8 shows that if we jointly predict the directionalities of all the relations in a new language, most of those numbers will be quite close to the truth (low aggregate error, weighted by relation frequency). This holds promise for aiding grammar induction.\nOur trained model is robust when applied to noisy POS tag sequences. In the future, however, we would like to make similar predictions from raw word sequences. That will require features that abstract away from the language-specific vocabulary. Although recurrent neural networks in the present paper did not show a clear advantage over handengineered features, they might be useful when used with word embeddings.\nFinally, we are interested in downstream uses. Several NLP tasks have benefited from typological features (§8). By using end-to-end training, our methods could be tuned to extract features (existing or novel) that are particularly useful for some task.\n12Although Wang and Eisner (2016) review uses of synthetic training data elsewhere in machine learning.\nAcknowledgements This work was funded by the U.S. National Science Foundation under Grant No. 1423276. We are grateful to the state of Maryland for providing indispensable computing resources via the Maryland Advanced Research Computing Center (MARCC). We thank the Argo lab members for useful discussions. Finally, we thank TACL action editor Mark Steedman and the anonymous reviewers for high-quality suggestions, including the EC baseline and the binary classification evaluation."
  }],
  "year": 2017,
  "references": [{
    "title": "Linguistically naı̈ve != language independent: Why NLP needs linguistic typology",
    "authors": ["Emily M. Bender"],
    "venue": "In Proceedings of the EACL 2009 Workshop on the Interaction between Linguistics and Computational Linguistics: Virtuous,",
    "year": 2009
  }, {
    "title": "Two experiments on learning probabilistic dependency grammars from corpora",
    "authors": ["Glenn Carroll", "Eugene Charniak"],
    "venue": "In Working Notes of the AAAI Workshop on Statistically-Based NLP Techniques,",
    "year": 1992
  }, {
    "title": "Typology and Universals",
    "authors": ["William Croft"],
    "year": 2002
  }, {
    "title": "Non-parametric Bayesian areal linguistics",
    "authors": ["Hal Daumé III"],
    "venue": "Proceedings of Human Language Technologies: The 2009 Annual Conference of the North American Chapter of the Association for Computational Linguistics,",
    "year": 2009
  }, {
    "title": "A Bayesian model for discovering typological implications",
    "authors": ["Hal Daumé III", "Lyle Campbell"],
    "venue": "In Proceedings of the 45th Annual Meeting of the Association of Computational Linguistics,",
    "year": 2007
  }, {
    "title": "The World Atlas of Language Structures Online",
    "authors": ["Matthew S. Dryer", "Martin Haspelmath", "editors"],
    "venue": "Max Planck Institute for Evolutionary Anthropology,",
    "year": 2013
  }, {
    "title": "Universal Dependencies 1.2. LINDAT/CLARIN digital library at the Institute of Formal and Applied Linguistics, Charles University in Prague",
    "authors": ["Joakim Nivre"],
    "venue": "Data available at http:// universaldependencies.org,",
    "year": 2015
  }, {
    "title": "On the use of triggers in parameter setting",
    "authors": ["Robert Frank", "Shyam Kapur"],
    "venue": "Linguistic Inquiry,",
    "year": 1996
  }, {
    "title": "Quantifying word order freedom in dependency corpora",
    "authors": ["Richard Futrell", "Kyle Mahowald", "Edward Gibson"],
    "venue": "In Proceedings of the Third International Conference on Dependency Linguistics,",
    "year": 2015
  }, {
    "title": "Posterior regularization for structured latent variable models",
    "authors": ["Kuzman Ganchev", "Joao Graça", "Jennifer Gillenwater", "Ben Taskar"],
    "venue": "Journal of Machine Learning Research,",
    "year": 2010
  }, {
    "title": "Comparing language similarity across genetic and typologically-based groupings",
    "authors": ["Ryan Georgi", "Fei Xia", "William Lewis"],
    "venue": "In Proceedings of the 23rd International Conference on Computational Linguistics,",
    "year": 2010
  }, {
    "title": "Understanding the difficulty of training deep feedforward neural networks",
    "authors": ["Xavier Glorot", "Yoshua Bengio"],
    "venue": "In Proceedings of the International Conference on Artificial Intelligence and Statistics,",
    "year": 2010
  }, {
    "title": "Long short-term memory",
    "authors": ["Sepp Hochreiter", "Jürgen Schmidhuber"],
    "venue": "Neural Computation,",
    "year": 1997
  }, {
    "title": "Corpus-based induction of syntactic structure: Models of dependency and constituency",
    "authors": ["Dan Klein", "Christopher Manning"],
    "venue": "In Proceedings of the 42nd Annual Meeting of the Association for Computational Linguistics,",
    "year": 2004
  }, {
    "title": "The estimation of stochastic context-free grammars using the Inside-Outside algorithm",
    "authors": ["Karim Lari", "Steve J. Young"],
    "venue": "Computer Speech and Language,",
    "year": 1990
  }, {
    "title": "Unsupervised dependency parsing: Let’s use supervised parsers",
    "authors": ["Phong Le", "Willem Zuidema"],
    "venue": "In Proceedings of the 2015 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language",
    "year": 2015
  }, {
    "title": "Automatically identifying computationally relevant typological features",
    "authors": ["William D. Lewis", "Fei Xia"],
    "venue": "In Proceedings of the Third International Joint Conference on Natural Language Processing: Volume-II,",
    "year": 2008
  }, {
    "title": "Dependency direction as a means of word-order typology: A method based on dependency treebanks",
    "authors": ["Haitao Liu"],
    "venue": "Lingua, 120(6):1567–1578,",
    "year": 2010
  }, {
    "title": "Continuous space representations of linguistic typology and their application to phylogenetic inference",
    "authors": ["Yugo Murawaki"],
    "venue": "In Proceedings of the 2015 Conference of the North American Chapter of the Association",
    "year": 2015
  }, {
    "title": "Using universal linguistic knowledge to guide grammar induction",
    "authors": ["Tahira Naseem", "Harr Chen", "Regina Barzilay", "Mark Johnson"],
    "venue": "In Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing,",
    "year": 2010
  }, {
    "title": "Using left-corner parsing to encode universal structural constraints in grammar induction",
    "authors": ["Hiroshi Noji", "Yusuke Miyao", "Mark Johnson"],
    "venue": "In Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing,",
    "year": 2016
  }, {
    "title": "Linguistic Typology: Morphology and Syntax",
    "authors": ["Jae Jung Song"],
    "year": 2014
  }, {
    "title": "From baby steps to leapfrog: How “less is more” in unsupervised dependency parsing",
    "authors": ["Valentin I. Spitkovsky", "Hiyan Alshawi", "Daniel Jurafsky"],
    "venue": "In Human Language Technologies: The 2010 Annual Conference of the North American Chapter",
    "year": 2010
  }],
  "id": "SP:956eb2cf57b35c5f8ce8baa12f87c17adf25bff5",
  "authors": [{
    "name": "Dingquan Wang",
    "affiliations": []
  }, {
    "name": "Jason Eisner",
    "affiliations": []
  }],
  "abstractText": "We show how to predict the basic word-order facts of a novel language given only a corpus of part-of-speech (POS) sequences. We predict how often direct objects follow their verbs, how often adjectives follow their nouns, and in general the directionalities of all dependency relations. Such typological properties could be helpful in grammar induction. While such a problem is usually regarded as unsupervised learning, our innovation is to treat it as supervised learning, using a large collection of realistic synthetic languages as training data. The supervised learner must identify surface features of a language’s POS sequence (hand-engineered or neural features) that correlate with the language’s deeper structure (latent trees). In the experiment, we show: 1) Given a small set of real languages, it helps to add many synthetic languages to the training data. 2) Our system is robust even when the POS sequences include noise. 3) Our system on this task outperforms a grammar induction baseline by a large margin.",
  "title": "Fine-Grained Prediction of Syntactic Typology: Discovering Latent Structure with Supervised Learning"
}