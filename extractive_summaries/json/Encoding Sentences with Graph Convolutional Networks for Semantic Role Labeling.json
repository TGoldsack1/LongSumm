{
  "sections": [{
    "text": "Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 1506–1515 Copenhagen, Denmark, September 7–11, 2017. c©2017 Association for Computational Linguistics"
  }, {
    "heading": "1 Introduction",
    "text": "Semantic role labeling (SRL) (Gildea and Jurafsky, 2002) can be informally described as the task of discovering who did what to whom. For example, consider an SRL dependency graph shown above the sentence in Figure 1. Formally, the task includes (1) detection of predicates (e.g., makes); (2) labeling the predicates with a sense from a sense inventory (e.g., make.01); (3) identifying and assigning arguments to semantic roles (e.g., Sequa is A0, i.e., an agent / ‘doer’ for the corresponding predicate, and engines is A1, i.e., a patient / ‘an affected entity’). SRL is often regarded\nas an important step in the standard NLP pipeline, providing information to downstream tasks such as information extraction and question answering.\nThe semantic representations are closely related to syntactic ones, even though the syntaxsemantics interface is far from trivial (Levin, 1993). For example, one can observe that many arcs in the syntactic dependency graph (shown in black below the sentence in Figure 1) are mirrored in the semantic dependency graph. Given these similarities and also because of availability of accurate syntactic parsers for many languages, it seems natural to exploit syntactic information when predicting semantics. Though historically most SRL approaches did rely on syntax (Thompson et al., 2003; Pradhan et al., 2005; Punyakanok et al., 2008; Johansson and Nugues, 2008), the last generation of SRL models put syntax aside in favor of neural sequence models, namely LSTMs (Zhou and Xu, 2015; Marcheggiani et al., 2017), and outperformed syntactically-driven methods on standard benchmarks. We believe that one of the reasons for this radical choice is the lack of simple and effective methods for incorporating syntactic information into sequential neural networks (namely, at the level of words). In this paper we\n1506\npropose one way how to address this limitation. Specifically, we rely on graph convolutional networks (GCNs) (Duvenaud et al., 2015; Kipf and Welling, 2017; Kearnes et al., 2016), a recent class of multilayer neural networks operating on graphs. For every node in the graph (in our case a word in a sentence), GCN encodes relevant information about its neighborhood as a real-valued feature vector. GCNs have been studied largely in the context of undirected unlabeled graphs. We introduce a version of GCNs for modeling syntactic dependency structures and generally applicable to labeled directed graphs.\nOne layer GCN encodes only information about immediate neighbors and K layers are needed to encode K-order neighborhoods (i.e., information about nodes at most K hops aways). This contrasts with recurrent and recursive neural networks (Elman, 1990; Socher et al., 2013) which, at least in theory, can capture statistical dependencies across unbounded paths in a trees or in a sequence. However, as we will further discuss in Section 3.3, this is not a serious limitation when GCNs are used in combination with encoders based on recurrent networks (LSTMs). When we stack GCNs on top of LSTM layers, we obtain a substantial improvement over an already state-of-the-art LSTM SRL model, resulting in the best reported scores on the standard benchmark (CoNLL-2009), both for English and Chinese.1\nInterestingly, again unlike recursive neural networks, GCNs do not constrain the graph to be a tree. We believe that there are many applications in NLP, where GCN-based encoders of sentences or even documents can be used to incorporate knowledge about linguistic structures (e.g., representations of syntax, semantics or discourse). For example, GCNs can take as input combined syntactic-semantic graphs (e.g., the entire graph from Figure 1) and be used within downstream tasks such as machine translation or question answering. However, we leave this for future work and here solely focus on SRL.\nThe contributions of this paper can be summarized as follows:\n• we are the first to show that GCNs are effective for NLP;\n• we propose a generalization of GCNs suited 1The code is available at https://github.com/\ndiegma/neural-dep-srl.\nto encoding syntactic information at word level;\n• we propose a GCN-based SRL model and obtain state-of-the-art results on English and Chinese portions of the CoNLL-2009 dataset;\n• we show that bidirectional LSTMs and syntax-based GCNs have complementary modeling power."
  }, {
    "heading": "2 Graph Convolutional Networks",
    "text": "In this section we describe GCNs of Kipf and Welling (2017). Please refer to Gilmer et al. (2017) for a comprehensive overview of GCN versions.\nGCNs are neural networks operating on graphs and inducing features of nodes (i.e., real-valued vectors / embeddings) based on properties of their neighborhoods. In Kipf and Welling (2017), they were shown to be very effective for the node classification task: the classifier was estimated jointly with a GCN, so that the induced node features were informative for the node classification problem. Depending on how many layers of convolution are used, GCNs can capture information only about immediate neighbors (with one layer of convolution) or any nodes at most K hops aways (if K layers are stacked on top of each other).\nMore formally, consider an undirected graph G = (V, E), where V (|V | = n) and E are sets of nodes and edges, respectively. Kipf and Welling (2017) assume that edges contain all the self-loops, i.e., (v, v) 2 E for any v. We can define a matrix X 2 Rm⇥n with each its column xv 2 Rm (v 2 V) encoding node features. The vectors can either encode genuine features (e.g., this vector can encode the title of a paper if citation graphs are considered) or be a one-hot vector. The node representation, encoding information about its immediate neighbors, is computed as\nhv = ReLU 0@ X u2N (v) (W xu + b) 1A , (1) where W 2 Rm⇥m and b 2 Rm are a weight matrix and a bias, respectively; N (v) are neighbors of v; ReLU is the rectifier linear unit activation function.2 Note that v 2 N (v) (because of selfloops), so the input feature representation of v (i.e. xv) affects its induced representation hv.\n2We dropped normalization factors used in Kipf and Welling (2017), as they are not used in our syntactic GCNs.\nAs in standard convolutional networks (LeCun et al., 2001), by stacking GCN layers one can incorporate higher degree neighborhoods:\nh(k+1)v = ReLU 0@ X u2N (v) W (k)h(k)u + b (k) 1A where k denotes the layer number and h(1)v = xv."
  }, {
    "heading": "3 Syntactic GCNs",
    "text": "As syntactic dependency trees are directed and labeled (we refer to the dependency labels as syntactic functions), we first need to modify the computation in order to incorporate label information (Section 3.1). In the subsequent section, we incorporate gates in GCNs, so that the model can decide which edges are more relevant to the task in question. Having gates is also important as we rely on automatically predicted syntactic representations, and the gates can detect and downweight potentially erroneous edges."
  }, {
    "heading": "3.1 Incorporating directions and labels",
    "text": "Now, we introduce a generalization of GCNs appropriate for syntactic dependency trees, and in\ngeneral, for directed labeled graphs. First note that there is no reason to assume that information flows only along the syntactic dependency arcs (e.g., from makes to Sequa), so we allow it to flow in the opposite direction as well (i.e., from dependents to heads). We use a graph G = (V, E), where the edge set contains all pairs of nodes (i.e., words) adjacent in the dependency tree. In our example, both (Sequa, makes) and (makes, Sequa) belong to the edge set. The graph is labeled, and the label L(u, v) for (u, v) 2 E contains both information about the syntactic function and indicates whether the edge is in the same or opposite direction as the syntactic dependency arc. For example, the label for (makes, Sequa) is subj, whereas the label for (Sequa, makes) is subj0, with the apostrophe indicating that the edge is in the direction opposite to the corresponding syntactic arc. Similarly, self-loops will have label self . Consequently, we can simply assume that the GCN parameters are label-specific, resulting in the following computation, also illustrated in Figure 2:\nh(k+1)v = ReLU 0@ X u2N (v) W (k) L(u,v)h (k) u + b (k) L(u,v) 1A . This model is over-parameterized,3 especially given that SRL datasets are moderately sized, by deep learning standards. So instead of learning the GCN parameters directly, we define them as\nW (k) L(u,v) = V (k) dir(u,v), (2)\nwhere dir(u, v) indicates whether the edge (u, v) is directed (1) along, (2) in the opposite direction to the syntactic dependency arc, or (3) is a selfloop; V (k)dir(u,v) 2 Rm⇥m. Our simplification captures the intuition that information should be propagated differently along edges depending whether this is a head-to-dependent or dependent-to-head edge (i.e., along or opposite the corresponding syntactic arc) and whether it is a self-loop. So we do not share any parameters between these three very different edge types. Syntactic functions are important, but perhaps less crucial, so they are encoded only in the feature vectors bL(u,v)."
  }, {
    "heading": "3.2 Edge-wise gating",
    "text": "Uniformly accepting information from all neighboring nodes may not be appropriate for the SRL\n3Chinese and English CoNLL-2009 datasets used 41 and 48 different syntactic functions, which would result in having 83 and 97 different matrices in every layer, respectively.\nsetting. For example, we see in Figure 1 that many semantic arcs just mirror their syntactic counterparts, so they may need to be up-weighted. Moreover, we rely on automatically predicted syntactic structures, and, even for English, syntactic parsers are far from being perfect, especially when used out-of-domain. It is risky for a downstream application to rely on a potentially wrong syntactic edge, so the corresponding message in the neural network may need to be down-weighted.\nIn order to address the above issues, inspired by recent literature (van den Oord et al., 2016; Dauphin et al., 2016), we calculate for each edge node pair a scalar gate of the form\ng(k)u,v = ⇣ h(k)u · v̂(k)dir(u,v) + b̂ (k) L(u,v) ⌘ , (3)\nwhere is the logistic sigmoid function, v̂\n(k) dir(u,v) 2 Rm and b̂ (k) L(u,v) 2 R are weights and a bias for the gate. With this additional gating mechanism, the final syntactic GCN computation is formulated as\nh(k+1)v =ReLU(X u2N (v) g(k)v,u(V (k) dir(u,v)h (k) u + b (k) L(u,v))). (4)"
  }, {
    "heading": "3.3 Complementarity of GCNs and LSTMs",
    "text": "The inability of GCNs to capture dependencies between nodes far away from each other in the graph may seem like a serious problem, especially in the context of SRL: paths between predicates and arguments often include many dependency arcs (Roth and Lapata, 2016). However, when graph convolution is performed on top of LSTM states (i.e., LSTM states serve as input xv = h (1) v to GCN) rather than static word embeddings, GCN may not need to capture more than a couple of hops.\nTo elaborate on this, let us speculate what role GCNs would play when used in combinations with LSTMs, given that LSTMs have already been shown very effective for SRL (Zhou and Xu, 2015; Marcheggiani et al., 2017). Though LSTMs are capable of capturing at least some degree of syntax (Linzen et al., 2016) without explicit syntactic supervision, SRL datasets are moderately sized, so LSTM models may still struggle with harder cases. Typically, harder cases for SRL involve arguments far away from their predicates. In fact, 20% and 30% of arguments are more than 5 tokens away from their predicate, in our English and\nChinese collections, respectively. However, if we imagine that we can ‘teleport’ even over a single (longest) syntactic dependency edge, the ’distance’ would shrink: only 9% and 13% arguments will now be more than 5 LSTM steps away (again for English and Chinese, respectively). GCNs provide this ‘teleportation’ capability. These observations suggest that LSTMs and GCNs may be complementary, and we will see that empirical results support this intuition."
  }, {
    "heading": "4 Syntax-Aware Neural SRL Encoder",
    "text": "In this work, we build our semantic role labeler on top of the syntax-agnostic LSTM-based SRL model of Marcheggiani et al. (2017), which already achieves state-of-the-art results on the CoNLL-2009 English dataset. Following their approach we employ the same bidirectional (BiLSTM) encoder and enrich it with a syntactic GCN.\nThe CoNLL-2009 benchmark assumes that predicate positions are already marked in the test set (e.g., we would know that makes, repairs and engines in Figure 1 are predicates), so no predicate identification is needed. Also, as we focus here solely on identifying arguments and labeling them with semantic roles, for predicate disambiguation\n(i.e., marking makes as make.01) we use of an offthe-shelf disambiguation model (Roth and Lapata, 2016; Björkelund et al., 2009). As in Marcheggiani et al. (2017) and in most previous work, we process individual predicates in isolation, so for each predicate, our task reduces to a sequence labeling problem. That is, given a predicate (e.g., disputed in Figure 3) one needs to identify and label all its arguments (e.g., label estimates as A1 and label those as ‘NULL’, indicating that those is not an argument of disputed).\nThe semantic role labeler we propose is composed of four components (see Figure 3):\n• look-ups of word embeddings; • a BiLSTM encoder that takes as input the\nword representation of each word in a sentence;\n• a syntax-based GCN encoder that re-encodes the BiLSTM representation based on the automatically predicted syntactic structure of the sentence;\n• a role classifier that takes as input the GCN representation of the candidate argument and the representation of the predicate to predict the role associated with the candidate word."
  }, {
    "heading": "4.1 Word representations",
    "text": "For each word wi in the considered sentence, we create a sentence-specific word representation xi. We represent each word w as the concatenation of four vectors:4 a randomly initialized word embedding xre 2 Rdw , a pre-trained word embedding xpe 2 Rdw estimated on an external text collection, a randomly initialized part-of-speech tag embedding xpos 2 Rdp and a randomly initialized lemma embedding xle 2 Rdl (active only if the word is a predicate). The randomly initialized embeddings xre, xpos, and xle are fine-tuned during training, while the pre-trained ones are kept fixed. The final word representation is given by x = xre xpe xpos xle, where represents the concatenation operator."
  }, {
    "heading": "4.2 Bidirectional LSTM layer",
    "text": "One of the most popular and effective ways to represent sequences, such as sentences (Mikolov et al., 2010), is to use recurrent neural networks\n4We drop the index i from the notation for the sake of brevity.\n(RNN) (Elman, 1990). In particular their gated versions, Long Short-Term Memory (LSTM) networks (Hochreiter and Schmidhuber, 1997) and Gated Recurrent Units (GRU) (Cho et al., 2014), have proven effective in modeling long sequences (Chiu and Nichols, 2016; Sutskever et al., 2014).\nFormally, an LSTM can be defined as a function LSTM✓(x1:i) that takes as input the sequence x1:i and returns a hidden state hi 2 Rdh . This state can be regarded as a representation of the sentence from the start to the position i, or, in other words, it encodes the word at position i along with its left context. However, the right context is also important, so Bidirectional LSTMs (Graves, 2008) use two LSTMs: one for the forward pass, and another for the backward pass, LSTMF and LSTMB , respectively. By concatenating the states of both LSTMs, we create a complete context-aware representation of a word BiLSTM(x1:n, i) = LSTMF (x1:i) LSTMB(xn:i). We follow Marcheggiani et al. (2017) and stack J layers of bidirectional LSTMs, where each layer takes the lower layer as its input."
  }, {
    "heading": "4.3 Graph convolutional layer",
    "text": "The representation calculated with the BiLSTM encoder is fed as input to a GCN of the form defined in Equation (4). The neighboring nodes of a node v, namely N (v), and their relations to v are predicted by an external syntactic parser."
  }, {
    "heading": "4.4 Semantic role classifier",
    "text": "The classifier predicts semantic roles of words given the predicate while relying on word representations provided by GCN; we concatenate hidden states of the candidate argument word and the predicate word and use them as input to a classifier (Figure 3, top). The softmax classifier computes the probability of the role (including special ‘NULL’ role):\np(r|ti, tp, l) / exp(Wl,r(ti tp)), (5)\nwhere ti and tp are representations produced by the graph convolutional encoder, l is the lemma of predicate p, and the symbol / signifies proportionality.5 As FitzGerald et al. (2015) and Marcheggiani et al. (2017), instead of using a fixed matrix Wl,r or simply assuming that Wl,r = Wr,\n5We abuse the notation and refer as p both to the predicate word and to its position in the sentence.\nwe jointly embed the role r and predicate lemma l using a non-linear transformation:\nWl,r = ReLU(U(ql qr)), (6)\nwhere U is a parameter matrix, whereas ql 2 Rd0l and qr 2 Rdr are randomly initialized embeddings of predicate lemmas and roles. In this way each role prediction is predicate-specific, and, at the same time, we expect to learn a good representation for roles associated with infrequent predicates. As our training objective we use the categorical cross-entropy."
  }, {
    "heading": "5 Experiments",
    "text": ""
  }, {
    "heading": "5.1 Datasets and parameters",
    "text": "We tested the proposed SRL model on the English and Chinese CoNLL-2009 dataset with standard splits into training, test and development sets. The predicted POS tags for both languages were provided by the CoNLL-2009 shared-task organizers. For the predicate disambiguator we used the ones from Roth and Lapata (2016) for English and from Björkelund et al. (2009) for Chinese. We parsed English sentences with the BIST Parser (Kiperwasser and Goldberg, 2016), whereas for Chinese we used automatically predicted parses provided by the CoNLL-2009 shared-task organizers.\nFor English, we used external embeddings of Dyer et al. (2015), learned using the structured skip n-gram approach of Ling et al. (2015). For Chinese we used external embeddings produced with the neural language model of Bengio et al. (2003). We used edge dropout in GCN: when\ncomputing h(k)v , we ignore each node v 2 N (v) with probability . Adam (Kingma and Ba, 2015) was used as an optimizer. The hyperparameter tuning and all model selection were performed on the English development set; the chosen values are shown in Appendix."
  }, {
    "heading": "5.2 Results and discussion",
    "text": "In order to show that GCN layers are effective, we first compare our model against its version which lacks GCN layers (i.e. essentially the model of Marcheggiani et al. (2017)). Importantly, to measure the genuine contribution of GCNs, we first tuned this syntax-agnostic model (e.g., the number of LSTM layers) to get best possible performance on the development set.6\nWe compare the syntax-agnostic model with 3 syntax-aware versions: one GCN layer over syntax (K = 1), one layer GCN without gates and two GCN layers (K = 2). As we rely on the same\n6For example, if we would have used only one layer of LSTMs, gains from using GCNs would be even larger.\noff-the-shelf disambiguator for all versions of the model, in Table 1 and 2 we report SRL-only scores (i.e., predicate disambiguation is not evaluated) on the English and Chinese development sets. For both datasets, the syntax-aware model with one GCN layers (K = 1) performs the best, outperforming the LSTM version by 1.9% and 0.6% for Chinese and English, respectively. The reasons why the improvements on Chinese are much larger are not entirely clear (e.g., both languages are relative fixed word order ones, and the syntactic parses for Chinese are considerably less accurate), this may be attributed to a higher proportion of longdistance dependencies between predicates and arguments in Chinese (see Section 3.3). Edge-wise gating (Section 3.2) also appears important: removing gates leads to a drop of 0.3% F1 for English and 0.6% F1 for Chinese.\nStacking two GCN layers does not give any benefit. When BiLSTM layers are dropped altogether, stacking two layers (K = 2) of GCNs greatly improves the performance, resulting in a 3.8% jump in F1 for English and a 3.0% jump in F1 for Chi-\nnese. Adding a 3rd layer of GCN (K = 3) further improves the performance.7 This suggests that extra GCN layers are effective but largely redundant with respect to what LSTMs already capture.\nIn Figure 4, we show the F1 scores results on the English development set as a function of the distance, in terms of tokens, between a candidate argument and its predicate. As expected, GCNs appear to be more beneficial for long distance dependencies, as shorter ones are already accurately captured by the LSTM encoder.\nWe looked closer in contribution of specific dependency relations for Chinese. In order to assess this without retraining the model multiple times, we drop all dependencies of a given type at test time (one type at a time, only for types appearing over 300 times in the development set) and observe changes in performance. In Figure 5, we see that the most informative dependency is COMP (complement). Relative clauses in Chinese are very frequent and typically marked with particle Ñ (de). The relative clause will syntactically depend on Ñ as COMP, so COMP encodes important information about predicate-argument structure. These are often long-distance dependencies and may not be accurately captured by LSTMs. Although TMP (temporal) dependencies are not as frequent (⇠2% of all dependencies), they are also important: temporal information is mirrored in semantic roles.\nIn order to compare to previous work, in Table 3 we report test results on the English indomain (WSJ) evaluation data. Our model is local, as all the argument detection and labeling decisions are conditionally independent: their interaction is captured solely by the LSTM+GCN encoder. This makes our model fast and simple, though, as shown in previous work, global modeling of the structured output is beneficial.8 We leave this extension for future work. Interestingly,\n7Note that GCN layers are computationally cheaper than LSTM ones, even in our non-optimized implementation.\n8As seen in Table 3, labelers of FitzGerald et al. (2015) and Roth and Lapata (2016) gained 0.6-1.0%.\nwe outperform even the best global model and the best ensemble of global models, without using global modeling or ensembles. When we create an ensemble of 3 models with the product-of-expert combination rule, we improve by 1.2% over the best previous result, achieving 89.1% F1.9\nFor Chinese (Table 4), our best model outperforms the state-of-the-art model of Roth and Lapata (2016) by even larger margin of 3.1%.\nFor English, in the CoNLL shared task, systems are also evaluated on the out-of-domain dataset. Statistical models are typically less accurate when they are applied to out-of-domain data. Consequently, the predicted syntax for the out-ofdomain test set is of lower quality, which negatively affects the quality of GCN embeddings. However, our model works surprisingly well on out-of-domain data (Table 5), substantially outperforming all the previous syntax-aware models. This suggests that our model is fairly robust to mistakes in syntax. As expected though, our model does not outperform the syntax-agnostic model of Marcheggiani et al. (2017)."
  }, {
    "heading": "6 Related Work",
    "text": "Perhaps the earliest methods modeling syntaxsemantics interface with RNNs are due to (Henderson et al., 2008; Titov et al., 2009; Gesmundo et al., 2009), they used shift-reduce parsers for joint SRL and syntactic parsing, and relied on RNNs to model statistical dependencies across syntactic and semantic parsing actions. A more\n9To compare to previous work, we report combined scores which also include predicate disambiguation. As we use disambiguators from previous work (see Section 5.1), actual gains in argument identification and labeling are even larger.\nmodern (e.g., based on LSTMs) and effective reincarnation of this line of research has been proposed in Swayamdipta et al. (2016). Other recent work which considered incorporation of syntactic information in neural SRL models include: FitzGerald et al. (2015) who use standard syntactic features within an MLP calculating potentials of a CRF model; Roth and Lapata (2016) who enriched standard features for SRL with LSTM representations of syntactic paths between arguments and predicates; Lei et al. (2015) who relied on low-rank tensor factorizations for modeling syntax. Also Foland and Martin (2015) used (nongraph) convolutional networks and provided syntactic features as input. A very different line of research, but with similar goals to ours (i.e. integrating syntax with minimal feature engineering), used tree kernels (Moschitti et al., 2008).\nBeyond SRL, there have been many proposals on how to incorporate syntactic information in RNN models, for example, in the context of neural machine translation (Eriguchi et al., 2017; Sennrich and Haddow, 2016). One of the most popular and attractive approaches is to use treestructured recursive neural networks (Socher et al., 2013; Le and Zuidema, 2014; Dyer et al., 2015), including stacking them on top of a sequential BiLSTM (Miwa and Bansal, 2016). An approach of Mou et al. (2015) to sentiment analysis and question classification, introduced even before GCNs became popular in the machine learning community, is related to graph convolution. However, it is inherently single-layer and tree-specific, uses bottom-up computations, does not share parameters across syntactic functions and does not use gates. Gates have been previously used in GCNs (Li et al., 2016) but between GCN layers rather than for individual edges.\nPrevious approaches to integrating syntactic information in neural models are mainly designed to induce representations of sentences or syntactic constituents. In contrast, the approach we presented incorporates syntactic information at word level. This may be attractive from the engineering perspective, as it can be used, as we have shown, instead or along with RNN models."
  }, {
    "heading": "7 Conclusions and Future Work",
    "text": "We demonstrated how GCNs can be used to incorporate syntactic information in neural models and specifically to construct a syntax-aware SRL\nmodel, resulting in state-of-the-art results for Chinese and English. There are relatively straightforward steps which can further improve the SRL results. For example, we relied on labeling arguments independently, whereas using a joint model is likely to significantly improve the performance. Also, in this paper we consider the dependency version of the SRL task, however the model can be generalized to the span-based version of the task (i.e. labeling argument spans with roles rather that syntactic heads of arguments) in a relatively straightforward fashion.\nMore generally, given simplicity of GCNs and their applicability to general graph structures (not necessarily trees), we believe that there are many NLP tasks where GCNs can be used to incorporate linguistic structures (e.g., syntactic and semantic representations of sentences and discourse parses or co-reference graphs for documents)."
  }, {
    "heading": "Acknowledgements",
    "text": "We would thank Anton Frolov, Michael Schlichtkrull, Thomas Kipf, Michael Roth, Max Welling, Yi Zhang, and Wilker Aziz for their suggestions and comments. The project was supported by the European Research Council (ERC StG BroadSem 678254), the Dutch National Science Foundation (NWO VIDI 639.022.518) and an Amazon Web Services (AWS) grant."
  }],
  "year": 2017,
  "references": [{
    "title": "A neural probabilistic language model",
    "authors": ["Yoshua Bengio", "Réjean Ducharme", "Pascal Vincent", "Christian Janvin."],
    "venue": "Journal of Machine Learning Research, 3:1137–1155.",
    "year": 2003
  }, {
    "title": "A high-performance syntactic and semantic dependency parser",
    "authors": ["Anders Björkelund", "Bernd Bohnet", "Love Hafdell", "Pierre Nugues."],
    "venue": "Proceedings of COLING: Demonstrations.",
    "year": 2010
  }, {
    "title": "Multilingual semantic role labeling",
    "authors": ["Anders Björkelund", "Love Hafdell", "Pierre Nugues."],
    "venue": "Proceedings of CoNLL.",
    "year": 2009
  }, {
    "title": "Named entity recognition with bidirectional LSTM-CNNs",
    "authors": ["Jason P.C. Chiu", "Eric Nichols."],
    "venue": "TACL, 4:357–370.",
    "year": 2016
  }, {
    "title": "Learning phrase representations using RNN encoder-decoder for statistical machine translation",
    "authors": ["Kyunghyun Cho", "Bart van Merrienboer", "Çaglar Gülçehre", "Dzmitry Bahdanau", "Fethi Bougares", "Holger Schwenk", "Yoshua Bengio."],
    "venue": "Proceedings of",
    "year": 2014
  }, {
    "title": "Language modeling with gated convolutional networks",
    "authors": ["Yann N. Dauphin", "Angela Fan", "Michael Auli", "David Grangier."],
    "venue": "arXiv preprint arXiv:1612.08083.",
    "year": 2016
  }, {
    "title": "Convolutional networks on graphs for learning molecular fingerprints",
    "authors": ["David K. Duvenaud", "Dougal Maclaurin", "Jorge Aguilera-Iparraguirre", "Rafael Bombarell", "Timothy Hirzel", "Alán Aspuru-Guzik", "Ryan P. Adams."],
    "venue": "Proceedings of NIPS.",
    "year": 2015
  }, {
    "title": "Transitionbased dependency parsing with stack long shortterm memory",
    "authors": ["Chris Dyer", "Miguel Ballesteros", "Wang Ling", "Austin Matthews", "Noah A. Smith."],
    "venue": "Proceedings of ACL.",
    "year": 2015
  }, {
    "title": "Finding structure in time",
    "authors": ["Jeffrey L. Elman."],
    "venue": "Cognitive Science, 14(2):179–211.",
    "year": 1990
  }, {
    "title": "Learning to parse and translate improves neural machine translation",
    "authors": ["Akiko Eriguchi", "Yoshimasa Tsuruoka", "Kyunghyun Cho."],
    "venue": "arXiv preprint arXiv:1702.03525.",
    "year": 2017
  }, {
    "title": "Semantic role labeling with neural network factors",
    "authors": ["Nicholas FitzGerald", "Oscar Täckström", "Kuzman Ganchev", "Dipanjan Das."],
    "venue": "Proceedings of EMNLP.",
    "year": 2015
  }, {
    "title": "Dependencybased semantic role labeling using convolutional neural networks",
    "authors": ["William Foland", "James Martin."],
    "venue": "Proceedings of the Fourth Joint Conference on Lexical and Computational Semantics (*SEM).",
    "year": 2015
  }, {
    "title": "Latent variable model of synchronous syntactic-semantic parsing for multiple languages",
    "authors": ["Andrea Gesmundo", "James Henderson", "Paola Merlo", "Ivan Titov."],
    "venue": "Proceedings of CoNLL.",
    "year": 2009
  }, {
    "title": "Automatic labeling of semantic roles",
    "authors": ["Daniel Gildea", "Daniel Jurafsky."],
    "venue": "Computational linguistics, 28(3):245–288.",
    "year": 2002
  }, {
    "title": "Neural message passing for quantum chemistry",
    "authors": ["Justin Gilmer", "Samuel S. Schoenholz", "Patrick F. Riley", "Oriol Vinyals", "George E. Dahl."],
    "venue": "arXiv preprint arXiv:1704.01212.",
    "year": 2017
  }, {
    "title": "Supervised sequence labelling with recurrent neural networks",
    "authors": ["Alex Graves."],
    "venue": "Ph.D. thesis, München, Techn. Univ., Diss., 2008.",
    "year": 2008
  }, {
    "title": "A latent variable model of synchronous parsing for syntactic and semantic dependencies",
    "authors": ["James Henderson", "Paola Merlo", "Gabriele Musillo", "Ivan Titov."],
    "venue": "Proceedings of CoNLL.",
    "year": 2008
  }, {
    "title": "Long short-term memory",
    "authors": ["Sepp Hochreiter", "Jürgen Schmidhuber."],
    "venue": "Neural Computation, 9(8):1735–1780.",
    "year": 1997
  }, {
    "title": "The effect of syntactic representation on semantic role labeling",
    "authors": ["Richard Johansson", "Pierre Nugues."],
    "venue": "Proceedings of COLING.",
    "year": 2008
  }, {
    "title": "Molecular graph convolutions: moving beyond fingerprints",
    "authors": ["Steven Kearnes", "Kevin McCloskey", "Marc Berndl", "Vijay Pande", "Patrick Riley."],
    "venue": "Journal of computer-aided molecular design, 30(8):595– 608.",
    "year": 2016
  }, {
    "title": "Adam: A method for stochastic optimization",
    "authors": ["Diederik Kingma", "Jimmy Ba."],
    "venue": "Proceedings of ICLR.",
    "year": 2015
  }, {
    "title": "Simple and accurate dependency parsing using bidirectional LSTM feature representations",
    "authors": ["Eliyahu Kiperwasser", "Yoav Goldberg."],
    "venue": "TACL, 4:313– 327.",
    "year": 2016
  }, {
    "title": "Semisupervised classification with graph convolutional networks",
    "authors": ["Thomas N. Kipf", "Max Welling."],
    "venue": "Proceedings of ICLR.",
    "year": 2017
  }, {
    "title": "The insideoutside recursive neural network model for dependency parsing",
    "authors": ["Phong Le", "Willem Zuidema."],
    "venue": "Proceedings of EMNLP.",
    "year": 2014
  }, {
    "title": "Gradient-based learning applied to document recognition",
    "authors": ["Yann LeCun", "Leon Bottou", "Yoshua Bengio", "Patrick Haffner."],
    "venue": "Proceedings of Intelligent Signal Processing.",
    "year": 2001
  }, {
    "title": "High-order lowrank tensors for semantic role labeling",
    "authors": ["Tao Lei", "Yuan Zhang", "Lluı́s Màrquez", "Alessandro Moschitti", "Regina Barzilay"],
    "venue": "In Proceedings of NAACL",
    "year": 2015
  }, {
    "title": "English verb classes and alternations: A preliminary investigation",
    "authors": ["Beth Levin."],
    "venue": "University of Chicago press.",
    "year": 1993
  }, {
    "title": "Gated graph sequence neural networks",
    "authors": ["Yujia Li", "Daniel Tarlow", "Marc Brockschmidt", "Richard S. Zemel."],
    "venue": "Proceedings of ICLR.",
    "year": 2016
  }, {
    "title": "Two/too simple adaptations of word2vec for syntax problems",
    "authors": ["Wang Ling", "Chris Dyer", "Alan W Black", "Isabel Trancoso."],
    "venue": "Proceedings of NAACL.",
    "year": 2015
  }, {
    "title": "Assessing the ability of LSTMs to learn syntax-sensitive dependencies",
    "authors": ["Tal Linzen", "Emmanuel Dupoux", "Yoav Goldberg."],
    "venue": "TACL, 4:521–535.",
    "year": 2016
  }, {
    "title": "A simple and accurate syntax-agnostic neural model for dependency-based semantic role labeling",
    "authors": ["Diego Marcheggiani", "Anton Frolov", "Ivan Titov."],
    "venue": "Proceedings of CoNLL.",
    "year": 2017
  }, {
    "title": "Recurrent neural network based language model",
    "authors": ["Tomas Mikolov", "Martin Karafiát", "Lukás Burget", "Jan Cernocký", "Sanjeev Khudanpur."],
    "venue": "Proceedings of INTERSPEECH.",
    "year": 2010
  }, {
    "title": "End-to-end relation extraction using lstms on sequences and tree structures",
    "authors": ["Makoto Miwa", "Mohit Bansal."],
    "venue": "Proceedings of ACL.",
    "year": 2016
  }, {
    "title": "Tree kernels for semantic role labeling",
    "authors": ["Alessandro Moschitti", "Daniele Pighin", "Roberto Basili."],
    "venue": "Computational Linguistics, 34(2):193–224.",
    "year": 2008
  }, {
    "title": "Discriminative neural sentence modeling by tree-based convolution",
    "authors": ["Lili Mou", "Hao Peng", "Ge Li", "Yan Xu", "Lu Zhang", "Zhi Jin."],
    "venue": "Proceedings of EMNLP.",
    "year": 2015
  }, {
    "title": "Conditional image generation with PixelCNN decoders",
    "authors": ["Aäron van den Oord", "Nal Kalchbrenner", "Lasse Espeholt", "Koray Kavukcuoglu", "Oriol Vinyals", "Alex Graves."],
    "venue": "Proceedings of NIPS.",
    "year": 2016
  }, {
    "title": "Semantic role chunking combining complementary syntactic views",
    "authors": ["Sameer Pradhan", "Kadri Hacioglu", "Wayne H. Ward", "James H. Martin", "Daniel Jurafsky."],
    "venue": "Proceedings of CoNLL.",
    "year": 2005
  }, {
    "title": "The importance of syntactic parsing and inference in semantic role labeling",
    "authors": ["Vasin Punyakanok", "Dan Roth", "Wen-tau Yih."],
    "venue": "Computational Linguistics, 34(2):257–287.",
    "year": 2008
  }, {
    "title": "Neural semantic role labeling with dependency path embeddings",
    "authors": ["Michael Roth", "Mirella Lapata."],
    "venue": "Proceedings of ACL.",
    "year": 2016
  }, {
    "title": "Linguistic input features improve neural machine translation",
    "authors": ["Rico Sennrich", "Barry Haddow."],
    "venue": "Proceedings of WMT.",
    "year": 2016
  }, {
    "title": "Recursive deep models for semantic compositionality over a sentiment treebank",
    "authors": ["Richard Socher", "Alex Perelygin", "Jean Wu", "Jason Chuang", "Christopher D. Manning", "Andrew Ng", "Christopher Potts."],
    "venue": "Proceedings of EMNLP.",
    "year": 2013
  }, {
    "title": "Sequence to sequence learning with neural networks",
    "authors": ["Ilya Sutskever", "Oriol Vinyals", "Quoc V. Le."],
    "venue": "Proceedings of NIPS.",
    "year": 2014
  }, {
    "title": "Greedy, joint syntacticsemantic parsing with stack LSTMs",
    "authors": ["Swabha Swayamdipta", "Miguel Ballesteros", "Chris Dyer", "Noah A. Smith."],
    "venue": "Proceedings of CoNLL.",
    "year": 2016
  }, {
    "title": "A generative model for semantic role labeling",
    "authors": ["Cynthia A. Thompson", "Roger Levy", "Christopher D. Manning."],
    "venue": "Proceedings of ECML.",
    "year": 2003
  }, {
    "title": "Online projectivisation for synchronous parsing of semantic and syntactic dependencies",
    "authors": ["Ivan Titov", "James Henderson", "Paola Merlo", "Gabriele Musillo."],
    "venue": "Proceedings of IJCAI.",
    "year": 2009
  }, {
    "title": "Multilingual dependency learning: Exploiting rich features for tagging syntactic and semantic dependencies",
    "authors": ["Hai Zhao", "Wenliang Chen", "Jun’ichi Kazama", "Kiyotaka Uchimoto", "Kentaro Torisawa"],
    "venue": "Proceedings of CoNLL",
    "year": 2009
  }, {
    "title": "End-to-end learning of semantic role labeling using recurrent neural networks",
    "authors": ["Jie Zhou", "Wei Xu."],
    "venue": "Proceedings of ACL.",
    "year": 2015
  }],
  "id": "SP:7d5a7e4e76ed0bf339502675b3d517b99e52e431",
  "authors": [{
    "name": "Diego Marcheggiani",
    "affiliations": []
  }, {
    "name": "Ivan Titov",
    "affiliations": []
  }],
  "abstractText": "Semantic role labeling (SRL) is the task of identifying the predicate-argument structure of a sentence. It is typically regarded as an important step in the standard NLP pipeline. As the semantic representations are closely related to syntactic ones, we exploit syntactic information in our model. We propose a version of graph convolutional networks (GCNs), a recent class of neural networks operating on graphs, suited to model syntactic dependency graphs. GCNs over syntactic dependency trees are used as sentence encoders, producing latent feature representations of words in a sentence. We observe that GCN layers are complementary to LSTM ones: when we stack both GCN and LSTM layers, we obtain a substantial improvement over an already state-of-theart LSTM SRL model, resulting in the best reported scores on the standard benchmark (CoNLL-2009) both for Chinese and English.",
  "title": "Encoding Sentences with Graph Convolutional Networks for Semantic Role Labeling"
}