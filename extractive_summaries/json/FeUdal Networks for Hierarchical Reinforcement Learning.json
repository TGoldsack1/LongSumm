{
  "sections": [{
    "heading": "1. Introduction",
    "text": "Deep reinforcement learning has recently enjoyed successes in many domains (Mnih et al., 2015; Schulman et al., 2015; Levine et al., 2015; Mnih et al., 2016; Lillicrap et al., 2015). Nevertheless, long-term credit assignment remains a major challenge for these methods, especially in environments with sparse reward signals, such as the infamous Montezuma’s Revenge ATARI game. It is symptomatic that the standard approach on the ATARI benchmark suite (Bellemare et al., 2012) is to use an actionrepeat heuristic, where each action translates into several (usually 4) consecutive actions in the environment. Yet another dimension of complexity is seen in non-Markovian environments that require memory – these are particularly\n1DeepMind, London, United Kingdom. Correspondence to: Alexander Sasha Vezhnevets <vezhnick@google.com>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\nchallenging, since the agent has to learn which parts of experience to store for later, using only a sparse reward signal.\nThe framework we propose takes inspiration from feudal reinforcement learning (FRL) introduced by Dayan & Hinton (1993), where levels of hierarchy within an agent communicate via explicit goals. Some key insights from FRL are that goals can be generated in a top-down fashion, and that goal setting can be decoupled from goal achievement; a level in the hierarchy communicates to the level below it what must be achieved, but does not specify how to do so. Making higher levels reason at a lower temporal resolution naturally structures the agents behaviour into temporally extended sub-policies.\nThe architecture explored in this work is a fullydifferentiable neural network with two levels of hierarchy (though there are obvious generalisations to deeper hierarchies). The top level, the Manager, sets goals at a lower temporal resolution in a latent state-space that is itself learnt by the Manager. The lower level, the Worker, operates at a higher temporal resolution and produces primitive actions, conditioned on the goals it receives from the Manager. The Worker is motivated to follow the goals by an intrinsic reward. However, significantly, no gradients are propagated between Worker and Manager; the Manager receives its learning signal from the environment alone. In other words, the Manager learns to select latent goals that maximise extrinsic reward.\nThe key contributions of our proposal are: (1) A consistent, end-to-end differentiable model that embodies and generalizes the principles of FRL. (2) A novel, approximate transition policy gradient update for training the Manager, which exploits the semantic meaning of the goals it produces. (3) The use of goals that are directional rather than absolute in nature. (4) A novel RNN design for the Manager – a dilated LSTM – which extends the longevity of the recurrent state memories and allows gradients to flow through large hops in time, enabling effective back-propagation through hundreds of steps.\nOur ablative analysis (Section 5.4) confirms that transitional policy gradient and directional goals are crucial for best performance. Our experiments on a selection of ATARI games (including the infamous Montezuma’s re-\nFeUdal Networks for Hierarchical Reinforcement Learning\nvenge) and on several memory tasks in the 3D DeepMind Lab environment (Beattie et al., 2016) show that FuN significantly improves long-term credit assignment and memorisation."
  }, {
    "heading": "2. Related Work",
    "text": "Building hierarchical agents is a long standing topic in reinforcement learning (Sutton et al., 1999; Precup, 2000; Dayan & Hinton, 1993; Dietterich, 2000; Boutilier et al., 1997; Dayan, 1993; Kaelbling, 2014; Parr & Russell, 1998; Precup et al., 1997; 1998; Schmidhuber, 1991; Sutton, 1995; Wiering & Schmidhuber, 1997; Vezhnevets et al., 2016; Bacon et al., 2017). The options framework (Sutton et al., 1999; Precup, 2000) is a popular formulation for considering the problem with a two level hierarchy. The bottom level – an option – is a sub-policy with a termination condition, which takes in environment observations and outputs actions until the termination condition is met. An agent picks an option using its policy-over-options (the top level) and subsequently follows it until termination, at which point the policy-over-options is queried again and the process continues. Options are typically learned using sub-goals and ‘pseudo-rewards’ that are provided explicitly (Sutton et al., 1999; Dietterich, 2000; Dayan & Hinton, 1993). For a simple, tabular case (Wiering & Schmidhuber, 1997; Schaul et al., 2015), each state can be used as a sub-goal. Given the options, a policy-over-options can be learned using standard techniques by treating options as actions. Recently (Tessler et al., 2016; Kulkarni et al., 2016) have demonstrated that combining deep learning with predefined sub-goals delivers promising results in challenging environments like Minecraft and Atari, however sub-goal discovery was not addressed.\nA recent work of (Bacon et al., 2017) shows the possibility of learning options jointly with a policy-over-options in an end-to-end fashion by extending the policy gradient theorem to options. When options are learnt end-toend, they tend to degenerate to one of two trivial solutions: (i) only one active option that solves the whole task; (ii) a policy-over-options that changes options at every step, micro-managing the behaviour. Consequently, regularisers (Bacon et al., 2017; Vezhnevets et al., 2016) are usually introduced to steer the solution towards multiple options of extended length. This is believed to provide an inductive bias towards re-usable temporal abstractions and to help generalisation.\nA key difference between our approach and the options framework is that in our proposal the top level produces a meaningful and explicit goal for the bottom level to achieve. Sub-goals emerge as directions in the latent statespace and are naturally diverse. We also achieve significantly better scores on ATARI than Option-Critic (section 5).\nℒ(rt+ cos(St+c-St,gt))\nPolicy gradient\n(Rt-V M t) cos(st+c-st,gt)\nTransition policy gradient\nThere has also been a significant progress in nonhierarchical deep RL methods by using auxiliary losses and rewards. (Bellemare et al., 2016a) have significantly advanced the state-of-the-art on Montezuma’s Revenge by using pseudo-count based auxiliary rewards for exploration, which stimulate agents to explore new parts of the state space. The recently proposed UNREAL agent (Jaderberg et al., 2016) also demonstrates a strong improvement by using unsupervised auxiliary tasks to help refine its internal representations. We note that these benefits are orthogonal to those provided by FuN, and that both approaches could be combined with FuN for even greater effect."
  }, {
    "heading": "3. The model",
    "text": "What is FuN? FuN is a modular neural-network consisting of two modules – the Worker and the Manager. The Manager internally computes a latent state representation st and outputs a goal vector gt. The Worker produces actions conditioned on external observation, its own state, and the Managers goal. The Manager and the Worker share a perceptual module which takes an observation from the environment xt and computes a shared intermediate representation zt. The Manager’s goals gt are trained using an approximate transition policy gradient. This is a particularly efficient form of policy gradient training that exploits the knowledge that the Worker’s behaviour will ultimately align with the goal directions it has been set. The Worker is then trained via intrinsic reward to produce actions that cause these goal directions to be achieved. Figure 1a illustrates the overall design and the following equations describe the forward dynamics of our network:\nzt = f percept(xt); st = fMspace(zt) (1)\nhMt , ĝt = f Mrnn(st, hMt−1); gt = ĝt/||ĝt||; (2)\nwt = φ( t∑ i=t−c gi) (3)\nhW , Ut = f Wrnn(zt, hWt−1);πt = SoftMax(Utwt) (4)\nwhere both the Manager and the Worker are recurrent. Here hM and hW correspond to the internal states of the Man-\nager and the Worker respectively. A linear transform φ maps a goal gt into an embedding vectorwt ∈ Rk, which is then combined via product with matrixUt (Workers output) to produce policy π – vector of probabilities over primitive actions. The next section provides the details on goal embedding and the following sections 3.2,3.3 describes how FuN is trained."
  }, {
    "heading": "3.1. Goal embedding",
    "text": "The goal g modulates the policy via a multiplicative interaction in a low dimensional goal-embedding space Rk, k << d. The Worker first produces an embedding vector for every action, represented by rows of matrix U ∈ R|a|×k (eq. 4). To incorporate goals from the Manager, the last c goals are first pooled by summation and then embedded into a vector w ∈ Rk using a linear projection φ (eq. 3). The projection φ is linear, with no biases, and is learnt with gradients coming from the Worker’s actions. The embedding matrix U is then combined with the goal embedding w via a matrix-vector product (eq. 4). Since φ has no biases it can never produce a constant non-zero vector – which is the only way the setup could ignore the Manager’s input. This makes sure that the goal output by the Manager always influences the final policy. Notice how, due to pooling of goals over several time-steps, the conditioning from the Manager varies smoothly."
  }, {
    "heading": "3.2. Learning",
    "text": "We consider a standard reinforcement learning setup. At each step t, the agent receives an observation xt from the environment and selects an action at from a finite set of possible actions. The environment responds with a new observation xt+1 and a scalar reward rt. The process continues until the terminal state is reached, after which it restarts. The goal of the agent is to maximise the discounted return Rt = ∑∞ k=0 γ\nkrt+k+1 with γ ∈ [0, 1]. The agent’s behaviour is defined by its action-selection policy π. FuN produces a distribution over possible actions (a stochastic policy) as defined in eq. 4.\nThe conventional wisdom would be to train the whole architecture monolithically through gradient descent on either the policy directly or via TD-learning. Notice, that since FuN is fully differentiable we could train it end-toend using a policy gradient algorithm operating on the actions taken by the Worker. The outputs g of the Manager would be trained by gradients coming from the Worker. This, however would deprive Manager’s goals g of any semantic meaning, making them just internal latent variables of the model. We propose instead to independently train Manager to predict advantageous directions (transitions) in state space and to intrinsically reward the Worker to follow these directions. If the Worker can fulfil the goal of moving in these directions (as it is rewarded for doing), then we ought to end up taking advantageous trajectories through\nstate-space. We formalise this in the following update rule for the Manager:\n∇gt = AMt ∇θdcos(st+c − st, gt(θ)), (5)\nwhere AMt = Rt − VMt (xt, θ) is the Manager’s advantage function, computed using a value function estimate VMt (xt, θ) from the internal critic; dcos(α, β) = αTβ/(|α||β|) is the cosine similarity between two vectors. Note: the dependence of s on θ is ignored when computing ∇θdcos – this avoids trivial solutions. Notice that now gt acquires a semantic meaning as an advantageous direction in the latent state space at a horizon c, which defines the temporal resolution of the Manager.\nThe intrinsic reward that encourages the Worker to follow the goals is defined as:\nrIt = 1/c c∑ i=1 dcos(st − st−i, gt−i) (6)\nWe use directions because it is more feasible for the Worker to be able to reliably cause directional shifts in the latent state than it is to assume that the Worker can take us to (potentially) arbitrary new absolute locations. It also gives a degree of invariance to the goals and allows for structural generalisation – the same directional sub-goal g can invoke a sub-policy that is valid and useful in a large part of the latent state space; e.g. evade an enemy, swim up for air, etc. We compare absolute against directional goals empirically in section 5.4.\nThe original feudal reinforcement learning formulation of Dayan & Hinton (1993) advocated completely concealing the reward from the environment from lower levels of hierarchy. In practice we take a softer approach by adding an intrinsic reward for following the goals, but retaining the environment reward as well. The Worker is then trained to maximise a weighted sum Rt + αRIt , where α is a hyperparameter that regulates the influence of the intrinsic reward. The Workers policy π can be trained to maximise intrinsic reward by using any off-the shelf deep reinforcement learning algorithm. Here we use an advantage actor critic (Mnih et al., 2016):\n∇πt = ADt ∇θ log π(at|xt; θ) (7)\nThe advantage function estimator ADt = (Rt + αR I t − V Dt (xt; θ)) is calculated using an internal critic, which estimates the value functions for both rewards.\nNote that the Worker and Manager can potentially have different discount factors γ for computing the return. This allows, for instance, the Worker to be more greedy and focus on immediate rewards while the Manager can consider a long-term perspective."
  }, {
    "heading": "3.3. Transition Policy Gradients",
    "text": "We now motivate our proposed update rule for the Manager as a novel form of policy gradient with respect to a model of the Worker’s behaviour. Consider a high-level policy ot = µ(st, θ) that selects among sub-policies (possibly from a continuous set), where we assume for now that these sub-policies are fixed duration behaviours (lasting for c steps). Corresponding to each sub-policy is a transition distribution, p(st+c|st, ot), that describes the distribution of states that we end up at the end of the sub-policy, given the start state and the sub-policy enacted. The high-level policy can be composed with the transition distribution to give a ‘transition policy’ πTP (st+c|st) = p(st+c|st, µ(st, θ)) describing the distribution over end states given start states. It is valid to refer to this as a policy because the original MDP is isomorphic to a new MDP with policy πTP and transition function st+c = πTP (st) (i.e. the state always transitions to the end state picked by the transition policy). As a result, we can apply the policy gradient theorem to the transition policy πTP , so as to find the performance gradient with respect to the policy parameters,\n∇θπTPt = E [(Rt − V (st))∇θ log p(st+c|st, µ(st, θ))] (8)\nIn general, the Worker may follow a complex trajectory. A naive application of policy gradients requires the agent to learn from samples of these trajectories. But if we know where these trajectories are likely to end up, by modelling the transitions, then we can skip directly over the Worker’s behaviour and instead follow the policy gradient of the predicted transition. FuN assumes a particular form for the transition model: that the direction in state-space, st+c−st, follows a von Mises-Fisher distribution. Specifically, if the mean direction of the von Mises-Fisher distribution is given by g(ot) (which for compactness we write as gt) we would have p(st+c|st, ot) ∝ edcos(st+c−st,gt). If this functional form were indeed correct, then we see that our proposed update heuristic for the Manager, eqn.5, is in fact the proper form for the transition policy gradient arrived at in eqn.8.\nNote that the Worker’s intrinsic reward (eqn. 6) is based on the log-likelihood of state trajectory. Through that the FuN architecture actively encourages the functional form of the transition model to hold true. Because the Worker is learning to achieve the Manager’s direction, its transitions should, over time, closely follow a distribution around this direction, and hence our approximation for transition policy gradients should hold reasonably well."
  }, {
    "heading": "4. Architecture details",
    "text": "This section provides the particular details of the model as described in section 3. The perceptual module fpercept is a convolutional network (CNN) followed by a fully connected layer. The CNN has a first layer with 16 8x8 fil-\nters of stride 4, followed by a layer with with 32 4x4 filters of stride 2. The fully connected layer has 256 hidden units. Each convolutional and fully-connected layer is followed by a rectifier non-linearity1. The state space which the Manager implicitly models in formulating its goals is computed via fMspace, which is another fully connected layer followed by a rectifier non-linearity. The dimensionality of the embedding vectors, w, is set as k = 16. To encourage exploration in transition policy, at every step with a small probability we emit a random goal sampled from a uni-variate Gaussian.\nThe Worker’s recurrent network fWrnn is a standard LSTM (Hochreiter & Schmidhuber, 1997). For the Manager’s recurrent network, fMrnn, we propose a novel design – the dilated LSTM, which is introduced in the next section. Both fMrnn and fWrnn have 256 hidden units."
  }, {
    "heading": "4.1. Dilated LSTM",
    "text": "We propose a novel RNN architecture for the Manager, which operates at lower temporal resolution than the data stream. The main contribution here is the inductive bias towards slowly varying outputs, which have very long-term temporal dependencies. We define a dilated LSTM analogously to dilated convolutional networks (Yu & Koltun, 2016). For a dilation radius r let the full state of the network be h = {ĥi}ri=1, i.e. it is composed of r separate groups of sub-states or ‘cores’. At time t the network is governed by the following equations: ĥt%rt , gt = LSTM(st, ĥt%rt−1; θ\nLSTM), where % denotes the modulo operation and allows us to indicate which group of cores is currently being updated. We make the parameters of the LSTM network θLSTM explicit to stress that the same set of parameters governs the update for each of the r groups within the dLSTM.\nAt each time step only the corresponding part of the state is updated and the output is pooled across the previous c outputs. This allows the r groups of cores inside the dLSTM to preserve the memories for long periods, yet the dLSTM as a whole is still able to process and learn from every input experience, and is also able to update its output at every step. This idea is similar to clockwork RNNs (Koutnı́k et al., 2014), however there the top level “ticks” at a fixed, slow pace, whereas the dLSTM observes all the available training data instead. In the experiments we set r = 10, and this was also used as the predictions horizon, c."
  }, {
    "heading": "5. Experiments",
    "text": "The goal of our experiments is to demonstrate that FuN learns non-trivial, helpful, and interpretable sub-policies\n1This is substantially the same CNN as in (Mnih et al., 2016; 2015), the only difference is that in the pre-processing stage we retain all colour channels.\nand sub-goals, and also to validate components of the architecture. We start by describing technical details of the experimental setup and then present results on Montezuma’s revenge – an infamously hard ATARI game – in section 5.1. Section 5.2 presents results on more ATARI games and extensively compares FuN to LSTM baseline with different discount factors and BPTT lengths. In section 5.3 we present results on a set of visual memorisation tasks in 3D environment. Section 5.4 presents an ablation study of FuN, validating our design choices.\nBaseline. Our main baseline is a recurrent LSTM network on top of a representation learned by a CNN. The LSTM (Hochreiter & Schmidhuber, 1997) architecture is a widely used recurrent network and it was demonstrated to perform very well on a suite of reinforcement learning problems (Mnih et al., 2016). LSTM uses 316 hidden units2 and its inputs are the feature representation of an observation and the previous action of the agent. Action probabilities and the value function estimate are regressed from its hidden state. All the methods the same CNN architecture, input pre-processing, and an action repeat of 4.\nOptimisation. We use the A3C method (Mnih et al., 2016) for all reinforcement learning experiments. It was shown to achieve state-of-the-art results on several challenging benchmarks (Mnih et al., 2016). We cut the trajectory and run backpropagation through time (BPTT) (Mozer, 1989) after K forward passes of a network or if a terminal signal is received. For FuN K = 400, for LSTM, unless otherwise stated, K = 40. We discuss different choice of K for LSTM in section 5.2. The optimization process runs 32 asynchronous threads using shared RMSProp. There are 3 hyper-parameters in\n2This choice means that FuN and the LSTM baseline to have roughly the same number of total parameters.\nFuN and 2 in the LSTM baselines. For each method, we ran 100 experiments, each using randomly sampled hyper-parameters. Learning rate and entropy penalty were sampled from a LogUniform(10−4, 10−3) interval for LSTM. For FuN the learning rate was sampled from LogUniform(10−4.5, 10−3.5), to account for higher gradients due to longer BPTT unrolls. The learning rate was linearly annealed from a sampled value to half the initial rate for all agents. To explore intrinsic motivation in FuN, we sample its weight α ∼ Uniform(0, 1). We define a training epoch as one million observations. When reporting learning curves, we plot the average episode score of the top 5 agents (according to the final score) against the training epochs. For all ATARI experiments we clip the reward to [−1,+1] interval"
  }, {
    "heading": "5.1. Montezuma’s revenge",
    "text": "Montezuma’s revenge is one of the hardest games available through the ALE (Bellemare et al., 2012). The game is infamous for challenging agents with lethal traps and sparse rewards. We had to broaden and intensify our hyper-parameter search for the LSTM baseline to see any progress at all for that model. We have experimented with many different hyper-parameter configurations for LSTM baseline, for instance expanding learning rate search to LogUniform(10−3, 10−2), and we report on the configuration that worked best. We use a small discount 0.99 for LSTM; for FuN we use 0.99 in Worker and 0.999 in Manager. Figure 2b analyses the sub-goals learnt by FuN in the first room. They turn out to be meaningful milestones, which bridge the agents progress to its first extrinsic reward – picking up the key. Interestingly, two of the learnt sub-goals correspond to roughly the same locations as the ones hand-crafted in (Kulkarni et al., 2016) (ladder and key), but here they are learnt by the agent itself. Figure 2a\nplots the learning curves. Notice how FuN starts learning much earlier and achieves much higher scores. It takes > 300 epochs for LSTM to reach the score 400, which corresponds to solving the first room (take the key, open a door); it stagnates at that score until about 900 epochs, when it starts exploring further. FuN solves the first room in less than 200 epochs and immediately moves on to explore further, eventually visiting several other rooms and scoring up to 2600 points."
  }, {
    "heading": "5.2. ATARI",
    "text": "Experiments in this section validate that the capabilities of FuN go beyond what standard tools for long-term credit assignment – discount factors and BPTT unroll length – can provide for a baseline LSTM agent. We use two discounts 0.99 and 0.95 for both FuN and LSTM agents. (For the experiments on FuN only the discount for the Manager changes, while the Worker’s discount is fixed at\n0.95.) For the LSTM we explore BPTT of 40 and 100, while for FuN we use a BPTT unroll of 400. For LSTM with BPTT 100 we search for learning rate in the interval LogUniform(10−4.5, 10−3.5), as for FuN. We use a diverse set of ATARI games, some of which involve longterm credit assignment and some which are more reactive.\nFigure 3 plots the learning curves. A few categories emerge. On Ms. Pacman, Amidar, and Gravitar FuN with a low Manager discount of 0.99 strongly outperforms all other methods. All of these games are known to require long-term reasoning to play well. Enduro stands out as all the LSTM agents completely fail at it. In this game the agent controls a racing car and scores points for overtaking other racers; this requires accelerating and steering for significant amount of time before the first reward is experienced. Frostbite is a hard game (Vezhnevets et al., 2016; Lake et al., 2016) that requires both long-term credit assignment and good exploration. The best-performing frost-\nbite agent is FuN with 0.95 Manager discount, which outperforms the rest by a factor of 7. On Hero and Space Invaders all agents perform equally well. On Seaquest and Breakout, the baseline LSTM with a more aggressive discount of 0.95 is the best. This suggests that in these games long-term credit assignment is not important and the agent is better off optimising more immediate rewards in a greedy fashion. Alien is the only game where using different discounts doesn’t meaningfully influence the agents performance; here we see the baseline LSTM outperforms our FuN model, although both still achieve a satisfactory scores. We provide qualitative analysis of subpolicies learnt on Seaquest in supplementary material.\nNote how using an unroll for BPTT=100 in the baseline LSTM significantly hurts its performance (hence we do not explore longer unrolls), while FuN performs very well with BPTT of 400 thanks to its ability to leverage the dLSTM. Being able to train a recurrent network over very long sequences could be an enabling tool for many memory related task, as we demonstrate in section 5.3.\nOption-critic architecture (Bacon et al., 2017) is, to the best of our knowledge, the only other end-to-end trainable system with sub-policies. The experimental results for Option-Critic on 4 ATARI (Bacon et al., 2017) games show scores similar those from a flat DQN (Mnih et al., 2015) baseline agent. Notice that our baseline (Mnih et al., 2016) is much stronger than DQN. We also ran FuN on the same games as Option-Critic (Asterix, Ms. Pacman, Seaquest and Zaxxon) and after 200 epochs it achieves a similar score on Seaquest, doubles it on Ms. Pacman, more than triples it on Zaxxon and gets more than 20x improvement on Asterix (see supplementary material for plots)."
  }, {
    "heading": "5.3. Memory in Labyrinth",
    "text": "DeepMind Lab (Beattie et al., 2016) is a first-person 3D game platform extended from OpenArena. It’s a visually complex 3D environment with agent actions corresponding to movement and orientation. We use 4 different levels that test long-term credit assignment and visual memory:\nWater maze is a reproduction of the Morris water maze experiment (Morris, 1981) from the behavioural science literature. An agent is dropped into a circular pool of water with a concealed platform at unknown random location. The agent can move around and upon stepping on the platform it receives a reward and the trial restarts. The platform remains in the same location for the rest of the episode, while agent starts each trial at a random location. The walls of the pool are decorated with visual cues to assist localisation.\nT-maze is another classic animal cognition test. The agent spawns in a small T-shaped maze. Two objects with randomly chosen shape and colour are spawned at the left and right ”baiting” locations. One of them is assigned a reward of +1 and the other a reward of -1. When the agent collects one of the objects, it receives the reward and is respawned at the beginning of the T-maze. The objects are also re-instantiated in the same locations and with the same rewards on the re-spawn event. The agent should remember which object gives the positive reward across re-spawns and collect it as many times as possible within the fixed time given for the episode. T-maze+ is a modification of T-maze, where at each trial the length of corridors can vary, adding additional dimension of complexity.\nNon-match is a visual memorisation task. Each trial begins in small room with an out of reach object being displayed in one of two display pods. There is a pad in the middle, which upon touching, the agent is rewarded with 1 point, and is teleported to a second room which has two objects in it, one of which matches the object in the previous room. Collecting the matching object gives a reward of -10 points, collecting the non matching object gives a reward of 10 points. Once either is collected, the agent is teleported back to the first room, with the same object being shown.\nFor all agents we include reward as a part of the observation. Figure 5 plots the learning curves. FuN consitently outperforms the LSTM baseline – it learns faster and also reaches a higher final reward. We analyse the FuN agent’s behaviour in more detail in Figure 4b. It demonstrates that FuN learns meaningful sub-policies, which are then efficiently integrated with memory to produce rewarding behaviour. Interestingly, the LSTM agent doesn’t appear to use its memory for water maze task at all, always circling the maze at the roughly the same radius."
  }, {
    "heading": "5.4. Ablative analysis",
    "text": "This section empirically validates the main innovations of this paper: transition policy gradient for training the Manager; relative rather than absolute goals; intrinsic motivation for the Worker. First we consider a ‘non-Feudal’ FuN – it has exactly the same network architecture as FuN, but the Managers output g is trained with gradients coming directly from the Worker and no intrinsic reward is used, much like in Option-Critic architecture (Bacon et al., 2017). Second, g is learnt using a standard policy gradient approach with the Manager emitting the mean of a Gaussian distribution from which goals are sampled (as if the Manager were solving a continuous control problem (Schulman et al., 2016; Mnih et al., 2016; Lillicrap et al., 2015)). Third, we explore a variant of FuN in which g specifies absolute, rather than relative/directional, goals (and the Worker’s intrinsic reward is adjusted accordingly) but otherwise everything is the same. The experiments (Figure 6) reveal that, although alternatives do work to some degree their performance is significantly inferior. We also evaluate a purely feudal version of FuN – in which the Worker is trained from the intrinsic reward alone. This ablation performs better than other, but still inferior to the full FuN approach. It shows that allowing the Worker to experience the external reward is beneficial."
  }, {
    "heading": "5.5. ATARI action repeat transfer",
    "text": "One of the advantages of FuN is the clear separation of duties between Manager and Worker. The Manager learns a transition policy, while the Worker learns to operate primitive actions to enact these transitions. This transition policy is invariant to the underlying embodiment of the agent – the way its primitive actions translate into state space transitions. Potentially, the transition policy can be transferred between agents with different embodiment – e.g. robot models with different bodies or different operational frequency. We provide evidence towards that possibility by transferring policies across agents with different action repeat on ATARI. Action repeat is a heuristic used in all successful agents (Mnih et al., 2015; 2016; Bellemare et al., 2016b; Vezhnevets et al., 2016). It enables better exploration, eases credit assignment, and saves computation by repeating an action chosen by the agent several (= 4) times.\nTo perform transfer, we initialise the FuN system with parameters extracted from an agent trained with action repeat of 4 and then make the following adjustments: (i) we accordingly adjust the discounts for all rewards; (ii) we increase the dilation of the dLSTM by a factor of 4; (iii) we increase the Manager’s goal horizon c by a factor of 4. (These modifications adapt all the “hard-wired” but explicitly temporally sensitive aspects of the agent.) We then train this agent without action repeat. As a baseline we use an LSTM agent transferred in a similar way (with adjusted discounts) as well as FuN and LSTM agents trained without action repeat from scratch. Figure 7 shows the corresponding learning curves. The transferred FuN agent (green curve) significantly outperforms every other method. Furthermore it shows positive transfer on each environment, whereas LSTM only shows positive transfer on Ms. Pacman."
  }, {
    "heading": "6. Discussion and future work",
    "text": "How to create agents that can learn to decompose their behaviour into meaningful primitives and then reuse them to more efficiently acquire new behaviours is a long standing research question. The solution to this question may be an important stepping stone towards agents with general intelligence and competence. This paper introduced FeUdal Networks, a novel architecture that formulates sub-goals as directions in latent state space, which, if followed, translate into a meaningful behavioural primitives. FuN clearly separates the module that discovers and sets sub-goals from the module that generates the behaviour through primitive actions. This creates a natural hierarchy that is stable and allows both modules to learn in complementary ways. Our experiments clearly demonstrate that this makes long-term credit assignment and memorisation more tractable. This also opens many avenues for further research, for instance: deeper hierarchies can be constructed by setting goals at multiple time scales, scaling agents to truly large environments with sparse rewards and partial observability. The modular structure of FuN is also lends itself to transfer and multitask learning – learnt behavioural primitives can be re-used to acquire new complex skills, or alternatively the transitional policies of the Manager can be transferred to agents with different embodiment."
  }, {
    "heading": "Acknowledgements",
    "text": "We thank Daan Wierstra, Olivier Pietquin, Tejas Kulkarni, Alex Graves, Oriol Vinyals, Joseph Modayil and Vlad Mnih for many helpful discussions, suggestions and comments on the paper."
  }],
  "year": 2017,
  "references": [{
    "title": "The option-critic architecture",
    "authors": ["Bacon", "Pierre-Luc", "Precup", "Doina", "Harb", "Jean"],
    "venue": "In AAAI,",
    "year": 2017
  }, {
    "title": "Unifying count-based exploration and intrinsic motivation",
    "authors": ["Bellemare", "Marc", "Srinivasan", "Sriram", "Ostrovski", "Georg", "Schaul", "Tom", "Saxton", "David", "Munos", "Remi"],
    "venue": "In NIPS,",
    "year": 2016
  }, {
    "title": "The arcade learning environment: An evaluation platform for general agents",
    "authors": ["Bellemare", "Marc G", "Naddaf", "Yavar", "Veness", "Joel", "Bowling", "Michael"],
    "venue": "Journal of Artificial Intelligence Research,",
    "year": 2012
  }, {
    "title": "Increasing the action gap: New operators for reinforcement learning",
    "authors": ["Bellemare", "Marc G", "Ostrovski", "Georg", "Guez", "Arthur", "Thomas", "Philip S", "Munos", "Rémi"],
    "venue": "In Proceedings of the AAAI Conference on Artificial Intelligence,",
    "year": 2016
  }, {
    "title": "Prioritized goal decomposition of markov decision processes: Toward a synthesis of classical and decision theoretic planning",
    "authors": ["Boutilier", "Craig", "Brafman", "Ronen I", "Geib", "Christopher"],
    "venue": "In IJCAI,",
    "year": 1997
  }, {
    "title": "Improving generalization for temporal difference learning: The successor representation",
    "authors": ["Dayan", "Peter"],
    "venue": "Neural Computation,",
    "year": 1993
  }, {
    "title": "Feudal reinforcement learning",
    "authors": ["Dayan", "Peter", "Hinton", "Geoffrey E"],
    "venue": "In NIPS. Morgan Kaufmann Publishers,",
    "year": 1993
  }, {
    "title": "Hierarchical reinforcement learning with the maxq value function decomposition",
    "authors": ["Dietterich", "Thomas G"],
    "venue": "J. Artif. Intell. Res.(JAIR),",
    "year": 2000
  }, {
    "title": "Long shortterm memory",
    "authors": ["Hochreiter", "Sepp", "Schmidhuber", "Jürgen"],
    "venue": "Neural computation,",
    "year": 1997
  }, {
    "title": "Reinforcement learning with unsupervised auxiliary tasks",
    "authors": ["Jaderberg", "Max", "Mnih", "Volodymyr", "Czarnecki", "Wojciech Marian", "Schaul", "Tom", "Leibo", "Joel Z", "Silver", "David", "Kavukcuoglu", "Koray"],
    "venue": "arXiv preprint arXiv:1611.05397,",
    "year": 2016
  }, {
    "title": "Hierarchical learning in stochastic domains: Preliminary results",
    "authors": ["Kaelbling", "Leslie Pack"],
    "venue": "In ICML,",
    "year": 2014
  }, {
    "title": "A clockwork rnn",
    "authors": ["Koutnı́k", "Jan", "Greff", "Klaus", "Gomez", "Faustino", "Schmidhuber", "Jürgen"],
    "venue": "In ICML,",
    "year": 2014
  }, {
    "title": "Hierarchical deep reinforcement learning: Integrating temporal abstraction and intrinsic motivation",
    "authors": ["Kulkarni", "Tejas D", "Narasimhan", "Karthik R", "Saeedi", "Ardavan", "Tenenbaum", "Joshua B"],
    "venue": "arXiv preprint arXiv:1604.06057,",
    "year": 2016
  }, {
    "title": "Building machines that learn and think like people",
    "authors": ["Lake", "Brenden M", "Ullman", "Tomer D", "Tenenbaum", "Joshua B", "Gershman", "Samuel J"],
    "venue": "arXiv preprint arXiv:1604.00289,",
    "year": 2016
  }, {
    "title": "End-to-end training of deep visuomotor policies",
    "authors": ["Levine", "Sergey", "Finn", "Chelsea", "Darrell", "Trevor", "Abbeel", "Pieter"],
    "venue": "arXiv preprint arXiv:1504.00702,",
    "year": 2015
  }, {
    "title": "Continuous control with deep reinforcement learning",
    "authors": ["Lillicrap", "Timothy P", "Hunt", "Jonathan J", "Pritzel", "Alexander", "Heess", "Nicolas", "Erez", "Tom", "Tassa", "Yuval", "Silver", "David", "Wierstra", "Daan"],
    "venue": "arXiv preprint arXiv:1509.02971,",
    "year": 2015
  }, {
    "title": "Human-level control through deep reinforcement learning",
    "authors": ["Dharshan", "Wierstra", "Daan", "Legg", "Shane", "Hassabis", "Demis"],
    "venue": "Nature, 518(7540):529–533,",
    "year": 2015
  }, {
    "title": "Asynchronous methods for deep reinforcement learning",
    "authors": ["Mnih", "Volodymyr", "Badia", "Adria Puigdomenech", "Mirza", "Mehdi", "Graves", "Alex", "Lillicrap", "Timothy P", "Harley", "Tim", "Silver", "David", "Kavukcuoglu", "Koray"],
    "year": 2016
  }, {
    "title": "Spatial localization does not require the presence of local cues",
    "authors": ["Morris", "Richard GM"],
    "venue": "Learning and motivation,",
    "year": 1981
  }, {
    "title": "A focused back-propagation algorithm for temporal pattern recognition",
    "authors": ["Mozer", "Michael C"],
    "venue": "Complex systems,",
    "year": 1989
  }, {
    "title": "Reinforcement learning with hierarchies of machines",
    "authors": ["Parr", "Ronald", "Russell", "Stuart"],
    "year": 1998
  }, {
    "title": "Temporal abstraction in reinforcement learning",
    "authors": ["Precup", "Doina"],
    "venue": "PhD thesis, University of Massachusetts,",
    "year": 2000
  }, {
    "title": "Planning with closed-loop macro actions",
    "authors": ["Precup", "Doina", "Sutton", "Richard S", "Singh", "Satinder P"],
    "venue": "Technical report,",
    "year": 1997
  }, {
    "title": "Theoretical results on reinforcement learning with temporally abstract options",
    "authors": ["Precup", "Doina", "Sutton", "Richard S", "Singh", "Satinder"],
    "venue": "In European Conference on Machine Learning (ECML). Springer,",
    "year": 1998
  }, {
    "title": "Universal value function approximators",
    "authors": ["Schaul", "Tom", "Horgan", "Dan", "Gregor", "Karol", "Silver", "David"],
    "year": 2015
  }, {
    "title": "Neural sequence chunkers",
    "authors": ["Schmidhuber", "Jürgen"],
    "venue": "Technical report,",
    "year": 1991
  }, {
    "title": "Trust region policy optimization",
    "authors": ["Schulman", "John", "Levine", "Sergey", "Moritz", "Philipp", "Jordan", "Michael I", "Abbeel", "Pieter"],
    "venue": "In ICML,",
    "year": 2015
  }, {
    "title": "High-dimensional continuous control using generalized advantage estimation",
    "authors": ["Schulman", "John", "Moritz", "Philipp", "Levine", "Sergey", "Jordan", "Michael", "Abbeel", "Pieter"],
    "year": 2016
  }, {
    "title": "Td models: Modeling the world at a mixture of time scales",
    "authors": ["Sutton", "Richard S"],
    "venue": "In ICML,",
    "year": 1995
  }, {
    "title": "Between mdps and semi-mdps: A framework for temporal abstraction in reinforcement learning",
    "authors": ["Sutton", "Richard S", "Precup", "Doina", "Singh", "Satinder"],
    "venue": "Artificial intelligence,",
    "year": 1999
  }, {
    "title": "A deep hierarchical approach to lifelong learning in minecraft",
    "authors": ["Tessler", "Chen", "Givony", "Shahar", "Zahavy", "Tom", "Mankowitz", "Daniel J", "Mannor", "Shie"],
    "venue": "arXiv preprint arXiv:1604.07255,",
    "year": 2016
  }, {
    "title": "Strategic attentive writer for learning macro-actions",
    "authors": ["Vezhnevets", "Alexander", "Mnih", "Volodymyr", "Osindero", "Simon", "Graves", "Alex", "Vinyals", "Oriol", "Agapiou", "John", "kavukcuoglu", "koray"],
    "year": 2016
  }, {
    "title": "Multi-scale context aggregation by dilated convolutions",
    "authors": ["Yu", "Fisher", "Koltun", "Vladlen"],
    "year": 2016
  }],
  "id": "SP:ede39992f6f709ce7cc9d29d7bb9b3cbe51f18e5",
  "authors": [{
    "name": "Alexander Sasha Vezhnevets",
    "affiliations": []
  }, {
    "name": "Simon Osindero",
    "affiliations": []
  }, {
    "name": "Tom Schaul",
    "affiliations": []
  }, {
    "name": "Nicolas Heess",
    "affiliations": []
  }, {
    "name": "Max Jaderberg",
    "affiliations": []
  }, {
    "name": "David Silver",
    "affiliations": []
  }, {
    "name": "Koray Kavukcuoglu",
    "affiliations": []
  }],
  "abstractText": "We introduce FeUdal Networks (FuNs): a novel architecture for hierarchical reinforcement learning. Our approach is inspired by the feudal reinforcement learning proposal of Dayan and Hinton, and gains power and efficacy by decoupling end-to-end learning across multiple levels – allowing it to utilise different resolutions of time. Our framework employs a Manager module and a Worker module. The Manager operates at a lower temporal resolution and sets abstract goals which are conveyed to and enacted by the Worker. The Worker generates primitive actions at every tick of the environment. The decoupled structure of FuN conveys several benefits – in addition to facilitating very long timescale credit assignment it also encourages the emergence of sub-policies associated with different goals set by the Manager. These properties allow FuN to dramatically outperform a strong baseline agent on tasks that involve long-term credit assignment or memorisation.",
  "title": "FeUdal Networks for Hierarchical Reinforcement Learning"
}