{
  "sections": [{
    "heading": "1. Introduction",
    "text": "Coordinate descent (CD) methods have attracted a substantial interest the optimization community in the last few years (Nesterov, 2012; Richtárik & Takáč, 2016). Due to their computational efficiency, scalability, as well as their ease of implementation, these methods are the state-of-theart for a wide selection of machine learning and signal processing applications (Fu, 1998; Hsieh et al., 2008; Wright, 2015). This is also theoretically well justified: The complexity estimates for CD methods are in general better than the estimates for methods that compute the full gradient in one batch pass (Nesterov, 2012; Nesterov & Stich, 2017).\nIn many CD methods, the active coordinate is picked at random, according to a probability distribution. For smooth functions it is theoretically well understood how the sampling procedure is related to the efficiency of the scheme and which distributions give the best complexity estimates (Nesterov, 2012; Zhao & Zhang, 2015; AllenZhu et al., 2016; Qu & Richtárik, 2016; Nesterov & Stich, 2017). For nonsmooth and composite functions — that appear in many machine learning applications — the pic-\n1EPFL 2Max Planck Institute for Intelligent Systems. Correspondence to: Sebastian U. Stich <sebastian.stich@epfl.ch>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\nture is less clear. For instance in (Shalev-Shwartz & Zhang, 2013; Friedman et al., 2007; 2010; Shalev-Shwartz & Tewari, 2011) uniform sampling (UCD) is used, whereas other papers propose adaptive sampling strategies that change over time (Papa et al., 2015; Csiba et al., 2015; Osokin et al., 2016; Perekrestenko et al., 2017).\nA very simple deterministic strategy is to move along the direction corresponding to the component of the gradient with the maximal absolute value (steepest coordinate descent, SCD) (Boyd & Vandenberghe, 2004; Tseng & Yun, 2009). For smooth functions this strategy yields always better progress than UCD, and the speedup can reach a factor of the dimension (Nutini et al., 2015). However, SCD requires the computation of the whole gradient vector in each iteration which is prohibitive (except for special applications, cf. Dhillon et al. (2011); Shrivastava & Li (2014)).\nIn this paper we propose approximate steepest coordinate descent (ASCD), a novel scheme which combines the best parts of the aforementioned strategies: (i) ASCD maintains an approximation of the full gradient in each iteration and selects the active coordinate among the components of this vector that have large absolute values — similar to SCD; and (ii) in many situations the gradient approximation can be updated cheaply at no extra cost — similar to UCD. We show that regardless of the errors in the gradient approximation (even if they are infinite), ASCD performs always better than UCD.\nSimilar to the methods proposed in (Tseng & Yun, 2009) we also present variants of ASCD for composite problems. We confirm our theoretical findings by numerical experiments for Lasso and Ridge regression on a synthetic dataset as well as on the RCV1 (binary) dataset.\nStructure of the Paper and Contributions. In Sec. 2 we review the existing theory for SCD and (i) extend it to the setting of smooth functions. We present (ii) a novel lower bound, showing that the complexity estimates for SCD and UCD can be equal in general. We (iii) introduce ASCD and the save selection rules for both smooth (Sec. 3) and to composite functions (Sec. 5). We prove that (iv) ASCD performs always better than UCD (Sec. 3) and (v) it can reach the performance of SCD (Sec. 6). In Sec. 4 we discuss important applications where the gradient estimate can efficiently be maintained. Our theory is supported by nu-\nmerical evidence in Sec. 7, which reveals that (vi) ASCD performs extremely well on real data.\nNotation. Define [x]i := 〈x, ei〉 with ei the standard unit vectors in Rn. We abbreviate ∇if := [∇f ]i. A convex function f : Rn → R with coordinate-wise LiLipschitz continuous gradients1 for constants Li > 0, i ∈ [n] := {1, . . . , n}, satisfies by the standard reasoning\nf(x + ηei) ≤ f(x) + η∇if(x) + Li2 η 2 (1)\nfor all x ∈ Rn and η ∈ R. A function is coordinate-wise L-smooth if Li ≤ L for i = 1, . . . , n. For an optimization problem minx∈Rn f(x) define X? := arg minx∈Rn f(x) and denote by x? ∈ Rn an arbitrary element x? ∈ X?."
  }, {
    "heading": "2. Steepest Coordinate Descent",
    "text": "In this section we present SCD and discuss its theoretical properties. The functions of interest are composite convex functions F : Rn → R of the form\nF (x) := f(x) + Ψ(x) (2)\nwhere f is coordinate-wise L-smooth and Ψ convex and separable, that is that is Ψ(x) = ∑n i=1 Ψi([x]i). In the first part of this section we focus on smooth problems, i.e. we assume that Ψ ≡ 0.\nCoordinate descent methods with constant step size generate a sequence {xt}t≥0 of iterates that satisfy the relation\nxt+1 = xt − 1L∇itf(x)eit . (3)\nIn UCD the active coordinate it is chosen uniformly at random from the set [n], it ∈u.a.r. [n]. SCD chooses the coordinate according to the Gauss-Southwell (GS) rule:\nit = arg max i∈[n]\n∇i |f(xt)| . (4)"
  }, {
    "heading": "2.1. Convergence analysis",
    "text": "With the quadratic upper bound (1) one can easily get a lower bound on the one step progress\nE [f(xt)− f(xt+1) | xt] ≥ Eit [ 1 2L |∇itf(xt)| 2 ] . (5)\nFor UCD and SCD the expression on the right hand side evaluates to\nτUCD(xt) := 1 2nL ‖∇f(xt)‖ 2 2 τSCD(xt) := 1 2L ‖∇f(xt)‖ 2 ∞\n(6)\nWith Cauchy-Schwarz we find\n1 nτSCD(xt) ≤ τUCD(xt) ≤ τSCD(xt) . (7)\n1|∇if(x+ ηei)−∇if(x)| ≤ Li |η| , ∀x ∈ Rn, η ∈ R.\nHence, the lower bound on the one step progress of SCD is always at least as large as the lower bound on the one step progress of UCD. Moreover, the one step progress could be even lager by a factor of n. However, it is very difficult to formally prove that this linear speed-up holds for more than one iteration, as the expressions in (7) depend on the (a priori unknown) sequence of iterates {xt}t≥0.\nStrongly Convex Objectives. Nutini et al. (2015) present an elegant solution of this problem for µ2-strongly convex functions2. They propose to measure the strong convexity of the objective function in the 1-norm instead of the 2-norm. This gives rise to the lower bound\nτSCD(xt) ≥ µ1L (f(xt)− f(x ?)) , (8)\nwhere µ1 denotes the strong convexity parameter. By this, they get a uniform upper bound on the convergence that does not directly depend on local properties of the function, like for instance τSCD(xt), but just on µ1. It always holds µ1 ≤ µ2, and for functions where both quantities are equal, SCD enjoys a linear speedup over UCD.\nSmooth Objectives. When the objective function f is just smooth (but not necessarily strongly convex), then the analysis mentioned above is not applicable. We here extend the analysis from (Nutini et al., 2015) to smooth functions. Theorem 2.1. Let f : Rn → R be convex and coordinatewise L-smooth. Then for the sequence {xt}t≥0 generated by SCD it holds:\nf(xt)− f(x?) ≤ 2LR21 t , (9)\nfor R1 := max x?∈X? { max x∈Rn [‖x− x?‖1 | f(x) ≤ f(x0)] } .\nProof. In the proof we first derive a lower bound on the one step progress (Lemma A.1), similar to the analysis in (Nesterov, 2012). The lower bound for the one step progress of SCD can in each iteration differ up to a factor of n from the analogous bound derived for UCD (similar as in (7)). All details are given in Section A.1 in the appendix.\nNote that the R1 is essentially the diameter of the level set at f(x0) measured in the 1-norm. In the complexity estimate of UCD, R21 in (9) is replaced by nR 2 2, where R2 is the diameter of the level at f(x0) measured in the 2-norm (cf. Nesterov (2012); Wright (2015)). As in (7) we observe with Cauchy-Schwarz\n1 nR 2 1 ≤ R22 ≤ R21 , (10)\ni.e. SCD can accelerate up to a factor of n over to UCD.\n2A function is µp-strongly convex in the p-norm, p ≥ 1, if f(y) ≥ f(x) + 〈∇f(x),y − x〉+ µp\n2 ‖y − x‖2p, ∀x,y ∈ R n."
  }, {
    "heading": "2.2. Lower bounds",
    "text": "In the previous section we provided complexity estimates for the methods SCD and UCD and showed that SCD can converge up to a factor of the dimension n faster than UCD. In this section we show that this analysis is tight. In Theorem 2.2 below we give a function q : Rn → R, for which the one step progress τSCD(xt) ≈ τUCD(xt) up to a constant factor, for all iterates {xt}t≥0 generated by SCD.\nBy a simple technique we can also construct functions for which the speedup is exactly equal to an arbitrary factor λ ∈ [1, n]. For instance we can consider functions with a (separable) low dimensional structure. Fix integers s, n such that ns ≈ λ, define the function f : R n → R as\nf(x) := q(πs(x)) (11)\nwhere πs denotes the projection to Rs (being the first s out of n coordinates) and q : Rs → R is the function from Theorem 2.2. Then\nτSCD(xt) ≈ λ · τUCD(xt) , (12)\nfor all iterates {xt}t≥0 generated by SCD. Theorem 2.2. Consider the function q(x) = 12 〈Qx,x〉 for Q := In − 99100nJn, where Jn = 1n1 T n , n > 2. Then there exists x0 ∈ Rn such that for the sequence {xt}t≥0 generated by SCD it holds\n‖∇q(xt)‖2∞ ≤ 4 n ‖∇q(xt)‖ 2 2 . (13)\nProof. In the appendix we discuss a family of functions defined by matrices Q := (α − 1) 1nJn + In and define corresponding parameters 0 < cα < 1 such that for x0 defined as [x0]i = ci−1α for i = 1, . . . , n, SCD cycles through the coordinates, that is, the sequence {xt}t≥0 generated by SCD satisfies\n[xt]1+(t−1 mod n) = c n α · [xt−1]1+(t−1 mod n) . (14)\nWe verify that for this sequence property (13) holds."
  }, {
    "heading": "2.3. Composite Functions",
    "text": "The generalization of the GS rule (4) to composite problems (2) with nontrival Ψ is not straight forward. The ‘steepest’ direction is not always meaningful in this setting; consider for instance a constrained problem where this rule could yield no progress at all when stuck at the boundary.\nNutini et al. (2015) discuss several generalizations of the Gauss-Southwell rule for composite functions. The GSs rule is defined to choose the coordinate with the most negative directional derivative (Wu & Lange, 2008). This rule is identical to (4) but requires the calculation of subgradients of Ψi. However, the length of a step could be\narbitrarily small. In contrast, the GS-r rule was defined to pick the coordinate direction that yields the longest step (Tseng & Yun, 2009). The rule that enjoys the best theoretical properties (cf. Nutini et al. (2015)) is the GS-q rule, which is defined as to maximize the progress assuming a quadratic upper bound on f (Tseng & Yun, 2009). Consider the coordinate-wise models\nVi(x, y, s) := sy + L 2 y 2 + Ψi([x]i + y) , (15)\nfor i ∈ [n]. The GS-q rule is formally defined as\niGS−q = arg min i∈[n] min y∈R\nVi(x, y,∇if(x)) . (16)"
  }, {
    "heading": "2.4. The Complexity of the GS rule",
    "text": "So far we only studied the iteration complexity of SCD, but we have disregarded the fact that the computation of the GS rule (4) can be as expensive as the computation of the whole gradient. The application of coordinate descent methods is only justified if the complexity to compute one directional derivative is approximately n times cheaper than the computation of the full gradient vector (cf. Nesterov (2012)). By Theorem 2.2 this reasoning also applies to SCD. A class of function with this property is given by functions F : Rn → R\nF (x) := f(Ax) + n∑ i=1 Ψi([x]i) (17)\nwhere A is a d × n matrix, and where f : Rd → R, and Ψi : Rn → R are convex and simple, that is the time complexity T for computing their gradients is linear: T (∇yf(y),∇xΨ(x) = O(d + n). This class of functions includes least squares, logistic regression, Lasso, and SVMs (when solved in dual form).\nAssuming the matrix is dense, the complexity to compute the full gradient of F is T (∇xF (x)) = O(dn). If the value w = Ax is already computed, one directional derivative can be computed in time T (∇iF (x)) = O(d). The recursive update of w after one step needs the addition of one column of matrix A with some factors and can be done in time O(d). However, we note that recursively updating the full gradient vector takes time O(dn) and consequently the computation of the GS rule cannot be done efficiently.\nNutini et al. (2015) consider sparse matrices, for which the computation of the Gauss-Southwell rule becomes traceable. In this paper, we propose an alternative approach. Instead of updating the exact gradient vector, we keep track of an approximation of the gradient vector and recursively update this approximation in time O(n log n). With these updates, the use of coordinate descent is still justified in case d = Ω(n).\nAlgorithm 1 Approximate SCD (ASCD) Input: f , x0, T , δ-gradient oracle g, methodM Initialize [g̃0]i = 0, [r0]i =∞ for i ∈ [n]. for t = 0 to T do\nFor i ∈ [n] define compute u.-and l.-bounds [ut]i := max{|[g̃t]i − [rt]i| , |[g̃t]i + [rt]i|} [`t]i := miny∈R{|y| | [g̃t]i−[rt]i ≤ y ≤ [g̃t]i+[rt]i} av(I) := 1|I| ∑ i∈I [`t] 2 i compute active set\nIt := arg minI ∣∣{I ⊆ [n] | [ut]2i < av(I),∀i /∈ I}∣∣\nPick it ∈u.a.r. arg maxi∈It{[`]i} active coordinate (xt+1, [g̃t+1]it , [rt+1]it) :=M(xt,∇itf(xt))\nγt := [xt+1]it − [xt]it update∇f(xt+1) estimate Update [g̃t+1]j := [g̃t]j + γtgitj(xt), j 6= it Update [rt+1]j := [rt]j + γtδitj , j 6= it\nend for"
  }, {
    "heading": "3. Algorithm",
    "text": "Is it possible to get the significantly improved convergence speed from SCD, when one is only willing to pay the computational cost of only the much simpler UCD? In this section, we give a formal definition of our proposed approximate SCD method which we denote ASCD.\nThe core idea of the algorithm is the following: While performing coordinate updates, ideally we would like to efficiently track the evolution of all elements of the gradient, not only the one coordinate which is updated in the current step. The formal definition of the method is given in Algorithm 1 for smooth objective functions. In each iteration, only one coordinate is modified according to some arbitrary update rule M. The coordinate update rule M provides two things: First the new iterate xt+1, and secondly also an estimate g̃ of the it-th entry of the gradient at the new iterate3. Formally,\n(xt+1, g̃, r) :=M(xt,∇itf(xt)) (18)\nsuch that the quality of the new gradient estimate g̃ satisfies\n|∇itf(xt+1)− g̃| ≤ r . (19)\nThe non-active coordinates are updated with the help of gradient oracles with accuracy δ ≥ 0 (see next subsection for details). The scenario of exact updates of all gradient entries is obtained for accuracy parameters δ = r = 0 and in this case ASCD is identical to SCD."
  }, {
    "heading": "3.1. Safe bounds for gradient evolution",
    "text": "ASCD maintains lower and upper bounds for the absolute values of each component of the gradient ([`]i ≤\n3For instance, for updates by exact coordinate optimization (line-search), we have g̃ = r = 0.\n|∇if(x)| ≤ [u]i). These bounds allow to identify the coordinates on which the absolute values of the gradient are small (and hence cannot be the steepest one). More precisely, the algorithm maintains a set It of active coordinates (similar in spirit as in active set methods, see e.g. Kim & Park (2008); Wen et al. (2012)). A coordinate j is excluded from It if the estimated progress in this direction (cf. (5)) is lower than the average of the estimated progress along coordinate directions in It, [ut]2j < 1|It| ∑ i∈It [`t] 2 i . The active set It can be computed in O(n log n) time by sorting. All other operations take linear O(n) time.\nGradient Oracle. The selection mechanism in ASCD crucially relies on the following definition of a δ-gradient oracle. While the update M delivers the estimated active entry of the new gradient, the additional gradient oracle is used to update all other coordinates j 6= it of the gradient; as in the last two lines of Algorithm 1. Definition 3.1 (δ-gradient oracle). For a function f : Rn → R and indices i, j ∈ [n], a (i, j)-gradient oracle with error δij ≥ 0 is a function gij : Rn → R satisfying ∀x ∈ Rn,∀γ ∈ R:\n|∇jf(x + γei)− γgij(x)| ≤ |γ| δij . (20)\nWe denote by a δ-gradient oracle a family {gij}i,j∈[n] of δij-gradient oracles.\nWe discuss the availability of good gradient oracles for many problem classes in more detail in Section 4. For example for least squares problems and general linear models, a δ-gradient oracle is for instance given by a scalar product estimator as in (24) below. Note that ASCD can also handle very bad estimates, as long as the property (20) is satisfied (possibly even with accuracy δij =∞).\nInitialization. In ASCD the initial estimate g̃0 of the gradient is just arbitrarily set to 0, with uncertainty r0 = ∞. Hence in the worst case it takes Θ(n log n) iterations until each coordinate gets picked at least once (cf. Dawkins (1991)) and until corresponding gradient estimates are set to a realistic value. If better estimates of the initial gradient are known, they can be used for the initialization as long as a strong error bound as in (19) is known as well. For instance the initialization can be done with ∇f(x0) if one is willing to compute this vector in one batch pass.\nConvergence Rate Guarantee. We present our first main result showing that the performance of ASCD is provably between UCD and SCD. First observe that if in Algorithm 1 the gradient oracle is always exact, i.e. δij ≡ 0, and if g̃0 is initialized with ∇f(x0), then in each iteration |∇itf(xt)| = ‖∇f(xt)‖∞ and ASCD identical to SCD. Lemma 3.1. Let imax := arg maxi∈[n] |∇if(xt)|. Then imax ∈ It, for It as in Algorithm 1.\nProof. This is immediate from the definitions of It and the upper and lower bounds. Suppose imax /∈ It, then there exists j 6= imax such that [`t]j > [ut]imax , and consequently |∇jf(xt)| > |∇imaxf(xt)|.\nTheorem 3.2. Let f : Rn → R be convex and coordinatewise L-smooth, let τUCD, τSCD, τASCD denote the expected one step progress (6) of UCD, SCD and ASCD, respectively, and suppose all methods use the same step-size ruleM. Then\nτUCD(x) ≤ τASCD(x) ≤ τSCD(x) ∀x ∈ Rn . (21)\nProof. By (5) we get τASCD(x) = 12L|I| ∑ i∈I |∇if(x)|\n2, where I denotes the corresponding index set of ASCD when at iterate x. Note that for j /∈ I it must hold that |∇jf(x)|2 ≤ [u]2j < 1|I| ∑ i∈I [`] 2 i ≤ 1|I| ∑ i∈I |∇if(x)| 2 by definition of I.\nObserve that the above theorem holds for all gradient oracles and coordinate update variants, as long as they are used with corresponding quality parameters r (as in (19)) and δij (as in (20)) as part of the algorithm.\nHeuristic variants. Below also propose three heuristic variants of ASCD. For all these variants the active set It can be computed O(n), but the statement of Theorem 3.2 does not apply. These variants only differ from ASCD in the choice of the active set in Algorithm 1:\nu-ASCD: It := arg maxi∈[n][ut]i `-ASCD: It := arg maxi∈[n][`t]i a-ASCD: It := { i ∈ [n] | [ut]i ≥ maxi∈[n][`t]i\n}"
  }, {
    "heading": "4. Approximate Gradient Update",
    "text": "In this section we argue that for a large class of objective functions of interest in machine learning, the change in the gradient along every coordinate direction can be estimated efficiently.\nLemma 4.1. Consider F : Rn → R as in (17) with twice-differentiable f : Rd → R. Then for two iterates xt,xt+1 ∈ Rn of a coordinate descent algorithm, i.e. xt+1 = xt + γteit , there exists a x̃ ∈ Rn on the line segment between xt and xt+1, x̃ ∈ [xt,xt+1] with\n∇iF (xt+1)−∇iF (xt) = γt〈ai,∇2f(Ax̃)ait〉 ∀i 6= it (22) where ai denotes the i-th column of the matrix A.\nProof. For coordinates i 6= it the gradient (or subgradient set) of Ψi([xt]i) does not change. Hence it suffices to calculate the change∇f(xt+1)−∇f(xt). This is detailed in the appendix.\nLeast-Squares with Arbitrary Regularizers. The least squares problem is defined as problem (17) with f(Ax) = 1 2 ‖Ax− b‖ 2 2 for a b ∈ Rd. This function is twice differentiable with∇2f(Ax) = In. Hence (22) reduces to\n∇iF (xt+1)−∇iF (xt) = γt〈ai,ait〉 ∀i 6= it . (23)\nThis formulation gives rise to various gradient oracles (20) for the least square problems. For for i 6= it we easily verify that the condition (20) is satisfied:\n1. g1ij := 〈ai,ait〉; δij = 0, 2. g2ij := max {−‖ai‖ ‖aj‖ ,min {S(i, j), ‖ai‖ ‖aj‖}}; δij = ‖ai‖ ‖aj‖, where S : [n]×[n] denotes a function with the property |S(i, j)− 〈ai,aj〉| ≤ ‖ai‖ ‖aj‖ , ∀i, j ∈ [n] (24) 3. g3ij := 0; δij = ‖ai‖ ‖aj‖, 4. g4ij ∈u.a.r. [−‖ai‖ ‖aj‖ , ‖ai‖ ‖aj‖]; δij = ‖ai‖ ‖aj‖.\nOracle g1 can be used in the rare cases where the dot product matrix is accessible to the optimization algorithm without any extra cost. In this case the updates will all be exact. If this matrix is not available, then the computation of each scalar product takes time O(d). Hence, they cannot be recomputed on the fly, as argued in Section 2.4. In contrast, the oracles g3 and g4 are extremely cheap to compute, but the error bounds are worse. In the numerical experiments in Section 7 we demonstrate that these oracles perform surprisingly well.\nThe oracle g2 can for instance be realized by lowdimensional embeddings, such as given by the JohnsonLindenstrauss lemma (cf. Achlioptas (2003); Matoušek (2008)). By embedding each vector in a lower-dimensional space of dimensionO ( −2 log n ) and computing the scalar products of the embedding in time O(log n), relation (24) is satisfied.\nUpdating the gradient of the active coordinate. So far we only discussed the update of the passive coordinates. For the active coordinate the best strategy depends on the update ruleM from (18). If exact line search is used, then 0 ∈ ∇itf(xt+1). For other update rules we can update the gradient ∇itf(xt+1) with the same gradient oracles as for the other coordinates, however we need also to take into account the change of the gradient of Ψi([xt]i). If Ψi is simple, like for instance in ridge or lasso, the subgradients at the new point can be computed efficiently.\nBounded variation. In many applications the Hessian ∇2f(Ax̃) is not so simple as in the case of square loss. If we assume that the Hessian of f is bounded, i.e. ∇2f(Ax) M · In for a constant M ≥ 0, ∀x ∈ Rn, then it is easy to see that the following holds :\n−M‖ai‖‖aj‖ ≤ 〈ai,∇2f(Ax̃)ait〉 ≤M‖ai‖‖aj‖ .\nUsing this relation, we can define gradient oracles for more general functions, by taking the additional approximation factor M into account. The quality can be improved, if we have access to local bounds on ∇2f(Ax).\nHeuristic variants. By design, ASCD is robust to high errors in the gradient estimations – the steepest descent direction is always contained in the active set. However, instead of using only the very crude oracle g4 to approximate all scalar products, it might be advantageous to compute some scalar products with higher precision. We propose to use a caching technique to compute the scalar products with high precision for all vectors in the active set (and storing a matrix of size O(It × n)). This presumably works well if the active set does not change much over time."
  }, {
    "heading": "5. Extension to Composite Functions",
    "text": "The key ingredients of ASCD are the coordinate-wise upper and lower bounds on the gradient and the definition of the active set It which ensures that the steepest descent direction is always kept and that only provably bad directions are removed from the active set. These ideas can also be generalized to the setting of composite functions (2). We already discussed some popular GS-∗ update rules in the introduction in Section 2.3.\nImplementing ASCD for the GS-s rule is straight forward, and we comment on the GS-r in the appendix in Sec. D.2. Here we exemplary detail the modification for the GS-q rule (16), which turns out to be the most evolved (the same reasoning also applies to the GSL-q rule from (Nutini et al., 2015)). In Algo. 2 we show the construction — based just on approximations of the gradient of the smooth part f — of the active set I. For this we compute upper and lower bounds v,w on miny∈R V (x, y,∇if(x)), such that\n[v]i ≤ min y∈R V (x, y,∇if(x) ≤ [w]i ∀i ∈ [n] . (25)\nThe selection of the active coordinate is then based on these bounds. Similar as in Lemma 3.1 and Theorem 3.2 this set has the property iGS−q ∈ I, and directions are only discarded in such a way that the efficiency of ASCD-q cannot drop below the efficiency of UCD. The proof can be found in the appendix in Section D.1."
  }, {
    "heading": "6. Analysis of Competitive Ratio",
    "text": "In Section 3 we derived in Thm. 3.2 that the one step progress of ASCD is between the bounds on the onestep progress of UCD and SCD. However, we know that the efficiency of the latter two methods can differ much, up to a factor of n. In this section we will argue that in certain cases where SCD performs much better than UCD, ASCD will accelerate as well. To measure this effect, we could for\nAlgorithm 2 Adaptation of ASCD for GS-q rule Input: Gradient estimate g̃, error bounds r. For i ∈ [n] define: compute u.-and l.-bounds [u]i := [g̃]i + [r]i, [`]i := [g̃]i − [r]i [u?]i := arg miny∈R V (x, y, [u]i) minimize the model [`?]i := arg miny∈R V (x, y, [`]i)\ncompute u.-and l. bounds on miny∈R V (x, y,∇if(x)) [ωu]i := V (x, [u\n?]i, [u]i)+max{0, [u?]i([`]i − [u]i)} [ω`]i := V (x, [`\n?]i, [`]i) + max{0, [`?]i([u]i − [`]i)} [v]i := min {V (x, [u?]i, [u]i), V (x, [`?]i, [`]i)} [w]i := min {[ωu]i, [ω`]i,Ψi([x]i)} av(I) := 1|I| ∑ i∈I [w]i compute active set It := arg minI |{I ⊆ [n] | [v]i > av(I),∀i /∈ I}|\ninstance consider the ratio:\n%t := ∣∣{i ∈ It | |∇if(xt)| ≥ 12 ‖∇f(xt)‖∞}∣∣ |It| , (26)\nFor general functions this expression is a bit cumbersome to study, therefore we restrict our discussion to the class of objective functions (11) as introduced in Sec. 2.2. Of course not all real-world objective functions will fall into this class, however this problem class is still very interesting in our study, as we will see in the following, because it will highlight the ability (or disability) of the algorithms to eventually identify the right set of ‘active’ coordinates.\nFor the functions with the structure (11) (and q as in Thm. 2.2), the active set falls into the first s coordinates. Hence it is reasonable to approximate %t by the competitive ratio\nρt := |It ∩ [s]| |It| . (27)\nIt is also reasonable to assume that in the limit, (t → ∞), a constant fraction of the [s] will be contained in the active set It (it might not hold [s] ⊆ It ∀t, as for instance with exact line search the directional derivative vanishes just after the update). In the following theorem we calculate ρt for (t→∞), the proof is given in the appendix. Theorem 6.1. Let f : Rn → R be of the form (11). For indices i /∈ [s] define Ki := {t | i /∈ It, i ∈ It−1}. For j ∈ Ki define T ij := min {t− j | i ∈ Ij+t}, i.e. the number of iterations outside the active set, T i∞ := limt→∞ Ej∈Ki [ T ij | j > k ] , and the average T∞ :=\nEi/∈[s] [ T i∞ ] . If there exists a constant c > 0 such that limt→∞ |[s] ∩ It| = cs, then (with the notation ρ∞ := limt→∞ E [ρt]),\nρ∞ ≥ 2cs\ncs+ n− s− T∞ + √ θ , (28)\nwhere θ ≡ θ := n2 + (c− 1)2s2 + 2n((c− 1)s− T∞) + 2(1 + c)sT∞ + T\n2 ∞. Especially, ρ∞ ≥ 1− n−sT∞ .\nIn Figure 1 we compare the lower bound (28) of the competitive ratio in the limit (t → ∞) with actual measurements of ρt for simulated example with parameters n = 100, s = 10, c = 1 and various T∞ ∈ {50, 100, 400}. We initialized the active set I0 = [s], but we see that the equilibrium is reached quickly."
  }, {
    "heading": "6.1. Estimates of the competitive ratio",
    "text": "Based on this Thm. 6.1, we can now estimate the competitive ratio in various scenarios. On the class (11) it holds c ≈ 1 as we argued before. Hence the competitive ratio (28) just depends on T∞. This quantity measures how many iterations a coordinate j /∈ [s] is in average outside of the active set It. From the lower bound we see that the competitive ratio ρt approaches a constant for (t → ∞) if T∞ = Θ (n), for instance ρ∞ ≥ 0.8 if T∞ ≥ 5n.\nAs an approximation to T∞, we estimate the quantities T j t0 defined in Thm. 6.1. T jt0 denotes the number of iterations it takes until coordinate j enters the active set again, assuming it left the active set at iteration t0 − 1. We estimate T jt0 ≥ T̂ , where T̂ denotes maximum number of iterations such that\nt0+T̂∑ t=t0 γtδiij ≤ 1 s s∑ k=1 ∣∣∣∇kf (xt0+T̂)∣∣∣ ∀j /∈ [s]. (29) For smooth functions, the steps γt = Θ (|∇itf(xt)|) and if we additionally assume that the errors of the gradient oracle are uniformly bounded δij ≤ δ, the sum in (29) simplifies to δ ∑t0+T̂ t=t0 |∇itf(xt)|.\nFor smooth, but not strongly convex function q, the norms of the gradient changes very slowly, with a rate independent of s or n, and we get T̂ = Θ ( 1 δ ) . Hence, the competitive\nratio is constant for δ = Θ (\n1 n\n) .\nFor strongly convex function q, the norm of the gradient decreases linearly, say ‖∇f(xt)‖22 ∝ eκt for κ ≈ 1 s . I.e. it decreases by half after each Θ (s) iterations. Therefore to guarantee T̂ = Θ (n) it needs to hold δ = e−Θ( n s ). This result seems to indicate that the use of ACDM is only\njustified if s is large, for instance s ≥ 14n. Otherwise the convergence on q is too fast, and the gradient approximations are too weak. However, notice that we assumed δ to be an uniform bound on all errors. If the errors have large discrepancy the estimates become much better (this holds for instance on datasets where the norm data vectors differs much, or when caching techniques as mentioned in Sec. 4 are employed)."
  }, {
    "heading": "7. Empirical Observations",
    "text": "In this section we evaluate the empirical performance of ASCD on synthetic and real datasets. We consider the following regularized general linear models:\nmin x∈Rn\n1 2‖Ax− b‖ 2 2 + λ 2 ‖x‖ 2 2 , (30)\nmin x∈Rn\n1 2‖Ax− b‖ 2 2 + λ‖x‖1 , (31)\nthat is, l2-regularized least squares (30) as well as l1regularized linear regression (Lasso) in (31), respectively.\nDatasets. The datasets A ∈ Rd×n in problems (30) and (31) were chosen as follows for our experiments. For the synthetic data, we follow the same generation procedure as described in (Nutini et al., 2015), which generates very sparse data matrices. For completeness, full details of the data generation process are also provided in the appendix in Sec. E. For the synthetic data we choose n = 5000 for problem (31) and n = 1000 for problem (30). Dimension d = 1000 is fixed for both cases. For real datasets, we perform the experimental evaluation on RCV1 (binary,training), which consists of 20, 242 samples, each of dimension 47, 236 (Lewis et al., 2004). We use the un-normalized version with all non-zeros values set to 1 (bag-of-words features).\nGradient oracles and implementation details. On the RCV1 dataset, we approximate the scalar products with the oracle g4 that was introduced in Sec. 4. This oracle is extremely cheap to compute, as the norms ‖ai‖ of the columns of A only need to be computed once. On the synthetic data, we simulate the oracle g2 for various precisions values . For this, we sample a value uniformly at random from the allowed error interval (24). Figs. 2d and 3d show the convergence for different accuracies. For the l1-regularized problems, we used ASCD with the GS-s rule (the experiments in (Nutini et al., 2015) revealed almost identical performance of the different GS-∗ rules). We compare the performance of UCD, SCD and ASCD. We also implement the heuristic version a-ASCD that was introduced in Sec. 3. All algorithm variants use the same step size rule (i.e. the methodM in Algorithm 1). We use exact line search for the experiment in Fig. 3c, for all others we used a fixed step size rule (the convergence is slower\nfor all algorithms, but the different effects of the selection of the active coordinate is more distinctly visible). ASCD is either initialized with the true gradient (Figs. 2a, 2b, 2d, 3c, 3d) or arbitrarely (with error bounds δ =∞) in Figs. 3a and 3b (Fig. 2c compares both initializations). Fig. 2 shows results on the synthetic data, Fig. 3 on the RCV1 dataset. All plots show also the size of the active set It. The plots 3c and 3d are generated on a subspace of RCV1, with 10000 and 5000 randomly chosen columns, respectively.\nHere are the highlights of our experimental study:\n1. No initialization needed. We observe (see e.g. Figs. 2c,3a, 3b) that initialization with the true gradient values is not needed at beginning of the optimization process (the cost of the initialization being as expensive as one epoch of ASCD). Instead, the algorithm performs strong in terms of learning the active set on its own, and the set converges very fast after just one epoch.\n2. High errors toleration. The gradient oracle g4 gives very crude approximations, however the convergence of ASCD is excellent on RCV1 (Fig. 3). Here the size of the true active set is very small (in the order of 0.1% on RCV1) and ASCD is able to identify this set. Fig. 3d shows that almost nothing can be gained from more precise (and more expensive) oracles.\n3. Heuristic a-ASCD performs well. The convergence behavior of ASCD follows theory. For the heuristic version a-ASCD (which computes the active set slightly\nfaster, but Thm. 3.2 does not hold) performs identical to ASCD in practice (cf. Figs. 2, 3), and sometimes slightly better. This is explained by the active set used in ASCD typically being larger than the active set of aASCD (Figs. 2a,2b, 3a, 3b)."
  }, {
    "heading": "8. Concluding Remarks",
    "text": "We proposed ASCD, a novel selection mechanism for the active coordinate in CD methods. Our scheme enjoys three favorable properties: (i) its performance can reach the performance steepest CD — both in theory and practice, (ii) the performance is never worse than uniform CD, (iii) in many important applications, the scheme it can be implemented at no extra cost per iteration.\nASCD calculates the active set in a safe manner, and picks the active coordinate uniformly at random from this smaller set. It seems possible that an adaptive sampling strategy on the active set could boost the performance even further. Here we only study CD methods where a single coordinate gets updated in each iteration. ASCD can immediately also be generalized to block-coordinate descent methods. However, the exact implementation in a distributed setting can be challenging.\nFinally, it is an interesting direction to extend ASCD also to the stochastic gradient descent setting (not only heuristically, but with the same strong guarantees as derived in this paper)."
  }],
  "year": 2017,
  "references": [{
    "title": "Database-friendly random projections: Johnson-lindenstrauss with binary coins",
    "authors": ["Achlioptas", "Dimitris"],
    "venue": "Journal of Computer and System Sciences,",
    "year": 2003
  }, {
    "title": "Even faster accelerated coordinate descent using non-uniform sampling",
    "authors": ["Z Allen-Zhu", "Z Qu", "P Richtarik", "Y. Yuan"],
    "year": 2016
  }, {
    "title": "Convex optimization",
    "authors": ["Boyd", "Stephen P", "Vandenberghe", "Lieven"],
    "year": 2004
  }, {
    "title": "Stochastic Dual Coordinate Ascent with Adaptive Probabilities",
    "authors": ["Csiba", "Dominik", "Qu", "Zheng", "Richtárik", "Peter"],
    "venue": "In ICML 2015 - Proceedings of the 32th International Conference on Machine Learning,",
    "year": 2015
  }, {
    "title": "Siobhan’s problem: The coupon collector revisited",
    "authors": ["Dawkins", "Brian"],
    "venue": "The American Statistician,",
    "year": 1991
  }, {
    "title": "Nearest Neighbor based Greedy Coordinate Descent",
    "authors": ["Dhillon", "Inderjit S", "Ravikumar", "Pradeep", "Tewari", "Ambuj"],
    "venue": "In NIPS 2014 - Advances in Neural Information Processing Systems",
    "year": 2011
  }, {
    "title": "Pathwise coordinate optimization",
    "authors": ["Friedman", "Jerome", "Hastie", "Trevor", "Höfling", "Holger", "Tibshirani", "Robert"],
    "venue": "The Annals of Applied Statistics,",
    "year": 2007
  }, {
    "title": "Regularization Paths for Generalized Linear Models via Coordinate Descent",
    "authors": ["Friedman", "Jerome", "Hastie", "Trevor", "Tibshirani", "Robert"],
    "venue": "Journal of Statistical Software,",
    "year": 2010
  }, {
    "title": "Penalized regressions: The bridge versus the lasso",
    "authors": ["Fu", "Wenjiang J"],
    "venue": "Journal of Computational and Graphical Statistics,",
    "year": 1998
  }, {
    "title": "A Dual Coordinate Descent Method for Large-scale Linear SVM",
    "authors": ["Hsieh", "Cho-Jui", "Chang", "Kai-Wei", "Lin", "Chih-Jen", "Keerthi", "S Sathiya", "S. Sundararajan"],
    "venue": "In the 25th International Conference on Machine Learning,",
    "year": 2008
  }, {
    "title": "Nonnegative matrix factorization based on alternating nonnegativity constrained least squares and active set method",
    "authors": ["Kim", "Hyunsoo", "Park", "Haesun"],
    "venue": "SIAM Journal on Matrix Analysis and Applications,",
    "year": 2008
  }, {
    "title": "Learning the parts of objects by non-negative matrix factorization",
    "authors": ["Lee", "Daniel D", "Seung", "H Sebastian"],
    "year": 1999
  }, {
    "title": "Rcv1: A new benchmark collection for text categorization research",
    "authors": ["Lewis", "David D", "Yang", "Yiming", "Rose", "Tony G", "Li", "Fan"],
    "venue": "J. Mach. Learn. Res.,",
    "year": 2004
  }, {
    "title": "On variants of the johnsonlindenstrauss lemma",
    "authors": ["Matoušek", "Jiřı"],
    "venue": "Random Structures & Algorithms,",
    "year": 2008
  }, {
    "title": "Efficiency of coordinate descent methods on hugescale optimization problems",
    "authors": ["Nesterov", "Yu"],
    "venue": "SIAM Journal on Optimization,",
    "year": 2012
  }, {
    "title": "Efficiency of the accelerated coordinate descent method on structured optimization problems",
    "authors": ["Nesterov", "Yurii", "Stich", "Sebastian U"],
    "venue": "SIAM Journal on Optimization,",
    "year": 2017
  }, {
    "title": "Coordinate Descent Converges Faster with the Gauss-Southwell Rule Than Random Selection",
    "authors": ["Nutini", "Julie", "Schmidt", "Mark W", "Laradji", "Issam H", "Friedlander", "Michael P", "Koepke", "Hoyt A"],
    "venue": "In ICML,",
    "year": 2015
  }, {
    "title": "Adaptive Sampling for Incremental Optimization Using Stochastic Gradient Descent",
    "authors": ["Papa", "Guillaume", "Bianchi", "Pascal", "Clémençon", "Stéphan"],
    "venue": "ALT 2015 - 26th International Conference on Algorithmic Learning Theory, pp",
    "year": 2015
  }, {
    "title": "Coordinate descent with arbitrary sampling i: algorithms and complexity",
    "authors": ["Qu", "Zheng", "Richtárik", "Peter"],
    "venue": "Optimization Methods and Software,",
    "year": 2016
  }, {
    "title": "Parallel coordinate descent methods for big data optimization",
    "authors": ["Richtárik", "Peter", "Takáč", "Martin"],
    "venue": "Mathematical Programming,",
    "year": 2016
  }, {
    "title": "Stochastic Methods for l1-regularized Loss Minimization",
    "authors": ["Shalev-Shwartz", "Shai", "Tewari", "Ambuj"],
    "venue": "JMLR, 12:1865–1892,",
    "year": 2011
  }, {
    "title": "Stochastic Dual Coordinate Ascent Methods for Regularized Loss Minimization",
    "authors": ["Shalev-Shwartz", "Shai", "Zhang", "Tong"],
    "venue": "JMLR, 14:567–599,",
    "year": 2013
  }, {
    "title": "Asymmetric LSH (ALSH) for sublinear time maximum inner product search (MIPS)",
    "authors": ["Shrivastava", "Anshumali", "Li", "Ping"],
    "venue": "In NIPS 2014 - Advances in Neural Information Processing Systems",
    "year": 2014
  }, {
    "title": "A coordinate gradient descent method for nonsmooth separable minimization",
    "authors": ["Tseng", "Paul", "Yun", "Sangwoon"],
    "venue": "Mathematical Programming,",
    "year": 2009
  }, {
    "title": "On the convergence of an active-set method for 1 minimization",
    "authors": ["Wen", "Zaiwen", "Yin", "Wotao", "Zhang", "Hongchao", "Goldfarb", "Donald"],
    "venue": "Optimization Methods and Software,",
    "year": 2012
  }, {
    "title": "Coordinate descent algorithms",
    "authors": ["Wright", "Stephen J"],
    "venue": "Mathematical Programming,",
    "year": 2015
  }, {
    "title": "Coordinate descent algorithms for lasso penalized regression",
    "authors": ["Wu", "Tong Tong", "Lange", "Kenneth"],
    "venue": "Ann. Appl. Stat.,",
    "year": 2008
  }, {
    "title": "Stochastic optimization with importance sampling for regularized loss minimization",
    "authors": ["Zhao", "Peilin", "Zhang", "Tong"],
    "venue": "In Proceedings of the 32nd International Conference on Machine Learning,",
    "year": 2015
  }],
  "id": "SP:f21ad1f4ce3524743a212c70cdddd4b485537bd2",
  "authors": [{
    "name": "Sebastian U. Stich",
    "affiliations": []
  }, {
    "name": "Anant Raj",
    "affiliations": []
  }, {
    "name": "Martin Jaggi",
    "affiliations": []
  }],
  "abstractText": "We propose a new selection rule for the coordinate selection in coordinate descent methods for huge-scale optimization. The efficiency of this novel scheme is provably better than the efficiency of uniformly random selection, and can reach the efficiency of steepest coordinate descent (SCD), enabling an acceleration of a factor of up to n, the number of coordinates. In many practical applications, our scheme can be implemented at no extra cost and computational efficiency very close to the faster uniform selection. Numerical experiments with Lasso and Ridge regression show promising improvements, in line with our theoretical guarantees.",
  "title": "Approximate Steepest Coordinate Descent"
}