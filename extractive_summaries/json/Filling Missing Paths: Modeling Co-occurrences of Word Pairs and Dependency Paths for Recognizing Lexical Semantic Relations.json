{
  "sections": [{
    "text": "Proceedings of NAACL-HLT 2018, pages 1123–1133 New Orleans, Louisiana, June 1 - 6, 2018. c©2018 Association for Computational Linguistics"
  }, {
    "heading": "1 Introduction",
    "text": "The semantic relations between words are important for many natural language processing tasks, such as recognizing textual entailment (Dagan et al., 2010) and question answering (Yang et al., 2017). Moreover, these relations have been also used as features for neural methods in machine translation (Sennrich and Haddow, 2016) and relation extraction (Xu et al., 2015). This type of information is provided by manually-created semantic taxonomies, such as WordNet (Fellbaum, 1998). However, these resources are expensive to expand manually and have limited domain coverage. Thus, the automatic detection of lexicosemantic relations has been studied for several\ndecades. One of the most popular approaches is based on patterns that encode a specific kind of relationship (synonym, hypernym, etc.) between adjacent words. This type of approach is called a pathbased method. Lexico-syntactic patterns between two words provide information on semantic relations. For example, if we see the pattern, “animals such as a dog” in a corpus, we can infer that animal is a hypernym of dog. On the basis of this assumption, Hearst (1992) detected the hypernymy relation of two words from a corpus based on several handcrafted lexico-syntactic patterns, e.g., X such as Y. Snow et al. (2004) used as features indicative dependency paths, in which target word pairs co-occurred, and trained a classifier with data to detect hypernymy relations.\nIn recent studies, Shwartz et al. (2016) proposed a neural path-based model that encoded dependency paths between two words into lowdimensional dense vectors with recurrent neural networks (RNN) for hypernymy detection. This method can prevent sparse feature space and generalize indicative dependency paths for detecting lexico-semantic relations. Their model outperformed the previous state-of-the-art path-based method. Moreover, they demonstrated that these dense path representations capture complementary information with word embeddings that contain individual word features. This was indicated by the experimental result that showed the combination of path representations and word embeddings improved classification performance. In addition, Shwartz and Dagan (2016) showed that the neural path-based approach, combined with word embeddings, is effective in recognizing multiple semantic relations.\nAlthough path-based methods can capture the relational information between two words, these methods can obtain clues only for word pairs that\n1123\nco-occur in a corpus. Even with a very large corpus, it is almost impossible to observe a cooccurrence of arbitrary word pairs. Thus, pathbased methods are still limited in terms of the number of word pairs that are correctly classified.\nTo address this problem, we propose a novel method with modeling P (path|w1, w2) in a neural unsupervised manner, where w1 and w2 are the two target words, and path is a dependency path that can connect the joint co-occurrence of w1 and w2. A neural model of P (path|w1, w2) can generalize co-occurrences of word pairs and dependency paths, and infer plausible dependency paths which connect two words that do not co-occur in a corpus. After unsupervised learning, this model can be used in two ways:\n• Path data augmentation through predicting dependency paths that are most likely to cooccur with a given word pair.\n• Feature extraction of word pairs, capturing the information of dependency paths as contexts where two words co-occur.\nWhile previous supervised path-based methods used only a small portion of a corpus, combining our models makes it possible to use an entire corpus for learning process.\nExperimental results for four common datasets of multiple lexico-semantic relations show that our methods improve the classification performance of supervised neural path-based models."
  }, {
    "heading": "2 Background",
    "text": ""
  }, {
    "heading": "2.1 Supervised Lexical Semantic Relation Detection",
    "text": "Supervised lexical semantic relation detection represents word pairs (w1, w2) as feature vectors v and trains a classifier with these vectors based on training data. For word pair representations v, we can use the distributional information of each word and path information in which two words cooccur.\nSeveral methods exploit word embeddings (Mikolov et al., 2013; Levy and Goldberg, 2014; Pennington et al., 2014) as distributional information. These methods use a combination of each word’s embeddings, such as vector concatenation (Baroni et al., 2012; Roller and Erk, 2016) or vector difference (Roller et al., 2014; Weeds et al., 2014; Vylomova et al., 2016), as word pair representations. While these distributional supervised\nmethods do not require co-occurrences of two words in a sentence, Levy et al. (2015) notes that these methods do not learn the relationships between two words but rather the separate property of each word, i.e., whether or not each word tends to have a target relation.\nIn contrast, supervised path-based methods can capture relational information between two words. These methods represent a word pair as the set of lexico-syntactic paths, which connect two target words in a corpus (Snow et al., 2004). However, these methods suffer from sparse feature space, as they cannot capture the similarity between indicative lexico-syntactic paths, e.g., X is a species of Y and X is a kind of Y."
  }, {
    "heading": "2.2 Neural Path-based Method",
    "text": "A neural path-based method can avoid the sparse feature space of the previous path-based methods (Shwartz et al., 2016; Shwartz and Dagan, 2016). Instead of treating an entire dependency path as a single feature, this model encodes a sequence of edges of a dependency path into a dense vector using a long short-term memory network (LSTM) (Hochreiter and Schmidhuber, 1997).\nA dependency path connecting two words can be extracted from the dependency tree of a sentence. For example, given the sentence “A dog is a mammal,” with X = dog and Y = mammal, the dependency path connecting the two words is X/NOUN/nsubj/> be/VERB/ROOT/- Y/NOUN/attr/<. Each edge of a dependency path is composed of a lemma, part of speech (POS), dependency label, and dependency direction.\nShwartz et al. (2016) represents each edge as the concatenation of its component embeddings:\ne = [vl;vpos;vdep;vdir] (1)\nwhere vl,vpos,vdep,and vdir represent the embedding vectors of the lemma, POS, dependency label, and dependency direction respectively. This edge vector e is an input of the LSTM at each time step. Here, ht, the hidden state at time step t, is abstractly computed as:\nht = LSTM(ht−1, et) (2)\nwhere LSTM computes the current hidden state given the previous hidden state ht−1 and the current input edge vector et along with the LSTM architecture. The final hidden state vector op is\ntreated as the representation of the dependency path p.\nWhen classifying a word pair (w1, w2), the word pair is represented as the average of the dependency path vectors that connect two words in a corpus:\nv(w1,w2) = vpaths(w1,w2)\n= ∑ p∈paths(w1,w2) fp,(w1,w2) · op∑\np∈paths(w1,w2) fp,(w1,w2) (3)\nwhere paths(w1, w2) is the set of dependency paths that connects w1 and w2 in the corpus, and fp,(w1,w2) is the frequency of p in paths(w1, w2). The final output of the network is calculated as follows:\ny = softmax(Wv(w1,w2) + b) (4)\nwhere W ∈ R|c|×d is a linear transformation matrix, b ∈ R|c| is a bias parameter, |c| is the number of the output class, and d is the size of v(w1,w2).\nThis neural path-based model can be combined with distributional methods. Shwartz et al. (2016) concatenated vpaths(w1,w2) to the word embeddings of w1 and w2, redefining v(w1,w2) as:\nv(w1,w2) = [vw1 ;vpaths(w1,w2);vw2 ] (5)\nwhere vw1 and vw2 are word embeddings of w1 and w2, respectively. This integrated model, named LexNET, exploits both path information and distributional information, and has high generalization performance for lexical semantic relation detection."
  }, {
    "heading": "2.3 Missing Path Problem",
    "text": "All path-based methods, including the neural ones, suffer from data sparseness as they depend on word pair co-occurrences in a corpus. However, we cannot observe all co-occurrences of semantically related words even with a very large corpus because of Zipf’s law, which states that the frequency distribution of words has a long tail; in other words, most words occur very infrequently (Hanks, 2009). In this paper, we refer to this phenomenon as the missing path problem.\nThis missing path problem leads to the fact that path-based models cannot find any clues for two words that do not co-occur. Thus, in the neural path-based method, paths(w1, w2) for these word pairs is padded with an empty path, like UNK-lemma/UNK-POS/UNK-dep/UNK-dir.\nHowever, this process makes path-based classifiers unable to distinguish between semanticallyrelated pairs with no co-occurrences and those that have no semantic relation.\nIn an attempt to solve this problem, Necsulescu et al. (2015) proposed a method that used a graph representation of a corpus. In this graph, words and dependency relations were denoted as nodes and labeled directed edges, respectively. From this graph representation, paths linking two target words can be extracted through bridging words, even if the two words do not co-occur in the corpus. They represent word pairs as the sets of paths linking word pairs on the graph and train a support vector machine classifier with training data, thereby improving recall. However, the authors reported that this method still suffered from data sparseness.\nIn this paper, we address this missing path problem, which generally restricts path-based methods, by neural modeling P (path|w1, w2)."
  }, {
    "heading": "3 Method",
    "text": "We present a novel method for modeling P (path|w1, w2). The purpose of this method is to address the missing path problem by generalizing the co-occurrences of word pairs and dependency paths. To model P (path|w1, w2), we used the context-prediction approach (Collobert and Weston, 2008; Mikolov et al., 2013; Levy and Goldberg, 2014; Pennington et al., 2014), which is a widely used method for learning word embeddings. In our proposed method, word pairs and dependency paths are represented as embeddings that are updated with unsupervised learning through predicting path from w1 and w2 (Section 3.1).\nAfter the learning process, our model can be used to (1) augment path data by predicting the plausibility of the co-occurrence of two words and a dependency path (Section 3.2); and to (2) extract useful features from word pairs, which reflect the information of co-occurring dependency paths (Section 3.3)."
  }, {
    "heading": "3.1 Unsupervised Learning",
    "text": "There are many possible ways to model P (path|w1, w2). In this paper, we present a straightforward and efficient architecture, similar to the skip-gram with negative sampling (Mikolov et al., 2013).\nX/NOUN/nsubj/>be/VERB/ROOT/-Y/NOUN/attr/< <latexit sha1_base64=\"E1oZqr/5jwif/GwMlUhFAQrUeDM=\">AAACt3ichVFNS+NQFD1mZvzojLaOG8GNTFFmY3MjgjqIiCK4slptraiUJL7a2DTJJK9FLf4B/4CCKwdciD/A3Wxc6B+YhT9hmKWCGxdzmwZERb3h5Z137j33vcM1PNsKJNFNi/Lh46fWtvaO2OcvnV3xRPfXXOBWfVNkTdd2/byhB8K2HJGVlrRF3vOFXjFssWKUZxr5lZrwA8t1luWuJzYq+pZjFS1Tl0wVEsPrUuxIKet5dT6dnVedoGpsq5OGUHOzmWk1k04vq0OrzZwupa9O7BcSSUpRGP0vgRaBJKJYcBMXWMcmXJioogIBB5KxDR0Bf2vQQPCY20CdOZ+RFeYF9hFjbZWrBFfozJb5v8WntYh1+NzoGYRqk2+xefms7McA/aEzuqVrOqe/9PBqr3rYo/GWXd6NplZ4hfhB79L9u6oK7xKlR9UbCoOr3/YkUcRY6MVib17INFyazf61vcPbpR+Zgfog/aJ/7O+EbuiSHTq1O/N0UWSOEeMBac/H8RLkhlMapbTFkeTUdDSqdvThG77zPEYxhTksIMv3HuE3rnCtjCsFpaiUmqVKS6TpwZNQfv4Hd26iKQ==</latexit><latexit sha1_base64=\"E1oZqr/5jwif/GwMlUhFAQrUeDM=\">AAACt3ichVFNS+NQFD1mZvzojLaOG8GNTFFmY3MjgjqIiCK4slptraiUJL7a2DTJJK9FLf4B/4CCKwdciD/A3Wxc6B+YhT9hmKWCGxdzmwZERb3h5Z137j33vcM1PNsKJNFNi/Lh46fWtvaO2OcvnV3xRPfXXOBWfVNkTdd2/byhB8K2HJGVlrRF3vOFXjFssWKUZxr5lZrwA8t1luWuJzYq+pZjFS1Tl0wVEsPrUuxIKet5dT6dnVedoGpsq5OGUHOzmWk1k04vq0OrzZwupa9O7BcSSUpRGP0vgRaBJKJYcBMXWMcmXJioogIBB5KxDR0Bf2vQQPCY20CdOZ+RFeYF9hFjbZWrBFfozJb5v8WntYh1+NzoGYRqk2+xefms7McA/aEzuqVrOqe/9PBqr3rYo/GWXd6NplZ4hfhB79L9u6oK7xKlR9UbCoOr3/YkUcRY6MVib17INFyazf61vcPbpR+Zgfog/aJ/7O+EbuiSHTq1O/N0UWSOEeMBac/H8RLkhlMapbTFkeTUdDSqdvThG77zPEYxhTksIMv3HuE3rnCtjCsFpaiUmqVKS6TpwZNQfv4Hd26iKQ==</latexit><latexit sha1_base64=\"E1oZqr/5jwif/GwMlUhFAQrUeDM=\">AAACt3ichVFNS+NQFD1mZvzojLaOG8GNTFFmY3MjgjqIiCK4slptraiUJL7a2DTJJK9FLf4B/4CCKwdciD/A3Wxc6B+YhT9hmKWCGxdzmwZERb3h5Z137j33vcM1PNsKJNFNi/Lh46fWtvaO2OcvnV3xRPfXXOBWfVNkTdd2/byhB8K2HJGVlrRF3vOFXjFssWKUZxr5lZrwA8t1luWuJzYq+pZjFS1Tl0wVEsPrUuxIKet5dT6dnVedoGpsq5OGUHOzmWk1k04vq0OrzZwupa9O7BcSSUpRGP0vgRaBJKJYcBMXWMcmXJioogIBB5KxDR0Bf2vQQPCY20CdOZ+RFeYF9hFjbZWrBFfozJb5v8WntYh1+NzoGYRqk2+xefms7McA/aEzuqVrOqe/9PBqr3rYo/GWXd6NplZ4hfhB79L9u6oK7xKlR9UbCoOr3/YkUcRY6MVib17INFyazf61vcPbpR+Zgfog/aJ/7O+EbuiSHTq1O/N0UWSOEeMBac/H8RLkhlMapbTFkeTUdDSqdvThG77zPEYxhTksIMv3HuE3rnCtjCsFpaiUmqVKS6TpwZNQfv4Hd26iKQ==</latexit><latexit sha1_base64=\"dO1RVWgbv0QBXFnWGIM/DJuxBX8=\">AAACdXichVG9TsJQGD1UVEQU3ExciARjHMhXHTROJi6O/MhPgoS05YINpW3aQoLEF2B1cHDSxMH4AD6Aiy/gwCMYR0xcHPwoJEaJ+jXtPffc73y3J0e1Dd31iAYBaSY4OzcfWggvRsJLy9FYpOBabUcTec0yLKekKq4wdFPkPd0zRMl2hNJSDVFUm4ej82JHOK5umcde1xaVltIw9bquKR5T6WosQSnyKz4N5AlIYFJW7AEnqMGChjZaEDDhMTagwOWnDBkEm7kKesw5jHT/XOAcYda2uUtwh8Jsk78N3pUnrMn70UzXV2t8i8Gvw8o4kvRMdzSkJ7qnF/r4dVbPnzH6ly6v6lgr7Gq0v5p7/1fV4tXD6ZfqD4XK3X978lDHnu9FZ2+2z4xcauP5nbPLYW4/m+xt0A29sr9rGtAjOzQ7b9ptRmSvEOZ85J9pTIPCdkqmlJwhhLCGdWxyDLs4wBHSyPN1NfRxIQWlLUke5ygFJoGu4FtJO59jaI2O</latexit><latexit sha1_base64=\"gm4KyDN5ykT3iI6S7uQ6SLnEvr0=\">AAACrHichVFNLwNRFD3Gd320rCQ2QoiNzh0bHxERIrFSSquCNDPjlWE6M5l5bdD4A/4AiRWJhfgBdjYW/AELP0EsSWws3E6bCII7efPuO/ee+97JMTzbCiTRY41SW1ff0NjUHGlpbWuPxjpa04Fb8E2RMl3b9TOGHgjbckRKWtIWGc8Xet6wxYqxO1OurxSFH1iusyz3PbGR17ccK2eZumQoGxtel2JPSlnKqPOJ1LzqBAVjR500hJqeTU6ryURiWR1ardR0KX114jAb66M4hdHzM9GqSR+qseDGrrGOTbgwUUAeAg4k5zZ0BPytQQPBY2wDJcZ8zqywLnCICHML3CW4Q2d0l/9bfFqrog6fyzODkG3yLTYvn5k96KcHuqQXuqcreqL3X2eVwhnlt+zzblS4wstGj7qW3v5l5XmX2P5k/cEwuPtvTRI5jIZaLNbmhUhZpVmZXzw4flkaT/aXBuicnlnfGT3SLSt0iq/mxaJIniLCBmnf7fiZpIfjGsW1RUITutGLQbZhBFOYwwJSfN0JbnCHe2VMySq5ipVKTdXTTnwJZfsDeRuhBg==</latexit><latexit sha1_base64=\"gm4KyDN5ykT3iI6S7uQ6SLnEvr0=\">AAACrHichVFNLwNRFD3Gd320rCQ2QoiNzh0bHxERIrFSSquCNDPjlWE6M5l5bdD4A/4AiRWJhfgBdjYW/AELP0EsSWws3E6bCII7efPuO/ee+97JMTzbCiTRY41SW1ff0NjUHGlpbWuPxjpa04Fb8E2RMl3b9TOGHgjbckRKWtIWGc8Xet6wxYqxO1OurxSFH1iusyz3PbGR17ccK2eZumQoGxtel2JPSlnKqPOJ1LzqBAVjR500hJqeTU6ryURiWR1ardR0KX114jAb66M4hdHzM9GqSR+qseDGrrGOTbgwUUAeAg4k5zZ0BPytQQPBY2wDJcZ8zqywLnCICHML3CW4Q2d0l/9bfFqrog6fyzODkG3yLTYvn5k96KcHuqQXuqcreqL3X2eVwhnlt+zzblS4wstGj7qW3v5l5XmX2P5k/cEwuPtvTRI5jIZaLNbmhUhZpVmZXzw4flkaT/aXBuicnlnfGT3SLSt0iq/mxaJIniLCBmnf7fiZpIfjGsW1RUITutGLQbZhBFOYwwJSfN0JbnCHe2VMySq5ipVKTdXTTnwJZfsDeRuhBg==</latexit><latexit sha1_base64=\"yO51ddTgyJig+DNKyqMB3pN8+sQ=\">AAACt3ichVFNS+NQFD1GHbXjjFU3ghuZoriZ5saNH4iIIriy2tpaaaUk8VWjaRKT16IW/4B/QGFWI7iQ+QGzm40L+wdm4U8Qlw7MxoW3aUBmRL3h5Z137j33vcM1PNsKJNFtm9Le0fmhq7sn9rH30+e+eP9ALnCrvimypmu7ft7QA2FbjshKS9oi7/lCrxi22DD2F5v5jZrwA8t11uWRJ7Yq+o5jlS1Tl0yV4hNFKQ6llPW8upLKrqhOUDX21DlDqLml9IKaTqXW1a+brZwupa/OnpTiCUpSGCMvgRaBBKJYdeM/UcQ2XJioogIBB5KxDR0BfwVoIHjMbaHOnM/ICvMCJ4ixtspVgit0Zvf5v8OnQsQ6fG72DEK1ybfYvHxWjmCUftMVPVCDftAdPb7aqx72aL7liHejpRVeqe90KPP3XVWFd4ndZ9UbCoOr3/YkUcZU6MVib17INF2arf6147OHzEx6tD5GF3TP/r7TLV2zQ6f2x7xcE+lviPGAtP/H8RLkJpIaJbU1SswvRKPqxjC+YJznMYl5LGMVWb73HL9wg4YyrZSUsrLbKlXaIs0g/gnl4Al2LqIl</latexit><latexit sha1_base64=\"E1oZqr/5jwif/GwMlUhFAQrUeDM=\">AAACt3ichVFNS+NQFD1mZvzojLaOG8GNTFFmY3MjgjqIiCK4slptraiUJL7a2DTJJK9FLf4B/4CCKwdciD/A3Wxc6B+YhT9hmKWCGxdzmwZERb3h5Z137j33vcM1PNsKJNFNi/Lh46fWtvaO2OcvnV3xRPfXXOBWfVNkTdd2/byhB8K2HJGVlrRF3vOFXjFssWKUZxr5lZrwA8t1luWuJzYq+pZjFS1Tl0wVEsPrUuxIKet5dT6dnVedoGpsq5OGUHOzmWk1k04vq0OrzZwupa9O7BcSSUpRGP0vgRaBJKJYcBMXWMcmXJioogIBB5KxDR0Bf2vQQPCY20CdOZ+RFeYF9hFjbZWrBFfozJb5v8WntYh1+NzoGYRqk2+xefms7McA/aEzuqVrOqe/9PBqr3rYo/GWXd6NplZ4hfhB79L9u6oK7xKlR9UbCoOr3/YkUcRY6MVib17INFyazf61vcPbpR+Zgfog/aJ/7O+EbuiSHTq1O/N0UWSOEeMBac/H8RLkhlMapbTFkeTUdDSqdvThG77zPEYxhTksIMv3HuE3rnCtjCsFpaiUmqVKS6TpwZNQfv4Hd26iKQ==</latexit><latexit sha1_base64=\"E1oZqr/5jwif/GwMlUhFAQrUeDM=\">AAACt3ichVFNS+NQFD1mZvzojLaOG8GNTFFmY3MjgjqIiCK4slptraiUJL7a2DTJJK9FLf4B/4CCKwdciD/A3Wxc6B+YhT9hmKWCGxdzmwZERb3h5Z137j33vcM1PNsKJNFNi/Lh46fWtvaO2OcvnV3xRPfXXOBWfVNkTdd2/byhB8K2HJGVlrRF3vOFXjFssWKUZxr5lZrwA8t1luWuJzYq+pZjFS1Tl0wVEsPrUuxIKet5dT6dnVedoGpsq5OGUHOzmWk1k04vq0OrzZwupa9O7BcSSUpRGP0vgRaBJKJYcBMXWMcmXJioogIBB5KxDR0Bf2vQQPCY20CdOZ+RFeYF9hFjbZWrBFfozJb5v8WntYh1+NzoGYRqk2+xefms7McA/aEzuqVrOqe/9PBqr3rYo/GWXd6NplZ4hfhB79L9u6oK7xKlR9UbCoOr3/YkUcRY6MVib17INFyazf61vcPbpR+Zgfog/aJ/7O+EbuiSHTq1O/N0UWSOEeMBac/H8RLkhlMapbTFkeTUdDSqdvThG77zPEYxhTksIMv3HuE3rnCtjCsFpaiUmqVKS6TpwZNQfv4Hd26iKQ==</latexit><latexit sha1_base64=\"E1oZqr/5jwif/GwMlUhFAQrUeDM=\">AAACt3ichVFNS+NQFD1mZvzojLaOG8GNTFFmY3MjgjqIiCK4slptraiUJL7a2DTJJK9FLf4B/4CCKwdciD/A3Wxc6B+YhT9hmKWCGxdzmwZERb3h5Z137j33vcM1PNsKJNFNi/Lh46fWtvaO2OcvnV3xRPfXXOBWfVNkTdd2/byhB8K2HJGVlrRF3vOFXjFssWKUZxr5lZrwA8t1luWuJzYq+pZjFS1Tl0wVEsPrUuxIKet5dT6dnVedoGpsq5OGUHOzmWk1k04vq0OrzZwupa9O7BcSSUpRGP0vgRaBJKJYcBMXWMcmXJioogIBB5KxDR0Bf2vQQPCY20CdOZ+RFeYF9hFjbZWrBFfozJb5v8WntYh1+NzoGYRqk2+xefms7McA/aEzuqVrOqe/9PBqr3rYo/GWXd6NplZ4hfhB79L9u6oK7xKlR9UbCoOr3/YkUcRY6MVib17INFyazf61vcPbpR+Zgfog/aJ/7O+EbuiSHTq1O/N0UWSOEeMBac/H8RLkhlMapbTFkeTUdDSqdvThG77zPEYxhTksIMv3HuE3rnCtjCsFpaiUmqVKS6TpwZNQfv4Hd26iKQ==</latexit><latexit sha1_base64=\"E1oZqr/5jwif/GwMlUhFAQrUeDM=\">AAACt3ichVFNS+NQFD1mZvzojLaOG8GNTFFmY3MjgjqIiCK4slptraiUJL7a2DTJJK9FLf4B/4CCKwdciD/A3Wxc6B+YhT9hmKWCGxdzmwZERb3h5Z137j33vcM1PNsKJNFNi/Lh46fWtvaO2OcvnV3xRPfXXOBWfVNkTdd2/byhB8K2HJGVlrRF3vOFXjFssWKUZxr5lZrwA8t1luWuJzYq+pZjFS1Tl0wVEsPrUuxIKet5dT6dnVedoGpsq5OGUHOzmWk1k04vq0OrzZwupa9O7BcSSUpRGP0vgRaBJKJYcBMXWMcmXJioogIBB5KxDR0Bf2vQQPCY20CdOZ+RFeYF9hFjbZWrBFfozJb5v8WntYh1+NzoGYRqk2+xefms7McA/aEzuqVrOqe/9PBqr3rYo/GWXd6NplZ4hfhB79L9u6oK7xKlR9UbCoOr3/YkUcRY6MVib17INFyazf61vcPbpR+Zgfog/aJ/7O+EbuiSHTq1O/N0UWSOEeMBac/H8RLkhlMapbTFkeTUdDSqdvThG77zPEYxhTksIMv3HuE3rnCtjCsFpaiUmqVKS6TpwZNQfv4Hd26iKQ==</latexit><latexit sha1_base64=\"E1oZqr/5jwif/GwMlUhFAQrUeDM=\">AAACt3ichVFNS+NQFD1mZvzojLaOG8GNTFFmY3MjgjqIiCK4slptraiUJL7a2DTJJK9FLf4B/4CCKwdciD/A3Wxc6B+YhT9hmKWCGxdzmwZERb3h5Z137j33vcM1PNsKJNFNi/Lh46fWtvaO2OcvnV3xRPfXXOBWfVNkTdd2/byhB8K2HJGVlrRF3vOFXjFssWKUZxr5lZrwA8t1luWuJzYq+pZjFS1Tl0wVEsPrUuxIKet5dT6dnVedoGpsq5OGUHOzmWk1k04vq0OrzZwupa9O7BcSSUpRGP0vgRaBJKJYcBMXWMcmXJioogIBB5KxDR0Bf2vQQPCY20CdOZ+RFeYF9hFjbZWrBFfozJb5v8WntYh1+NzoGYRqk2+xefms7McA/aEzuqVrOqe/9PBqr3rYo/GWXd6NplZ4hfhB79L9u6oK7xKlR9UbCoOr3/YkUcRY6MVib17INFyazf61vcPbpR+Zgfog/aJ/7O+EbuiSHTq1O/N0UWSOEeMBac/H8RLkhlMapbTFkeTUdDSqdvThG77zPEYxhTksIMv3HuE3rnCtjCsFpaiUmqVKS6TpwZNQfv4Hd26iKQ==</latexit><latexit sha1_base64=\"E1oZqr/5jwif/GwMlUhFAQrUeDM=\">AAACt3ichVFNS+NQFD1mZvzojLaOG8GNTFFmY3MjgjqIiCK4slptraiUJL7a2DTJJK9FLf4B/4CCKwdciD/A3Wxc6B+YhT9hmKWCGxdzmwZERb3h5Z137j33vcM1PNsKJNFNi/Lh46fWtvaO2OcvnV3xRPfXXOBWfVNkTdd2/byhB8K2HJGVlrRF3vOFXjFssWKUZxr5lZrwA8t1luWuJzYq+pZjFS1Tl0wVEsPrUuxIKet5dT6dnVedoGpsq5OGUHOzmWk1k04vq0OrzZwupa9O7BcSSUpRGP0vgRaBJKJYcBMXWMcmXJioogIBB5KxDR0Bf2vQQPCY20CdOZ+RFeYF9hFjbZWrBFfozJb5v8WntYh1+NzoGYRqk2+xefms7McA/aEzuqVrOqe/9PBqr3rYo/GWXd6NplZ4hfhB79L9u6oK7xKlR9UbCoOr3/YkUcRY6MVib17INFyazf61vcPbpR+Zgfog/aJ/7O+EbuiSHTq1O/N0UWSOEeMBac/H8RLkhlMapbTFkeTUdDSqdvThG77zPEYxhTksIMv3HuE3rnCtjCsFpaiUmqVKS6TpwZNQfv4Hd26iKQ==</latexit> X/NOUN/nsubj/>use/VERB/ROOT/-Y/NOUN/dobj/< <latexit sha1_base64=\"mXtEx9P6NC/iCWUB9W39xWtgAWk=\">AAACuHichVHBShtRFD2Otmpaa9SN0I00pLgxc6cKioiIpeDKaExiRCWdGZ/p08nMMPMm1AZ/oD9QiisFF6Uf0GUX3dgP6CKfUFxGcOOiN5OBUkV7hzfvvHPvue8druU7MlRErR6tt+/R4/6BwdSTp0PPhtMjo+XQiwJblGzP8YKKZYbCka4oKakcUfEDYdYtR2xah687+c2GCELpuUV15Ivdullz5b60TcVUNT29o8R7pVSzoq/mS6u6G0bWgb4YhUIvvyks64V8vqhPbXWTex7nFo6r6QzlKI6Ju8BIQAZJrHnpb9jBHjzYiFCHgAvF2IGJkL9tGCD4zO2iyVzASMZ5gWOkWBtxleAKk9lD/tf4tJ2wLp87PcNYbfMtDq+AlRPI0i/6Qm26oK/0m27u7dWMe3TecsS71dUKvzr8cXzj+r+qOu8K7/6qHlBYXP2wJ4V9zMVeJHvzY6bj0u72b3z41N6YL2SbL+mMLtnfKbXoBzt0G1f2+boonCDFAzJuj+MuKL/KGZQz1mcyS8vJqAbwHC8wyfOYxRJWsIYS3/sZ33GBn9q89larabJbqvUkmjH8E1rwB5T3op0=</latexit><latexit sha1_base64=\"mXtEx9P6NC/iCWUB9W39xWtgAWk=\">AAACuHichVHBShtRFD2Otmpaa9SN0I00pLgxc6cKioiIpeDKaExiRCWdGZ/p08nMMPMm1AZ/oD9QiisFF6Uf0GUX3dgP6CKfUFxGcOOiN5OBUkV7hzfvvHPvue8druU7MlRErR6tt+/R4/6BwdSTp0PPhtMjo+XQiwJblGzP8YKKZYbCka4oKakcUfEDYdYtR2xah687+c2GCELpuUV15Ivdullz5b60TcVUNT29o8R7pVSzoq/mS6u6G0bWgb4YhUIvvyks64V8vqhPbXWTex7nFo6r6QzlKI6Ju8BIQAZJrHnpb9jBHjzYiFCHgAvF2IGJkL9tGCD4zO2iyVzASMZ5gWOkWBtxleAKk9lD/tf4tJ2wLp87PcNYbfMtDq+AlRPI0i/6Qm26oK/0m27u7dWMe3TecsS71dUKvzr8cXzj+r+qOu8K7/6qHlBYXP2wJ4V9zMVeJHvzY6bj0u72b3z41N6YL2SbL+mMLtnfKbXoBzt0G1f2+boonCDFAzJuj+MuKL/KGZQz1mcyS8vJqAbwHC8wyfOYxRJWsIYS3/sZ33GBn9q89larabJbqvUkmjH8E1rwB5T3op0=</latexit><latexit sha1_base64=\"mXtEx9P6NC/iCWUB9W39xWtgAWk=\">AAACuHichVHBShtRFD2Otmpaa9SN0I00pLgxc6cKioiIpeDKaExiRCWdGZ/p08nMMPMm1AZ/oD9QiisFF6Uf0GUX3dgP6CKfUFxGcOOiN5OBUkV7hzfvvHPvue8druU7MlRErR6tt+/R4/6BwdSTp0PPhtMjo+XQiwJblGzP8YKKZYbCka4oKakcUfEDYdYtR2xah687+c2GCELpuUV15Ivdullz5b60TcVUNT29o8R7pVSzoq/mS6u6G0bWgb4YhUIvvyks64V8vqhPbXWTex7nFo6r6QzlKI6Ju8BIQAZJrHnpb9jBHjzYiFCHgAvF2IGJkL9tGCD4zO2iyVzASMZ5gWOkWBtxleAKk9lD/tf4tJ2wLp87PcNYbfMtDq+AlRPI0i/6Qm26oK/0m27u7dWMe3TecsS71dUKvzr8cXzj+r+qOu8K7/6qHlBYXP2wJ4V9zMVeJHvzY6bj0u72b3z41N6YL2SbL+mMLtnfKbXoBzt0G1f2+boonCDFAzJuj+MuKL/KGZQz1mcyS8vJqAbwHC8wyfOYxRJWsIYS3/sZ33GBn9q89larabJbqvUkmjH8E1rwB5T3op0=</latexit><latexit sha1_base64=\"mXtEx9P6NC/iCWUB9W39xWtgAWk=\">AAACuHichVHBShtRFD2Otmpaa9SN0I00pLgxc6cKioiIpeDKaExiRCWdGZ/p08nMMPMm1AZ/oD9QiisFF6Uf0GUX3dgP6CKfUFxGcOOiN5OBUkV7hzfvvHPvue8druU7MlRErR6tt+/R4/6BwdSTp0PPhtMjo+XQiwJblGzP8YKKZYbCka4oKakcUfEDYdYtR2xah687+c2GCELpuUV15Ivdullz5b60TcVUNT29o8R7pVSzoq/mS6u6G0bWgb4YhUIvvyks64V8vqhPbXWTex7nFo6r6QzlKI6Ju8BIQAZJrHnpb9jBHjzYiFCHgAvF2IGJkL9tGCD4zO2iyVzASMZ5gWOkWBtxleAKk9lD/tf4tJ2wLp87PcNYbfMtDq+AlRPI0i/6Qm26oK/0m27u7dWMe3TecsS71dUKvzr8cXzj+r+qOu8K7/6qHlBYXP2wJ4V9zMVeJHvzY6bj0u72b3z41N6YL2SbL+mMLtnfKbXoBzt0G1f2+boonCDFAzJuj+MuKL/KGZQz1mcyS8vJqAbwHC8wyfOYxRJWsIYS3/sZ33GBn9q89larabJbqvUkmjH8E1rwB5T3op0=</latexit>\nFigure 1 depicts our network structure, which is described below.\nData and Network Architecture We are able to extract many triples (w1, w2, path) from a corpus after dependency parsing. We denote a set of these triples as D. These triples are the instances used for the unsupervised learning of P (path|w1, w2). Given (w1, w2, path), our model learns through predicting path fromw1 and w2.\nWe encode word pairs into dense vectors as follows:\nh(w1,w2) = tanh(W1[vw1 ;vw2 ] + b1) (6)\nh̃(w1,w2) = tanh(W2h(w1,w2) + b2) (7)\nwhere [vw1 ;vw2 ] is the concatenation of the word embeddings of w1 and w2; W1, b1, W2, and b2 are the parameter matrices and bias parameters of the two linear transformations; and h̃(w1,w2) is the representation of the word pair.\nWe associate each path with the embedding vpath, initialized randomly. While we use a simple way to represent dependency paths in this paper, LSTM can be used to encode each path in the way described in Section 2.2. If LSTM is used, learning time increases but similarities among paths will be captured.\nObjective We used the negative sampling objective for training (Mikolov et al., 2013). Given the word pair\nrepresentations h̃(w1,w2) and the dependency path representations vpath, our model was trained to distinguish real (w1, w2, path) triples from incorrect ones. The log-likelihood objective is as follows:\nL = ∑\n(w1,w2,path)∈D log σ(vpath · h̃(w1,w2))\n+ ∑\n(w1,w2,path′)∈D′ log σ(−vpath′ · h̃(w1,w2)) (8)\nwhere, D′ is the set of randomly generated negative samples. We constructed n triples (w1, w2, path\n′) for each (w1, w2, path) ∈ D, where n is a hyperparameter and each path′ is drawn according to its unigram distribution raised to the 3/4 power. The objective L was maximized using the stochastic gradient descent algorithm."
  }, {
    "heading": "3.2 Path Data Augmentation",
    "text": "After the unsupervised learning described above, our model of P (path|w1, w2) can assign the plausibility score σ(vpath · h̃(w1,w2)) to the cooccurrences of a word pair and a dependency path. We can then append the plausible dependency paths to paths(w1, w2), the set of dependency paths that connectsw1 andw2 in the corpus, based on these scores.\nWe calculate the score of each dependency path given (X = w1, Y = w2) and append the k dependency paths with the highest scores to paths(w1, w2), where k is a hyperparameter. We perform the same process given (X = w2, Y = w1) with the exception of swapping the X and Y in the dependency paths to be appended. As a result, we add 2k dependency paths to the set of dependency paths for each word pair. Through this data augmentation, we can obtain plausible dependency paths even when word pairs do not co-occur in the corpus. Note that we retain the empty path indicators of paths(w1, w2), as we believe that this information contributes to classifying two unrelated words."
  }, {
    "heading": "3.3 Feature Extractor of Word Pairs",
    "text": "Our model can be used as a feature extractor of word pairs. We can exploit h̃(w1,w2) to represent the word pair (w1, w2). This representation captures the information of co-occurrence dependency paths of (w1, w2) in a generalized fashion. Thus, h̃(w1,w2) is used to construct the pseudo-path representation vp−paths(w1,w2). With our model, we represent the word pair (w1, w2) as\nfollows:\nvp−paths(w1,w2) = [h̃(w1,w2); h̃(w2,w1)] (9)\nThis representation can be used for word pair classification tasks, such as lexical semantic relation detection."
  }, {
    "heading": "4 Experiment",
    "text": "In this section, we examine how our method improves path-based models on several datasets for recognizing lexical semantic relations. In this paper, we focus on major noun relations, such as hypernymy, co-hypernymy, and meronymy."
  }, {
    "heading": "4.1 Dataset",
    "text": "We relied on the datasets used in Shwartz and Dagan (2016); K&H+N (Necsulescu et al., 2015). BLESS (Baroni and Lenci, 2011), EVALution (Santus et al., 2015), and ROOT09 (Santus et al., 2016). These datasets were constructed with knowledge resources (e.g., WordNet, Wikipedia), crowd-sourcing, or both. We used noun pair instances of these datasets.1 Table 1 displays the relations in each dataset used in our experiments. Note that we removed the two relations Entails and MemberOf with few instances from EVALution following Shwartz and Dagan (2016). For data splitting, we used the presplitted train/val/test sets from Shwartz and Dagan (2016) after removing all but the noun pairs from each set."
  }, {
    "heading": "4.2 Corpus and Dependency Parsing",
    "text": "For path-based methods, we used the June 2017 Wikipedia dump as a corpus and extracted (w1, w2, path) triples of noun pairs using the dependency parser of spaCy2 to construct D. In this process, w1 and w2 were lemmatized with spaCy. We only used the dependency paths which oc-\n1We focused only noun pairs to shorten the unsupervised learning time, though this restriction is not necessary for our methods and the unsupervised learning is still tractable.\n2https://spacy.io\ncurred at least five times following the implementation of Shwartz and Dagan (2016).3\nTable 2 displays the number of instances and the proportion of the instances for which at least one dependency path was obtained."
  }, {
    "heading": "4.3 Baseline",
    "text": "We conducted experiments with three neural pathbased methods. The implementation details below follow those in Shwartz and Dagan (2016). We implemented all models using Chainer.4\nNeural Path-Based Model (NPB). We implemented and trained the neural path-based model described in Section 2.2. We used the two-layer LSTM with 60-dimensional hidden units. An input vector was composed of embedding vectors of the lemma (50 dims), POS (4 dims), dependency label (5 dims), and dependency direction (1 dim). Regularization was applied by a dropout on each of the components embeddings (Iyyer et al., 2015; Kiperwasser and Goldberg, 2016).\nLexNET. We implemented and trained the integrated model LexNET as described in Section 2.2. The LSTM details are the same as in the NPB model.\nLexNET h. This model, a variant of LexNET, has an additional hidden layer between the output layer and v(w1,w2) of Equation (5). Because of this additional hidden layer, this model can take into account the interaction of the path information\n3https://github.com/vered1986/LexNET 4https://chainer.org\nand distributional information of two word embeddings. The size of the additional hidden layer was set to 60.\nFollowing Shwartz and Dagan (2016), we optimized each model using Adam (whose learning rate is 0.001) while tuning the dropout rate dr among {0.0, 0.2, 0.4} on the validation set. The minibatch size was set to 100.\nWe initialized the lemma embeddings of LSTM and concatenated the word embeddings of LexNET with the pretrained 50-dimensional GloVe vector.5 Training was stopped if performance on the validation set did not improve for seven epochs, and the best model for test evaluation was selected based on the score of the validation set."
  }, {
    "heading": "4.4 Our Method",
    "text": "We implemented and trained our model of P (path|w1, w2), described in Section 3.1, as follows. We used the most frequent 30,000 paths connecting nouns as the context paths for unsupervised learning. We initialized word embeddings with the same pretrained GloVe vector as the baseline models. For unsupervised learning data, we\n5https://nlp.stanford.edu/projects/ glove/\nextracted (w1, w2, path), whose w1 and w2 are included in the vocabulary of the GloVe vector, and whose path is included in the context paths, from D. The number of these triples was 217,737,765.\nWe set the size of h(w1,w2), h̃(w1,w2), and vpath for context paths to 100. The negative sampling size n was set to 5. We trained our model for five epochs using Adam (whose learning rate is 0.001). The minibatch size was 100. To preserve the distributional regularity of the pretrained word embeddings, we did not update the input word embeddings during the unsupervised learning.\nWith our trained model, we applied the two methods described in Section 3.2 and 3.3 to the NPB and LexNET models as follows:\n+Aug. We added the most plausible 2k paths to each paths(w1, w2) as in Section 3.2. We tuned k ∈ {1, 3, 5} on the validation set.\n+Rep. We concatenated vp−paths(w1,w2) in Equation (9) with the penultimate layer. To focus on the pure contribution of unsupervised learning, we did not update this component during supervised learning.\nFigure 2 illustrates +Aug and +Rep applied to LexNET in the case where the two target words, w1 and w2, do not co-occur in the corpus."
  }, {
    "heading": "5 Result",
    "text": "In this section we examine how our methods improved the baseline models. Following the previous research (Shwartz and Dagan, 2016), the performance metrics were the “averaged” F1 of scikit-learn (Pedregosa et al., 2011), which computes the F1 for each relation, and reports their average weighted by the number of true instances for each relation."
  }, {
    "heading": "5.1 Path-based Model and Path Data Augmentation",
    "text": "We examined whether or not our path data augmentation method +Aug contributes to the neural path-based method. The results are displayed in Table 3.\nApplying our path data augmentation method improved the classification performance on each dataset. Especially for K&H+N, the large dataset where the three-fourths of word pairs had no paths, our method significantly improved the performance. This result shows that our path data augmentation effectively solves the missing path problem. Moreover, the model with our method outperforms the baseline on EVALution, in which nearly all word pairs co-occurred in the corpus. This indicates that the predicted paths provide useful information and enhance the path-based classification. We examine the paths that were predicted by our model of P (path|w1, w2) in Section 6.1."
  }, {
    "heading": "5.2 Integrated Model and Our Methods",
    "text": "We investigated how our methods using modeling P (path|w1, w2) improved the baseline integrated model, LexNET. Table 4 displays the results.\nOur proposed methods, +Aug and +Rep, improved the performance of LexNET on each dataset.6 Moreover, the best score on each dataset was achieved by the model to which our methods were applied. These results show that our methods are also effective with the integrated models based on path information and distributional information.\nThe table also shows that LexNET+Rep outperforms LexNET h, though the former has fewer parameters to be tuned during the supervised learning than the latter. This indicates that the word pair representations of our model capture information beyond the interaction of two word embeddings. We investigate the properties of our word pair representation in Section 6.2.\nFinally, We found that applying both methods did not necessarily yield the best performance. A possible explanation for this is that applying both methods is redundant, as both +Aug and +Rep depend on the same model of P (path|w1, w2)."
  }, {
    "heading": "6 Analysis",
    "text": "In this section, we investigate the properties of the predicted dependency paths and word pair representations of our model."
  }, {
    "heading": "6.1 Predicted Dependency Paths",
    "text": "We extracted the word pairs of BLESS without co-occurring dependency paths and predicted the\n6The improvement for K&H+N is smaller than those for the others. We think this owes to most instances of this dataset being correctly classified only by distributional information. This view is supported by Shwartz and Dagan (2016), in which LexNET hardly outperformed a distributional method for this dataset.\nplausible dependency paths of those pairs with our model of P (path|w1, w2). The examples are displayed in Table 5 at the top three paths. We used the bold style for the paths that we believe to be indicative or representative for a given relationship.\nOur model predicted plausible and indicative dependency paths for each relation, although the predicted paths also contain some implausible or unindicative ones. For hypernymy, our model predicted variants of the is-a path according to domains, such as X is Y manufactured in the clothing domain and X is a species of Y in the animal domain. For (owl, rump), which is a meronymy pair, the top predicted path was X that Y represent. This is not plausible for (owl, rump) but is indicative for meronymy, particularly memberof relations. Moreover, domain-independent paths which indicate meronymy, such as all X have Y, were predicted. For (mug, plastic), one of the predicted paths, X is made from Y, is also a domain-independent indicative path for meronymy. For co-hypernymy, our model predicted domain-specific paths, which indicate that two nouns are of the same kind. For examples, given X leaf and Y and X specie and Y of\n(carrot, beans), we can infer that both X and Y are plants or vegetables. Likewise, given play X, guitar, and Y of (cello, kazoo), we can infer that both X and Y are musical instruments. These examples show that our path data augmentation is effective for the missing path problem and enhances path-based models."
  }, {
    "heading": "6.2 Visualizing Word Pair Representations",
    "text": "We visualized the word pair representations vp−paths(w1,w2) to examine their specific properties. In BLESS, every pair was annotated with 17 domain class labels. For each domain, we reduced the dimensionality of the representations using tSNE (Maaten and Hinton, 2008) and plotted the data points of the hypernyms, co-hyponyms, and meronyms. We compared our representations with the concatenation of two word embeddings (pretrained 50-dimensional GloVe). The examples are displayed in Figure 3.\nWe found that our representations (the top row in Figure 3) grouped the word pairs according to their semantic relation in some specific domains based only on unsupervised learning. This property is desirable for the lexical semantic relation detection task. In contrast to our representations,\nthe concatenation of word embeddings (the bottom row in Figure 3) has little or no such tendency in all domains. The data points of the concatenation of word embeddings are scattered or jumbled. This is because the concatenation of word embeddings cannot capture the relational information of word pairs but only the distributional information of each word (Levy et al., 2015).\nThis visualization further shows that our word pair representations can be used as pseudo-path representations to alleviate the missing path problem."
  }, {
    "heading": "7 Conclusion",
    "text": "In this paper, we proposed the novel methods with modeling P (path|w1, w2) to solve the missing path problem. Our neural model of P (path|w1, w2) can be learned from a corpus in an unsupervised manner, and can generalize cooccurrences of word pairs and dependency paths. We demonstrated that this model can be applied in the two ways: (1) to augment path data by predicting plausible paths for a given word pair, and (2) to extract from word pairs useful features capturing co-occurring path information. Finally, our experiments demonstrated that our methods can improve upon the previous models and successfully solve the missing path problem.\nIn future work, we will explore unsupervised learning with a neural path encoder. Our model bears not only word pair representations but also dependency path representations as context vec-\ntors. Thus, we intend to apply these representations to various tasks, which path representations contribute to."
  }, {
    "heading": "Acknowledgments",
    "text": "This work was supported by JSPS KAKENHI Grant numbers JP17H01831, JP15K12873."
  }],
  "year": 2018,
  "references": [{
    "title": "Automatic acquisition",
    "authors": ["Marti A. Hearst"],
    "year": 1992
  }, {
    "title": "Nine features in a",
    "authors": ["Lu", "Chu-Ren Huang"],
    "year": 2016
  }, {
    "title": "Evalution 1.0: an evolving",
    "authors": ["Chu-Ren Huang"],
    "year": 2015
  }, {
    "title": "Learning to distinguish",
    "authors": ["Weir", "Bill Keller"],
    "year": 2014
  }, {
    "title": "Classifying relations via long",
    "authors": ["Zhi Jin"],
    "year": 2015
  }, {
    "title": "Efficiently answering techni",
    "authors": ["Ji-Rong Wen"],
    "year": 2017
  }],
  "id": "SP:143d917aefe939251531bc161759bff6e07cf17a",
  "authors": [{
    "name": "Koki Washio",
    "affiliations": []
  }, {
    "name": "Tsuneaki Kato",
    "affiliations": []
  }],
  "abstractText": "Recognizing lexical semantic relations between word pairs is an important task for many applications of natural language processing. One of the mainstream approaches to this task is to exploit the lexico-syntactic paths connecting two target words, which reflect the semantic relations of word pairs. However, this method requires that the considered words co-occur in a sentence. This requirement is hardly satisfied because of Zipf’s law, which states that most content words occur very rarely. In this paper, we propose novel methods with a neural model of P (path|w1, w2) to solve this problem. Our proposed model of P (path|w1, w2) can be learned in an unsupervised manner and can generalize the cooccurrences of word pairs and dependency paths. This model can be used to augment the path data of word pairs that do not co-occur in the corpus, and extract features capturing relational information from word pairs. Our experimental results demonstrate that our methods improve on previous neural approaches based on dependency paths and successfully solve the focused problem.",
  "title": "Filling Missing Paths: Modeling Co-occurrences of Word Pairs and Dependency Paths for Recognizing Lexical Semantic Relations"
}