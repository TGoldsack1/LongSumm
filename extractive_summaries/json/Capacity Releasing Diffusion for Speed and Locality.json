{
  "sections": [{
    "heading": "1. Introduction",
    "text": "Diffusions and related random walk procedures are of central importance in many areas of machine learning, data analysis, and applied mathematics, perhaps most conspicuously in the area of spectral clustering (Cheeger, 1969; Donath & Hoffman, 1973; von Luxburg, 2006; Shi & Malik, 2000), community detection in networks (Ng et al., 2001; White & Smyth, 2005; Leskovec et al., 2009; Jeub et al., 2015), so-called manifold learning (Belkin & Niyogi,\n1EECS, UC Berkeley, Berkeley, CA, USA 2ICSI and Statistics, UC Berkeley, Berkeley, CA, USA 3Computer Science, University of Vienna, Vienna, Austria. Correspondence to: Di Wang <wangd@eecs.berkeley.edu>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\n2003; Mahoney et al., 2012), and PageRank-based spectral ranking in web ranking (Page et al., 1999; Gleich, 2015). Particularly relevant for our results are local/personalized versions of PageRank (Jeh & Widom, 2003) and local/distributed versions of spectral clustering (Spielman & Teng, 2004; Andersen et al., 2006; Andersen & Peres, 2009). These latter algorithms can be used to find provablygood small-sized clusters in very large graphs without even touching the entire graph; they have been implemented and applied to billion-node graphs (Shun et al., 2016); and they have been used to characterize the clustering and community structure in a wide range of social and information networks (Leskovec et al., 2009; Jeub et al., 2015).\nSomewhat more formally, we will use the term diffusion on a graph to refer to a process that spreads mass among vertices by sending mass along edges step by step according to some rule. With this interpretation, classical spectral diffusion spreads mass by distributing the mass on a given node equally to the neighbors of that node in an iterative manner. A well-known problem with spectral methods is that—due to their close relationship with random walks—they sometimes spread mass “too aggressively,” and thereby they don’t find the “right” partition. In theory, this can be seen with so-called Cockroach Graph (Guattery & Miller, 1998; von Luxburg, 2006). In practice, this is seen by the extreme sensitivity of spectral methods to high-degree nodes and other structural heterogeneities in real-world graphs constructed from very noisy data (Leskovec et al., 2009; Jeub et al., 2015). More generally, it is well-known that spectral methods can be very sensitive to a small number of random edges, e.g., in small-world graphs, that “short circuit” very distant parts of the original graph, as well as other noise properties in realistic data. Empirically, this is well-known to be a particular problem when there are moderately good—but not very good—clusters in the data, a situation that is all too common in machine learning and data analysis applications (Jeub et al., 2015).\nHere, we introduce a novel Capacity Releasing Diffusion (CRD) Process to address this problem. Our CRD Process is a type of diffusion that spreads mass according to a carefully-constructed push-relabel rule, using techniques that are well-known from flow-based graph algorithms, but modified here to release the capacity of edges to transmit mass. Our CRD Process has better properties with respect\nto limiting the spread of mass inside local well-connected clusters. It does so with improved running time properties. We show that this yields improved local clustering algorithms, both in worst-case theory and in empirical practice."
  }, {
    "heading": "1.1. Capacity Releasing Diffusion (CRD)",
    "text": "We start by describing the generic CRD process in Figures 1 and 2, which lays down the dynamics of spreading mass across the graph. Importantly, this dynamical process is independent of any particular task to which it may be applied. Later (in Section 2) we also present a concrete CRD algorithm for the specific task of local clustering that exploits the dynamics of the generic CRD process1.\nThe entire CRD process (Figure 1) repeatedly applies the generic CRD inner process (which we call a CRD step), and then it doubles the amount of mass at all vertices between invocations. A CRD step starts with each vertex u having mass m(u) ≤ 2d(u), where d(u) is the degree of u, and spreads the mass so that at the end each vertex u has mass m(u) ≤ d(u). Observe that, essentially, each CRD step\nspreads the mass to a region of roughly twice the volume\n1The relation between the generic CRD process and the CRD algorithm for local graph clustering is analogous to the relation between local random walks and a local spectral graph partitioning algorithm such as that of Andersen et al. (2006).\ncomparing to the previous step.\nThe generic CRD inner process (Figure 2) implements a modification of the classic “push-relabel” algorithm (Goldberg & Tarjan, 1988; 2014) for routing a source-sink flow. The crucial property of our process (different from the standard push-relabel) is that edge capacity is made available to the process slowly by releasing. That is, we only allow l(u) units of mass to move across any edge (u, v), where l(u) is the label (or height) maintained by the CRD inner process. Thus, edge capacity is released to allow mass to cross the edge as the label of the endpoint rises. As we will see, this difference is critical to the theoretical and empirical performance of the CRD algorithm."
  }, {
    "heading": "1.2. Example: Classical Versus Capacity Releasing",
    "text": "To give insight into the differences between classical spectral diffusion and our CRD Process, consider the graph in Figure 3. There is a “cluster” B, which consists of k paths, each of length l, joined at a common node u. There is one edge from u to the rest of the graph, and we assume the other endpoint v has very high degree such that the vast majority of the mass arriving there is absorbed by its neighbors in B. While idealized, such an example is not completely unrealistic (Leskovec et al., 2009; Jeub et al., 2015).\nConsider first classical spectral diffusion, with a random walk starting from some vertex in B. This process requires Ω(`2) steps to spread probability mass to a constant fraction of the nodes on the paths, and in this many steps, the expected number of times to visit u is Ω(`). Because of the edge to v, each time we visit u, we have a Ω(1/k) chance of leaving B. Thus, when ` is Ω(k), the random walk is expected to leave B and never return, i.e., the classical diffusion will leak out all the probability mass before even spreading beyond a constant fraction of B.\nConsider next our CRD Process, starting with mass at the vertex u ∈ B (which would be a worst-case starting node in B for CRD). Assume that at some point the mass is spread along z neighboring vertices on each of the k paths. To continue the spread to 2z vertices in the next CRD step, the labels will be raised to (at most) 2z to allow the mass to spread over the path of length 2z. This enables the spread along the paths, but it only releases a capacity of 2z to the exiting edge (u, v). Since in this call, a total of 2zk mass\nis in the set B, at most 1/k of the mass escapes. After log ` CRD steps, the mass is spread over all the k length-` paths, and only a (2 log `)/k fraction of the mass has escaped from B. Thus if ` = Ω(k), as before, a factor of k/ log ` less mass has escaped from B with the CRD Process than with the classical diffusion process.\nWithout the releasing, however, the mass escapingB would be large, as even raising the label of vertex u to 1 would allow an arbitrary amount of mass to leak out.\nFinally, note that the `2 mixing time makes spectral diffusions a Ω(`) factor slower than CRD. This drawback of spectral techniques can perhaps be resolved using sophisticated methods such as evolving sets (Andersen & Peres, 2009), though it comes easily with CRD."
  }, {
    "heading": "1.3. Our Main Results",
    "text": "We provide theoretical and empirical evidence that our CRD algorithm is superior to classical diffusion methods at finding clusters, with respect to noise tolerance, recovery accuracy, cut conductance, and running time. Here the cut conductance Φ(S) of a cut (S, S̄) is Φ(S) := |E(S,S̄)| min(vol(S),vol(V \\S)) , where E(S, S̄) denotes the set of edges between S and S̄,2 and the volume vol(S) is the sum of the degrees of the vertices in S. In all these measures, we break the quadratic Cheeger barrier for classical diffusions (explained below) while presenting a local algorithm (i.e., an algorithm whose running time depends on the volume of the cluster found and not of the whole graph).\nOur first main result (Section 2) presents a CRD algorithm and its running time. The CRD algorithm is a parameterized specialization of the generic CRD Process, where we limit the maximum label of vertices, as well as the maximum edge capacity. We prove that this specialization is efficient, in that it runs in time linear in the total mass and the label limit, and it either succeeds in spreading the mass or it leaves all unspread mass at nodes with high label. This property is analogous to the ispoerimetric capacity control provided by local spectral methods, and it is important for locating cluster bottlenecks. We use this crucially in our context to find low conductance clusters.\nOur second main result (Section 3) concerns the use of the CRD algorithm to find good local clusters in large graphs. Our result posits the existence of a “good” clusterB, which satisfies certain conditions (Assumption 1 and 2) that naturally capture the notion of a local structure. The rather weak Assumption 1 states that B’s internal connectivity φS(B) (see Section 3 for definition) is a constant factor better (i.e., larger) than the conductance φ(B). Assumption 2 states that we have a smoothness condition which needs\n2Unless otherwise noted, when speaking of the conductance of a cut S, we assume S to be the side of minimum volume.\nthat any subset T ⊂ B has polylog(vol(B)) times more neighbors inB−T than in V −B. Under these conditions, we can recover B starting from any vertex in B.\nBoth assumptions formalize the idea that the signal of the local structure is stronger than the noise of the cluster by some moderately large factor. More specifically, Assumption 1 roughly says that the weakest signal of any subset of B is a constant times stronger than the average noise of B; and Assumption 2 roughly says the signal of any subset is polylog(vol(B)) times stronger than the noise of the subset.\nWe note that Assumption 1 is significantly weaker than the factor in Zhu et al. (2013), where it is shown how to localize a cluster B such that φS(B) ≥ √ φ(B). Their condition is considerably stricter than our condition on the ratio between φS(B) and φ(B), especially when φ(B) is small, as is common. Their algorithm relies on proving that a classical diffusion starting at a typical node keeps most of its mass inside of B. However, they do not need something like our smoothness condition.\nWith the additional smoothness condition, we break the dependence on √ φ(B) that is central to all approaches using spectral diffusions, including Zhu et al. (2013), for the first time with a local algorithm. In particular, comparing to Zhu et al. (2013), under their parameter settings (but with the smoothness condition), we identify a cluster with √ φ(B) times less error, and we have a 1/ √ φ(B) speedup in running time. This improvement is (up to a log `-factor) consistent with the behavior in the example of the previous section where the improvement is k/ log ` = O(1/( √ 1/φ(B) log `)) as φ(B) = 1/k` and ` = Ω(k).\nWe note that with the additional smoothness condition, our theoretical results hold for any starting node vs in B, in contrast to prior spectral-based results which only work when starting from a “good” node (where only a constant fraction of the nodes inB are good). We expect the smoothness condition to be an artifact of our analysis, i.e., similar results actually hold when starting at good nodes inB, even without this assumption.\nOur third main result (Section 4) is an empirical illustration of our method. We consider several social and information networks studied previously that are particularly challenging for spectral methods. In particular, while graphs that have upward-sloping NCPs (Network Community Profiles) have good small clusters (Leskovec et al., 2009; Jeub et al., 2015), denser social networks with flat NCPs do not have any very-good conductance clusters of any size. They do, however, often have moderately-good clusters, but these are very difficult for spectral methods to identify (Jeub et al., 2015). Our empirical results show that our CRD-based local clustering algorithm is better able to iden-\ntify and extract in a strongly local running time moderately good quality clusters from several such social networks."
  }, {
    "heading": "1.4. Previous Work: Low Conductance Cuts, Diffusions, and Multicommodity Flow",
    "text": "Spectral algorithms for computing eigenvalues use some variant of repeated matrix multiplication, which for graphs is a type of classical diffusion. For the Laplacian of a graph, the convergence rate is O(1/λ2), where λ2 is the second smallest eigenvalue by of this matrix. The Lanczos method improves this rate to O( √ 1/λ2) by cleverly and efficiently combining different iterations of the diffusions. See, e.g., Orecchia et al. (2012) for more details on this.\nOne application of such a computation is to find a low conductance cut in a graph. The second eigenvector for G can be used to find a cut of conductance O( 1λ2 ) (Cheeger, 1969; Donath & Hoffman, 1973). Let φG be the minimum conductance in the graph. In his work, Cheeger already observed that random-walk based diffusion can make a Θ(1/ √ φG) error in estimating the conductance, informally known as the (quadratic) Cheeger barrier, and illustrated in our example. This, combined with the fact that λ2 = O(1/φG), gives a spectral method to find anO(φ 1/2 G ) conductance cut in G.\nSpielman-Teng (2004) used local versions of diffusions (i.e., those with small support) to compute recursive decompositions efficiently, and then they used locality to produce linear time partitioning algorithms. Andersen, Chung and Lang (2006) developed an improved version that adjusts the standard diffusion by having mass settled at vertices, resulting in significantly improved bounds to O( √ φG log n) on the conductance of the returned cut (B, B̄) in time Õ(vol(B)φG ). Allen-Zhu, Lattanzi and Mirrokni (2013) analyzed the behavior of the same algorithm under certain well-connected conditions. The EvoCut algorithm of Andersen and Peres (2009) improved the running time of this method to Õ(vol(B)√\nφG ). As all these methods are\nbased on spectral diffusion, their performance with respect to conductance is subject to the Cheeger barrier. Other processes have been proposed for random walks that mix faster, e.g., non-backtracking random walks (Alon et al., 2007). These too are subject to the Cheeger barrier asymptotically. Our result is the first to break this barrier in any broad setting, where classical spectral methods fail.\nMulticommodity flow based methods are able to find clusters of conductance O(φG log n) (Leighton & Rao, 1988), bypassing the limit inherent in purely spectral methods. A semidefinite programming approach, which can be viewed as combining multicommodity flow and spectral methods, yields cuts of conductance O(φG √ log n) (Arora et al., 2009). These algorithms are very non-local, e.g., in the sense that their running time depends on the size of the\nwhole graph, and it is not clear that they can be meaningfully localized. We do, however, use well-known flowbased ideas in our algorithm. In particular, recall that push-relabel and in general “shortest-path” based methods have a celebrated history in algorithms (Goldberg & Tarjan, 2014). Using levels to release capacity, however, as we do in our algorithm, is (to our knowledge) completely new."
  }, {
    "heading": "2. Capacity Releasing Diffusion",
    "text": "In this section, we describe our algorithm which implements a specific version of the generic CRD Process. In particular, it has some modifications for efficiency reasons, and it terminates the diffusion when it finds a bottleneck during the process. The algorithm iteratively calls a subroutine CRD-inner, which implements one CRD step.\nFor efficiency reasons, CRD-inner doesn’t necessarily carry out a full CRD step, where a full CRD step means every node u has at most d(u) mass at termination. In particular, CRD-inner only makes a certain amount of “effort” (which is tuned by a parameter φ) to spread the mass, and if there is a bottleneck in the form of a cut that requires “too much effort” for the diffusion to get through, then CRDinner may leave excess mass on nodes, i.e.,m(v) > d(v) at termination. More specifically, given φ, CRD-inner guarantees to overcome any bottleneck of conductance Ω(φ), i.e., if it doesn’t carry out a full CRD step, then it returns a cut of conductance O(φ) as a certificate. We will discuss CRD-inner with more detail in Section 2.2."
  }, {
    "heading": "2.1. CRD Algorithm",
    "text": "Given a starting node vs, the CRD algorithm (Algorithm 1) is essentially the CRD Process starting from vs, as described in Figure 1. The algorithm takes as input a parameter φ, which is used to tune CRD-inner. Since CRDinner may stop short of a full CRD step due to a bottleneck, we remove any excess mass remaining on nodes after calling CRD-inner. Due to the excess removal, we may discard mass as the algorithm proceeds. In particular, as we start with 2d(vs) mass, and double the amount after every CRD step, the amount of mass after the j-th doubling is 2d(vs) · 2j if we never remove excess. When the actual amount of mass is significantly smaller than 2d(vs) · 2j , there must be a bottleneck (K, K̄) during the last CRD step, such that K contains a large fraction of the mass (and of the excess) and such that CRD-inner cannot push any more mass from K to K̄. We terminate the CRD algorithm when this happens, as the mass and, as we can show, thus the volume of K must be large, while there are few edges between K and K̄. Thus K is a low-conductance cluster around vs. Formally, the algorithm takes input parameters τ and t, and it terminates either when the amount of mass drops below τ(2d(vs) · 2j) after iteration j, or after iteration t if the former never happens. It returns the mass on\nAlgorithm 1 CRD Algorithm(G, vs, φ, τ, t)\n. Initialization: m(vs) = d(vs),m(v) = 0, ∀v 6= vs; j = 0. . For j = 0, . . . , t . . m(v)← 2m(v), ∀v . . Assertion: m(v) ≤ 2d(v), ∀v . . Call CRD-inner with G,m(·), φ, get cut Kj (Kj empty if CRD-inner finishes full CRD step). . . m(v)← min(m(v), d(v)), ∀v\n. . If ∑ vm(v) ≤ τ(2d(vs) · 2 j) . . . Return m(·), and K def= Kj . Terminate. . End For . Return m(·),K def= Kt.\nthe nodes (i.e., m(·)), as well as the cut K returned by the last CRD-inner call in the former termination state.\nThe running time of our CRD algorithm is local (i.e., proportional to the volume of the region it spreads mass to, rather than the volume of the entire graph). In particular, each CRD-inner call takes time linear in the amount of mass, and as the amount of mass increases geometrically before we terminate, the running time of the CRD algorithm is dominated by the last CRD-inner call."
  }, {
    "heading": "2.2. CRD Inner Procedure",
    "text": "Now we discuss the CRD-inner subroutine (Algorithm 2), which aims to carry out one CRD step. In particular, each node v has m(v) ≤ 2d(v) mass at the beginning, and CRD-inner tries to spread the mass so each node v has m(v) ≤ d(v) mass at the end. Not surprisingly, as the CRD step draws intuition from flow routing, our CRD-inner can be viewed as a modification of the classic push-relabel algorithm.\nAs described in Figure 2, we maintain a label l(v) for each node v, and the net mass being pushed along each edge. Although the graph is undirected, we consider each edge e = {u, v} as two directed arcs (u, v) and (v, u), and we use m(u, v) to denote the net mass pushed from u to v (during the current CRD-inner invocation). Under this notation, we have m(u, v) = −m(v, u). We denote |m(·)| def= ∑ vm(v) as the total amount of mass, ex(v) def = max(m(v)− d(v), 0) as the amount of excess on v, and we let φ be the input parameter tuning the “effort” made by CRD-inner (which will be clear shortly).\nAs noted earlier, to make CRD-inner efficient, we deviate from the generic CRD step. In particular, we make the following modifications:\n1. The label of any node can be at most h = 3 log |m(·)|/φ. If v is raised to level h, but still has excess mass, CRD-inner leaves the excess on v, and won’t work on v any more. Formally, v is active if\nl(v) < h and ex(v) > 0. We keep a list Q of all active nodes, and terminate CRD-inner when Q is empty.\n2. In addition to capacity releasing, the net mass along any edge can be at mostC = 1/φ. Formally, for an arc (v, u), its effective capacity is ĉ(v, u) def= min(l(v), C), and its residual capacity is rm(v, u) def = ĉ(v, u) −\nm(v, u). The arc (v, u) is eligible iff l(v) > l(u) (i.e., downhill) and rm(v, u) > 0. We only push mass along eligible arcs.\n3. We enforce m(v) ≤ 2d(v) for all v through the execution. This is assumed at the start, and we never push mass to v if that would result in m(v) > 2d(v).\nThe parameter φ in the first two modifications limits the work done by CRD-inner, and it captures how hard CRDinner will try to carry out the full CRD step (e.g., when h,C are infinitely large, CRD-inner implements the full CRD step). Given any φ, CRD-inner makes enough effort by allowing nodes to have height up to h and by using the above edge capacities to overcome bottlenecks of conductance Ω(φ) during the diffusion process. If it doesn’t finish the full CRD step, then it returns a cut of conductanceO(φ) as certificate.\nAnother motivation of tuning with parameter φ is to keep the diffusion local. Since CRD-inner doesn’t try to get through low-conductance bottlenecks, the diffusion tends to spread mass over well-connected region, instead of pushing mass out of a bottleneck. This guarantees that the work performed is linear in the volume of the returned cluster, i.e., that it is a strongly local algorithm, since only a small fraction of mass can leak out of the cluster.\nThe third modification guarantees when CRD-inner terminates with a lot of excess on nodes, the excess won’t be concentrated on a few nodes, as no node can have more mass than twice its degree, and thus the cut returned must contain a large region.\nWe have the following theorem for CRD-inner.\nTheorem 1. Given G,m(·), and φ ∈ (0, 1], such that |m(·)| ≤ vol(G), and ∀v : m(v) ≤ 2d(v) at the start, CRD-inner terminates with one of the following cases:\n1. CRD-inner finishes the full CRD step: ∀v : m(v) ≤ d(v).\n2. There are nodes with excess, and we can find a cut A of conductance O(φ). Moreover, ∀v ∈ A : 2d(v) ≥ m(v) ≥ d(v), and ∀v ∈ Ā : m(v) ≤ d(v).\nThe running time is O(|m(·)| log(|m(·)|)/φ).\nProof sketch. Let l(·) be the labels of nodes at termination. First note all nodes with excess must be on level h.\nAlgorithm 2 CRD-inner(G,m(·),φ)\n. Initialization: . . ∀{v, u} ∈ E, m(u, v) = m(v, u) = 0; ∀v, l(v) = 0 . . Q = {v|m(v) > d(v)}, h = 3 log |m(·)| φ . While Q is not empty . . Let v be the lowest labeled node in Q. . . Push/Relabel(v). . . If Push/Relabel(v) pushes mass along (v, u) . . . If v becomes in-active, remove v from Q . . . If u becomes active, add u to Q . . Else If Push/Relabel(v) increases l(v) by 1 . . . If l(v) = h, remove v from Q.\nPush/Relabel(v) . If there is any eligible arc (v, u) . . Push(v, u). . Else . . Relabel(v).\nPush(v, u) . ψ = min (ex(v), rm(v, u), 2d(u)−m(u)) . Push ψ units of mass from v to u: m(v, u)← m(v, u) + ψ,m(u, v)← m(u, v)− ψ; m(v)← m(v)− ψ,m(u)← m(u) + ψ.\nRelabel(v) . l(v)← l(v) + 1.\nMoreover, since we only push from a node v if it has excess (i.e., m(v) ≥ d(v)), once a node has at least d(v) mass, it always has at least d(v) mass. Note further that l(v) ≥ 1 if and only if ex(v) > 0 at some point during the process. Thus, we know the following: l(v) = h ⇒ 2d(v) ≥ m(v) ≥ d(v); h > l(v) ≥ 1 ⇒ m(v) = d(v); l(v) = 0⇒ m(v) ≤ d(v).\nLet Bi = {v|l(v) = i}. Since the total amount of mass |m(·)| is at most the volume of the graph, if B0 = ∅ or Bh = ∅, then we have case (1) of the theorem.\nOtherwise, both Bh and B0 are non-empty. Let the level cut Si = ∪hj=iBj be the set of nodes with label at least i. We have h level cuts Sh, . . . , S1, where vol(Sh) ≥ 1, and Sj ⊆ Si if j > i. The conductance of these cuts, when we go from Sh down to S1, lower bounds how much the volume grows from Sh to S1. If all these cuts have Ω(φ) conductance, by our choice of h, the volume of S1 will be much larger than |m(·)|. This gives a contradiction, since any node v ∈ S1 has m(v) ≥ d(v), and we don’t have enough mass. It follows that at least one of the level cuts has conductance O(φ).\nAs to the running time, the graph G is given implicitly, and we only acess the list of edges of a node when it is active. Each active node v has d(v) mass, and the total amount of mass is |m(·)|, so the algorithm touches a region of volume at most |m(·)|. Thus, the running time has linear dependence on |m(·)|. Using an amortization argument one\ncan show that the total work of the subroutine (in the worst case) is O(|m(·)|h) = O(|m(·)| log(|m(·)|)/φ)."
  }, {
    "heading": "3. Local Graph Clustering",
    "text": "In this section, we provide theoretical evidence that the CRD algorithm can identify a good local cluster in a large graph if there exists one around the starting node. We define set conductance, φS(B) (or internal connectivity) of a set B ⊂ V is the minimum conductance of any cut in the induced subgraph on B.\nInformally, for a “good” cluster B, any inside bottleneck should have larger conductance than φ(B), and nodes in B should be more connected to other nodes inside B than to nodes outside. We capture the intuition formally as follows.\nAssumption 1. σ1 def = φS(B)φ(B) ≥ Ω(1). Assumption 2. There exists σ2 ≥ Ω(1), such that any T ⊂ B with volB(T ) ≤ volB(B)/2 satisfies\n|E(T,B \\ T )| |E(T, V \\B)| log vol(B) log 1φS(B) ≥ σ2.\nFollowing prior work in local clustering, we formulate the goal as a promise problem, where we assume the existence of an unknown target good cluster B ⊂ V satisfying Assumption 1 and 2. In the context of local clustering, we also assume vol(B) ≤ vol(G)/2. Similar to prior work, we assume the knowledge of a node vs ∈ B, and rough estimates (i.e., within constant factor) of the value of φS(B) and vol(B). We use the CRD algorithm with vs as the starting node, φ = Θ(φS(B)), τ = 0.5, and t = Θ(log vol(B)d(vs) ). With the parameters we use, the algorithm will terminate due to too much excess removed, i.e., |m(·)| ≤ τ(2d(vs) · 2j) after some iteration j. The region where the diffusion spreads enough mass will be a good approximation of B. Theorem 2. Starting from any vs ∈ B, with the above parameters, when the CRD algorithm terminates, if we let S = {v|m(v) ≥ d(v)}, then we have:\n1. vol(S \\B) ≤ O( 1σ ) · vol(B) 2. vol(B \\ S) ≤ O( 1σ ) · vol(B)\nwhere σ = min(σ1, σ2) ≥ Ω(1), with the σ1, σ2 from Assumption 1 and 2. The running time is O(vol(B) log vol(B)φS(B) ).\nThe theorem states that the cluster recovered by the CRD algorithm has both good (degree weighted) precision and recall with respect to B; and that the stronger the “signal” (relative to the “noise”), i.e., the larger σ1, σ2, the more accurate our result approximates B.\nIf the goal is to minimize conductance, then we can run one extra iteration of the CRD algorithm after termination with a smaller value for φ (not necessarily Θ(φS(B)) as used in previous iterations). In this case, we have the following.\nTheorem 3. If we run the CRD algorithm for one extra iteration, with φ ≥ Ω(φ(B)), then CRD-inner will end with case (2) of Theorem 1. LetK be the cut returned. We have:\n1. vol(K \\B) ≤ O(φ(B)φ ) · vol(B)\n2. vol(B \\K) ≤ O( φ(B)φS(B) ) · vol(B)\n3. φ(K) ≤ O(φ) The running time is O(vol(B) log vol(B)φ ).\nNow we can search for the smallest φ that gives case (2) of Theorem 1, which must give a cut of conductance within an O(1) factor of the best we can hope for (i.e., φ(B)). If we search with geometrically decreasing φ values, then the running time is O(vol(B) log vol(B)/φ(B)).\nTheorem 2 and 3 hold due to the particular flow-based dynamics of the CRD algorithm, which tends to keep the diffusion local, without leaking mass out of a bottleneck.\nFormally, for each CRD step, we can bound the total amount of mass that starts on nodes in B, and leaves B at any point during the diffusion. We have the following lemma, a sketch of the proof of which is given.\nLemma 1. In the j-th CRD step, let Mj be the total amount of mass in B at the start, and let Lj be the amount of mass that ever leaves B during the diffusion. Then Lj ≤ O( 1σ2 log vol(B) ) ·Mj , when Mj ≤ volB(B)/2; and Lj ≤ O( 1σ1 ) ·Mj , when Mj ≥ volB(B)/2.\nProof sketch. We have two cases, corresponding to whether the diffusion already spread a lot of mass over B.\nIn the first case, if Mj ≥ volB(B)/2, then we use the upper bound 1/φ that is enforced on the net mass over any edge to limit the amount of mass that can leak out. In particular Lj ≤ O(vol(B)φ(B)/φS(B)), since there are vol(B)φ(B) edges from B to B̄, and φ = Θ(φS(B)) in CRD-inner. As Mj ≥ Ω(vol(B)), we have Lj ≤ O( 1σ1 ) ·Mj .\nThe second case is when Mj ≤ volB(B)/2. In this case, a combination of Assumption 2 and capacity releasing controls the leakage of mass. Intuitively, there are still many nodes in B to which the diffusion can spread mass. For the nodes in B with excess on them, when they push their excess, most of the downhill directions go to nodes inside B. As a consequence of capacity releasing, only a small fraction of mass will leak out.\nTheorem 2 and 3 follow from straightforward analysis of the total amount of leaked mass at termination. We sketch the ideas for the proof of Theorem 2.\nProof sketch. Since we use φ = Θ(φS(B)) when we call CRD-inner, the diffusion will be able to spread mass over nodes inside B, since there is no bottleneck with conductance smaller than φS(B) in B.\nThus, before every node v in B has d(v) mass on it (in which case we say v is saturated), there will be no excess on nodes in B at the end of a CRD step. Consequently, the amount of mass in B only decreases (compared to the supposed 2d(vs) · 2j amount in the j-th CRD step) due to mass leaving B.\nAs long as the total amount Mj of mass in B at the start of a CRD step is less than volB(B)/2, the mass loss to B̄ is at most a O(1/(σ2 log vol(B))) fraction of the mass in B each CRD step. After O(log vol(B)) CRD steps, Mj reaches vol(B)B/2, and only a O(1/σ2) fraction of mass has left B so far. After O(1) more CRD steps, there will be enough mass to saturate all nodes in B, and each of these CRD steps looses at most a O(1/σ1) fraction of the mass to B̄. Thus we loose at most a O(1/σ) fraction of mass before all nodes in B are saturated.\nOnce the diffusion has saturated all nodes in B, the amount of mass in B will be 2vol(B) at the start of every subsequent CRD step. At most vol(B)φ(B)/φS(B) ≤ O(vol(B)/σ) mass can leave B, and nodes in B can hold vol(B) mass, so there must be a lot of excess (in B) at the end. Thus, the CRD algorithm will terminate in at most 2 more CRD steps, since the amount of mass almost stops growing due to excess removal.\nAt termination, the amount of mass is Θ(vol(B)), and only O(1/σ) fraction of the mass is in B̄. Since S = {v|m(v) ≥ d(v)}, and the total mass outside is O(vol(B)/σ), we get claim (1) of the theorem. In our simplified argument, all nodes in B have saturated sinks (i.e., vol(B \\ S) = 0) at termination. We get the small loss in claim (2) when we carry out the argument in more detail.\nThe amount of mass grows geometrically before the CRD algorithm terminates, so the running time is dominated by the last CRD step. The total amount of mass is O(vol(B)) in the last CRD step, and the running time follows Theorem 1 with φ = Θ(φS(B)). The proof of Theorem 3 is very similar to Theorem 2, and the conductance guarantee follows directly from Theorem 1. We leave the detailed proofs in the full version."
  }, {
    "heading": "4. Empirical Illustration",
    "text": "We have compared the performance of the CRD algorithm (Algorithm 1), the Andersen-Chung-Lang local spectral algorithm (ACL) (2006), and the flow-improve algorithm (FlowImp) (Andersen & Lang, 2008). Given a starting node vs and teleportation probability α, ACL is a local algorithm that computes an approximate personalized PageRank vector, which is then used to identify local structure via a sweep cut. FlowImp is a flow-based algorithm that takes as input a set of reference nodes and finds a cluster around the given reference set with small conductance value. Note that we only couple FlowImp with ACL. The\nreason is that, while FlowImp needs a very good reference set as input to give meaningful results in our setting, it can be used as a “clean up” step for spectral methods, since they give good enough output. Note also that FlowImp has running time that depends on the volume of the entire graph, as it optimizes a global objective, while our CRD algorithm takes time linear in the volume of the local region explored.\nWe compare these methods on 5 datasets, one of which is a synthetic grid graph. For the 4 real-world graphs, we use the Facebook college graphs of John Hopkins (Hop.), Rice, Simmons (Sim.), and Colgate, as introduced in Traud et al. (2012). Each graph in the Facebook dataset comes along with some features, e.g., “dorm 217,” and “class year 2009.” We consider a set of nodes with the same feature as a “ground truth” cluster, e.g., students of year 2009. We filter out very noisy features via some reasonable thresholds, and we run our computations on the the remaining features. The clusters of the features we use are shown in Table 1.\nWe filter bad clusters from all the ground truth clusters, by setting reasonable thresholds on volume, conductance, and gap (which is the ratio between the spectral gap of the induced graph of cluster, and the cut conductance of the cluster). In Table 1, we show the size and conductance of the clusters of the features used in our experiments.\nFor the synthetic experiment, we measure performance by conductance; the smaller the better. For real-world experiments, we use precision and recall. We also compare to ACLopt which “cheats” in the sense that it uses ground truth to choose the parameter α with best F1-score (a combination of precision and recall).\nFor the synthetic data, we use a grid graph of size 60× 60. We add noise to the grid by randomly connecting two vertices. We illustrate the performance of the algorithms versus probability of random connection in Figure 4. The range of probabilities was chosen consistent with theory. As expected, CRD outperforms ACL in the intermediate range, and the two method’s performances meet at the endpoints. One view of this is that the random connections initially adds noise to the local structure and eventually destroys it. CRD is more tolerant to this noise process.\nSee Table 2 for results for real-world data. We run algorithms starting at each vertex in a random sample of half the vertices in each cluster and report the median.\nFor clusters with good but not great conductance (e.g., Rice 2009, Colgate 2008), CDR outperforms ACL and has nearly identical performance to FlowImp (which, recall, is a global algorithm). This is a consequence of CDR avoiding the trap of leaking mass out of the local structure, in contrast to ACL, which leaks a large fraction of mass. For clusters with great conductance, all methods perform very well; and all methods perform poorly when the conductance of the clusters gets close to 0.5.\nHere again, as with the synthetic data, we see that for high conductance sets (which do not have good local structure) and very good conductance sets (which have excellent local structure), all methods perform similarly. In the intermediate range, i.e., when there are moderately good but not very good quality clusters, CDR shows distinct advantages, as suggested by the theory."
  }, {
    "heading": "Acknowledgements",
    "text": "SR and DW are supported by the National Science Foundation under Grant CCF-1528174 and CCF-1535989. MM and KF would like to thank the Army Research Office and the Defense Advanced Research Projects Agency for partial support of this work. MH has received funding from the European Research Council under the European Union’s Seventh Framework Programme (FP/20072013)/ERC Grant Agreement no. 340506."
  }],
  "year": 2017,
  "references": [{
    "title": "Non-backtracking random walks mix faster",
    "authors": ["Alon", "Noga", "Benjamini", "Itai", "Lubetzky", "Eyal", "Sodin", "Sasha"],
    "venue": "Communications in Contemporary Mathematics,",
    "year": 2007
  }, {
    "title": "An algorithm for improving graph partitions",
    "authors": ["R. Andersen", "K. Lang"],
    "venue": "SODA",
    "year": 2008
  }, {
    "title": "Finding sparse cuts locally using evolving sets",
    "authors": ["Andersen", "Reid", "Peres", "Yuval"],
    "venue": "STOC",
    "year": 2009
  }, {
    "title": "Local graph partitioning using PageRank vectors",
    "authors": ["Andersen", "Reid", "Chung", "Fan", "Lang", "Kevin"],
    "venue": "FOCS",
    "year": 2006
  }, {
    "title": "Expander flows, geometric embeddings and graph partitioning",
    "authors": ["Arora", "Sanjeev", "Rao", "Satish", "Vazirani", "Umesh"],
    "venue": "Journal of the ACM (JACM),",
    "year": 2009
  }, {
    "title": "Laplacian eigenmaps for dimensionality reduction and data representation",
    "authors": ["M. Belkin", "P. Niyogi"],
    "venue": "Neural Computation,",
    "year": 2003
  }, {
    "title": "A lower bound for the smallest eigenvalue of the Laplacian",
    "authors": ["Cheeger", "Jeff"],
    "venue": "In Proceedings of the Princeton conference in honor of Professor S. Bochner,",
    "year": 1969
  }, {
    "title": "Lower bounds for the partitioning of graphs",
    "authors": ["Donath", "William E", "Hoffman", "Alan J"],
    "venue": "IBM Journal of Research and Development,",
    "year": 1973
  }, {
    "title": "PageRank beyond the web",
    "authors": ["D.F. Gleich"],
    "venue": "SIAM Review,",
    "year": 2015
  }, {
    "title": "A new approach to the maximum-flow problem",
    "authors": ["Goldberg", "Andrew V", "Tarjan", "Robert E"],
    "venue": "Journal of the ACM (JACM),",
    "year": 1988
  }, {
    "title": "Efficient maximum flow algorithms",
    "authors": ["Goldberg", "Andrew V", "Tarjan", "Robert Endre"],
    "venue": "Commun. ACM,",
    "year": 2014
  }, {
    "title": "On the quality of spectral separators",
    "authors": ["S. Guattery", "G.L. Miller"],
    "venue": "SIAM Journal on Matrix Analysis and Applications,",
    "year": 1998
  }, {
    "title": "Scaling personalized web search",
    "authors": ["Jeh", "Glen", "Widom", "Jennifer"],
    "venue": "In Proceedings of the 12th international conference on World Wide Web,",
    "year": 2003
  }, {
    "title": "Think locally, act locally: Detection of small, medium-sized, and large communities in large networks",
    "authors": ["L.G.S. Jeub", "P. Balachandran", "M.A. Porter", "P.J. Mucha", "M.W. Mahoney"],
    "venue": "Physical Review E,",
    "year": 2015
  }, {
    "title": "An approximate maxflow min-cut theorem for uniform multicommodity flow problems with applications to approximation algorithms",
    "authors": ["Leighton", "Tom", "Rao", "Satish"],
    "venue": "In FOCS,",
    "year": 1988
  }, {
    "title": "Community structure in large networks: Natural cluster sizes and the absence of large well-defined clusters",
    "authors": ["J. Leskovec", "K.J. Lang", "A. Dasgupta", "M.W. Mahoney"],
    "venue": "Internet Mathematics,",
    "year": 2009
  }, {
    "title": "A local spectral method for graphs: with applications to improving graph partitions and exploring data graphs locally",
    "authors": ["M.W. Mahoney", "L. Orecchia", "N.K. Vishnoi"],
    "venue": "Journal of Machine Learning Research,",
    "year": 2012
  }, {
    "title": "On spectral clustering: Analysis and an algorithm",
    "authors": ["A.Y. Ng", "M.I. Jordan", "Y. Weiss"],
    "venue": "Proceedings of the 15th Annual Conference on Advances in Neural Information Processing Systems,",
    "year": 2001
  }, {
    "title": "Approximating the exponential, the Lanczos method and an Õ(m)-time spectral algorithm for balanced separator",
    "authors": ["Orecchia", "Lorenzo", "Sachdeva", "Sushant", "Vishnoi", "Nisheeth K"],
    "year": 2012
  }, {
    "title": "The pagerank citation ranking: Bringing order to the web",
    "authors": ["Page", "Lawrence", "Brin", "Sergey", "Motwani", "Rajeev", "Winograd", "Terry"],
    "venue": "Technical report, Stanford InfoLab,",
    "year": 1999
  }, {
    "title": "Normalized cuts and image segmentation",
    "authors": ["J. Shi", "J. Malik"],
    "venue": "IEEE Transcations of Pattern Analysis and Machine Intelligence,",
    "year": 2000
  }, {
    "title": "Parallel local graph clustering",
    "authors": ["J. Shun", "F. Roosta-Khorasani", "K. Fountoulakis", "M.W. Mahoney"],
    "venue": "Proceedings of the VLDB Endowment,",
    "year": 2016
  }, {
    "title": "Nearly-linear time algorithms for graph partitioning, graph sparsification, and solving linear systems",
    "authors": ["Spielman", "Daniel A", "Teng", "Shang-Hua"],
    "venue": "STOC",
    "year": 2004
  }, {
    "title": "Social structure of facebook networks",
    "authors": ["A.L. Traud", "P.J. Mucha", "M.A. Porter"],
    "venue": "Physica A: Statistical Mechanics and its Applications,",
    "year": 2012
  }, {
    "title": "A tutorial on spectral clustering",
    "authors": ["U. von Luxburg"],
    "venue": "Technical Report 149,",
    "year": 2006
  }, {
    "title": "A spectral clustering approach to finding communities in graphs",
    "authors": ["S. White", "P. Smyth"],
    "venue": "In SDM ’05: Proceedings of the 5th SIAM International Conference on Data Mining,",
    "year": 2005
  }, {
    "title": "A local algorithm for finding well-connected clusters",
    "authors": ["Zhu", "Zeyuan Allen", "Lattanzi", "Silvio", "Mirrokni", "Vahab S"],
    "venue": "ICML",
    "year": 2013
  }],
  "id": "SP:0b4ea13aa4f1a83e494f9197a347e0a020e127da",
  "authors": [{
    "name": "Di Wang",
    "affiliations": []
  }, {
    "name": "Kimon Fountoulakis",
    "affiliations": []
  }, {
    "name": "Monika Henzinger",
    "affiliations": []
  }, {
    "name": "Michael W. Mahoney",
    "affiliations": []
  }, {
    "name": "Satish Rao",
    "affiliations": []
  }],
  "abstractText": "Diffusions and related random walk procedures are of central importance in many areas of machine learning, data analysis, and applied mathematics. Because they spread mass agnostically at each step in an iterative manner, they can sometimes spread mass “too aggressively,” thereby failing to find the “right” clusters. We introduce a novel Capacity Releasing Diffusion (CRD) Process, which is both faster and stays more local than the classical spectral diffusion process. As an application, we use our CRD Process to develop an improved local algorithm for graph clustering. Our local graph clustering method can find local clusters in a model of clustering where one begins the CRD Process in a cluster whose vertices are connected better internally than externally by an O(log n) factor, where n is the number of nodes in the cluster. Thus, our CRD Process is the first local graph clustering algorithm that is not subject to the well-known quadratic Cheeger barrier. Our result requires a certain smoothness condition, which we expect to be an artifact of our analysis. Our empirical evaluation demonstrates improved results, in particular for realistic social graphs where there are moderately good—but not very good—clusters.",
  "title": "Capacity Releasing Diffusion for Speed and Locality"
}