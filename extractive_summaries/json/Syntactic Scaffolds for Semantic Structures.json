{
  "sections": [{
    "text": "Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 3772–3782 Brussels, Belgium, October 31 - November 4, 2018. c©2018 Association for Computational Linguistics\n3772"
  }, {
    "heading": "1 Introduction",
    "text": "As algorithms for the semantic analysis of natural language sentences have developed, the role of syntax has been repeatedly revisited. Linguistic theories have argued for a very tight integration of syntactic and semantic processing (Steedman, 2000; Copestake and Flickinger, 2000), and many systems have used syntactic dependency or phrase-based parsers as preprocessing for semantic analysis (Gildea and Palmer, 2002; Punyakanok et al., 2008; Das et al., 2014). Meanwhile, some recent methods forgo explicit syntactic processing altogether (Zhou and Xu, 2015; He et al., 2017; Lee et al., 2017; Peng et al., 2017).\nBecause annotated training datasets for semantics will always be limited, we expect that syntax—which offers an incomplete but potentially useful view of semantic structure—will continue to offer useful inductive bias, encouraging semantic models toward better generalization. We address the central question: is there a way for semantic analyzers to benefit from syntax without the computational cost of syntactic parsing?\nWe propose a multitask learning approach to incorporating syntactic information into learned\nrepresentations of neural semantics models (§2). Our approach, the syntactic scaffold, minimizes an auxiliary supervised loss function, derived from a syntactic treebank. The goal is to steer the distributed, contextualized representations of words and spans toward accurate semantic and syntactic labeling. We avoid the cost of training or executing a full syntactic parser, and at test time (i.e., runtime in applications) the semantic analyzer has no additional cost over a syntax-free baseline. Further, the method does not assume that the syntactic treebank overlaps the dataset for the primary task.\nMany semantic tasks involve labeling spans, including semantic role labeling (SRL; Gildea and Jurafsky, 2002) and coreference resolution (Ng, 2010) (tasks we consider in this paper), as well as named entity recognition and some reading comprehension and question answering tasks (Rajpurkar et al., 2016). These spans are usually syntactic constituents (cf. PropBank; Palmer et al., 2005), making phrase-based syntax a natural choice for a scaffold. See Figure 1 for an example sentence with syntactic and semantic annotations. Since the scaffold task is not an end in itself, we relax the syntactic parsing problem to a collection of independent span-level predictions, with no constraint that they form a valid parse tree. This means we never need to run a syntactic parsing algorithm.\nOur experiments demonstrate that the syntactic scaffold offers a substantial boost to state-of-theart baselines for two SRL tasks (§5) and coreference resolution (§6). Our models use the strongest available neural network architectures for these tasks, integrating deep representation learning (He et al., 2017) and structured prediction at the level of spans (Kong et al., 2016). For SRL, the base-\nline itself is a novel globally normalized structured conditional random field, which outperforms the previous state of the art.1 Syntactic scaffolds result in further improvements over prior work— 3.6 absolute F1 in FrameNet SRL, 1.1 absolute F1 in PropBank SRL, and 0.6 F1 in coreference resolution (averaged across three standard scores). Our code is open source and available at https: //github.com/swabhs/scaffolding."
  }, {
    "heading": "2 Syntactic Scaffolds",
    "text": "Multitask learning (Caruana, 1997) is a collection of techniques in which two or more tasks are learned from data with at least some parameters shared. We assume there is only one task about whose performance we are concerned, denoted T1 (in this paper, T1 is either SRL or coreference resolution). We use the term “scaffold” to refer to a second task, T2, that can be combined with T1 during multitask learning. A scaffold task is only used during training; it holds no intrinsic interest beyond biasing the learning of T1, and after learning is completed, the scaffold is discarded.\nA syntactic scaffold is a task designed to steer the (shared) model toward awareness of syntactic\n1This excludes models initialized with deep, contextualized embeddings (Peters et al., 2018), an approach orthogonal to ours.\nstructure. It could be defined through a syntactic parser that shares some parameters with T1’s model. Since syntactic parsing is costly, we use simpler syntactic prediction problems (discussed below) that do not produce whole trees.\nAs with multitask learning in general, we do not assume that the same data are annotated with outputs for T1 and T2. In this work, T2 is defined using phrase-structure syntactic annotations from OntoNotes 5.0 (Weischedel et al., 2013; Pradhan et al., 2013). We experiment with three settings: one where the corpus for T2 does not overlap with the training datasets for T1 (frame-SRL) and two where there is a complete overlap (PropBank SRL and coreference). Compared to approaches which require multiple output labels over the same data, we offer the major advantage of not requiring any assumptions about, or specification of, the relationship between T1 and T2 output."
  }, {
    "heading": "3 Related Work",
    "text": "We briefly contrast the syntactic scaffold with existing alternatives.\nPipelines. In a typical pipeline, T1 and T2 are separately trained, with the output of T2 used to define the inputs to T1 (Wolpert, 1992). Using syntax as T2 in a pipeline is perhaps the most\ncommon approach for semantic structure prediction (Toutanova et al., 2008; Yang and Mitchell, 2017; Wiseman et al., 2016).2 However, pipelines introduce the problem of cascading errors (T2’s mistakes affect the performance, and perhaps the training, of T1; He et al., 2013). To date, remedies to cascading errors are so computationally expensive as to be impractical (e.g., Finkel et al., 2006). A syntactic scaffold is quite different from a pipeline since the output of T2 is never explicitly used.\nLatent variables. Another solution is to treat the output of T2 as a (perhaps structured) latent variable. This approach obviates the need of supervision for T2 and requires marginalization (or some approximation to it) in order to reason about the outputs of T1. Syntax as a latent variable for semantics was explored by Zettlemoyer and Collins (2005) and Naradowsky et al. (2012). Apart from avoiding marginalization, the syntactic scaffold offers a way to use auxiliary syntacticallyannotated data as direct supervision for T2, and it need not overlap the T1 training data.\nJoint learning of syntax and semantics. The motivation behind joint learning of syntactic and semantic representations is that any one task is helpful in predicting the other (Lluı́s and Màrquez, 2008; Lluı́s et al., 2013; Henderson et al., 2013; Swayamdipta et al., 2016). This typically requires joint prediction of the outputs of T1 and T2, which tends to be computationally expensive at both training and test time.\nPart of speech scaffolds. Similar to our work, there have been multitask models that use partof-speech tagging as T2, with transition-based dependency parsing (Zhang and Weiss, 2016) and CCG supertagging (Søgaard and Goldberg, 2016) as T1. Both of the above approaches assumed parallel input data and used both tasks as supervision. Notably, we simplify our T2, throwing away the structured aspects of syntactic parsing, whereas part-of-speech tagging has very little structure to begin with. While their approach results in improved token-level representations learned via supervision from POS tags, these must still be composed to obtain span representations. In-\n2 There has been some recent work on SRL which completely forgoes syntactic processing (Zhou and Xu, 2015), however it has been shown that incorporating syntactic information still remains useful (He et al., 2017).\nstead, our approach learns span-level representations from phrase-type supervision directly, for semantic tasks. Additionally, these methods explore architectural variations in RNN layers for including supervision, whereas we focus on incorporating supervision with minimal changes to the baseline architecture. To the best of our knowledge, such simplified syntactic scaffolds have not been tried before.\nWord embeddings. Our definition of a scaffold task almost includes stand-alone methods for estimating word embeddings (Mikolov et al., 2013; Pennington et al., 2014; Peters et al., 2018). After training word embeddings, the tasks implied by models like the skip-gram or ELMo’s language model become irrelevant to the downstream use of the embeddings. A noteworthy difference is that, rather than pre-training, a scaffold is integrated directly into the training of T1 through a multitask objective.\nMultitask learning. Neural architectures have often yielded performance gains when trained for multiple tasks together (Collobert et al., 2011; Luong et al., 2015; Chen et al., 2017; Hashimoto et al., 2017). In particular, performance of semantic role labeling tasks improves when done jointly with other semantic tasks (FitzGerald et al., 2015; Peng et al., 2017, 2018). Contemporaneously with this work, Hershcovich et al. (2018) proposed a multitask learning setting for universal syntactic dependencies and UCCA semantics (Abend and Rappoport, 2013). Syntactic scaffolds focus on a primary semantic task, treating syntax as an auxillary, eventually forgettable prediction task."
  }, {
    "heading": "4 Syntactic Scaffold Model",
    "text": "We assume two sources of supervision: a corpusD1 with instances x annotated for the primary task’s outputs y (semantic role labeling or coreference resolution), and a treebankD2 with sentences x, each with a phrase-structure tree z."
  }, {
    "heading": "4.1 Loss",
    "text": "Each task has an associated loss, and we seek to minimize the combination of task losses,∑\n(x,y)∈D1 L1(x, y) + δ ∑ (x,z)∈D2 L2(x, z) (1)\nwith respect to parameters, which are partially shared, where δ is a tunable hyperparameter. In\nthe rest of this section, we describe the scaffold task. We define the primary tasks in Sections 5–6.\nEach input is a sequence of tokens, x = 〈x1, x2, . . . , xn〉, for some n. We refer to a span of contiguous tokens in the sentence as xi: j = 〈xi, xi+1, . . . , x j〉, for any 1 6 i 6 j 6 n. In our experiments we consider only spans up to a maximum length D, resulting in O(nD) spans.\nSupervision comes from a phrase-syntactic tree z for the sentence, comprising a syntactic category zi: j ∈ C for every span xi: j in x (many spans are given a null label). We experiment with different sets of labels C (§4.2).\nIn our model, every span xi: j is represented by an embedding vector vi: j (see details in §5.3). A distribution over the category assigned to zi: j is derived from vi: j:\np(zi: j = c | xi: j) = softmax c wc · vi: j (2)\nwhere wc is a parameter vector associated with category c. We sum the log loss terms for all the spans in a sentence to give its loss:\nL2(x, z) = − ∑\n16i6 j6n j−i6D\nlog p(zi: j | xi: j). (3)"
  }, {
    "heading": "4.2 Labels for the Syntactic Scaffold Task",
    "text": "Different kinds of syntactic labels can be used for learning syntactically-aware span representations: • Constituent identity: C = {0, 1}; is a span a\nconstituent, or not? • Non-terminal: c is the category of a span,\nincluding a null for non-constituents. • Non-terminal and parent: c is the category\nof a span, concatenated with the category of its immediate ancestor. null is used for nonconstituents, and for empty ancestors. • Common non-terminals: Since a majority\nof semantic arguments and entity mentions are labeled with a small number of syntactic categories,3 we experiment with a threeway classification among (i) noun phrase (or prepositional phrase, for frame SRL); (ii) any other category; and (iii) null. In Figure 1, for the span “encouraging them”, the constituent identity scaffold label is 1, the nonterminal label is S|VP, the non-terminal and parent label is S|VP+par=PP, and the common nonterminals label is set to OTHER.\n3In the OntoNotes corpus, which includes both syntactic and semantic annotations, 44% of semantic arguments are noun phrases and 13% are prepositional phrases."
  }, {
    "heading": "5 Semantic Role Labeling",
    "text": "We contribute a new SRL model which contributes a strong baseline for experiments with syntactic scaffolds. The performance of this baseline itself is competitive with state-of-the-art methods (§7).\nFrameNet. In the FrameNet lexicon (Baker et al., 1998), a frame represents a type of event, situation, or relationship, and is associated with a set of semantic roles, called frame elements. A frame can be evoked by a word or phrase in a sentence, called a target. Each frame element of an evoked frame can then be realized in the sentence as a sentential span, called an argument (or it can be unrealized). Arguments for a given frame do not overlap.\nPropBank. PropBank similarly disambiguates predicates and identifies argument spans. Targets are disambiguated to lexically specific senses rather than shared frames, and a set of generic roles is used for all targets, reducing the argument label space by a factor of 17. Most importantly, the arguments were annotated on top of syntactic constituents, directly coupling syntax and semantics. A detailed example for both formalisms is provided in Figure 1.\nSemantic structure prediction is the task of identifying targets, labeling their frames or senses, and labeling all their argument spans in a sentence. Here we assume gold targets and frames, and consider only the SRL task.\nFormally, a single input instance for argument identification consists of: an n-word sentence x = 〈x1, x2, . . . , xn〉, a single target span t = 〈tstart, tend〉, and its evoked frame, or sense, f . The argument labeling task is to produce a segmentation of the sentence: s = 〈s1, s2, . . . , sm〉 for each input x. A segment s = 〈i, j, yi: j〉 corresponds to a labeled span of the sentence, where the label yi: j ∈ Y f ∪ {null} is either a role that the span fills, or null if the span does not fill any role. In the case of PropBank, Y f consists of all possible roles. The segmentation is constrained so that argument spans cover the sentence and do not overlap (ik+1 = 1 + jk for sk; i1 = 1; jm = n). Segments of length 1 such that i = j are allowed. A separate segmentation is predicted for each target annotation in a sentence."
  }, {
    "heading": "5.1 Semi-Markov CRF",
    "text": "In order to model the non-overlapping arguments of a given target, we use a semi-Markov conditional random field (semi-CRF; Sarawagi et al., 2004). Semi-CRFs define a conditional distribution over labeled segmentations of an input sequence, and are globally normalized. A single target’s arguments can be neatly encoded as a labeled segmentation by giving the spans in between arguments a reserved null label. Semi-Markov models are more powerful than BIO tagging schemes, which have been used successfully for PropBank SRL (Collobert et al., 2011; Zhou and Xu, 2015, inter alia), because the semi-Markov assumption allows scoring variable-length segments, rather than fixed-length label n-grams as under an (n − 1)-order Markov assumption. Computing the marginal likelihood with a semi-CRF can be done using dynamic programming in O(n2) time (§5.2). By filtering out segments longer than D tokens, this is reduced to O(nD).\nGiven an input x, a semi-CRF defines a conditional distribution p(s | x). Every segment s = 〈i, j, yi: j〉 is given a real-valued score, ψ(〈i, j, yi: j = r〉, xi: j) = wr · vi: j, where vi: j is an embedding of the span (§5.3) and wr is a parameter vector corresponding to its label. The score of the entire segmentation s is the sum of the scores of its segments: Ψ(x, s) = ∑m k=1 ψ(sk, xik: jk ). These scores are exponentiated and normalized to define the probability distribution. The sum-product variant of the semi-Markov dynamic programming algorithm is used to calculate the normalization term (required during learning). At test time, the maxproduct variant returns the most probable segmentation, ŝ = arg max sΨ(s, x).\nThe parameters of the semi-CRF are learned to maximize a criterion related to the conditional loglikelihood of the gold-standard segments in the training corpus (§5.2). The learner evaluates and adjusts segment scores ψ(sk, x) for every span in the sentence, which in turn involves learning embedded representations for all spans (§5.3)."
  }, {
    "heading": "5.2 Softmax-Margin Objective",
    "text": "Typically CRF and semi-CRF models are trained to maximize a conditional log-likelihood objective. In early experiments, we found that incorporating a structured cost was beneficial; we do so by using a softmax-margin training objective (Gimpel and Smith, 2010), a “cost-aware” variant\nof log-likelihood:\nL1 = − ∑\n(x,s∗)∈D1 log\nexp Ψ(s∗, x) Z(x, s∗) , (4)\nZ(x, s∗) = ∑\ns exp {Ψ(s, x) + cost(s, s∗)}. (5)\nWe design the cost function so that it factors by predicted span, in the same way Ψ does:\ncost(s, s∗) = ∑ s∈s cost(s, s∗) = ∑ s∈s I(s < s∗). (6)\nThe softmax-margin criterion, like log-likelihood, is globally normalized over all of the exponentially many possible labeled segmentations. The following zeroth-order semi-Markov dynamic program (Sarawagi et al., 2004) efficiently computes the new partition function:\nα j = ∑\ns=〈i, j,yi: j〉 j−i6D\nαi−1 exp{Ψ(s, x) + cost(s, s∗)}, (7)\nwhere Z = αn, under the base case α0 = 1. The prediction under the model can be calculated using a similar dynamic program with the following recurrence where γ0 = 1:\nγ j = max s=〈i, j,yi: j〉\nj−i6D\nγi−1 exp Ψ(s, x). (8)\nOur model formulation enforces that arguments do not overlap. We do not enforce any other SRL constraints, such as non-repetition of core frame elements (Das et al., 2012)."
  }, {
    "heading": "5.3 Input Span Representation",
    "text": "This section describes the neural architecture used to obtain the span embedding, vi: j, corresponding to a span xi: j and the target in consideration, t = 〈tstart, tend〉. For the scaffold task, since the syntactic treebank does not contain annotations for semantic targets, we use the last verb in the sentence as a placeholder target, wherever target features are used. If there are no verbs, we use the first token in the sentence as a placeholder target. The parameters used to learn v are shared between the tasks.\nWe construct an embedding for the span using • hi and h j: contextualized embeddings for the\nwords at the span boundary (§5.3.1), • ui: j: a span summary that pools over the con-\ntents of the span (§5.3.2), and\n• ai: j: and a hand-engineered feature vector for the span (§5.3.3).\nThis embedding is then passed to a feedforward layer to compute the span representation, vi: j."
  }, {
    "heading": "5.3.1 Contextualized Token Embeddings",
    "text": "To obtain contextualized embeddings of each token in the input sequence, we run a bidirectional LSTM (Graves, 2012) with ` layers over the full input sequence. To indicate which token is a predicate, a linearly transformed one-hot embedding v is used, following Zhou and Xu (2015) and He et al. (2017). The input vector representing the token at position q in the sentence is the concatenation of a fixed pretrained embedding xq and vq. When given as input to the bidirectional LSTM, this yields a hidden state vector hq representing the qth token in the context of the sentence."
  }, {
    "heading": "5.3.2 Span Summary",
    "text": "Tokens within a span might convey different amounts of information necessary to label the span as a semantic argument. Following Lee et al. (2017), we use an attention mechanism (Bahdanau et al., 2014) to summarize each span. Each contextualized token in the span is passed through a feed-forward network to obtain a weight, normalized to give σk = softmax\ni6k6 j whead · hk, where whead\nis a learned parameter. The weights σ are then used to obtain a vector that summarizes the span, ui: j = ∑ i6k6 j; j−i<D σk · hk."
  }, {
    "heading": "5.3.3 Span Features",
    "text": "We use the following three features for each span: • width of the span in tokens (Das et al., 2014) • distance (in tokens) of the span from the tar-\nget (Täckström et al., 2015) • position of the span with respect to the tar-\nget (before, after, overlap) (Täckström et al., 2015)\nEach of these features is encoded as a one-hotembedding and then linearly transformed to yield a feature vector, ai: j."
  }, {
    "heading": "6 Coreference Resolution",
    "text": "Coreference resolution is the task of determining clusters of mentions that refer to the same entity. Formally, the input is a document x = x1, x2, . . . , xn consisting of n words. The goal is to predict a set of clusters c = {c1, c2, . . .}, where each cluster c = {s1, s2, . . .} is a set of spans and\neach span s = 〈i, j〉 is a pair of indices such that 1 6 i 6 j 6 n.\nAs a baseline, we use the model of Lee et al. (2017), which we describe briefly in this section. This model decomposes the prediction of coreference clusters into a series of span classification decisions. Every span s predicts an antecedent ws ∈ Y(s) = {null, s1, s2, . . . , sm}. Labels s1 to sm indicate a coreference link between s and one of the m spans that precede it, and null indicates that s does not link to anything, either because it is not a mention or it is in a singleton cluster. The predicted clustering of the spans can be recovered by aggregating the predicted links.\nAnalogous to the SRL model (§5), every span s is represented by an embedding vs, which is central to the model. For each span s and a potential antecedent a ∈ Y(s), pairwise coreference scores Ψ(vs, va, φ(s, a)) are computed via feedforward networks with the span embeddings as input. φ(s, a) are pairwise discrete features encoding the distance between span s and span a and metadata, such as the genre and speaker information. We refer the reader to Lee et al. (2017) for the details of the scoring function.\nThe scores from Ψ are normalized over the possible antecedents Y(s) of each span to induce a probability distribution for every span:\np(ws = a) = softmax a∈Y(s) Ψ(vs, va, φ(s, a)) (9)\nIn learning, we minimize the negative loglikelihood marginalized over the possibly correct antecedents:\nL1 = − ∑ s∈D log ∑ a∗∈G(s)∩Y(s) p(ws = a∗) (10)\nwhereD is the set of spans in the training dataset, and G(s) indicates the gold cluster of s if it belongs to one and {null} otherwise.\nTo operate under reasonable computational requirements, inference under this model requires a two-stage beam search, which reduces the number of span pairs considered. We refer the reader to Lee et al. (2017) for details.\nInput span representation. The input span embedding, vs for coreference resolution and its syntactic scaffold follow the definition used in §5.3, with the key difference of using no target features. Since there is a complete overlap of input sentences betweenDsc andDpr as the coreference annotations are also from OntoNotes (Pradhan et al.,\n2012), we reuse the v for the scaffold task. Additionally, instead of the entire document, each sentence in it is independently given as input to the bidirectional LSTMs."
  }, {
    "heading": "7 Results",
    "text": "We evaluate our models on the test set of FrameNet 1.5 for frame SRL and on the test set of OntoNotes for both PropBank SRL and coreference. For the syntactic scaffold in each case, we use syntactic annotations from OntoNotes 5.0 (Weischedel et al., 2013; Pradhan et al., 2013).4 Further details on experimental settings and datasets have been elaborated in the supplemental material.\nFrame SRL. Table 1 shows the performance of all the scaffold models on frame SRL with respect to prior work and a semi-CRF baseline (§5.1) without a syntactic scaffold. We follow the official evaluation from the SemEval shared task for frame-semantic parsing (Baker et al., 2007).\nPrior work for frame SRL has relied on predicted syntactic trees, in two different ways: by using syntax-based rules to prune out spans of text that are unlikely to contain any frame’s argument; and by using syntactic features in their statistical model (Das et al., 2014; Täckström et al., 2015; FitzGerald et al., 2015; Kshirsagar et al., 2015).\nThe best published results on FrameNet 1.5 are due to Yang and Mitchell (2017). In their sequential model (seq), they treat argument identification as a sequence-labeling problem using a deep bidirectional LSTM with a CRF layer. In their relational model (Rel), they treat the same problem as a span classification problem. Finally, they introduce an ensemble to integerate both models, and use an integer linear program for inference satisfying SRL constraints. Though their model does not do any syntactic pruning, it does use syntactic features for argument identification and labeling.5\nNotably, all prior systems for frame SRL listed in Table 1 use a pipeline of syntax and semantics. Our semi-CRF baseline outperforms all prior work, without any syntax. This highlights the ben-\n4http://cemantix.org/data/ontonotes.html 5Yang and Mitchell (2017) also evaluated on the full frame-semantic parsing task, which includes frame-SRL as well as identifying frames. Since our frame SRL performance improves over theirs, we expect that incorporation into a full system (e.g., using their frame identification module) would lead to overall benefits as well; this experiment is left to future work.\nefits of modeling spans and of global normalization.\nTurning to scaffolds, even the most coarsegrained constituent identity scaffold improves the performance of our syntax-agnostic baseline. The nonterminal and nonterminal and parent scaffolds, which use more detailed syntactic representations, improve over this. The greatest improvements come from the scaffold model predicting common nonterminal labels (NP and PP, which are the most common syntactic categories of semantic arguments, vs. others): 3.6% absolute improvement in F1 measure over prior work.\nContemporaneously with this work, Peng et al. (2018) proposed a system for joint frame-semantic and semantic dependency parsing. They report results for joint frame and argument identification, and hence cannot be directly compared in Table 1. We evaluated their output for argument identification only; our semi-CRF baseline model exceeds their performance by 1 F1, and our common nonterminal scaffold by 3.1 F1.6\n6This result is not reported in Table 1 since Peng et al. (2018) used a preprocessing which renders the test set slightly larger — the difference we report is calculated using their test set.\nPropBank SRL. We use the OntoNotes data from the CoNLL shared task in 2012 (Pradhan et al., 2013) for Propbank SRL. Table 2 reports results using gold predicates.\nRecent competitive systems for PropBank SRL follow the approach of Zhou and Xu (2015), employing deep architectures, and forgoing the use of any syntax. He et al. (2017) improve on those results, and in analysis experiments, show that constraints derived using syntax may further improve performance. Tan et al. (2018) employ a similar approach but use feed-forward networks with selfattention. He et al. (2018a) use a span-based classification to jointly identify and label argument spans.\nOur syntax-agnostic semi-CRF baseline model improves on prior work (excluding ELMo), showing again the value of global normalization in semantic structure prediction. We obtain further improvement of 0.8 absolute F1 with the best syntactic scaffold from the frame SRL task. This indicates that a syntactic inductive bias is beneficial even when using sophisticated neural architectures.\nHe et al. (2018a) also provide a setup where initialization was done with deep contextualized embeddings, ELMo (Peters et al., 2018), resulting in 85.5 F1 on the OntoNotes test set. The improvements from ELMo are methodologically orthogonal to syntactic scaffolds.\nSince the datasets for learning PropBank semantics and syntactic scaffolds completely overlap, the performance improvement cannot be attributed to a larger training corpus (or, by extension, a larger vocabulary), though that might be a factor for frame SRL.\nA syntactic scaffold can match the performance of a pipeline containing carefully extracted syntactic features for semantic prediction (Swayamdipta et al., 2017). This, along with other recent ap-\nproaches (He et al., 2017, 2018b) show that syntax remains useful, even with strong neural models for SRL.\nCoreference. We report the results on four standard scores from the CoNLL evaluation: MUC, B3 and CEAFφ4 , and their average F1 in Table 3. Prior competitive coreference resolution systems (Wiseman et al., 2016; Clark and Manning, 2016b,a) all incorporate synctactic information in a pipeline, using features and rules for mention proposals from predicted syntax.\nOur baseline is the model from Lee et al. (2017), described in §6. Similar to the baseline model for frame SRL, and in contrast with prior work, this model does not use any syntax.\nWe experiment with the best syntactic scaffold from the frame SRL task. We used NP, OTHER, and null as the labels for the common nonterminals scaffold here, since coreferring mentions are rarely prepositional phrases. The syntactic scaffold outperforms the baseline by 0.6 absolute F1. Contemporaneously, Lee et al. (2018) proposed a model which takes in account higher order inference and more aggressive pruning, as well as initialization with ELMo embeddings, resulting in 73.0 average F1. All the above are orthogonal to our approach, and could be incorporated to yield higher gains."
  }, {
    "heading": "8 Discussion",
    "text": "To investigate the performance of the syntactic scaffold, we focus on the frame SRL results, where we observed the greatest improvement with respect to a non-syntactic baseline.\nWe consider a breakdown of the performance by the syntactic phrase types of the arguments, provided in FrameNet7 in Figure 2. Not surpris-\n7We used FrameNet syntactic phrase annotations for analysis only, and not in our models, since they are annotated only for the gold arguments.\ningly, we observe large improvements in the common nonterminals used (NP and PP). However, the phrase type annotations in FrameNet do not correspond exactly to the OntoNotes phrase categories. For instance, FrameNet annotates nonmaximal (A) and standard adjective phrases (AJP), while OntoNotes annotations for noun-phrases are flat, ignore the underlying adjective phrases. This explains why the syntax-agnostic baseline is able to recover the former while the scaffold is not.\nSimilarly, for frequent frame elements, scaffolding improves performance across the board, as shown in Fig. 3. The largest improvements come for Theme and Goal, which are predominantly realized as noun phrases and prepositional phrases."
  }, {
    "heading": "9 Conclusion",
    "text": "We introduced syntactic scaffolds, a multitask learning approach to incorporate syntactic bias into semantic processing tasks. Unlike pipelines and approaches which jointly model syntax and semantics, no explicit syntactic processing is required at runtime. Our method improves the performance of competitive baselines for semantic role labeling on both FrameNet and PropBank, and for coreference resolution. While our focus was on span-based tasks, syntactic scaffolds could be applied in other settings (e.g., dependency and graph representations). Moreover, scaffolds need not be syntactic; we can imagine, for example, semantic scaffolds being used to improve NLP applications with limited annotated data. It remains an open empirical question to determine the relative merits of different kinds of scaffolds and multitask learners, and how they can be most produc-\ntively combined. Our code is publicly available at https://github.com/swabhs/scaffolding."
  }, {
    "heading": "Acknowledgments",
    "text": "We thank several members of UW-NLP, particularly Luheng He, as well as David Weiss and Emily Pitler for thoughtful discussions on prior versions of this paper. We also thank the three anonymous reviewers for their valuable feedback. This work was supported in part by NSF grant IIS1562364 and by the NVIDIA Corporation through the donation of a Tesla GPU."
  }],
  "references": [{
    "title": "Universal Conceptual Cognitive Annotation (UCCA)",
    "authors": ["Omri Abend", "Ari Rappoport."],
    "venue": "ACL.",
    "year": 2013
  }, {
    "title": "Neural machine translation by jointly learning to align and translate",
    "authors": ["Dzmitry Bahdanau", "Kyunghyun Cho", "Yoshua Bengio."],
    "venue": "ArXiv:1409.0473.",
    "year": 2014
  }, {
    "title": "SemEval’07 Task 19: Frame semantic structure extraction",
    "authors": ["Collin Baker", "Michael Ellsworth", "Katrin Erk."],
    "venue": "Proc. of SemEval.",
    "year": 2007
  }, {
    "title": "The Berkeley FrameNet project",
    "authors": ["Collin F. Baker", "Charles J. Fillmore", "John B. Lowe."],
    "venue": "Proc. of ACL.",
    "year": 1998
  }, {
    "title": "Multitask learning",
    "authors": ["Rich Caruana."],
    "venue": "Machine Learning, 28(1).",
    "year": 1997
  }, {
    "title": "Adversarial multi-criteria learning for chinese word segmentation",
    "authors": ["Xinchi Chen", "Zhan Shi", "Xipeng Qiu", "Xuanjing Huang."],
    "venue": "ArXiv:1704.07556.",
    "year": 2017
  }, {
    "title": "Deep reinforcement learning for mention-ranking coreference models",
    "authors": ["Kevin Clark", "Christopher D Manning."],
    "venue": "Proc. of EMNLP.",
    "year": 2016
  }, {
    "title": "Improving coreference resolution by learning entitylevel distributed representations",
    "authors": ["Kevin Clark", "Christopher D. Manning."],
    "venue": "Proc. of ACL.",
    "year": 2016
  }, {
    "title": "Natural language processing (almost) from scratch",
    "authors": ["Ronan Collobert", "Jason Weston", "Léon Bottou", "Michael Karlen", "Koray Kavukcuoglu", "Pavel Kuksa."],
    "venue": "Journal of Machine Learning Research, 12:2493–2537.",
    "year": 2011
  }, {
    "title": "An open source grammar development environment and broad-coverage English grammar using HPSG",
    "authors": ["Ann Copestake", "Dan Flickinger."],
    "venue": "Proc. of LREC.",
    "year": 2000
  }, {
    "title": "Framesemantic parsing",
    "authors": ["Dipanjan Das", "Desai Chen", "André FT Martins", "Nathan Schneider", "Noah A Smith."],
    "venue": "Computational linguistics, 40(1):9–56.",
    "year": 2014
  }, {
    "title": "An exact dual decomposition algorithm for shallow semantic parsing with constraints",
    "authors": ["Dipanjan Das", "André F.T. Martins", "Noah A. Smith."],
    "venue": "Proc. of *SEM.",
    "year": 2012
  }, {
    "title": "Solving the problem of cascading errors: Approximate bayesian inference for linguistic annotation pipelines",
    "authors": ["Jenny Rose Finkel", "Christopher D Manning", "Andrew Y Ng."],
    "venue": "Proc. of EMNLP.",
    "year": 2006
  }, {
    "title": "Semantic role labeling with neural network factors",
    "authors": ["Nicholas FitzGerald", "Oscar Täckström", "Kuzman Ganchev", "Dipanjan Das."],
    "venue": "Proc. of EMNLP.",
    "year": 2015
  }, {
    "title": "Automatic labeling of semantic roles",
    "authors": ["Daniel Gildea", "Daniel Jurafsky."],
    "venue": "Computational Linguistics, 28(3):245–288.",
    "year": 2002
  }, {
    "title": "The necessity of parsing for predicate argument recognition",
    "authors": ["Daniel Gildea", "Martha Palmer."],
    "venue": "Proc. of ACL.",
    "year": 2002
  }, {
    "title": "Softmaxmargin CRFs: Training log-linear models with cost functions",
    "authors": ["Kevin Gimpel", "Noah A. Smith."],
    "venue": "Proc. of NAACL.",
    "year": 2010
  }, {
    "title": "Supervised Sequence Labelling with Recurrent Neural Networks, volume 385 of Studies in Computational Intelligence",
    "authors": ["Alex Graves."],
    "venue": "Springer.",
    "year": 2012
  }, {
    "title": "Generating sequences with recurrent neural networks",
    "authors": ["Alex Graves."],
    "venue": "ArXiv:1308.0850.",
    "year": 2013
  }, {
    "title": "A joint many-task model: Growing a neural network for multiple NLP tasks",
    "authors": ["Kazuma Hashimoto", "Caiming Xiong", "Yoshimasa Tsuruoka", "Richard Socher."],
    "venue": "Proc. of EMNLP.",
    "year": 2017
  }, {
    "title": "Dynamic feature selection for dependency parsing",
    "authors": ["He He", "Hal Daumé III", "Jason Eisner."],
    "venue": "Proc. of EMNLP.",
    "year": 2013
  }, {
    "title": "Jointly predicting predicates and arguments in neural semantic role labeling",
    "authors": ["Luheng He", "Kenton Lee", "Omer Levy", "Luke Zettlemoyer."],
    "venue": "Proc. of ACL.",
    "year": 2018
  }, {
    "title": "Deep semantic role labeling: What works and what’s next",
    "authors": ["Luheng He", "Kenton Lee", "Mike Lewis", "Luke Zettlemoyer."],
    "venue": "Proc. of ACL.",
    "year": 2017
  }, {
    "title": "Syntax for semantic role labeling, to be, or not to be",
    "authors": ["Shexia He", "Zuchao Li", "Hai Zhao", "Hongxiao Bai."],
    "venue": "Proc. of ACL.",
    "year": 2018
  }, {
    "title": "Multi-lingual joint parsing of syntactic and semantic dependencies with a latent variable model",
    "authors": ["James Henderson", "Paola Merlo", "Ivan Titov", "Gabriele Musillo."],
    "venue": "Computational Linguistics, 39(4):949–998.",
    "year": 2013
  }, {
    "title": "Multitask parsing across semantic representations",
    "authors": ["Daniel Hershcovich", "Omri Abend", "Ari Rappoport."],
    "venue": "Proc. of ACL.",
    "year": 2018
  }, {
    "title": "ADAM: A method for stochastic optimization",
    "authors": ["Diederik P. Kingma", "Jimmy Ba."],
    "venue": "ArXiV:1412.6980.",
    "year": 2014
  }, {
    "title": "Segmental Recurrent Neural Networks",
    "authors": ["Lingpeng Kong", "Chris Dyer", "Noah A. Smith."],
    "venue": "Proc. of ICLR.",
    "year": 2016
  }, {
    "title": "Frame-semantic role labeling with heterogeneous annotations",
    "authors": ["Meghana Kshirsagar", "Sam Thomson", "Nathan Schneider", "Jaime Carbonell", "Noah A Smith", "Chris Dyer."],
    "venue": "Proc. of NAACL.",
    "year": 2015
  }, {
    "title": "End-to-end neural coreference resolution",
    "authors": ["Kenton Lee", "Luheng He", "Mike Lewis", "Luke Zettlemoyer."],
    "venue": "Proc. of EMNLP.",
    "year": 2017
  }, {
    "title": "Higher-order coreference resolution with coarse-tofine inference",
    "authors": ["Kenton Lee", "Luheng He", "Luke Zettlemoyer."],
    "venue": "Proc. of NAACL.",
    "year": 2018
  }, {
    "title": "Joint arc-factored parsing of syntactic and semantic dependencies",
    "authors": ["Xavier Lluı́s", "Xavier Carreras", "Lluı́s Màrquez"],
    "venue": "Transactions of the ACL,",
    "year": 2013
  }, {
    "title": "A joint model for parsing syntactic and semantic dependencies",
    "authors": ["Xavier Lluı́s", "Lluı́s Màrquez"],
    "venue": "In Proc. of CoNLL",
    "year": 2008
  }, {
    "title": "Multi-task sequence to sequence learning",
    "authors": ["Minh-Thang Luong", "Quoc V Le", "Ilya Sutskever", "Oriol Vinyals", "Lukasz Kaiser."],
    "venue": "ArXiv:1511.06114.",
    "year": 2015
  }, {
    "title": "Efficient estimation of word representations in vector space",
    "authors": ["Tomas Mikolov", "Kai Chen", "Gregory S. Corrado", "Jeffrey Dean."],
    "venue": "ArXiv:1301.3781.",
    "year": 2013
  }, {
    "title": "Rectified linear units improve restricted Boltzmann machines",
    "authors": ["Vinod Nair", "Geoffrey E. Hinton."],
    "venue": "Proc. of ICML.",
    "year": 2010
  }, {
    "title": "Improving NLP through marginalization of hidden syntactic structure",
    "authors": ["Jason Naradowsky", "Sebastian Riedel", "David A. Smith."],
    "venue": "Proc. of EMNLP.",
    "year": 2012
  }, {
    "title": "Supervised noun phrase coreference research: The first fifteen years",
    "authors": ["Vincent Ng."],
    "venue": "Proc. of ACL.",
    "year": 2010
  }, {
    "title": "The Proposition Bank: An annotated corpus of semantic roles",
    "authors": ["Martha Palmer", "Daniel Gildea", "Paul Kingsbury."],
    "venue": "Computational Linguistics, 31(1):71–106.",
    "year": 2005
  }, {
    "title": "Deep multitask learning for semantic dependency parsing",
    "authors": ["Hao Peng", "Sam Thomson", "Noah A. Smith."],
    "venue": "Proc. of ACL.",
    "year": 2017
  }, {
    "title": "Learning joint semantic parsers from disjoint data",
    "authors": ["Hao Peng", "Sam Thomson", "Swabha Swayamdipta", "Noah A. Smith."],
    "venue": "Proc. of NAACL.",
    "year": 2018
  }, {
    "title": "GloVe: Global vectors for word representation",
    "authors": ["Jeffrey Pennington", "Richard Socher", "Christopher D. Manning."],
    "venue": "Proc. of EMNLP.",
    "year": 2014
  }, {
    "title": "Deep contextualized word representations",
    "authors": ["Matthew E Peters", "Mark Neumann", "Mohit Iyyer", "Matt Gardner", "Christopher Clark", "Kenton Lee", "Luke Zettlemoyer."],
    "venue": "ArXiv:1802.05365.",
    "year": 2018
  }, {
    "title": "Towards robust linguistic analysis using OntoNotes",
    "authors": ["Sameer Pradhan", "Alessandro Moschitti", "Nianwen Xue", "Hwee Tou Ng", "Anders Björkelund", "Olga Uryupina", "Yuchen Zhang", "Zhi Zhong."],
    "venue": "Proc. of CoNLL.",
    "year": 2013
  }, {
    "title": "CoNLL2012 shared task: Modeling multilingual unrestricted coreference in OntoNotes",
    "authors": ["Sameer Pradhan", "Alessandro Moschitti", "Nianwen Xue", "Olga Uryupina", "Yuchen Zhang."],
    "venue": "Proc. of EMNLP.",
    "year": 2012
  }, {
    "title": "The importance of syntactic parsing and inference in semantic role labeling",
    "authors": ["Vasin Punyakanok", "Dan Roth", "Wen-tau Yih."],
    "venue": "Computational Linguistics, 34(2):257–287.",
    "year": 2008
  }, {
    "title": "SQuAD: 100,000+ questions for machine comprehension of text",
    "authors": ["Pranav Rajpurkar", "Jian Zhang", "Konstantin Lopyrev", "Percy Liang."],
    "venue": "ArXiv:1606.05250.",
    "year": 2016
  }, {
    "title": "Semimarkov conditional random fields for information extraction",
    "authors": ["Sunita Sarawagi", "William W Cohen"],
    "venue": "In Proc. of NIPS,",
    "year": 2004
  }, {
    "title": "Deep multi-task learning with low level tasks supervised at lower layers",
    "authors": ["Anders Søgaard", "Yoav Goldberg."],
    "venue": "Proc. of ACL.",
    "year": 2016
  }, {
    "title": "Training very deep networks",
    "authors": ["Rupesh Kumar Srivastava", "Klaus Greff", "Jürgen Schmidhuber."],
    "venue": "Proc. of NIPS.",
    "year": 2015
  }, {
    "title": "Information structure and the syntax-phonology interface",
    "authors": ["Mark Steedman."],
    "venue": "Linguistic Inquiry, 31(4):649–689.",
    "year": 2000
  }, {
    "title": "Greedy, joint syntacticsemantic parsing with Stack LSTMs",
    "authors": ["Swabha Swayamdipta", "Miguel Ballesteros", "Chris Dyer", "Noah A. Smith."],
    "venue": "Proc. of CoNLL.",
    "year": 2016
  }, {
    "title": "Frame-semantic parsing with softmax-margin segmental rnns and a syntactic scaffold",
    "authors": ["Swabha Swayamdipta", "Sam Thomson", "Chris Dyer", "Noah A. Smith."],
    "venue": "Arxiv:1706.09528.",
    "year": 2017
  }, {
    "title": "Efficient inference and structured learning for semantic role labeling",
    "authors": ["Oscar Täckström", "Kuzman Ganchev", "Dipanjan Das."],
    "venue": "Transactions of the ACL, 3:29–41.",
    "year": 2015
  }, {
    "title": "Deep semantic role labeling with self-attention",
    "authors": ["Zhixing Tan", "Mingxuan Wang", "Jun Xie", "Yidong Chen", "Xiaodong Shi."],
    "venue": "Proc. of AAAI.",
    "year": 2018
  }, {
    "title": "A global joint model for semantic role labeling",
    "authors": ["Kristina Toutanova", "Aria Haghighi", "Christopher D. Manning."],
    "venue": "Computational Linguistics, 34(2):161–191.",
    "year": 2008
  }, {
    "title": "OntoNotes release 5.0 ldc2013t19",
    "authors": ["Ralph Weischedel", "Martha Palmer", "Mitchell Marcus", "Eduard Hovy", "Sameer Pradhan", "Lance Ramshaw", "Nianwen Xue", "Ann Taylor", "Jeff Kaufman", "Michelle Franchini"],
    "year": 2013
  }, {
    "title": "Learning global features for coreference resolution",
    "authors": ["Sam Wiseman", "Alexander M Rush", "Stuart M Shieber."],
    "venue": "Proc. of NAACL.",
    "year": 2016
  }, {
    "title": "Stacked generalization",
    "authors": ["David H Wolpert."],
    "venue": "Neural networks, 5(2):241–259.",
    "year": 1992
  }, {
    "title": "A joint sequential and relational model for frame-semantic parsing",
    "authors": ["Bishan Yang", "Tom Mitchell."],
    "venue": "Proc. of EMNLP.",
    "year": 2017
  }, {
    "title": "Learning to map sentences to logical form: Structured classification with probabilistic categorial grammars",
    "authors": ["Luke S Zettlemoyer", "Michael Collins."],
    "venue": "Proc. of UAI.",
    "year": 2005
  }, {
    "title": "Stackpropagation: Improved representation learning for syntax",
    "authors": ["Yuan Zhang", "David Weiss."],
    "venue": "Proc. of ACL.",
    "year": 2016
  }, {
    "title": "End-to-end learning of semantic role labeling using recurrent neural networks",
    "authors": ["Jie Zhou", "Wei Xu."],
    "venue": "Proc. of ACL.",
    "year": 2015
  }],
  "id": "SP:bb438e42ccc46b63766c59b2265f18a42d49d014",
  "authors": [{
    "name": "Swabha Swayamdipta",
    "affiliations": []
  }, {
    "name": "Sam Thomson",
    "affiliations": []
  }, {
    "name": "Kenton Lee",
    "affiliations": []
  }, {
    "name": "Luke Zettlemoyer",
    "affiliations": []
  }, {
    "name": "Chris Dyer",
    "affiliations": []
  }, {
    "name": "Noah A. Smithr",
    "affiliations": []
  }],
  "abstractText": "We introduce the syntactic scaffold, an approach to incorporating syntactic information into semantic tasks. Syntactic scaffolds avoid expensive syntactic processing at runtime, only making use of a treebank during training, through a multitask objective. We improve over strong baselines on PropBank semantics, frame semantics, and coreference resolution, achieving competitive performance on all three tasks.",
  "title": "Syntactic Scaffolds for Semantic Structures"
}