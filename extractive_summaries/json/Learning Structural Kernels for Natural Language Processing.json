{
  "sections": [{
    "heading": "1 Introduction",
    "text": "Kernel-based methods are a staple machine learning approach in Natural Language Processing (NLP). Frequentist kernel methods like the Support Vector Machine (SVM) pushed the state of the art in many NLP tasks, especially classification and regression. One interesting aspect of kernels is their ability to be defined directly on structured objects like strings, trees and graphs. This approach has the potential to move the modelling effort from feature engineering to kernel engineering. This is useful when we do not have much prior knowledge about how the data\nbehaves, as we can more readily define a similarity metric between inputs instead of trying to characterize which features are the best for the task at hand.\nKernels are a very flexible framework: they can be combined and parameterized in many different ways. Complex kernels, however, lead to the problem of model selection, where the aim is to obtain the best kernel configuration in terms of hyperparameter values. The usual approach for model selection in frequentist methods is to employ grid search on some development data disjoint from the training data. This approach can rapidly become impractical when using complex kernels which increase the number of model hyperparameters. Grid search also requires the user to explicitly set the grid values, making it difficult to fine tune the hyperparameters. Recent advances in model selection tackle some of these issues, but have several limitations (see §6 for details).\nOur proposed approach for model selection relies on Gaussian Processes (GPs) (Rasmussen and Williams, 2006), a widely used Bayesian kernel machine. GPs allow efficient and fine-grained model selection by maximizing the evidence on the training data using gradient-based methods, dropping the requirement for development data. As a Bayesian procedure, GPs also naturally balance between model capacity and generalization. GPs have been shown to achieve state of the art performance in various regression tasks (Hensman et al., 2013; Cohn and Specia, 2013). Therefore, we base our approach on this framework.\nWhile prediction performance is important to consider (as we show in our experiments), we are\n461\nTransactions of the Association for Computational Linguistics, vol. 3, pp. 461–473, 2015. Action Editor: Stefan Riezler. Submission batch: 2/2015; Revision batch 7/2015; Published 8/2015.\nc©2015 Association for Computational Linguistics. Distributed under a CC-BY 4.0 license.\nmainly interested in two other significant aspects that are enabled by our approach:\n• Gradient-based methods are more efficient than grid search for high dimensional spaces. This allows us to easily propose new rich kernel extensions that rely on a large number of hyperparameters, which in turn can result in better modelling capacity.\n• Since the model selection process is now finegrained, we can interpret the resulting hyperparameter values, depending on how the kernel is defined.\nIn this work we focus on tree kernels, which have been successfully used in a number of NLP tasks (see §6). In most cases, these kernels are used as an SVM component and model selection is not considered an important issue. Hyperparameters are usually set to default values, which work reasonably well in terms of prediction performance. However, this is only possible due to the small number of hyperparameters these kernels contain.\nWe perform experiments comprising synthetic data (§4) and two real NLP regression tasks: Emotion Analysis (§5.1) and Translation Quality Estimation (§5.2). Our findings show that our approach outperforms SVMs using the same kernels."
  }, {
    "heading": "2 Gaussian Process Regression",
    "text": "Our definition of GPs closely follows that of Rasmussen and Williams (2006). Consider a setting where we have a dataset X = {(x1, y1), (x2, y2), . . . , (xn, yn)}, where xi is a ddimensional input and yi the corresponding output. Our goal is to infer an underlying function f : Rd → R to explain this data, i.e. f(xi) ≈ yi. Formally, f is drawn from a GP prior,\nf(x) ∼ GP(µ(x), k(x,x′)),\nwhere µ(x) is the mean function, which is usually the 0 constant, and k(x,x′) is the kernel function.\nIn a regression setting, we assume that the response variables are noisy latent function evaluations, i.e., yi = f(xi) + η, where η ∼ N (0, σ2n) is added white noise. We assume a Gaussian likelihood, which allows us to obtain a closed formula\nsolution for the posterior, namely\ny∗ ∼ N (k∗(K + σnI)−1yT , k(x∗,x∗)− kT∗ (K + σnI)−1k∗),\nwhere x∗ and y∗ are respectively the test input and its response variable, K is the Gram matrix corresponding to the training inputs and k∗ = [〈x1,x∗〉, 〈x2,x∗〉, . . . , 〈xn,x∗〉] is the vector of kernel evaluations between the test input and each training input.\nA key property of GP models is their ability to perform efficient model selection. This is achieved by employing gradient-based methods to maximize the marginal likelihood,\np(y|X,θ) = ∫ p(y|X,θ, f)p(f)df,\nwhere θ represents the vector of model hyperparameters and y is the vector of response variables from the training data. For a Gaussian likelihood, we can take the log of the expression above to obtain in closed-form1,\nlog p(y|X,θ) =\n−1 2 yTG−1y\n︸ ︷︷ ︸ data fit\n−1 2\nlog |G| ︸ ︷︷ ︸\ncomplexity penalty\n−n 2\nlog 2π ︸ ︷︷ ︸\nconstant\nwhere G = K+σnI. The data fit term is dependent on the training response variables, while the complexity penalty term relies only on the kernel and training inputs. Since the first two terms have conflicting objectives, optimizing the log marginal likelihood will naturally achieve a compromise and thus limit overfitting (without the need for any validation step or additional data).\nTo enable gradient-based optimization we need to derive the gradients w.r.t. the hyperparameters:\n∂ ∂θj log p(y|X,θ) =1 2 yTG−1 ∂G ∂θj G−1y\n− 1 2\ntrace ( G−1 ∂G\n∂θj\n) .\n1See Rasmussen and Williams (2006, pp. 113-114) for details on the derivation of this formula and also its correspondent gradient calculation.\nThe gradients of G depend on the underlying kernel. Therefore we can employ any kind of valid kernel in this procedure as long as its gradients can be computed. This not only allows for fine-tuning of hyperparameters but also allows for kernel extensions which are richly parameterized."
  }, {
    "heading": "3 Tree Kernels",
    "text": "The seminal work on Convolution Kernels by Haussler (1999) defines a broad class of kernels on discrete structures by counting and weighting the number of substructures they share. Applying Haussler’s formulation to trees we reach a general formula for a tree kernel between two trees t1 and t2, namely\nk(t1, t2) = ∑\nf∈F w(f)c1(f)c2(f), (1)\nwhere F is the set of all tree fragments, c1(f) and c2(f) return the counts for fragment f in trees t1 and t2, respectively, and w(f) assigns a weight to fragment f . In other words, we can consider the kernel a weighted dot product over vectors of fragment counts. The actual fragment set F is deliberately left undefined: different concepts of tree fragments define different tree kernels.\nIn this paper, we will focus on Subset Tree Kernels (henceforth SSTK), first introduced by Collins and Duffy (2001). This kernel considers tree fragments that contains complete grammar rules (see Figure 1 for an example). Consider the set of nodes in the two trees as N1 and N2 respectively. We define Ii(n) as an indicator function that returns 1 if fragment fi ∈ F has root n and 0 otherwise. A SSTK can then be defined as:\nk(t1, t2) = ∑\nn1∈N1\n∑\nn2∈N2 ∆(n1, n2) , (2)\nwhere ∆(n1, n2) = |F|∑\ni=1\nλ s(i) 2 Ii(n1)Ii(n2)\nand s(i) is the number of fragments in i with at least one child2.\nThe formulation in Equation 2 is the same as the one shown in Equation 1, except that we are now restricting the weights w(f) to be a function of a\n2See Pighin and Moschitti (2010) for details and a proof on this derivation.\nhyperparameter λ. The original goal of λ is to act as a decay factor that penalizes contributions from larger fragments cf smaller ones (and therefore, it should be in the [0, 1] interval). Without this factor, the resulting distribution over tree pairs is skewed, giving extremely large values when trees are equal and rapidly decreasing for small differences over fragment counts. The decay factor helps to spread this distribution, effectively giving smaller weights to larger fragments.\nThe function ∆ can be defined recursively,\n∆(n1, n2) =    0 pr(n1) 6= pr(n2) λ pr(n1) = pr(n2) ∧\npreterm(n1) λg(n1, n2) otherwise,\nwhere pr(n) is the grammar production at node n and preterm(n) returns true if n is a pre-terminal node. The function g is defined as follows:\ng(n1, n2) =\n|n1|∏\ni=1\n(α+ ∆(cin1 , c i n2)) , (3)\nwhere |n| is the number of children of node n and cin is the i\nth child of node n. This recursive definition is calculated efficiently by employing dynamic programming to cache intermediate ∆ results.\nEquation 3 also adds another hyperparameter, α. This hyperparameter was introduced by Moschitti (2006b)3 as a way to select between two different tree kernels. If α = 1, we get the original SSTK, if α = 0, then we obtain the Subtree Kernel, which only allows fragments with terminal symbols\n3In his original formulation, this hyperparameter was named σ but here we use α to not confuse it with the GP noise hyperparameter.\nas leaves. We can also interpret the Subtree Kernel as a “sparse” version of the SSTK, where the “nonsubtree” fragments have their weights equal to zero.\nEven though fragment weights are affected by both kernel hyperparameters, previous work did not discuss their effects. The usual procedure fixes α to 1 (selecting the original SSTK) and sets λ to a default value (around 0.4). As explained in §2, the GP model selection procedure enables us to learn finegrained values for these hyperparameters, which can lead to better performing models and aid interpretation. Furthermore, it also allows us to extend these kernels by adding new hyperparameters. We propose one such kernel in the next Section."
  }, {
    "heading": "3.1 Symbol-aware Subset Tree Kernel",
    "text": "While varying the SSTK hyperparameters can lead to different weight schemes, they do that in a very coarse way. For some applications, it may be necessary to give more weight to specific fragments or set of fragments (e.g., NPs being more important than ADVP in an information extraction setting). The Symbol-aware Subset Tree Kernel (henceforth, SASSTK), which we introduce here, allows a more fine-grained control over the weights by employing one λ and one α hyperparameter for each non-terminal symbol in the training data. The calculation uses a similar recursive formula to the SSTK, namely:\n∆(n1, n2) =    0 pr(n1) 6= pr(n2) λx pr(n1) = pr(n2) ∧\npreterm(n1) λxgx(n1, n2) otherwise,\nwhere x is the symbol at node n1 and\ngx(n1, n2) =\n|n1|∏\ni=1\n(αx + ∆(c i n1 , c i n2)) . (4)\nThe SASSTK can be interpreted as a generalization of the SSTK: we can recover the latter by tying all λ and setting all α = 1. By employing different hyperparameter values for each specific symbol, we can effectively modify the weights of all fragments where the symbol appears. Table 1 shows an example where we unrolled a kernel computation into its corresponding feature space, showing the resulting weighted counts for each feature."
  }, {
    "heading": "3.2 Kernel Gradients",
    "text": "To enable hyperparameter optimization via gradient descent we must provide gradients for the kernels. In this Section we derive the gradients for SASSTK.\nFrom Equation 2 we know that the kernel is a double summation over the ∆ function. Therefore all gradients are also double summations, but over the gradients of ∆. We can obtain these in a vectorized way, by considering the gradients of the hyperparameter vectors λ and α over ∆. Let k be the number of symbols considered in the model and λ and α be k-dimensional vectors containing the respective hyperparameters.\nIn the following, we use the notation ∆i as a shorthand for ∆(cin1 , c i n2) and we also omit the parameters of gx. We start with the λ gradient:\n∂∆ ∂λ =    0 pr(n1) 6= pr(n2) u pr(n1) = pr(n2) ∧ preterm(n1) ∂(λxgx)\n∂λ otherwise,\nwhere x is the symbol at n1, gx is defined in Equation 4 and u is the k-dimensional unit vector with the element corresponding to symbol x equal to 1 and all others equal to 0. The gradient in the third case is defined recursively,\n∂(λxgx)\n∂λ = ugx + λx ∂gx ∂λ\n= ugx + λx\n|n1|∑\ni=1\ngx αx + ∆i ∂∆i ∂λ .\nThe α gradient is derived in a similar way,\n∂∆ ∂α =    0 pr(n1) 6= pr(n2) ∨ preterm(n1)\n∂(λxgx) ∂α otherwise,\nand the gradient at the second case is also defined recursively,\n∂(λxgx)\n∂α = λx ∂gx ∂α\n= λx\n|n1|∑\ni=1\ngx αx + ∆i\n( u+\n∂∆i ∂α\n) .\nGradients can be efficiently obtained using dynamic programming. In fact, they can be calculated at the same time as ∆ to improve performance since they all share many terms in their derivations. Finally, we can easily obtain the gradients for the original SSTK by letting u = 1."
  }, {
    "heading": "3.3 Kernel Normalization",
    "text": "It is common practice when using tree kernels to normalize the kernel. This helps reduce the random effect of tree size. Normalization can be achieved using the following, where k̂ is the normalized kernel:\nk̂(t1, t2) = k(t1, t2)√\nk(t1, t1)k(t2, t2) .\nTo apply this normalized version in the optimization procedure we must also derive gradients for the normalization function. In the following equation, we use kij and k̂ij as a shorthand for k(ti, tj) and k̂(ti, tj), respectively:\n∂k̂12 ∂θ = ∂k12 ∂θ√ k11k22 − k̂12 ∂k11 ∂θ k22 + k11 ∂k22 ∂θ 2k11k22 ."
  }, {
    "heading": "3.4 Other Extensions",
    "text": "Many other structural kernels rely on recursive definitions and dynamic programming to perform their calculations. Examples include other tree kernels like the Partial Tree Kernel (Moschitti, 2006a) and string kernels like the ones defined on character ngrams (Lodhi et al., 2002) or word sequences (Cancedda et al., 2003). While in this paper we focus\non the SSTK (and our proposed SASSTK), our approach can easily be extended to these other kernels, as long as all the corresponding recursive definitions are differentiable."
  }, {
    "heading": "4 Synthetic Data Experiments",
    "text": "A natural question that arises in the proposed method is how much data is needed to accurately learn the kernel hyperparameters. To answer this question, we run a set of experiments using synthetic data. We generate this data by using a set of 1000 natural language syntactic trees, where we fix a random subset of 200 instances for testing and use the remaining 800 instances as training. For each training set size we define a GP over the full dataset, sample a function from it and use the function output as the response variable for each tree. We try two different GP priors, one using the SSTK and another one using the SASSTK.\nThe conditions above provide a controlled environment to check the modelling capacities of our approach since we know the exact distribution where the data comes from. The reasoning behind these experiments is that to be able to provide benefits in real tasks, where the data distribution is not known, our models have to be learnable in this controlled setting as well using a reasonable amount of data.\nFinally, we also provide an empirical evaluation comparing the speed performance between our approach and grid search."
  }, {
    "heading": "4.1 SSTK Prior",
    "text": "Our first experiments use a SSTK as the kernel with λ = 0.001, α = 1 and σ2n = 0.01. After obtaining the input trees and their sampled labels, we define a new GP model using only the training data plus the obtained response variables, this time using a SSTK with randomized hyperparameter values. Then we optimize the GP and check if the learned hyperparameters are close to the original ones, using 10 random restarts to limit the effect of local optima. We also use the optimized GP to predict response variables on the test set and measure Root Mean Squared Error (RMSE). Our hypothesis is that with a reasonable sample size we can retrieve the original hyperparameter values and obtain low RMSE. For each training set size, we repeat the experiment 20 times.\nFigure 2 shows the results of these experiments. For small sizes the variance in the resulting hyperparameter values is large but as soon as we reach 200 instances we are able to retrieve the original values with high confidence. In other words, in an ideal setting 200 instances are enough to learn the kernel. It is also interesting to note that test RMSE after optimization steadily decreases as we increase training data size. This shows that if one is more interested in predictions themselves, it is still worth optimizing hyperparameters even if the training data is small."
  }, {
    "heading": "4.2 SASSTK Prior",
    "text": "The large number of hyperparameters of the SASSTK makes it more prone to optimization and overfitting issues when compared to the SSTK. This raises the question of how much data is needed to justify its use. To address this question, we run similar experiments to those above for the SSTK, except that now we sample from a GP using a SASSTK as the kernel.\nInstead of optimizing all hyperparameters freely we use a simpler version where we tie λ and α for each symbol to the same value, except for the symbol ’S’. Effectively this version has one extra λ and one extra α (henceforth λS and αS) when compared to the SSTK. The GP prior hyperparameter values are set to λ = 0.001, λS = 0.5, α = 0.1, αS = 1 and σ2n = 0.01. For each training set size, we train two GPs, one using this SASSTK and one using the original SSTK, optimize them using 10 random restarts and measure RMSE on the test set.\nResults are shown in Figure 3. For all training set sizes the SASSTK reaches lower RMSE than SSTK, with a substantial difference after reaching 100 instances. This shows that even for small datasets our proposed kernel manages to capture aspects which can not be explained by the original SSTK. Note that this is an ideal setting, and real datasets may need to be larger to realize gains from SASSTK. Nevertheless, these are promising results since they give evidence of a small lower bound on the dataset size for SASSTK to be effective."
  }, {
    "heading": "4.3 Performance Experiments",
    "text": "To provide an overview of how efficient is the gradient-based method compared to grid search we also run a set of experiments measuring wall clock training time vs. RMSE on a test set. For both GP and SVM models we employ the SSTK as the kernel and we use the same synthetic data from the previous experiments4. We perform 20 runs, keeping the test set as the same 200 instances for all runs and randomly sampling 200 instances from the remaining instances as training data.\nFigure 4 shows the curves for both GP and SVM models. The GP curve is obtained by increasing the maximum number of iterations of the gradient-based method (in this case, L-BFGS) and the SVM curve is obtained by increasing the granularity of the grid size.\nWe can see that optimizing the GP model is consistently much faster than doing grid search on the SVM model (notice the logarithmic scale), even though it shows some variance when letting L-BFGS run for a larger number of iterations. The GP model also is able to better predictions in general. Even when taking the variances into account, grid search would still need around 10 times more computation\n4For specific details on the SVM models used in all experiments performed in this paper we refer the reader to Appendix A.\ntime to achieve the same predictions obtained by the GP model. In real settings, SVMs predictions tend to be more on par with the ones provided by a GP (as shown in §5) but nevertheless these figures show that the GP can be much more time efficient when optimizing hyperparameters of a tree kernel.\nAn important performance aspect to take into account is parallelization. Grid search is embarassingly parallelizable since each grid point can run in a different core. However, the GP optimization can also benefit from multiple cores by running each kernel computation inside the Gram matrix in parallel. To keep the comparisons simpler, the results shown in this section use a single core but all experiments in §5 employ parallelization in the Gram matrix computation level (for both SVM and GP models)."
  }, {
    "heading": "5 NLP Experiments",
    "text": "Our experiments with NLP data address two regression tasks: Emotion Analysis and Quality Estimation. For both tasks, we use the Stanford parser (Manning et al., 2014) to obtain constituency trees for all sentences. Also, rather than using data official splits, we perform 5-fold cross-validation in order to obtain more reliable results."
  }, {
    "heading": "5.1 Emotion Analysis",
    "text": "The goal of Emotion Analysis is to automatically detect emotions in a text (Strapparava and Mihalcea, 2008). This problem is closely related to Opinion Mining (Pang and Lee, 2008), with similar applications, but it is usually done at a more fine-grained level and involves the prediction of a set of labels for each text (one for each emotion) instead of a single label.\nBeck et al. (2014a) used a multi-task GP for this task with a bag-of-words feature representation. In theory, it is possible to combine their multi-task kernel with our tree kernels, but to keep the focus of the experiments on testing tree kernel approaches, here we use independently trained models, one per emotion.\nDataset We use the dataset provided by the “Affective Text” shared task in SemEval2007 (Strapparava and Mihalcea, 2007), which is composed of 1000 news headlines annotated in terms of six emotions: Anger, Disgust, Fear, Joy, Sadness and Sur-\nprise. For each emotion, a score between 0 and 100 is given, 0 meaning total lack of emotion and 100, maximally emotional. Scores are mean-normalized before training the models.\nModels We perform experiments using the following tree kernels:\n• SSTK: the SSTK formulation introduced by Moschitti (2006b);\n• SASSTKfull: our proposed Symbol-Aware SSTK;\n• SASSTKS: same as before, but using only two λ and two α hyperparameters: one for symbols corresponding to full sentences5 and another for all other symbols. This configuration is similar to that in Section 4.2.\nFor all kernels, we also use a variation fixing the α hyperparameters to 1 to emulate the original SSTK.\nBaselines and evaluation Our results are compared against three baselines:\n• SVM SSTK: a SVM using an SSTK kernel.\n• SVM BOW: same as before, but using an RBF kernel with a bag-of-words representation.\n• GP BOW: same as SVM BOW but using a GP instead.\nThe SVM models are trained using a wrapper for LIBSVM6 (Chang and Lin, 2001) provided by the scikit-learn toolkit7 (Pedregosa et al., 2011) and optimized via grid search. Following previous work, we use Pearson’s correlation coefficient as evaluation metric. Pearson’s scores are obtained by concatenating all six emotions outputs together.\nTable 2 shows the results. The best GP model with tree kernels outperforms the SVMs, showing that the fine-grained model selection procedure provided by the GP models is helpful when dealing with tree kernels. However, using the SASSTK models do not help in the case of free α and the SASSTKfull actually performs worse than the original SSTK,\n5In this dataset, symbols are S, SQ, SBARQ and SINV . 6http://www.csie.ntu.edu.tw/˜cjlin/\nlibsvm 7http://scikit-learn.org\neven though the optimized marginal likelihood was higher. This is evidence that the SASSTKfull model is overfitting the training data, probably due to its large number of hyperparameters.\nAnother interesting finding in Table 2 is that fixing the α values often harms performance. Inspecting the free α models showed that the values found by the optimizer were very close to zero. This indicates that the model selection procedure prefer towards giving smaller weights to incomplete tree fragments. We can interpret this as the model selecting a more lexicalized feature space, which also explains why the GP RBF model on bag-of-words performed the best in this task.\nFinally, to understand how the optimized kernels could provide more interpretability, Table 3 shows the top 15 λ values obtained by the SASSTKfull (fixed α variant) with their corresponding symbols. In this specific case the kernel does not give the best performance so there are limitations in doing a full linguistic analysis. Nevertheless, we believe this example shows the potential for developing more interpretable kernels. This is especially interesting because these models take into account a much richer feature space than what it is allowed by parametric models."
  }, {
    "heading": "5.2 Quality Estimation",
    "text": "The goal of Quality Estimation is to provide a quality prediction for new, unseen machine translated texts (Blatz et al., 2004; Bojar et al., 2014). Exam-\nples of applications include filtering machine translated sentences that would require more post-editing effort than translation from scratch (Specia et al., 2009), selecting the best translation from different MT systems (Specia et al., 2010) or between an MT system and a translation memory (He et al., 2010), and highlighting segments that need revision (Bach et al., 2011). While various quality metrics exist, here we focus on post-editing time prediction.\nTree kernels have been used before in this task (with SVMs) by Hardmeier (2011) and Hardmeier et al. (2012). While their best models combine tree kernels with a set of explicit features, they also show good results using only the tree kernels. This makes Quality Estimation a good benchmark task to test our models.\nDatasets We use two publicly available datasets containing post-edited machine translated sentences. Both are composed of a set of source sentences, their machine translated outputs and the corresponding post-editing time.\n• French-English (fr-en): This dataset, described in (Specia, 2011), contains 2524 French sentences translated into English and postedited by a novice translator.\n• English-Spanish (en-es): This dataset was used in the WMT14 Quality Estimation shared task (Bojar et al., 2014), containing 858 sentences translated from English into Spanish and post-edited by an expert translator.\nFor each dataset, post-editing times are first divided by the translation output length (obtaining the post-editing time per word) and then mean normalized.\nModels Since our data consists of pairs of trees, our models in this task use a pair of tree kernels. We combine these two kernels by either summing or multiplying them. As for underlying tree kernels, we try both SSTK and SASSTKS . As in the Emotion Analysis task, we also experiment with a set of kernel configurations with the α hyperparameters fixed at 1. We also test models that combine our tree kernels with an RBF kernel on a set of 17 features extracted using the QuEst framework (Specia et al., 2013). These features are part of a strong baseline model used by the WMT14 shared task.\nBaselines and evaluation We compare our results with a number of SVM models:\n• SVM SSTK: same as in the Emotion Analysis task, using either a sum (+) or a product (×) of SSTKs.\n• SVM RBF: this is an SVM trained on the 17 features extracted by Quest.\n• SVM RBF SSTK: a combination of the two models above.\nFor further comparison, we also show results obtained using a GP model and an RBF kernel on the QuEst-only features. Following previous work, we measure prediction performance using both Mean Absolute Error (MAE) and RMSE.\nThe prediction results are given in Table 4. They indicate a number of interesting findings:\n• For the fr-en dataset, the GP models combining tree kernels with an RBF kernel outperform all other models. Results for the en-es dataset are less consistent, probably due to the small size of the dataset, but on average they are better than their SVM counterparts.\n• The SVMs using a combination of kernels performs worse than using the RBF kernel alone. Inspecting the models, we found that grid search actually harms performance. For instance, for the fr-en dataset, MAE and RMSE for the RBF + SSTK × model before grid search are 0.4681 and 0.6016, respectively. On the other hand, for this dataset all GP models achieve better results after optimization.\n• Unlike in the Emotion Analysis task, fixing α results in better performance, even though the resulting models have lower marginal likelihood than the ones with free α. The same effect happened when comparing the SASSTK models with the SSTK ones for the en-es dataset. Both cases are evidence of model overfitting.\nWe also inspect the resulting hyperparameters to obtain insights about the features used by the model. Table 5 shows the optimized λ values for the GP SSTK models with fixed α for the fr-en dataset. The λ values obtained are higher for the target sentence kernels than for the source sentence ones. We can interpret this as the model giving preference to features from the target trees instead of the source trees, which is what we would expect for this task."
  }, {
    "heading": "5.3 Overfitting",
    "text": "Both NLP tasks show evidence that the GP models with large number of hyperparameters (SASSTKfull in the case of Emotion Analysis and the free α models in Quality Estimation) are overfitting the corresponding datasets. While the Bayesian formula-\ntion for the marginal likelihood does help limiting overfitting, it does not prevent it completely. Small datasets or invalid assumptions about the Gaussian distribution of the data may still lead to poorly fitting models. Another means of reducing overfitting is by taking a fully Bayesian approach in which hyperparameters are considered as random variables and are marginalized out (Osborne, 2010); this is a research direction we plan to pursue in the future.8"
  }, {
    "heading": "5.4 Extensions to Other Tasks",
    "text": "The GP framework introduced in Section 2 can be extended to non-regression problems by changing the likelihood function. For instance, models for classification (Rasmussen and Williams, 2006, Chap. 3), ordinal regression (Chu and Ghahramani, 2005) and structured prediction (Altun et al., 2004; Bratières et al., 2013) were proposed in the literature. Since the likelihood is independent of the kernel, a natural future step is to apply the kernels and models introduced in this paper to different NLP tasks.\nIn light of that, we did initial experiments with constituency parsing reranking.9 The first results were inconclusive but we do believe this is because we employed naive approaches using classification (1-best result vs. all) and regression (using PARSEVAL metrics as the response variable) models. A more appropriate way to tackle this task is by employing a reranking-based likelihood and this is a direction we plan to pursue in the future."
  }, {
    "heading": "6 Related Work",
    "text": "Interest in model selection procedures for kernelbased methods has been growing in the last years.\n8See also Rasmussen and Williams (2006, Chap. 5) for an in-depth discussion on this issue.\n9We thank the anonymous reviewers for this suggestion.\nOne widely used approach for that is Multiple Kernel Learning (MKL) (Gönen and Alpaydın, 2011). MKL is based on the idea of using combinations of kernels to model the data and developing algorithms to tune the kernel coefficients. This is different from our method, where we focus on learning the hyperparameters of a single structural kernel. An approach similar to ours was proposed by Igel et al. (2007). They combine oligo kernels (a kind of ngram kernel) with MKL, derive their gradients and optimize towards a kernel alignment metric. Compared to our approach, they restrict the length of the n-grams being considered, while we rely on dynamic programming to explore the whole substructure space. Also, their method does not take into account the underlying learning algorithm. Another recent approach proposed for model selection is random search (Bergstra and Bengio, 2012). Like grid search, it has the drawback of not employing gradient information, as it is designed for any kind of hyperparameters (including categorical ones).\nStructural kernels have been successfully employed in a number of NLP tasks. The original SSTK proposed by Collins and Duffy (2001) was used to rerank the output of syntactic parsers. Recently, this reranking idea was also applied to discourse parsing (Joty and Moschitti, 2014). Other tree kernel applications include Semantic Role Labelling (Moschitti et al., 2008) and Relation Extraction (Plank and Moschitti, 2013). String kernels were mostly used in Text Classification (Lodhi et al., 2002; Cancedda et al., 2003), while graph kernels have been used for recognizing Textual Entailment (Zanzotto and Dell’Arciprete, 2009). However, these previous works focused on frequentist methods like SVM or voted perceptron while we employ a Bayesian approach.\nGaussian Processes are a major framework in machine learning nowadays: applications include Robotics (Ko et al., 2007), Geolocation (Schwaighofer et al., 2004) and Computer Vision (Sinz et al., 2004). Only very recently they have been successfully employed in a few NLP tasks such as translation quality estimation (Cohn and Specia, 2013; Beck et al., 2014b), detection of temporal patterns in text (Preoţiuc-Pietro and Cohn, 2013), semantic similarity (Rios and Specia, 2014) and emotion analysis (Beck et al., 2014a). In terms of feature\nrepresentations, previous work focused on the vectorial inputs and applied well-known kernels for these inputs, e.g. the RBF kernel. As shown on §5.2, our approach is orthogonal to these previous ones, since kernels can be easily combined in different ways.\nIt is important to note that we are not the first ones to combine GPs with kernels on structured inputs. Driessens et al. (2006) employed a combination of GPs and graph kernels for reinforcement learning. However, unlike our approach, they did not attempt model selection, evaluating only a few hyperparameter values empirically."
  }, {
    "heading": "7 Conclusions",
    "text": "This paper describes a Bayesian approach for structural kernel learning, based on Gaussian Processes for easy model selection. Experiments applying our models to synthetic data showed that it is possible to learn structural kernel hyperparameters using a fairly small amount of data. Furthermore we obtained promising results in two NLP tasks, including Quality Estimation, where we beat the state of the art. Finally, we showed how these rich parameterizations can lead to more interpretable kernels.\nBeyond empirical improvements, an important goal of this paper is to present a method that enables new kernel developments through the extension of the number of hyperparameters. We focused on the Subset Tree Kernel, proposing an extension and then deriving its gradients. This approach can be applied to any structural kernel, as long as gradients are available. It is our hope that this work will serve as a starting point for future developments in these research directions."
  }, {
    "heading": "Acknowledgements",
    "text": "Daniel Beck was supported by funding from CNPq/Brazil (No. 237999/2012-9). Dr. Cohn is the recipient of an Australian Research Council Future Fellowship (project number FT130101105). The authors would also like to thank the three anonymous reviewers for their helpful comments and suggestions."
  }, {
    "heading": "A Details on SVM Baselines",
    "text": "All SVM baselines employ the -insensitve loss function. Grid search optimization is done via 3- fold cross-validation on the respective training set and use RMSE as the metric to be minimized. After obtained the best hyperparameter values, the SVM is retrained using these values on the full respective training set. The specific intervals used in grid search depend on the task.\nFor the performance experiments on synthetic data, we employed an interval of [10−2, 10] for C (regularization coefficient) and , [10−8, 1] for λ and [10−4, 2] for α. In each run we incrementally increase the size of the grid by adding intermediate values on each interval. We keep a linear scale for the SSTK hyperparameters and a logarithmic scale for C and . As an example, Table 6 shows the resulting grids when the grid value is 4 for each hyperparameter. For all NLP experiments the grid is fixed for all hyperparameters (including γ, the lengthscale value in the RBF kernel), with its corresponding values shown on Table 7."
  }, {
    "heading": "C / [10−2, 10−1, 1, 10]",
    "text": ""
  }],
  "year": 2015,
  "references": [{
    "title": "Goodness: A Method for Measuring Machine Translation Confidence",
    "authors": ["Nguyen Bach", "Fei Huang", "Yaser Al-Onaizan."],
    "venue": "Proceedings of ACL, pages 211– 219.",
    "year": 2011
  }, {
    "title": "Joint Emotion Analysis via Multi-task Gaussian Processes",
    "authors": ["Daniel Beck", "Trevor Cohn", "Lucia Specia."],
    "venue": "Proceedings of EMNLP, pages 1798–1803.",
    "year": 2014
  }, {
    "title": "SHEF-Lite 2.0 : Sparse Multi-task Gaussian Processes for Translation Quality Estimation",
    "authors": ["Daniel Beck", "Kashif Shah", "Lucia Specia"],
    "venue": "In Proceedings of WMT14,",
    "year": 2014
  }, {
    "title": "Random Search for Hyper-Parameter Optimization",
    "authors": ["James Bergstra", "Yoshua Bengio."],
    "venue": "Journal of Machine Learning Research, 13:281–305.",
    "year": 2012
  }, {
    "title": "Confidence estimation for machine translation",
    "authors": ["John Blatz", "Erin Fitzgerald", "George Foster."],
    "venue": "Proceedings of the 20th Conference on Computational Linguistics, pages 315–321.",
    "year": 2004
  }, {
    "title": "Bayesian Structured Prediction using Gaussian Processes",
    "authors": ["Sébastien Bratières", "Novi Quadrianto", "Zoubin Ghahramani."],
    "venue": "arXiv:1307.3846, pages 1–",
    "year": 2013
  }, {
    "title": "Word-Sequence Kernels",
    "authors": ["Nicola Cancedda", "Eric Gaussier", "Cyril Goutte", "JeanMichel Renders."],
    "venue": "The Journal of Machine Learning Research, 3:1059–1082.",
    "year": 2003
  }, {
    "title": "LIBSVM : A Library for Support Vector Machines",
    "authors": ["Chih-Chung Chang", "Chih-Jen Lin."],
    "venue": "ACM Transactions on Intelligent Systems and Technology (TIST), 2(3):1–39.",
    "year": 2001
  }, {
    "title": "Gaussian Processes for Ordinal Regression",
    "authors": ["Wei Chu", "Zoubin Ghahramani."],
    "venue": "Journal of Machine Learning Research, 6:1019–1041.",
    "year": 2005
  }, {
    "title": "Modelling Annotator Bias with Multi-task Gaussian Processes: An Application to Machine Translation Quality Estimation",
    "authors": ["Trevor Cohn", "Lucia Specia."],
    "venue": "Proceedings of ACL, pages 32–42.",
    "year": 2013
  }, {
    "title": "Convolution Kernels for Natural Language",
    "authors": ["Michael Collins", "Nigel Duffy."],
    "venue": "Proceedings of NIPS, pages 625–632.",
    "year": 2001
  }, {
    "title": "Graph Kernels and Gaussian Processes for Relational Reinforcement Learning",
    "authors": ["Kurt Driessens", "Jan Ramon", "Thomas Gärtner."],
    "venue": "Machine Learning, 64(13):91–119.",
    "year": 2006
  }, {
    "title": "Multiple kernel learning algorithms",
    "authors": ["Mehmet Gönen", "Ethem Alpaydın."],
    "venue": "Journal of Machine Learning Research, 12:2211–2268.",
    "year": 2011
  }, {
    "title": "Tree Kernels for Machine Translation Quality Estimation",
    "authors": ["Christian Hardmeier", "Joakim Nivre", "Jörg Tiedemann."],
    "venue": "Proceedings of WMT12, pages 109– 113.",
    "year": 2012
  }, {
    "title": "Improving Machine Translation Quality Prediction with Syntactic Tree Kernels",
    "authors": ["Christian Hardmeier."],
    "venue": "Proceedings of EAMT, pages 233–240.",
    "year": 2011
  }, {
    "title": "Convolution Kernels on Discrete Structures",
    "authors": ["David Haussler."],
    "venue": "Technical report, University of California at Santa Cruz.",
    "year": 1999
  }, {
    "title": "Bridging SMT and TM with Translation Recommendation",
    "authors": ["Yifan He", "Yanjun Ma", "Josef van Genabith", "Andy Way."],
    "venue": "Proceedings of ACL, pages 622– 630.",
    "year": 2010
  }, {
    "title": "Gaussian Processes for Big Data",
    "authors": ["James Hensman", "Nicolò Fusi", "Neil D. Lawrence."],
    "venue": "Proceedings of UAI, pages 282–290.",
    "year": 2013
  }, {
    "title": "Gradient-based Optimization of Kernel-Target Alignment for Sequence Kernels Applied to Bacterial Gene Start Detection",
    "authors": ["Christian Igel", "Tobias Glasmachers", "Britta Mersch", "Nico Pfeifer."],
    "venue": "IEEE/ACM Transactions on Computational Biology and Bioinfor-",
    "year": 2007
  }, {
    "title": "Discriminative Reranking of Discourse Parses Using Tree Kernels",
    "authors": ["Shafiq Joty", "Alessandro Moschitti."],
    "venue": "EMNLP, pages 2049–2060.",
    "year": 2014
  }, {
    "title": "Gaussian Processes and Reinforcement Learning for Identification and Control of an Autonomous Blimp",
    "authors": ["Jonathan Ko", "Daniel J. Klein", "Dieter Fox", "Dirk Haehnel."],
    "venue": "Proceedings of IEEE International Conference on Robotics and Automation, pages",
    "year": 2007
  }, {
    "title": "Text Classification using String Kernels",
    "authors": ["Huma Lodhi", "Craig Saunders", "John Shawe-Taylor", "Nello Cristianini", "Chris Watkins."],
    "venue": "The Journal of Machine Learning Research, 2:419–444.",
    "year": 2002
  }, {
    "title": "The Stanford CoreNLP Natural Language Processing Toolkit",
    "authors": ["Christopher D. Manning", "Mihai Surdeanu", "John Bauer", "Jenny Finkel", "Steven J. Bethard", "David McClosky."],
    "venue": "Proceedings of ACL Demo Session, pages 55–60.",
    "year": 2014
  }, {
    "title": "Tree Kernels for Semantic Role Labeling",
    "authors": ["Alessandro Moschitti", "Daniele Pighin", "Roberto Basili."],
    "venue": "Computational Linguistics, pages 1–32.",
    "year": 2008
  }, {
    "title": "Efficient Convolution Kernels for Dependency and Constituent Syntactic Trees",
    "authors": ["Alessandro Moschitti."],
    "venue": "Proceedings of ECML, pages 318–329.",
    "year": 2006
  }, {
    "title": "Making Tree Kernels practical for Natural Language Learning",
    "authors": ["Alessandro Moschitti."],
    "venue": "EACL, pages 113–120.",
    "year": 2006
  }, {
    "title": "Bayesian Gaussian Processes for Sequential Prediction, Optimisation and Quadrature",
    "authors": ["Michael Osborne."],
    "venue": "Ph.D. thesis, University of Oxford.",
    "year": 2010
  }, {
    "title": "Opinion Mining and Sentiment Analysis",
    "authors": ["Bo Pang", "Lillian Lee."],
    "venue": "Foundations and Trends in Information Retrieval, 2(12):1–135.",
    "year": 2008
  }, {
    "title": "Scikit-learn: Machine learning in Python",
    "authors": ["rot", "Édouard Duchesnay"],
    "venue": "Journal of Machine Learning Research,",
    "year": 2011
  }, {
    "title": "On Reverse Feature Engineering of Syntactic Tree Kernels",
    "authors": ["Daniele Pighin", "Alessandro Moschitti."],
    "venue": "Proceedings of CONLL, pages 223–233.",
    "year": 2010
  }, {
    "title": "Embedding Semantic Similarity in Tree Kernels for Domain Adaptation of Relation Extraction",
    "authors": ["Barbara Plank", "Alessandro Moschitti."],
    "venue": "Proceedings of ACL, pages 1498–1507.",
    "year": 2013
  }, {
    "title": "A temporal model of text periodicities using Gaussian Processes",
    "authors": ["Daniel Preoţiuc-Pietro", "Trevor Cohn."],
    "venue": "Proceedings of EMNLP, pages 977–988.",
    "year": 2013
  }, {
    "title": "Gaussian processes for machine learning, volume 1",
    "authors": ["Carl Edward Rasmussen", "Christopher K.I. Williams."],
    "venue": "MIT Press Cambridge.",
    "year": 2006
  }, {
    "title": "UoW : Multi-task Learning Gaussian Process for Semantic Textual Similarity",
    "authors": ["Miguel Rios", "Lucia Specia."],
    "venue": "Proceedings of SemEval, pages 779–784.",
    "year": 2014
  }, {
    "title": "GPPS: A Gaussian Process Positioning System for Cellular Networks",
    "authors": ["Anton Schwaighofer", "Marian Grigoras", "Volker Tresp", "Clemens Hoffmann."],
    "venue": "Proceedings of NIPS, pages 579–586.",
    "year": 2004
  }, {
    "title": "Learning Depth from Stereo",
    "authors": ["Fabian H. Sinz", "Joaquin Quiñonero Candela", "Gökhan H. Bakır", "Carl E. Rasmussen", "Matthias O. Franz."],
    "venue": "Pattern Recognition, pages 1–8.",
    "year": 2004
  }, {
    "title": "Estimating the sentence-level quality of machine translation systems",
    "authors": ["Lucia Specia", "Nicola Cancedda", "Marc Dymetman", "Marco Turchi", "Nello Cristianini."],
    "venue": "Proceedings of EAMT, pages 28–35.",
    "year": 2009
  }, {
    "title": "Machine translation evaluation versus quality estimation",
    "authors": ["Lucia Specia", "Dhwaj Raj", "Marco Turchi."],
    "venue": "Machine Translation, 24(1):39–50.",
    "year": 2010
  }, {
    "title": "QuEst - A translation quality estimation framework",
    "authors": ["Lucia Specia", "Kashif Shah", "José G.C. De Souza", "Trevor Cohn."],
    "venue": "Proceedings of ACL Demo Session, pages 79–84.",
    "year": 2013
  }, {
    "title": "Exploiting Objective Annotations for Measuring Translation Post-editing Effort",
    "authors": ["Lucia Specia."],
    "venue": "Proceedings of EAMT, pages 73–80.",
    "year": 2011
  }],
  "id": "SP:aa825cbf9b034f8706f56a6935ec181fb2c7e4da",
  "authors": [{
    "name": "Daniel Beck",
    "affiliations": []
  }, {
    "name": "Trevor Cohn",
    "affiliations": []
  }, {
    "name": "Christian Hardmeier",
    "affiliations": []
  }, {
    "name": "Lucia Specia",
    "affiliations": []
  }],
  "abstractText": "Structural kernels are a flexible learning paradigm that has been widely used in Natural Language Processing. However, the problem of model selection in kernel-based methods is usually overlooked. Previous approaches mostly rely on setting default values for kernel hyperparameters or using grid search, which is slow and coarse-grained. In contrast, Bayesian methods allow efficient model selection by maximizing the evidence on the training data through gradient-based methods. In this paper we show how to perform this in the context of structural kernels by using Gaussian Processes. Experimental results on tree kernels show that this procedure results in better prediction performance compared to hyperparameter optimization via grid search. The framework proposed in this paper can be adapted to other structures besides trees, e.g., strings and graphs, thereby extending the utility of kernel-based methods.",
  "title": "Learning Structural Kernels for Natural Language Processing"
}