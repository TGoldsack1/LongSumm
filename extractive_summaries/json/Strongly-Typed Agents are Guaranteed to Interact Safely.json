{
  "sections": [{
    "heading": "1. Introduction “First, do no harm”",
    "text": "Recent years have seen rapid progress on core problems in artificial intelligence such as object and voice recognition (Hinton & et al, 2012; Krizhevsky et al., 2012), playing video and board games (Mnih et al., 2015; Silver et al., 2016), and driving autonomous vehicles (Zhang et al., 2016). As artificial agents proliferate, it is increasingly important to ensure their interactions with one another, with humans, and with their environment are safe.\nConcretely, the number of neural networks being trained and used is growing rapidly. There are enormous and increasing economies of scale that can likely be derived from treating them as populations – rather than as isolated algorithms. How to ensure interacting neural networks cooperate effectively? When can weights trained on one problem\n1Victoria University of Wellington, New Zealand. Correspondence to: David Balduzzi <dbalduzzi@gmail.com>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\nbe adapted to another without adverse effects? The problems fall under mechanism design, a branch of game theory (Nisan et al., 2007). However, neural nets differ from humans in that they optimize clear objectives using gradient descent. The setting is thus more structured than traditional mechanism design.\nSafety. The first contribution of the paper is formalize safety as a criterion on how agents interact. We propose a basic notion of safety based on the common-sense principle that agents should do no harm to one another. More formally, each agent optimizes an objective whose value depends on the actions of the agent and the actions of the rest of the population. A game is safe if the actions chosen by each agent do no (infinitesimal) harm to any other agent, where harm is measured as increased loss.\nThe key simplifying assumption in the paper is to take gradient descent as a computational primitive (Balduzzi, 2016). Questions about mechanism design are sharpened under the assumption that agents use gradient descent. The assumption holds broadly since the key driver of progress in artificial intelligence is deep learning, which uses gradient descent to optimize complicated objective functions composed from simple differentiable modules (LeCun et al., 2015).\nA weakness of the approach is that it conceives safety more narrowly than, for example, Amodei et al. (2016) which is concerned with societal risks arising from artificial intelligence. We argue that a necessary foundational component of the broader AI-safety project is to clarify exactly what safety entails when the objectives of the agents and the algorithms they employ are precisely specified.\nStrongly-typed games. The second contribution is to introduce type systems suited to multi-agent optimization problems (that is, games). We build on the typed linear algebra introduced in Balduzzi & Ghifary (2016). The nomenclature is motivated by an analogy with types in the theory of programming. Type systems are used to prevent untrapped errors (errors that go unnoticed and cause arbitrary behavior later on) when running a program (Cardelli, 1997). A program is safe if it does not cause untrapped errors. Type systems can enforce safety by statically rejecting all programs that are potentially unsafe.\nThe idea underlying types in programming is that “like should interact with like”. Typed linear algebra, definition 1, formalizes “like interacts with like” in the simplest possible way – by fixing an orthogonal basis. Section 2 introduces a wider class of games than in the literature and defines safety. Theorem 1 shows that gradient descent converges to a Nash equilibrium in safe games. Section 3 extracts the key ingredients required for safe gradients from two warmup examples. The ingredients are simultaneous diagonalization, i.e. the existence of a shared latent orthogonal basis, and monotonic covariation, i.e. that the derivatives of the objectives have the same sign in the latent coordinate system. The main result, theorem 2, is that strongly-typed games are guaranteed to be safe.\nImplications. Safety and strong-typing generalize key properties of convexity. Convexity is of course the gold standard for well-behaved gradients. We uncover latent types and demonstrate safety of Newton’s method, natural gradient and mirror descent; see sections 3.2, A2 and A3.\nThe main theme of sections 4 and 5 is disentangling latent factors. We show that strong-typing in quadratic games is closely related to blind source separation. Section 5 analyzes classical N -player games. The analysis yields a new perspective on classical games based on tensor-SVD that is closely related to independent component analysis.\nSections 6 and A6 switch to neural networks and analyze two biologically plausible variants of backpropagation (Balduzzi et al., 2015; Lillicrap et al., 2016). We show that the main results of the papers are to prove the respective algorithms are safe.\nScope and related work. This paper lays the foundations of safety in gradient-based optimization. Applications are deferred to future work.\nThe literature on safety is mostly focused on problems arising in reinforcement learning, for example ensuring agents avoid dangerous outcomes (Turchetta et al., 2016; Amodei et al., 2016; Berkenkamp et al., 2016). Gradients are typically not available in reinforcement learning problems. We study interactions between algorithms with clearly defined objectives that utilize gradient-based optimization, which gives a more technical perspective.\nThe idea of a population of neural networks solving multiple related tasks is developed in Fernando et al. (2017), which uses genetic algorithms to adapt components to new tasks. However, they repeatedly reinitialize components to undo the damage done by the genetic algorithm. Our work is intended, ultimately, to help design algorithms that detect and avoid damaging updates. A recent survey paper argues the brain optimizes a family of complementary loss functions (Marblestone et al., 2016) without considering how\nthe complementarity of the loss functions could be checked or enforced.\nThe idea of investigating game-theoretic and mechanism design questions specific to certain classes of algorithms is introduced in Rakhlin & Sridharan (2013); Syrgkanis et al. (2015). The papers consider how convergence in games can be accelerated if the players use variants of mirror descent.\nTerminology. If ↵ 0 then ↵ is positive; if ↵ > 0 then it is strictly positive. A (not necessarily square) matrix D is diagonal if d\nij = 0 for all i 6= j and similarly for tensors. Vectors are columns. The inner product is hv,wi = v|w."
  }, {
    "heading": "2. Safety",
    "text": ""
  }, {
    "heading": "2.1. Types and orthogonal projections",
    "text": "Let us recall some basic facts about orthogonal projections. Let (V, h•, •i) be a vector space equipped with an inner product. An orthogonal projection is a linear transform ⇡ : V ! V that is\nO1. idempotent, ⇡2 = ⇡, and\nO2. self-adjoint, h⇡v,v0i = hv,⇡v0i for any v,v0 2 V . Lemma 1. Let P denote an (n ⇥ k)-matrix with orthogonal columns p1, . . . ,pk. Then the (n⇥ n)-matrix PP| =P\nk i=1 pihpi, •i = P k i=1 pip | i\nis an (orthogonal) projection.\nLemma 2. If two orthogonal projections ⇡ and ⌧ commute then their product is an orthogonal projection.\nProof. Let q := ⇡⌧ . If ⇡⌧ = ⌧⇡ then\nq2 = ⇡⌧ · ⇡⌧ = ⇡⇡ · ⌧⌧ = ⇡⌧ = q. Checking self-adjointness is an exercise.\nDefinition 1. A type T V = V, h•, •i, {⇡ r }R r=1 is a Ddimensional vector space with an inner product and orthogonal projections ⇡\nr : V ! V such that ⇡ r ⇡ s = 0\nfor r 6= s and PR r=1 ⇡r = IV is the identity. Type TV has dimension D and rank R.\nA full rank type, D = R, is equivalent to a vector space equipped with an orthogonal basis. Lower rank types are less rigid, and can be thought of as vector spaces equipped with generalized orthogonal coordinates."
  }, {
    "heading": "2.2. Safe games",
    "text": "Definition 2. A game consists of a type T V\n, feasible set H ⇢ V , players [N ] := {1, . . . , N}, losses `\nn : H ! R, and an assignment ⇢ : [N ] ! [R] of players to projections.\nThe type structure and assignments specify the coordinates controlled by each player. On round t, player n chooses ⇠t n\n2 V and updates the joint action via wt+1 = wt ⇡\n⇢(n)(⇠ t\nn ) where wt,wt+1 2 H. Updates leaving the feasible set can be mapped back into it, see section A1. The projection ⇡\n⇢(n) specifies the coordinates of the joint-action vector that player n can modify. Example 1. In a block game actions w 2 V =QN\nn=1 RDn decompose as w = (w1, . . . ,wN ) where the nth player can modify the coordinates in w\nn . The orthogonal projections ⇡\nn (w) = (0, . . . ,w n , . . . ,0) form a rank-N type with ⇢(n) = n for all n 2 [N ]. Example 2. In an open game the type has rank(T\nV\n) = 1\nso the single projection is the identity and ⇢(n) = 1 for all n. Every player can modify all the coordinates.\nBlock games coincide with the standard definition of a game in the literature. Open games arise below when considering Newton’s method, natural gradients, mirror descent and neural networks.\nThe goal of each player is to minimize its loss. Safety is the condition that no player’s updates harm any other player. Definition 3. It is safe for player m to choose ⇠t\nm 2 V if it does no infinitesimal harm to any player\n⌦ ⇡\n⇢(m)(⇠ t\nm\n),r ` n (wt) ↵ 0 for all n 2 [N ].\nA game is safe if it is safe for players to use gradient descent: i.e. if choosing ⇠t\nm\n:= r ` m (wt) is safe for all m.\nIt is worth getting a degenerate case out of the way. A block game is decomposable if player m’s loss only depends on the actions it controls. Intuitively, a decomposable game is N independent optimization problems. More formally: Lemma 3. A block game is decomposable if `\nm (w) = ` m (⇡ m w) for all w and m. Decomposable games are safe.\nProof. Since ⇡ m is self-adjoint, we have that h⇡ m ⇠,⌘i = h⇡\nm ⇠,⇡ m ⌘i. Decomposability implies ⇡ m (r ` n ) = 0\nwhen m 6= n, so ⌦ ⇡\nm (r ` m ),⇡ m (r ` n ) ↵ =\n( k⇡\nm (r ` m )k22 if m = n 0 else\nwhich is always positive."
  }, {
    "heading": "2.3. Convergence",
    "text": "A block game is convex if the feasible set H is compact and convex and the losses `\nn : H ! R are convex in the coordinates controlled by the respective players. Nash equilibria are guaranteed to exist in convex block games (Nash, 1950). However, finding them is often intractable\n(Daskalakis et al., 2009). We show gradient descent converges to a Nash equilibrium in safe convex games.\nTheorem 1. Gradient descent converges to a Nash equilibrium in safe convex games with smooth losses.\nProof. Introduce potential function (w) = P N\nn=1 ↵n · ` n (w) where ↵ n > 0 are strictly positive. Then\nh⇡ m (r ),r ` m i = NX\nn=1\n↵ n\nD ⇡\nm (r ` n ),r ` m E (1)\n↵ m · k⇡ m (r ` m )k22 0 since safety implies the cross-terms are nonnegative. The players’ updates therefore converge to either a critical point of or to the boundary of the feasible set. Suppose gradient descent converges to the interior of H. Eq (1) implies that if r = 0 then ⇡\nm (r ` m\n) = 0 for all m. By convexity of the losses, the critical point is a minimizer of each loss with respect to that player’s actions, implying it is a Nash equilibrium. A similar argument holds if gradient descent converges to the boundary, see section A1.\nExample 3 (convergence in a safe constrained game). Consider a two-player block game with `1(x, y) = x+ 2y and `2(x, y) = 2x + y where player-1 controls x and player2 controls y. Introduce feasible set H = {(x, y) 2 R2 : x2 + y2  1}. The game is convex and safe. The set of Nash equilibria is the bottom-left quadrant of the boundary {(x, y) 2 H : x, y  0 and x2 + y2 = 1}. Gradient descent with positive combinations of ⇡1(r `1) = @\n@x and ⇡2(r `2) = @\n@y\nalways converges to a Nash equilibrium.\nA simple game that does not converge is the following zerosum game, which is related to generative adversarial networks (Goodfellow, 2017). Example 4 (convergence requires positivity). Consider the two-player block game `1(x, y) = xy and `2(x, y) = xy where player-1 controls x and player-2 controls y. The Nash equilibrium is the origin (x, y) = (0, 0). However, gradient descent does not converge. Observe that r `1 = y @ @x + x @ @y and r `2 = y @ @x x @ @y so ⇡1(r `1) = y @ @x and ⇡2(r `2) = x @ @y\n. The flow ⇡1(r `1) + ⇡2(r `2) rotates around the origin. No positive combination of ⇡1(r `1) and ⇡2(r `2) converges to the origin."
  }, {
    "heading": "3. Strongly-Typed Games",
    "text": "Strong-typing is based two key ideas: diagonalization and positivity. Diagonalization is an important tool in applied mathematics. The Fourier transform simultaneously diagonalizes differentiation and convolution:\nF ⇣ df dx ⌘ = 2⇡i!F(f) and F(f ⇤ g) = F(f) · F(g)\nThe SVD diagonalizes any matrix: Q|MP = D. Finally, the Legendre transform f⇤(⌘) = max✓{⌘|✓ f(✓)} diagonalizes the infimal convolution\n(f⇤g)⇤ = f⇤+g⇤ for (f⇤g)(✓) = min # {f(#)+g(✓ #)}.\nDiagonalization finds a latent orthogonal basis that is more mathematically amenable than the naturally occurring coordinate system. Strong-typing is based on an extension of diagonalization to nonlinear functions. Before diving in, we recall the basics of simultaneous diagonalization.\nSymmetric matrices. Any symmetric matrix A factorizes as A = P|DP where P is orthogonal and D is diagonal. A collection A1, . . . ,AN of symmetric matrices is simultaneously diagonalizable iff the matrices commute, in which case A\ni = P|D i P where D i\nis diagonal and P determines a common latent coordinate system (or type).\nArbitrary matrices. The diagonalization of an (m⇥n)matrix A is A = PDQ| where P and Q are orthogonal (m⇥m) and (n⇥ n) matrices and D is positive diagonal. A collection of matrices is simultaneously diagonalizable if A\ni = PD i Q| for all i. A necessary condition for simultaneous diagonalizability is that\nA| i A j and A i A| j are symmetric for all i, j. (2)\nNext, we work through two examples where diagonalization and a positivity condition imply safety."
  }, {
    "heading": "3.1. Warmup: When are two-player games safe?",
    "text": "To orient the reader, we consider a minimal example which illustrates most of the main ideas of the paper: two-player bilinear games (von Neumann & Morgenstern, 1944). Consider a two-player block game with loss functions\n`1(v,w) = v |Aw and `2(v,w) = v|Bw\nand projections ⇡1/2(v,w) = (v,0) and (0,w). The gradients are r `1 = P ij (w j A ij @ @vi + v i A ij @ @wj ) = (w|A|,v|A) and r `2 = (w|B|,v|B). The game is safe if\nh⇡1(r `1),r `2i = w|A|Bw 0 and hr `1,⇡2(r `2)i = v|BA|v 0 for all v and w.\nSafety requires that A|B and BA| are positive semidefinite. Any square matrix decomposes into symmetric and antisymmetric components M = Ms + Ma = 12 (M + M|) + 12 (M M|) where w|Maw = 0 for all w. Thus, a square matrix is positive semidefinite iff its symmetric component is positive semidefinite.\nWe therefore restrict to when A|B and BA| are symmetric. Recalling (2), we further suppose that A and B are simultaneously diagonalizable and obtain:\nLemma 4. A two-player game is safe if A = PDQ| and B = PEQ| where P and Q are orthogonal matrices, D and E are diagonal, and DE 0.\nProof. The assumptions imply that\nh⇡1 r `1,r `2i = w|A|Bw = w|Q(D|E)Q|w 0\nand hr `1,⇡2 r `2i = w|P(E|D)P|w 0."
  }, {
    "heading": "3.2. Warmup: When is Newton’s method safe?",
    "text": "It was observed in Dauphin et al. (2014) that applying Newton’s method to neural networks is problematic because it is attracted to saddle points and can increase the loss on nonconvex problems. We reformulate their observation in the language of safety.\nConsider a single player open game with twice differentiable loss ` : V ! R and projection ⇡ = I\nV . Newton’s method optimizes ` via weight updates\nwt+1 = wt ⇠t with ⇠t = ⌘t ·H 1(wt) ·r `(wt),\nwhere H ij (w) = @ 2 `\n@wi@wj (w) is the Hessian and ⌘t > 0.\nLemma 5. If ` is strictly convex then Newton’s method is safe, i.e. hH 1 r `,r `i 0 for all w.\nProof. Factorize the Hessian at wt as H = PDP|. If ` is strictly convex then D > 0 and so\nhH 1 r `,r `i = hD 1P| r `,P| r `i 0\nas required.\nTwo features are noteworthy: (i) the transform ⌘ = P|⇠ diagonalizes the second-order Taylor expansion of `,\ncompare `(w + ⇠) = `(w) + ⇠| ·r `+ 1 2 ⇠|H⇠\nwith `(w +P⌘) = `(w) + ⌘|(P| r `) + 1 2 ⌘|D⌘,\nand (ii) the proof hinges on the positivity of D. Sections A2 and A3 extend the approach to show the natural gradient (Amari, 1998) and mirror descent (Raskutti & Mukherjee, 2015) are safe using the Legendre transform."
  }, {
    "heading": "3.3. Strongly-typed games are safe",
    "text": "We apply the lessons from the warmups to define a factorization of nonlinear functions.\nDefinition 4. The functions {` n : V ! R}N n=1 simultaneously factorize if there is a triple ⇣ {P\nl }L l=1, {fl : Rpl ! R}Ll=1, {gn : RL ! R}Nn=1\n⌘ ,\nsatisfying\n` n (w) = g n ⇣ f1(P | 1w), . . . , fL(P | L w) ⌘ for all n\nwhere P l are (D⇥p l\n)-matrices whose columns jointly form an orthogonal basis of V and f\nl and g n are differentiable, and the g\nn ’s co-vary monotonically: @gm @fl @gn @fl 0.\nThe projections ⌧ l = P l P| l\ndefine a type structure on V . Intuitively, the outputs z\nl = f l (P| l\nw) are latent factors computed from the inputs w such that each z\nl is independent of the others – independence is enforced by the projections ⌧\nl . Monotonic covariation of the functions g n with respect to the factors z\nl plays the same role as positivity in two-player games and Newton’s method. Definition 5. Game (T\nV , {` n }N n=1) is strongly-typed if the\nloss functions admit a simultaneous factorization whose projections {⌧\nl = P l P| l }L l=1 commute with {⇡n}Nn=1.\nTheorem 2. Strongly-typed games are safe.\nProof. Commutativity implies there is a basis {e i }D i=1 for V that simultaneously diagonalizes the projections {⇡ n\n} and {⌧\nl }. Express elements of V as (v1, . . . , vD) in the basis. Safety then reduces to showing\nh⇡ m (r ` m ),r ` n i = X\n{i:⇡m(ei) 6=0}\n@g m\n@v i\n· @gn @v\ni\n0.\nObserve that @fk @vi @fl @vi = 0 if k 6= l since f k and f l are functions of orthogonal coordinates. It follows that\n@g m\n@v i\n· @gn @v\ni\n=\nLX\nk=1\n@g m\n@f k\n@f k\n@v i\n! · LX\nl=1\n@g n\n@f l\n@f l\n@v i\n!\n=\nLX\nl=1\n@g m\n@f l\n@g n\n@f l\n· ✓ @f l\n@v i\n◆2 0\nsince the g n ’s co-vary monotonically.\nStrong-typing is a sufficient but not necessary condition for safety. More general definitions can be proposed according to taste. Definition 5 is easy to check, covers the basic examples below, and incorporates the concrete intuition developed in the warmups."
  }, {
    "heading": "3.4. Comparison with potential games",
    "text": "The proof of theorem 1 suggests that safe games are related to potential games (Monderer & Shapley, 1996). In our\nnotation, a block game is a weighted potential game if there exists a potential function and scalar weights ↵\nn > 0 satisfying\n` n (w) ` n (w+⇡ n v) = ↵ n\n· ⇣ (w) (w+⇡\nn\nv) ⌘\nfor all w,v 2 V and n 2 [N ]. We provide two counter-examples to show that stronglytyped games are distinct from potential games. Example 5 (a strongly-typed game that is not a potential game). Let `1(x,y) = x1y1 + 2x2y2 and `2(x,y) = 3x1y1 + 4x2y2. The block game with projections onto x and y is strongly-typed but is not a weighted potential game. Example 6 (a potential game that is not safe). Let `1(x, y) = xy and `2(x, y) = xy 9x, with projections onto x and y. The game is a potential game but is not safe because\nh⇡1(r `1),r `2i = h(y, 0), (y 9, x)i = y2 9y can be negative."
  }, {
    "heading": "4. Quadratic Games",
    "text": "Given a collection of (D⇥D)-matrices {A(n)}N\nn=1 and Dvectors {b(n)} the corresponding quadratic game has loss functions\n` n\n(w) = 1\n2\nw|A(n)w +w|b(n).\nWe assume the matrices A(n) are symmetric without loss of generality."
  }, {
    "heading": "4.1. Open quadratic games",
    "text": "In an open quadratic game, each player updates the entire joint action.\nCorollary 1. An open quadratic game is safe if there is an orthogonal (D⇥D)-matrix P, diagonal matrices D(n) such that D(m)D(n) 0, and D-vector b such that\nA(n) = PD(n)P| and b(n) = A(n)b.\nWe derive corollaries 1 and 2 from theorem 2. Alternate, direct proofs are provided in appendix A4.\nProof. Let f i (x) = x(x2 bi) and gn(z) = P D i=1 d (n) i · z i\n. Then\n` n (w) = g n ⇣ f1(p | 1w), . . . , fD(p | D w) ⌘ ,\nwhere p i are the columns of P, is strongly-typed.\nThe Hessian of ` n is H `n = A (n). The conditions of corollary 1 can be reformulated as (i) the Hessians of the losses commute H\n`mH`n = H`nH`m for all m and n, and (ii) the Newton steps for the losses coincide (when the Hessians are nonsingular):\nH 1 `n (r ` n ) | {z } Newton step = (A(n)) 1A(n)(w b) = w b.\nExample: Disentangling latent factors. An important problem in machine learning is disentangling latent factors (Bengio, 2013). Basic methods for tackling the problem include PCA, canonical correlation analysis (CCA) and independent component analysis (ICA). We show how the factorization in corollary 1 can arise “in nature” as a variant of blind source separation.\nSuppose a signal on D channels is recorded for T timepoints giving (D⇥T )-matrix X. Assume the observations combine L independent latent signals: X = MS where S is an (L ⇥ T )-matrix representing the latent signal and M is a mixing matrix.\nBlind source separation is concerned with recovering the latent signals. The covariance of the signal is A = XX|. Factorize A = PDP| and let ˜S = P|X. Although this may not recover the original signal, i.e. ˜S 6= S in general, it does disentangle X into uncorrelated factors:\n˜S˜S| = P|XX|P = D.\nFinally, recall that finding the first principal component can be formulated as the constrained maximization problem:\nargmax {w:kwk2=1} w|Aw.\nNow suppose there are N sets of observations X(1), . . . ,X(N) generated by a single orthogonal mixing matrix acting on different sets of (potentially rescaled) latent signals: X(n) = PS(n). Finding the first principle components of the signals reduces to solving the constrained optimization problems\n( argmax\n{w:kwk2=1} w|X(n)(X(n))|w\n) N\nn=1\n(3)\nCorollary 1 implies that (3) is a safe. Note the corollary implies the optimization problems have compatible gradients, not that they share a common solution. In general there are many Nash equilibria, analogous to example 3.\nQuadratic games and linear regression. The blind source separation example assumes that the linear terms b(n) in the loss are zero. If the linear term is nonzero then linear regression is a special case of minimizing the quadratic loss. Safety then relates to searching for weights that simultaneously solve linear regression problems on multiple datasets."
  }, {
    "heading": "4.2. Block Quadratic Games",
    "text": "The block quadratic game has losses as above; however the action space decomposes into (w1, . . . ,wN ) with corresponding projections. Block decompose the components of the loss as\nA(n) =\n0\nBB@ A(n)11 · · · A(n)1N ...\n... A(n)\nN1 · · · A(n)NN\n1\nCCA and b (n) =\n0\nBB@ b(n)1 ...\nb(n) N\n1\nCCA .\nCorollary 2. A block quadratic game is safe if there are:\n(i) (D ⇥D)-orthogonal P with P mn = 0 for m 6= n; (ii) (D ⇥ L) matrix R with R n• diagonal for all n;\n(iii) diagonal (L⇥L)-matrices D(n) with D(m)D(n) 0; (iv) and a D-vector b\nsuch that A(n) = PRD(n)R|P| and\nb(n) = A(n)b for all n.\nThe notation P mn and R•n refers to blocks in the rows and columns of P and columns of R.\nProof. Let p i denote the columns of P and g n (z) =P L\nl=1 d (n) l · z l . Given l, construct P l\nby concatenating the columns p\ni of P for which the corresponding entries of R il\nare nonzero and let r l be the vector containing the nonzero entries of R•l. Define fl(xl) = r|\nl\n( xl 2 bl) · (r|l xl). Then\n` n (w) = g n ⇣ f1(P | 1w), . . . , fL(P | L w) ⌘ .\nIt is an exercise to check the game is strongly-typed.\nExample: Disentangling latent factors. We continue the discussion of blind source separation and safety. Suppose that the mixing matrix decomposes into blocks\nM =\n0 B@ M1•\n... M\nN•\n1\nCA\nThe blocks generate multiple views on a single latent signal, (Kakade & Foster, 2007; McWilliams et al., 2013; Benton et al., 2017). The nth view is M n•S.\nAs in the example in section 4.1, now suppose there are N sets of observed signals generated from N sets of latent signals. Each agent attempts to find the principal component specific to its view on its set of observations. Corollary 2 implies that the problems\n( argmax\n{wn:kwnk2=1} w|X(n)(X(n))|w\n) N\nn=1\ncan be safely optimized using gradient descent if the mixing matrix has the block form\nM n• = Pnn ·Rn•\nwhere P nn is orthogonal and R n• is diagonal. In other words, if the views are generated by rescaling and changing-the-basis of the latent signals.\nThe open and block settings share a common theme: Safe disentangling requires observed signals that are generated by a single (structured) mixing process applied to (arbitrary) sets of independent latent signals. The same phenomenon arises in multi-player games, resulting in tensor decompositions that generalize ICA."
  }, {
    "heading": "5. Multi-Player Games and Tensor-SVD",
    "text": "A classic N -player strategic game consists in finite actionsets A\nn and losses ` n : A = Q N\nn=1 An ! R. Enumerate the elements of each set as A\nn = [D n ], and encode the losses as (D1, . . . , DN )-tensors\nA n [↵1, . . . ,↵N ] := `n(↵1, . . . ,↵N ) where ↵n 2 [Dn].\nGiven a collection of N such tensors, define the corresponding multilinear game1 as\n` n (w1, . . . ,wN ) = An ⇥1 w1 ⇥ · · ·⇥N wN\n:=\nD1,...,DNX\n↵1,...,↵N=1\nA[↵1, . . . ,↵N ] ·w1[↵1] · · ·wN [↵N ].\nThe classic example is when actions are drawn from the D\nn -simplex 4Dn = {w n 2 RDn : PDn ↵=1 wn[↵] =\n1 and w n [↵] 0 for all ↵}. We now recall the orthogonal tensor decomposition or tensor SVD (Zhang & Golub, 2001; Chen & Saad, 2009). A tensor admits a tensor-SVD if it can be written in the form\nA = LX\nl=1\nd l · u1 l ⌦ · · ·⌦ uN l = D⇥1 U1 ⇥ · · ·⇥N UN\nwhere Un is a (D n ⇥ L)-matrix with orthogonal columns and D is a diagonal (L, . . . , L)-tensor. Corollary 3. A multilinear game is safe if it admits a simultaneous tensor-SVD\nA(n) = D(n) ⇥1 U1 ⇥ · · ·⇥N UN\nwhere the diagonals have the same sign coordinatewise. 1We use the n-mode product notation ⇥n, see de Lathauwer et al. (2000).\nProof. Let g n (z) = P L l=1 d (n) l z l and f l (x) = Q n x n\n. Define P\nl as the (D ⇥N)-matrix whose nth column is un l\nin the block of rows corresponding to w\nn and zero elsewhere. Then\n` n (w) = g n f1(P | 1w), . . . , fL(P | L w)\nand the game is strongly-typed.\nNot all tensors admit a tensor-SVD. However, all tensors do admit a higher-order SVD (de Lathauwer et al., 2000). Section A5 explains why simultaneous HOSVD does not guarantee safety and the stronger tensor-SVD is required.\nExample: Disentangling latent factors Suppose S is a latent signal with independent non-Gaussian coordinates. We observe X = PS + ✏ where P is a (D ⇥ L) mixing matrix and ✏ is Gaussian noise. By whitening the signal as a preprocessing step, one can ensure the columns of P are orthogonal. ICA recovers S from the cumulants of X, see Hyvärinen et al. (2001). The main insight is that the 4 th-order cumulant tensor admits a tensor-SVD:\nA[i, j, k, l] = cum(x i , x j , x k , x l )\n=\nX\no,p,q,r\nP io P jp P kq P lr · cum(s o , s p , s q , s r )\n=\nX\nr\nP ir P jr P kr P lr · kurt(s r )\nsince cum(s o , s p , s q , s r ) = 0 unless o = p = s = r because the signals are independent. The expression can be written A = K⇥1P⇥2P⇥3P⇥4P where diagonal tensor K specifies the kurtosis of the latent signal. In other words, computing the tensor-SVD recovers the mixing matrix and allows to recover the latent signal up to basic symmetries.\nFollowing the same prescription as the examples above, if there are N sets of observations generated from N latent signals by the same mixing matrix, then the resulting cumulant tensors satisfy corollary 3."
  }, {
    "heading": "6. Biologically Plausible Backpropagation",
    "text": "Our ultimate goal is to apply strong-typing to safely optimize neural nets with multiple loss functions (Marblestone et al., 2016). Doing so requires constructing variants of backprop that allow the propagation of multiple error signals. First steps in this direction have been taken with biologically plausible models of backprop that introduce additional degrees of freedom into the algorithm.\nFeedback alignment is a recent algorithm with comparable empirical performance to backprop. It is also more biologically plausible since it loosens backprop’s requirement that forward- and back- propagating weights are sym-\nmetric (Lillicrap et al., 2016). The main theoretical result of the paper, see their supplementary information, is Theorem. Let\nBP = W|e denote the error backpropagated one layer of the neural network. Under certain conditions, the error signal computed by feedback alignment, FA = Be, satisfies\nFA = ↵ ·W†e where ↵ > 0 and W† is the pseudoinverse of W.\nProof. See theorem 2 of Lillicrap et al. (2016).\nCorollary 4. Under the same conditions, feedback alignment is safe.\nProof. We require to check h FA , BP i 0. Applying the theorem obtains\nh FA , BP i = ↵ · hW†e,W|ei = ↵ · hWW†e, ei. Observe that WW† is an orthogonal projection by standard properties of the pseudoinverse so\nh FA , BP i = ↵ · hWW†e,WW†ei 0 as required.\nIn fact, Lillicrap et al. (2016) provide experimental and theoretical evidence that feedback alignment learns to align the feedforward weights with the pseudoinverse of the backconnections. In other words, they argue that feedback alignment learns safe gradients.\nAnother variant of backprop is kickback, which loosens backprop’s requirement that there are distinct forward- and backward signals (Balduzzi et al., 2015). Kickback truncates backprop’s error signals so that the network learns from just the feedforward sweep together with scalar error signals. One of the main results of Balduzzi et al. (2015) is that kickback is safe, see section A6."
  }, {
    "heading": "7. Conclusion",
    "text": "Backprop provides a general-purpose tool to train configurations of differentiable modules that share a single objective. However, effectively training populations of neural networks on potentially conflicting tasks, such that they automatically exploit synergies and avoid damaging incompatibilities (such as unlearning old features that are not useful on a new task) requires fundamentally new ideas.\nA key piece of the puzzle is to develop type systems that can be used to (i) guarantee when certain optimizations can be safely performed jointly and (ii) flag potential conflicts so that the incompatible optimization problems can be separated. The paper provides a first step in this direction.\nFrom a different perspective, convex methods have played an enormous role in optimization yet their relevance to deep learning is limited. The approach to strong-typing developed here is inspired by and extends certain features of convexity. One of the goals of this paper is to carve out some of the key concepts underlying convex geometry and reassemble them into a more flexible, but still powerful framework. The proposed definition of strong-typing should be considered a first and far from final attempt.\nA large class of natural examples is generated by imposing strong-typing on simple quadratic and multilinear games. It turns out that, in these settings, strong-typing yields the same matrix and tensor decompositions that arise in blind source separation and independent component analysis, where multiple latent signals are mixed by the same structured process. An important future direction is to disentangle nonlinear latent factors.\nStrong-typing and safety in neural nets. We conclude by discussing the relevance of the framework to neural networks. Firstly, neural nets and strong-typing have many of the same ingredients: neural nets combine linear algebra (matrix multiplications and convolutions) with monotonic functions (sigmoids, tanhs, rectifiers, and max-pooling amongst others). Rectifiers and sigmoids have the additional feature that their outputs are always positive.\nSecondly, there is a deeper connection between rectifiers and strong-typing. Rectifiers are orthogonal projections on weights: ⇢(W|x) zeroes out the columns w\nl of W for which w|\nl x  0. Rectifiers are more sophisticated projections than we have previously considered because they are context-dependent. The columns that are zeroed out depend on W and x: the rectifier-projection takes W and x as parameters, compare remarks 1 and 2 in the appendix. Representation learning in rectifier networks can thus be recast as learning parameterized type structures. An interesting future direction is to consider tensor-switching networks (Tsai et al., 2016), which decouple a neuron’s decision to activate from the information it passes along (for a rectifier, both depend on W|x).\nFinally, it has long been known that the brain does not use backprop (Crick, 1989). One possibility is that backprop is the optimal deep learning algorithm which, unfortunately, evolution failed to stumble upon. Another is that there are evolutionary advantages to not using backpropagation. For example, it has been argued that the brain optimizes multiple loss functions (Marblestone et al., 2016). Does jointly optimizing or satisficing multiple objectives require learning mechanisms with more degrees of freedom than backprop (Balduzzi et al., 2015; Lillicrap et al., 2016)? Safety and strong-typing provide the tools needed to frame and investigate the question."
  }, {
    "heading": "Acknowledgements",
    "text": "I am grateful to Stephen Marsland and James Benn for useful discussions."
  }],
  "year": 2017,
  "references": [{
    "title": "Natural Gradient Works Efficiently in Learning",
    "authors": ["S. Amari"],
    "venue": "Neural Comp,",
    "year": 1998
  }, {
    "title": "Information Geometry and Its Applications: Convex Function and Dually Flat Manifold",
    "authors": ["S. Amari"],
    "venue": "Emerging Trends in Visual Computing,",
    "year": 2009
  }, {
    "title": "Concrete Problems in AI Safety",
    "authors": ["Amodei", "Dario", "Olah", "Chris", "Steinhardt", "Jacob", "Christiano", "Paul", "Schulman", "John", "Mané", "Dan"],
    "venue": "In arXiv:1606.06565,",
    "year": 2016
  }, {
    "title": "Kickback cuts Backprop’s red-tape: Biologically plausible credit assignment in neural networks",
    "authors": ["D Balduzzi", "H Vanchinathan", "J. Buhmann"],
    "venue": "In AAAI,",
    "year": 2015
  }, {
    "title": "Grammars for Games: A Gradient-Based, Game-Theoretic Framework for Optimization in Deep Learning",
    "authors": ["Balduzzi", "David"],
    "venue": "Frontiers in Robotics and AI,",
    "year": 2016
  }, {
    "title": "Strongly-Typed Recurrent Neural Networks",
    "authors": ["Balduzzi", "David", "Ghifary", "Muhammad"],
    "venue": "In ICML,",
    "year": 2016
  }, {
    "title": "Deep Learning of Representations: Looking Forward",
    "authors": ["Bengio", "Yoshua"],
    "venue": "Statistical Language and Speech Processing. Springer,",
    "year": 2013
  }, {
    "title": "Deep Generalized Canonical Correlation Analysis",
    "authors": ["Benton", "Adrian", "Khayrallah", "Huda", "Gujral", "Biman", "Reisinger", "Drew", "Zhang", "Sheng", "Arora", "Raman"],
    "venue": "In arXiv:1702.02519,",
    "year": 2017
  }, {
    "title": "Safe learning of regions of attraction for uncertain, nonlinear systems with gaussian processes",
    "authors": ["F Berkenkamp", "R Moriconi", "A Schoellig", "A. Krause"],
    "venue": "In IEEE CDC,",
    "year": 2016
  }, {
    "title": "Convex Optimization: Algorithms and Complexity",
    "authors": ["Bubeck", "Sébastien"],
    "venue": "Foundations and Trends in Machine Learning,",
    "year": 2015
  }, {
    "title": "On the tensor SVD and the optimal low rank orthogonal approximation of tensors",
    "authors": ["Chen", "Jie", "Saad", "Yousef"],
    "venue": "SIAM J. Matrix Anal. Appl.,",
    "year": 2009
  }, {
    "title": "The recent excitement about neural networks",
    "authors": ["Crick", "Francis"],
    "venue": "Nature, 337(12):129–132,",
    "year": 1989
  }, {
    "title": "The Complexity of Computing a Nash Equilibrium",
    "authors": ["Daskalakis", "Constantinos", "Goldberg", "Paul W", "Papadimitriou", "Christos"],
    "venue": "SIAM J. Computing,",
    "year": 2009
  }, {
    "title": "Identifying and attacking the saddle point problem in high-dimensional non-convex optimization",
    "authors": ["Dauphin", "Yann", "Pascanu", "Razvan", "Gulcehre", "Caglar", "Cho", "Kyunghyun", "Ganguli", "Surya", "Bengio", "Yoshua"],
    "venue": "In NIPS,",
    "year": 2014
  }, {
    "title": "A multilinear singular value decomposition",
    "authors": ["de Lathauwer", "Lieven", "de Moor", "Bart", "Vandewalle", "Joos"],
    "venue": "SIAM J. Matrix Anal. Appl.,",
    "year": 2000
  }, {
    "title": "PathNet: Evolution Channels Gradient Descent in Super Neural Networks",
    "authors": ["C Fernando", "D Banarse", "C Blundell", "Y Zwols", "D Ha", "A Rusu", "A Pritzel", "D. Wierstra"],
    "year": 2017
  }, {
    "title": "Tutorial: Generative Adversarial Networks",
    "authors": ["Goodfellow", "Ian J"],
    "venue": "NIPS",
    "year": 2016
  }, {
    "title": "Deep Neural Networks for Acoustic Modeling in Speech Recognition: The Shared Views of Four Research Groups",
    "authors": ["G Hinton"],
    "venue": "IEEE Signal Proc Magazine,",
    "year": 2012
  }, {
    "title": "Independent Component Analysis",
    "authors": ["Hyvärinen", "Aapo", "Karhunen", "Juha", "Oja", "Erkki"],
    "year": 2001
  }, {
    "title": "Multi-view Regression Via Canonical Correlation Analysis",
    "authors": ["Kakade", "Sham", "Foster", "Dean P"],
    "venue": "In COLT,",
    "year": 2007
  }, {
    "title": "Imagenet classification with deep convolutional neural networks",
    "authors": ["A Krizhevsky", "I Sutskever", "Hinton", "G E"],
    "venue": "In Advances in Neural Information Processing Systems (NIPS),",
    "year": 2012
  }, {
    "title": "Random feedback weights support error backpropagation for deep learning",
    "authors": ["Lillicrap", "Timothy P", "Cownden", "Daniel", "Tweed", "Douglas B", "Ackerman", "Colin J"],
    "venue": "Nature Communications,",
    "year": 2016
  }, {
    "title": "Towards an Integration of Deep Learning and Neuroscience",
    "authors": ["Marblestone", "Adam H", "Wayne", "Greg", "Kording", "Konrad P"],
    "venue": "Front. Comput. Neurosci.,",
    "year": 2016
  }, {
    "title": "Correlated random features for fast semi-supervised learning",
    "authors": ["McWilliams", "Brian", "Balduzzi", "David", "Buhmann", "Joachim"],
    "venue": "In NIPS,",
    "year": 2013
  }, {
    "title": "Human-level control through deep reinforcement learning",
    "authors": ["Mnih", "Volodymyr", "Kavukcuoglu", "Koray", "Silver", "David"],
    "venue": "Nature, 518(7540):529–533,",
    "year": 2015
  }, {
    "title": "Equilibrium Points in n-Person Games",
    "authors": ["Nash", "John F"],
    "venue": "Proc Natl Acad Sci U S A,",
    "year": 1950
  }, {
    "title": "Optimization, learning, and games with predictable sequences",
    "authors": ["Rakhlin", "Alexander", "Sridharan", "Karthik"],
    "venue": "In NIPS,",
    "year": 2013
  }, {
    "title": "The Information Geometry of Mirror Descent",
    "authors": ["G Raskutti", "S. Mukherjee"],
    "venue": "IEEE Trans. Inf. Theory,",
    "year": 2015
  }, {
    "title": "Mastering the game of go with deep neural networks and tree search",
    "authors": ["Silver", "David", "Huang", "Aja"],
    "year": 2016
  }, {
    "title": "Fast Convergence of Regularized Learning in Games",
    "authors": ["Syrgkanis", "Vasilis", "Agarwal", "Alekh", "Luo", "Haipeng", "Schapire", "Robert"],
    "venue": "In NIPS,",
    "year": 2015
  }, {
    "title": "Tensor Switching Networks",
    "authors": ["Tsai", "Chuan-Yung", "Saxe", "Andrew", "Cox", "David"],
    "venue": "In NIPS,",
    "year": 2016
  }, {
    "title": "Safe Exploration in Finite Markov Decision Processes with Gaussian Processes",
    "authors": ["Turchetta", "Matteo", "Berkenkamp", "Felix", "Krause", "Andreas"],
    "venue": "In NIPS,",
    "year": 2016
  }, {
    "title": "Theory of Games and Economic Behavior",
    "authors": ["von Neumann", "John", "Morgenstern", "Oskar"],
    "year": 1944
  }, {
    "title": "Learning deep control policies for autonomous aerial vehicles with mpc-guided policy search",
    "authors": ["T Zhang", "G Kahn", "S Levine", "P. Abbeel"],
    "year": 2016
  }, {
    "title": "Rank-one approximation to higher order tensors",
    "authors": ["Zhang", "Tong", "Golub", "Gene H"],
    "venue": "SIAM J. Matrix Anal. Appl.,",
    "year": 2001
  }],
  "id": "SP:d9c2a6c6ba81616afbd3b69956917cb53831e081",
  "authors": [{
    "name": "David Balduzzi",
    "affiliations": []
  }],
  "abstractText": "As artificial agents proliferate, it is becoming increasingly important to ensure that their interactions with one another are well-behaved. In this paper, we formalize a common-sense notion of when algorithms are well-behaved: an algorithm is safe if it does no harm. Motivated by recent progress in deep learning, we focus on the specific case where agents update their actions according to gradient descent. The paper shows that that gradient descent converges to a Nash equilibrium in safe games. The main contribution is to define strongly-typed agents and show they are guaranteed to interact safely, thereby providing sufficient conditions to guarantee safe interactions. A series of examples show that strong-typing generalizes certain key features of convexity, is closely related to blind source separation, and introduces a new perspective on classical multilinear games based on tensor decomposition.",
  "title": "Strongly-Typed Agents are Guaranteed to Interact Safely"
}