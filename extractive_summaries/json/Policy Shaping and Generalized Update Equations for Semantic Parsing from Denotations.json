{
  "sections": [{
    "text": "Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 2442–2452 Brussels, Belgium, October 31 - November 4, 2018. c©2018 Association for Computational Linguistics\n2442"
  }, {
    "heading": "1 Introduction",
    "text": "Semantic parsing from denotations (SpFD) is the problem of mapping text to executable formal representations (or program) in a situated environment and executing them to generate denotations (or answer), in the absence of access to correct representations. Several problems have been handled within this framework, including question answering (Berant et al., 2013; Iyyer et al., 2017) and instructions for robots (Artzi and Zettlemoyer, 2013; Misra et al., 2015).\nConsider the example in Figure 1. Given the question and a table environment, a semantic parser maps the question to an executable program, in this case a SQL query, and then executes the query on the environment to generate the answer England. In the SpFD setting, the training data does not contain the correct programs. Thus, the existing learning approaches for SpFD perform two steps for every training example, a search step that explores the space of programs\nQuestion: what nation scored the most points\nIndex Name Nation Points Games Pts/game 1 Karen Andrew England 44 5 8.8 2 Daniella Waterman England 40 5 8 3 Christelle Le Duff France 33 5 6.6 4 Charlotte Barras England 30 5 6 5 Naomi Thomas Wales 25 5 5\nSelect Nation Where Points is Maximum\nProgram:\nAnswer:\nEnvironment:\nEngland\nFigure 1: An example of semantic parsing from denotations. Given the table environment, map the question to an executable program that evaluates to the answer.\nand finds suitable candidates, and an update step that uses these programs to update the model. Figure 2 shows the two step training procedure for the above example.\nIn this paper, we address two key challenges in model training for SpFD by proposing a novel learning framework, improving both the search and update steps. The first challenge, the existence of spurious programs, lies in the search step. More specifically, while the success of the search step relies on its ability to find programs that are semantically correct, we can only verify if the program can generate correct answers, given that no gold programs are presented. The search step is complicated by spurious programs, which happen to evaluate to the correct answer but do not represent accurately the meaning of the natural language question. For example, for the environment in Figure 1, the program Select Nation Where Name = Karen Andrew is spurious. Selecting spurious programs as positive examples can greatly affect the performance of semantic parsers as these programs generally do not gen-\neralize to unseen questions and environments. The second challenge, choosing a learning algorithm, lies in the update step. Because of the unique indirect supervision setting of SpFD, the quality of the learned semantic parser is dictated by the choice of how to update the model parameters, often determined empirically. As a result, several families of learning methods, including maximum marginal likelihood, reinforcement learning and margin based methods have been used. How to effectively explore different model choices could be crucial in practice.\nOur contributions in this work are twofold. To address the first challenge, we propose a policy shaping (Griffith et al., 2013) method that incorporates simple, lightweight domain knowledge, such as a small set of lexical pairs of tokens in the question and program, in the form of a critique policy (§ 3). This helps bias the search towards the correct program, an important step to improve supervision signals, which benefits learning regardless of the choice of algorithm. To address the second challenge, we prove that the parameter update step in several algorithms are similar and can be viewed as special cases of a generalized update equation (§ 4). The equation contains two variable terms that govern the update behavior. Changing these two terms effectively defines an infinite class of learning algorithms where different values lead to significantly different results. We study this effect and propose a novel learning framework that improves over existing methods.\nWe evaluate our methods using the sequential question answering (SQA) dataset (Iyyer et al., 2017), and show that our proposed improvements to the search and update steps consistently enhance existing approaches. The proposed algorithm achieves new state-of-the-art and outperforms existing parsers by 5.0%."
  }, {
    "heading": "2 Background",
    "text": "We give a formal problem definition of the semantic parsing task, followed by the general learning framework for solving it."
  }, {
    "heading": "2.1 The Semantic Parsing Task",
    "text": "The problem discussed in this paper can be formally defined as follows. Let X be the set of all possible questions, Y programs (e.g., SQL-like queries), T tables (i.e., the structured data in this work) and Z answers. We further assume access to an executor : Y ⇥ T ! Z , that given a program y 2 Y and a table t 2 T , generates an answer (y, t) 2 Z . We assume that the executor and all tables are deterministic and the executor can be called as many times as possible. To facilitate discussion in the following sections, we define an environment function et : Y ! Z , by applying the executor to the program as et(y) = (y, t).\nGiven a question x and an environment et, our aim is to generate a program y⇤ 2 Y and then execute it to produce the answer et(y⇤). Assume that for any y 2 Y , the score of y being a correct program for x is score✓(y, x, t), parameterized by ✓. The inference task is thus:\ny⇤ = arg max y2Y score✓(y, x, t) (1)\nAs the size of Y is exponential to the length of the program, a generic search procedure is typically employed for Eq. (1), as efficient dynamic algorithms typically do not exist. These search procedures generally maintain a beam of program states sorted according to some scoring function, where each program state represents an incomplete program. The search then generates a new program state from an existing state by performing an action. Each action adds a set of tokens (e.g., Nation) and keyword (e.g., Select) to a\nprogram state. For example, in order to generate the program in Figure 1, the DynSP parser (Iyyer et al., 2017) will take the first action as adding the SQL expression Select Nation. Notice that score✓ can be used in either probabilistic or nonprobabilistic models. For probabilistic models, we assume that it is a Boltzmann policy, meaning that p✓(y | x, t) / exp{score✓(y, x, t)}."
  }, {
    "heading": "2.2 Learning",
    "text": "Learning a semantic parser is equivalent to learning the parameters ✓ in the scoring function, which is a structured learning problem, due to the large, structured output space Y . Structured learning algorithms generally consist of two major components: search and update. When the gold programs are available during training, the search procedure finds a set of high-scoring incorrect programs. These programs are used by the update step to derive loss for updating parameters. For example, these programs are used for approximating the partition-function in maximum-likelihood objective (Liang et al., 2011) and finding set of programs causing margin violation in margin based methods (Daumé III and Marcu, 2005). Depending on the exact algorithm being used, these two components are not necessarily separated into isolated steps. For instance, parameters can be updated in the middle of search (e.g., Huang et al., 2012).\nFor learning semantic parsers from denotations, where we assume only answers are available in a training set {(xi, ti, zi)}Ni=1 of N examples, the basic construction of the learning algorithms remains the same. However, the problems that search needs to handle in SpFD is more challenging. In addition to finding a set of high-scoring incorrect programs, the search procedure also needs to guess the correct program(s) evaluating to the gold answer zi. This problem is further complicated by the presence of spurious programs, which generate the correct answer but are semantically incompatible with the question. For example, although all programs in Figure 2 evaluate to the same answer, only one of them is correct. The issue of the spurious programs also affects the design of model update. For instance, maximum marginal likelihood methods treat all the programs that evaluate to the gold answer equally, while maximum margin reward networks use model score to break tie and pick one of the\nprograms as the correct reference."
  }, {
    "heading": "3 Addressing Spurious Programs: Policy Shaping",
    "text": "Given a training example (x, t, z), the aim of the search step is to find a set K(x, t, z) of programs consisting of correct programs that evaluate to z and high-scoring incorrect programs. The search step should avoid picking up spurious programs for learning since such programs typically do not generalize. For example, in Figure 2, the spurious program Select Nation Where Index is Min will evaluate to an incorrect answer if the indices of the first two rows are swapped1. This problem is challenging since among the programs that evaluate to the correct answer, most of them are spurious.\nThe search step can be viewed as following an exploration policy b✓(y|x, t, z) to explore the set of programs Y . This exploration is often performed by beam search and at each step, we either sample from b✓ or take the top scoring programs. The set K(x, t, z) is then used by the update step for parameter update. Most search strategies use an exploration policy which is based on the score function, for example b✓(y|x, t, z) / exp{score✓(y, t)}. However, this approach can suffer from a divergence phenomenon whereby the score of spurious programs picked up by the search in the first epoch increases, making it more likely for the search to pick them up in the future. Such divergence issues are common with latent-variable learning and often require careful initialization to overcome (Rose, 1998). Unfortunately such initialization schemes are not applicable for deep neural networks which form the model of most successful semantic parsers today (Jia and Liang, 2016; Misra and Artzi, 2016; Iyyer et al., 2017). Prior work, such as ✏-greedy exploration (Guu et al., 2017), has reduced the severity of this problem by introducing random noise in the search procedure to avoid saturating the search on high-scoring spurious programs. However, random noise need not bias the search towards the correct program(s). In this paper, we introduce a simple policy-shaping method to guide the search. This approach allows incorporating prior knowledge in the exploration policy and can bias the search away from spurious programs.\n1This transformation preserves the answer of the question.\nAlgorithm 1 Learning a semantic parser from denotation using generalized updates.\nInput: Training set {(xi, ti, zi}Ni=1 (see Section 2), learning rate µ and stopping epoch T (̃see Section 4). Definitions: score✓(y, x, t) is a semantic parsing model parameterized by ✓. ps(y | x, t) is the policy used for exploration and search(✓, x, t, z, ps) generates candidate programs for updating parameters (see Section 3). is the generalized update (see Section 4). Output: Model parameters ✓. 1: » Iterate over the training data. 2: for t = 1 to T , i = 1 to N do 3: » Find candidate programs using the shaped policy. 4: K = search(✓, xi, ti, zi, ps) 5: » Compute generalized gradient updates 6: ✓ = ✓ + µ (K) 7: return ✓\nPolicy Shaping Policy shaping is a method to introduce prior knowledge into a policy (Griffith et al., 2013). Formally, let the current behavior policy be b✓(y|x, t, z) and a predefined critique policy, the prior knowledge, be pc(y|x, t). Policy shaping defines a new shaped behavior policy pb(y|x, t) given by:\npb(y|x, t) = b✓(y|x, t, z)pc(y|x, t)P\ny02Y b✓(y 0|x, t, z)pc(y0|x, t)\n. (2)\nUsing the shaped policy for exploration biases the search towards the critique policy’s preference. We next describe a simple critique policy that we use in this paper.\nLexical Policy Shaping We qualitatively observed that correct programs often contains tokens which are also present in the question. For example, the correct program in Figure 2 contains the token Points, which is also present in the question. We therefore, define a simple surface form similarity feature match(x, y) that computes the ratio of number of non-keyword tokens in the program y that are also present in the question x.\nHowever, surface-form similarity is often not enough. For example, both the first and fourth program in Figure 2 contain the token Points but only the fourth program is correct. Therefore, we also use a simple co-occurrence feature that triggers on frequently co-occurring pairs of tokens in the program and instruction. For example, the token most is highly likely to co-occur with a correct program containing the keyword Max. This happens for the example in Figure 2. Similarly the token not may co-occur with the keyword NotEqual. We assume access to a lexicon ⇤ = {(wj , !j)}kj=1 containing\nk lexical pairs of tokens and keywords. Each lexical pair (w, !) maps the token w in a text to a keyword ! in a program. For a given program y and question x, we define a co-occurrence score as co_occur(y, x) = P (w,!)2⇤ {w 2 x ^ ! 2 y}}. We define critique score critique(y, x) as the sum of the match and co_occur scores. The critique policy is given by:\npc(y|x, t) / exp (⌘ ⇤ critique(y, x)) , (3)\nwhere ⌘ is a single scalar hyper-parameter denoting the confidence in the critique policy."
  }, {
    "heading": "4 Addressing Update Strategy Selection: Generalized Update Equation",
    "text": "Given the set of programs generated by the search step, one can use many objectives to update the parameters. For example, previous work have utilized maximum marginal likelihood (Krishnamurthy et al., 2017; Guu et al., 2017), reinforcement learning (Zhong et al., 2017; Guu et al., 2017) and margin based methods (Iyyer et al., 2017). It could be difficult to choose the suitable algorithm from these options.\nIn this section, we propose a principle and general update equation such that previous update algorithms can be considered as special cases to this equation. Having a general update is important for the following reasons. First, it allows us to understand existing algorithms better by examining their basic properties. Second, the generalized update equation also makes it easy to implement and experiment with various different algorithms. Moreover, it provides a framework that enables the development of new variations or extensions of existing learning methods.\nIn the following, we describe how the commonly used algorithms are in fact very similar – their update rules can all be viewed as special cases of the proposed generalized update equation. Algorithm 1 shows the meta-learning framework. For every training example, we first find a set of candidates using an exploration policy (line 4). We use the program candidates to update the parameters (line 6)."
  }, {
    "heading": "4.1 Commonly Used Learning Algorithms",
    "text": "We briefly describe three algorithms: maximum marginalized likelihood, policy gradient and maximum margin reward.\nMaximum Marginalized Likelihood The maximum marginalized likelihood method maximizes the log-likelihood of the training data by marginalizing over the set of programs.\nJMML = log p(zi|xi, ti) = log X\ny2Y p(zi|y, ti)p(y|xi, ti) (4)\nBecause an answer is deterministically computed given a program and a table, we define p(z | y, t) as 1 or 0 depending upon whether the y evaluates to z given t, or not. Let Gen(z, t) ✓ Y be the set of compatible programs that evaluate to z given the table t. The objective can then be expressed as:\nJMML = log X\ny2Gen(zi,ti)\np(y|xi, ti) (5)\nIn practice, the summation over Gen(.) is approximated by only using the compatible programs in the set K generated by the search step.\nPolicy Gradient Methods Most reinforcement learning approaches for semantic parsing assume access to a reward function R : Y ⇥X ⇥Z ! R, giving a scalar reward R(y, z) for a given program y and the correct answer z.2 We can further assume without loss of generality that the reward is always in [0, 1]. Reinforcement learning approaches maximize the expected reward JRL:\nJRL = X\ny2Y p(y|xi, ti)R(y, zi) (6)\nJRL is hard to approximate using numerical integration since the reward for all programs may not be known a priori. Policy gradient methods solve this by approximating the derivative using a sample from the policy. When the search space is large, the policy may fail to sample a correct program, which can greatly slow down the learning. Therefore, off-policy methods are sometimes introduced to bias the sampling towards high-reward yielding programs. In those methods, an additional exploration policy u(y|xi, ti, zi) is used to improve sampling. Importance weights are used to make the gradient unbiased (see Appendix for derivation).\n2This is essentially a contextual bandit setting. Guu et al. (2017) also used this setting. A general reinforcement learning setting requires taking a sequence of actions and receiving a reward for each action. For example, a program can be viewed as a sequence of parsing actions, where each action can get a reward. We do not consider the general setting here.\nMaximum Margin Reward For every training example (xi, ti, zi), the maximum margin reward method finds the highest scoring program yi that evaluates to zi, as the reference program, from the set K of programs generated by the search. With a margin function : Y⇥Y⇥Z ! R and reference program y, the set of programs V that violate the margin constraint can thus be defined as:\nV = {y0 | y0 2 Y and score✓(y, x, t)  score✓(y0, x, t) + (y, y0, z)}, (7)\nwhere (y, y0, z) = R(y, z) R(y0, z). Similarly, the program that most violates the constraint can be written as:\nȳ = arg max y02Y\n{score✓(y0, x, t) + (y, y0, z)\nscore✓(y, x, t)} (8)\nThe most-violation margin objective (negative margin loss) is thus defined as:\nJMMR = max{0, score✓(ȳ, xi, ti) score✓(yi, xi, ti) + (yi, ȳ, zi)}\nUnlike the previous two learning algorithms, margin methods only update the score of the reference program and the program that violates the margin."
  }, {
    "heading": "4.2 Generalized Update Equation",
    "text": "Although the algorithms described in §4.1 seem very different on the surface, the gradients of their loss functions can in fact be described in the same generalized form, given in Eq. (9)3. In addition to the gradient of the model scoring function, this equation has two variable terms, w(·), q(·). We call the first term w(y, x, t, z) intensity, which is a positive scalar value and the second term q(y|x, t) the competing distribution, which is a probability distribution over programs. Varying them makes the equation equivalent to the update rule of the algorithms we discussed, as shown in Table 1. We also consider meritocratic update policy which uses a hyperparameter to sharpen or smooth the intensity of maximum marginal likelihood (Guu et al., 2017).\nIntuitively, w(y, x, t, z) defines the positive part of the update equation, which defines how aggressively the update favors program y. Likewise, q(y|x, t) defines the negative part of the learning\n3See Appendix for the detailed derivation.\nGeneralized Update Equation:\n(K) = X\ny2K w(y, x, t, z)\n0 @r✓score✓(y, x, t) X\ny02Y q(y0|x, t)r✓score✓(y0, x, t)\n1\nA (9)\nalgorithm, namely how aggressively the update penalizes the members of the program set.\nThe generalized update equation provides a tool for better understanding individual algorithm, and helps shed some light on when a particular method may perform better.\nIntensity versus Search Quality In SpFD, the effectiveness of the algorithms for SpFD is closely related to the quality of the search results given that the gold program is not available. Intuitively, if the search quality is good, the update algorithm could be aggressive on updating the model parameters. When the search quality is poor, the algorithm should be conservative.\nThe intensity w(·) is closely related to the aggressiveness of the algorithm. For example, the maximum marginal likelihood is less aggressive given that it produces a non-zero intensity over all programs in the program set K that evaluate to the correct answer. The intensity for a particular correct program y is proportional to its probability p(y|x, t). Further, meritocratic update becomes more aggressive as becomes larger.\nIn contrast, REINFORCE and maximum margin reward both have a non-zero intensity only on a single program in K. This value is 1.0 for maximum margin reward, while for reinforcement learning, this value is the reward. Maximum margin reward therefore updates most aggressively in favor of its selection while maximum marginal\nlikelihood tends to hedge its bet. Therefore, the maximum margin methods should benefit the most when the search quality improves.\nStability The general equation also allows us to investigate the stability of a model update algorithm. In general, the variance of update direction can be high, hence less stable, if the model update algorithm has peaky competing distribution, or it puts all of its intensity on a single program. For example, REINFORCE only samples one program and puts non-zero intensity only on that program, so it could be unstable depending on the sampling results.\nThe competing distribution affects the stability of the algorithm. For example, maximum margin reward penalizes only the most violating program and is benign to other incorrect programs. Therefore, the MMR algorithm could be unstable during training.\nNew Model Update Algorithm The general equation provides a framework that enables the development of new variations or extensions of existing learning methods. For example, in order to improve the stability of the MMR algorithm, we propose a simple variant of maximum margin reward, which penalizes all violating programs instead of only the most violating one. We call this approach maximum margin average violation reward (MAVER), which is included in Table 1 as well. Given that MAVER effectively considers\nmore negative examples during each update, we expect that it is more stable compared to the MMR algorithm."
  }, {
    "heading": "5 Experiments",
    "text": "We describe the setup in §5.1 and results in §5.2."
  }, {
    "heading": "5.1 Setup",
    "text": "Dataset We use the sequential question answering (SQA) dataset (Iyyer et al., 2017) for our experiments. SQA contains 6,066 sequences and each sequence contains up to 3 questions, with 17,553 questions in total. The data is partitioned into training (83%) and test (17%) splits. We use 4/5 of the original train split as our training set and the remaining 1/5 as the dev set. We evaluate using exact match on answer. Previous state-of-theart result on the SQA dataset is 44.7% accuracy, using maximum margin reward learning.\nSemantic Parser Our semantic parser is based on DynSP (Iyyer et al., 2017), which contains a set of SQL actions, such as adding a clause (e.g., Select Column) or adding an operator (e.g., Max). Each action has an associated neural network module that generates the score for the action based on the instruction, the table and the list of past actions. The score of the entire program is given by the sum of scores of all actions.\nWe modified DynSP to improve its representational capacity. We refer to the new parser as DynSP++. Most notably, we included new features and introduced two additional parser actions. See Appendix 8.2 for more details. While these improvements help us achieve state-of-the-art results, the majority of the gain comes from the learning contributions described in this paper.\nHyperparameters For each experiment, we train the model for 30 epochs. We find the optimal stopping epoch by evaluating the model on the dev set. We then train on train+dev set till the stopping epoch and evaluate the model on the held-out test set. Model parameters are trained using stochastic gradient descent with learning rate of 0.1. We set the hyperparameter ⌘ for policy shaping to 5. All hyperparameters were tuned on the dev set. We use 40 lexical pairs for defining the co-occur score. We used common English superlatives (e.g., highest, most) and comparators (e.g., more, larger) and did not fit the lexical pairs based on the dataset.\nGiven the model parameter ✓, we use a base exploration policy defined in (Iyyer et al., 2017). This exploration policy is given by b✓(y | x, t, z) / exp( · R(y, z) + score✓(y, ✓, z)). R(y, z) is the reward function of the incomplete program y, given the answer z. We use a reward function R(y, z) given by the Jaccard similarity of the gold answer z and the answer generated by the program y. The value of is set to infinity, which essentially is equivalent to sorting the programs based on the reward and using the current model score for tie breaking. Further, we prune all syntactically invalid programs. For more details, we refer the reader to (Iyyer et al., 2017)."
  }, {
    "heading": "5.2 Results",
    "text": "Table 2 contains the dev and test results when using our algorithm on the SQA dataset. We observe that margin based methods perform better than maximum likelihood methods and policy gradient in our experiment. Policy shaping in general improves the performance across different algorithms. Our best test results outperform previous SOTA by 5.0%.\nPolicy Gradient vs Off-Policy Gradient REINFORCE, a simple policy gradient method, achieved extremely poor performance. This likely due to the problem of exploration and having to sample from a large space of programs. This is further corroborated from observing the much superior performance of off-policy policy gradient methods. Thus, the sampling policy is an important factor to consider for policy gradient methods.\nThe Effect of Policy Shaping We observe that the improvement due to policy shaping is 6.0% on the SQA dataset for MAVER and only 1.3% for maximum marginal likelihood. We also observe that as increases, the improvement due to policy shaping for meritocratic update increases. This supports our hypothesis that aggressive updates of margin based methods is beneficial when the search method is more accurate as compared to maximum marginal likelihood which hedges its bet between all programs that evaluate to the right answer.\nStability of MMR In Section 4, the general update equation helps us point out that MMR could be unstable due to the peaky competing distribution. MAVER was proposed to increase the stability of the algorithm. To measure stability, we cal-\nculate the mean absolute difference of the development set accuracy between successive epochs during training, as it indicates how much an algorithm’s performance fluctuates during training. With this metric, we found mean difference for MAVER is 0.57% where the mean difference for MMR is 0.9%. This indicates that MAVER is in fact more stable than MMR.\nOther variations We also analyze other possible novel learning algorithms that are made possible due to generalized update equations. Table 3 reports development results using these algorithms. By mixing different intensity scalars and competing distribution from different algorithms, we can create new variations of the model update algorithm. In Table 3, we show that by mixing the MMR’s intensity and MML’s competing distribution, we can create an algorithm that outperform MMR on the development set.\nPolicy Shaping helps against Spurious Programs In order to better understand if policy shaping helps bias the search away from spurious programs, we analyze 100 training examples. We look at the highest scoring program in the beam at the end of training using MAVER. Without policy shaping, we found that 53 programs were spurious while using policy shaping this number came down to 23. We list few examples of spurious program errors corrected by policy shaping in Table 4.\nPolicy Shaping vs Model Shaping Critique policy contains useful information that can bias the search away from spurious programs. Therefore, one can also consider making the critique policy as part of the model. We call this model shaping. We define our model to be the shaped policy and train and test using the new model. Using MAVER updates, we found that the dev accuracy dropped to 37.1%. We conjecture that the strong prior in the critique policy can hinder generalization in model shaping."
  }, {
    "heading": "6 Related Work",
    "text": "Semantic Parsing from Denotation Mapping natural language text to formal meaning representation was first studied by Montague (1970). Early work on learning semantic parsers rely on labeled formal representations as the supervision signals (Zettlemoyer and Collins, 2005, 2007; Zelle and Mooney, 1993). However, because getting access to gold formal representation generally requires expensive annotations by an expert, distant supervision approaches, where semantic parsers are learned from denotation only, have become the main learning paradigm (e.g., Clarke et al., 2010; Liang et al., 2011; Artzi and Zettlemoyer, 2013; Berant et al., 2013; Iyyer et al., 2017; Krishnamurthy et al., 2017). Guu et al. (2017) studied the problem of spurious programs and considered adding noise to diversify the search procedure and introduced meritocratic updates.\nReinforcement Learning Algorithms Reinforcement learning algorithms have been applied to various NLP problems including dialogue (Li et al., 2016), text-based games (Narasimhan et al., 2015), information extraction (Narasimhan et al., 2016), coreference resolution (Clark and Man-\nning, 2016), semantic parsing (Guu et al., 2017) and instruction following (Misra et al., 2017). Guu et al. (2017) show that policy gradient methods underperform maximum marginal likelihood approaches. Our result on the SQA dataset supports their observation. However, we show that using off-policy sampling, policy gradient methods can provide superior performance to maximum marginal likelihood methods.\nMargin-based Learning Margin-based methods have been considered in the context of SVM learning. In the NLP literature, margin based learning has been applied to parsing (Taskar et al., 2004; McDonald et al., 2005), text classification (Taskar et al., 2003), machine translation (Watanabe et al., 2007) and semantic parsing (Iyyer et al., 2017). Kummerfeld et al. (2015) found that max-margin based methods generally outperform likelihood maximization on a range of tasks. Previous work have studied connections between margin based method and likelihood maximization for supervised learning setting. We show them as special cases of our unified update equation for distant supervision learning. Similar to this work, Lee et al. (2016) also found that in the context of supervised learning, margin-based algorithms which update all violated examples perform better than the one that only updates the most violated example.\nLatent Variable Modeling Learning semantic parsers from denotation can be viewed as a latent variable modeling problem, where the program is the latent variable. Probabilistic latent variable models have been studied using EM-algorithm and its variant (Dempster et al., 1977). The graphical model literature has studied latent variable learning on margin-based methods (Yu and Joachims, 2009) and probabilistic models (Quattoni et al., 2007). Samdani et al. (2012) studied various vari-\nants of EM algorithm and showed that all of them are special cases of a unified framework. Our generalized update framework is similar in spirit."
  }, {
    "heading": "7 Conclusion",
    "text": "In this paper, we propose a general update equation from semantic parsing from denotation and propose a policy shaping method for addressing the spurious program challenge. For the future, we plan to apply the proposed learning framework to more semantic parsing tasks and consider new methods for policy shaping."
  }, {
    "heading": "8 Acknowledgements",
    "text": "We thank Ryan Benmalek, Alane Suhr, Yoav Artzi, Claire Cardie, Chris Quirk, Michel Galley and members of the Cornell NLP group for their valuable comments. We are also grateful to Allen Institute for Artificial Intelligence for the computing resource support. This work was initially started when the first author interned at Microsoft Research."
  }],
  "year": 2018,
  "references": [{
    "title": "Weakly supervised learning of semantic parsers for mapping instructions to actions",
    "authors": ["Yoav Artzi", "Luke Zettlemoyer."],
    "venue": "Transactions of the Association of Computational Linguistics, 1:49–62.",
    "year": 2013
  }, {
    "title": "Semantic parsing on Freebase from question-answer pairs",
    "authors": ["Jonathan Berant", "Andrew Chou", "Roy Frostig", "Percy Liang."],
    "venue": "Proceedings of the Con-",
    "year": 2013
  }, {
    "title": "Deep reinforcement learning for mention-ranking coreference models",
    "authors": ["Kevin Clark", "D. Christopher Manning."],
    "venue": "Proceedings of the 2016 Con-",
    "year": 2016
  }, {
    "title": "Driving semantic parsing",
    "authors": ["James Clarke", "Dan Goldwasser", "Ming-Wei Chang", "Dan Roth"],
    "year": 2010
  }, {
    "title": "Learning as search optimization: Approximate large margin methods for structured prediction",
    "authors": ["Hal Daumé III", "Daniel Marcu."],
    "venue": "Proceedings",
    "year": 2005
  }, {
    "title": "Maximum likelihood from incomplete data via the em algorithm",
    "authors": ["Arthur P Dempster", "Nan M Laird", "Donald B Rubin."],
    "venue": "Journal of the royal statistical society. Series B (methodological), pages 1–38.",
    "year": 1977
  }, {
    "title": "Policy shaping: Integrating human feedback with reinforcement learning",
    "authors": ["Shane Griffith", "Kaushik Subramanian", "Jonathan Scholz", "Charles Lee Isbell", "Andrea Lockerd Thomaz."],
    "venue": "Advances in Neural Information Processing Systems.",
    "year": 2013
  }, {
    "title": "From language to programs: Bridging reinforcement learning and maximum marginal likelihood",
    "authors": ["Kelvin Guu", "Panupong Pasupat", "Evan Liu", "Percy Liang."],
    "venue": "Proceedings of the 55th Annual Meet-",
    "year": 2017
  }, {
    "title": "Structured perceptron with inexact search",
    "authors": ["Liang Huang", "Suphan Fayong", "Yang Guo."],
    "venue": "Pro-",
    "year": 2012
  }, {
    "title": "Search-based neural structured learning for sequential question answering",
    "authors": ["Mohit Iyyer", "Wen-tau Yih", "Ming-Wei Chang."],
    "venue": "Proceedings of the 55th",
    "year": 2017
  }, {
    "title": "Data recombination for neural semantic parsing",
    "authors": ["Robin Jia", "Percy Liang."],
    "venue": "Proceedings of the",
    "year": 2016
  }, {
    "title": "Neural semantic parsing with type constraints for semi-structured tables",
    "authors": ["Jayant Krishnamurthy", "Pradeep Dasigi", "Matt Gardner."],
    "venue": "Proceedings of",
    "year": 2017
  }, {
    "title": "An empirical analysis of optimization for max-margin nlp",
    "authors": ["Jonathan K. Kummerfeld", "Taylor Berg-Kirkpatrick", "Dan Klein."],
    "venue": "EMNLP.",
    "year": 2015
  }, {
    "title": "Global neural CCG parsing with optimality guarantees",
    "authors": ["Kenton Lee", "Mike Lewis", "Luke Zettlemoyer."],
    "venue": "Proceedings of the 2016 Conference on Em-",
    "year": 2016
  }, {
    "title": "Deep reinforcement learning for dialogue generation",
    "authors": ["Jiwei Li", "Will Monroe", "Alan Ritter", "Dan Jurafsky", "Michel Galley", "Jianfeng Gao."],
    "venue": "Pro-",
    "year": 2016
  }, {
    "title": "Online large-margin training of dependency parsers",
    "authors": ["Linguistics. Ryan T. McDonald", "Koby Crammer", "Fernando Pereira"],
    "year": 2005
  }, {
    "title": "Environment-driven lexicon induction for high-level instructions",
    "authors": ["Conference on Empirical Methods in Natural Language Processing. Kumar Dipendra Misra", "Kejia Tao", "Percy Liang", "Ashutosh Saxena."],
    "venue": "Pro-",
    "year": 2015
  }, {
    "title": "Language understanding for textbased games using deep reinforcement learning",
    "authors": ["Barzilay."],
    "venue": "In",
    "year": 2015
  }, {
    "title": "Unified expectation maximization",
    "authors": ["Rajhans Samdani", "Ming-Wei Chang", "Dan Roth"],
    "year": 2012
  }, {
    "title": "Max-margin markov networks",
    "authors": ["Ben Taskar", "Carlos Guestrin", "Daphne Koller."],
    "venue": "NIPS.",
    "year": 2003
  }, {
    "title": "Max-margin parsing",
    "authors": ["Ben Taskar", "Dan Klein", "Mike Collins", "Daphne Koller", "Christopher Manning."],
    "venue": "Proceedings of the 2004 Conference on Empirical Methods in Natural Language Processing.",
    "year": 2004
  }, {
    "title": "Online large-margin training for statistical machine translation",
    "authors": ["Taro Watanabe", "Jun Suzuki", "Hajime Tsukada", "Hideki Isozaki."],
    "venue": "EMNLPCoNLL.",
    "year": 2007
  }, {
    "title": "Simple statistical gradientfollowing algorithms for connectionist reinforcement learning",
    "authors": ["Ronald J. Williams."],
    "venue": "Machine Learning, 8.",
    "year": 1992
  }, {
    "title": "Learning structural svms with latent variables",
    "authors": ["Chun-Nam John Yu", "Thorsten Joachims."],
    "venue": "In",
    "year": 2009
  }, {
    "title": "Learning semantic grammars with constructive inductive logic programming",
    "authors": ["John M Zelle", "Raymond J Mooney."],
    "venue": "AAAI, pages 817–822.",
    "year": 1993
  }, {
    "title": "Learning to map sentences to logical form: Structured classification with probabilistic categorial grammars",
    "authors": ["Luke S. Zettlemoyer", "Michael Collins."],
    "venue": "Proceedings of the Conference on Uncertainty in Artificial Intelligence.",
    "year": 2005
  }, {
    "title": "Online learning of relaxed CCG grammars for parsing to logical form",
    "authors": ["Luke S. Zettlemoyer", "Michael Collins."],
    "venue": "Proceedings of the Conference on",
    "year": 2007
  }, {
    "title": "Seq2SQL: Generating structured queries from natural language using reinforcement learning",
    "authors": ["Victor Zhong", "Caiming Xiong", "Richard Socher."],
    "venue": "CoRR, abs/1709.00103.",
    "year": 2017
  }],
  "id": "SP:6d7c5118f68646eac489b26bd555a7008f656bb2",
  "authors": [{
    "name": "Dipendra Misra",
    "affiliations": []
  }, {
    "name": "Ming-Wei Chang",
    "affiliations": []
  }, {
    "name": "Xiaodong He",
    "affiliations": []
  }, {
    "name": "Wen-tau Yih",
    "affiliations": []
  }],
  "abstractText": "Semantic parsing from denotations faces two key challenges in model training: (1) given only the denotations (e.g., answers), search for good candidate semantic parses, and (2) choose the best model update algorithm. We propose effective and general solutions to each of them. Using policy shaping, we bias the search procedure towards semantic parses that are more compatible to the text, which provide better supervision signals for training. In addition, we propose an update equation that generalizes three different families of learning algorithms, which enables fast model exploration. When experimented on a recently proposed sequential question answering dataset, our framework leads to a new state-of-theart model that outperforms previous work by 5.0% absolute on exact match accuracy.",
  "title": "Policy Shaping and Generalized Update Equations for Semantic Parsing from Denotations"
}