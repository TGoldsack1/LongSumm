{
  "sections": [{
    "heading": "1. Introduction",
    "text": "The method of k-nearest neighbours is a fundamental building block of many machine learning algorithms and also has broad applications beyond artificial intelligence, including in statistics, bioinformatics and database systems, e.g. (Biau et al., 2011; Behnam et al., 2013; Eldawy & Mokbel, 2015). Consequently, since the problem of nearest neighbour search was first posed by Minsky & Papert (1969), it has for decades intrigued the artificial intelligence and theoretical computer science communities alike. Unfortunately, the myriad efforts at devising efficient algorithms have encountered a recurring obstacle: the\n1University of California, Berkeley, CA 94720, United States. Correspondence to: Ke Li <ke.li@eecs.berkeley.edu>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\ncurse of dimensionality, which describes the phenomenon of query time complexity depending exponentially on dimensionality. As a result, even on datasets with moderately high dimensionality, practitioners often have resort to naı̈ve exhaustive search.\nTwo notions of dimensionality are commonly considered. The more familiar notion, ambient dimensionality, refers to the dimensionality of the space data points are embedded in. On the other hand, intrinsic dimensionality1 characterizes the intrinsic properties of the data and measures the rate at which the number of points inside a ball grows as a function of its radius. More precisely, for a dataset with intrinsic dimension d0, any ball of radius r contains at most O(rd 0 ) points. Intuitively, if the data points are uniformly distributed on a manifold, then the intrinsic dimensionality is roughly the dimensionality of the manifold.\nMost existing methods suffer from some form of curse of dimensionality. Early methods like k-d trees (Bentley, 1975) and R-trees (Guttman, 1984) have query times that grow exponentially in ambient dimensionality. Later methods (Krauthgamer & Lee, 2004; Beygelzimer et al., 2006; Dasgupta & Freund, 2008) overcame the exponential dependence on ambient dimensionality, but have not been able to escape from an exponential dependence on intrinsic dimensionality. Indeed, since a linear increase in the intrinsic dimensionality results in an exponential increase in the number of points near a query, the problem seems fundamentally hard when intrinsic dimensionality is high.\nRecently, Li & Malik (2016) proposed an approach known as Dynamic Continuous Indexing (DCI) that successfully reduces the dependence on intrinsic dimensionality from exponential to sublinear, thereby making high-dimensional nearest neighbour search more practical. The key observation is that the difficulties encountered by many existing methods, including k-d trees and Locality-Sensitive Hashing (LSH) (Indyk & Motwani, 1998), may arise from their reliance on space partitioning, which is a popular divideand-conquer strategy. It works by partitioning the vector space into discrete cells and maintaining a data structure\n1The measure of intrinsic dimensionality used throughout this paper is the expansion dimension, also known as the KRdimension, which is defined as log\n2 c, where c is the expansion rate introduced in (Karger & Ruhl, 2002).\nthat keeps track of the points lying in each cell. At query time, these methods simply look up of the contents of the cell containing the query and possibly adjacent cells and perform brute-force search over points lying in these cells. While this works well in low-dimensional settings, would it work in high dimensions?\nSeveral limitations of this approach in high-dimensional space are identified in (Li & Malik, 2016). First, because the volume of space grows exponentially in dimensionality, either the number or the volumes of cells must grow exponentially. Second, the discretization of the space essentially limits the “field of view” of the algorithm, as it is unaware of points that lie in adjacent cells. This is especially problematic when the query lies near a cell boundary, as there could be points in adjacent cells that are much closer to the query. Third, as dimensionality increases, surface area grows faster than volume; as a result, points are increasingly likely to lie near cell boundaries. Fourth, when the dataset exhibits varying density across space, choosing a good partitioning is non-trivial. Furthermore, once chosen, the partitioning is fixed and cannot adapt to changes in density arising from updates to the dataset.\nIn light of these observations, DCI is built on the idea of avoiding partitioning the vector space. Instead, it constructs a number of indices, each of which imposes an ordering of all data points. Each index is constructed so that two points with similar ranks in the associated ordering are nearby along a certain random direction. These indices are then combined to allow for retrieval of points that are close to the query along multiple random directions.\nIn this paper, we propose a variant of DCI, which assigns a priority to each index that is used to determine which index to process in the upcoming iteration. For this reason, we will refer to this algorithm as Prioritized DCI. This simple change results in a significant improvement in the dependence of query time on intrinsic dimensionality. Specifically, we show a remarkable result: a linear increase in intrinsic dimensionality, which could mean an exponential increase in the number of points near a query, can be mostly counteracted with a corresponding linear increase in the number of indices. In other words, Prioritized DCI can make a dataset with high intrinsic dimensionality seem almost as easy as a dataset with low intrinsic dimensionality, with just a linear increase in space. To our knowledge, there had been no exact method that can cope with high intrinsic dimensionality; Prioritized DCI represents the first method that can do so.\nWe also demonstrate empirically that Prioritized DCI significantly outperforms prior methods. In particular, compared to LSH, it achieves a 14- to 116-fold reduction in the number of distance evaluations and a 21-fold reduction in the memory usage."
  }, {
    "heading": "2. Related Work",
    "text": "There is a vast literature on algorithms for nearest neighbour search. They can be divided into two categories: exact algorithms and approximate algorithms. Early exact algorithms are deterministic and store points in treebased data structures. Examples include k-d trees (Bentley, 1975), R-trees (Guttman, 1984) and X-trees (Berchtold et al., 1996; 1998), which divide the vector space into a hierarchy of half-spaces, hyper-rectangles or Voronoi polygons and keep track of the points that lie in each cell. While their query times are logarithmic in the size of the dataset, they exhibit exponential dependence on the ambient dimensionality. A different method (Meiser, 1993) partitions the space by intersecting multiple hyperplanes. It effectively trades off space for time and achieves polynomial query time in ambient dimensionality at the cost of exponential space complexity in ambient dimensionality.\nTo avoid poor performance on worst-case configurations of the data, exact randomized algorithms have been proposed. Spill trees (Liu et al., 2004), RP trees (Dasgupta & Freund, 2008) and virtual spill trees (Dasgupta & Sinha, 2015) extend the ideas behind k-d trees by randomizing the orientations of hyperplanes that partition the space into halfspaces at each node of the tree. While randomization enables them to avoid exponential dependence on the ambient dimensionality, their query times still scale exponentially in the intrinsic dimensionality. Whereas these methods rely on space partitioning, other algorithms (Orchard, 1991; Clarkson, 1999; Karger & Ruhl, 2002) have been proposed that utilize local search strategies. These methods start with a random point and look in the neighbourhood of the current point to find a new point that is closer to the query than the original in each iteration. Like space partitioningbased approaches, the query time of (Karger & Ruhl, 2002) scales exponentially in the intrinsic dimensionality. While\nthe query times of (Orchard, 1991; Clarkson, 1999) do not exhibit such undesirable dependence, their space complexities are quadratic in the size of the dataset, making them impractical for large datasets. A different class of algorithms performs search in a coarse-to-fine manner. Examples include navigating nets (Krauthgamer & Lee, 2004), cover trees (Beygelzimer et al., 2006) and rank cover trees (Houle & Nett, 2015), which maintain sets of subsampled data points at different levels of granularity and descend through the hierarchy of neighbourhoods of decreasing radii around the query. Unfortunately, the query times of these methods again scale exponentially in the intrinsic dimensionality.\nDue to the difficulties of devising efficient algorithms for the exact version of the problem, there has been extensive work on approximate algorithms. Under the approximate setting, returning any point whose distance to the query is within a factor of 1 + ✏ of the distance between the query and the true nearest neighbour is acceptable. Many of the same strategies are employed by approximate algorithms. Methods based on tree-based space partitioning (Arya et al., 1998) and local search (Arya & Mount, 1993) have been developed; like many exact algorithms, their query times also scale exponentially in the ambient dimensionality. Locality-Sensitive Hashing (LSH) (Indyk & Motwani, 1998; Datar et al., 2004; Andoni & Indyk, 2006) partitions the space into regular cells, whose shapes are implicitly defined by the choice of the hash function. It achieves a query time of O(dn⇢) using O(dn1+⇢) space, where d is the ambient dimensionality, n is the dataset size and ⇢ ⇡ 1/(1 + ✏)2 for large n in Euclidean space,\nthough the dependence on intrinsic dimensionality is not made explicit. In practice, the performance of LSH degrades on datasets with large variations in density, due to the uneven distribution of points across cells. Consequently, various data-dependent hashing schemes have been proposed (Paulevé et al., 2010; Weiss et al., 2009; Andoni & Razenshteyn, 2015); unlike data-independent hashing schemes, however, they do not allow dynamic updates to the dataset. A related approach (Jégou et al., 2011) decomposes the space into mutually orthogonal axis-aligned subspaces and independently partitions each subspace. It has a query time linear in the dataset size and no known guarantee on the probability of correctness under the exact or approximate setting. A different approach (Anagnostopoulos et al., 2015) projects the data to a lower dimensional space that approximately preserves approximate nearest neighbour relationships and applies other approximate algorithms like BBD trees (Arya et al., 1998) to the projected data. Its query time is also linear in ambient dimensionality and sublinear in the dataset size. Unlike LSH, it uses space linear in the dataset size, at the cost of longer query time than LSH. Unfortunately, its query time is exponential in intrinsic dimensionality.\nOur work is most closely related to Dynamic Continuous Indexing (DCI) (Li & Malik, 2016), which is an exact randomized algorithm for Euclidean space whose query time is linear in ambient dimensionality, sublinear in dataset size and sublinear in intrinsic dimensionality and uses space linear in the dataset size. Rather than partitioning the vector space, it uses multiple global one-dimensional indices, each of which orders data points along a certain random direction and combines these indices to find points that are near the query along multiple random directions. The proposed algorithm builds on the ideas introduced by DCI and achieves a significant improvement in the dependence on intrinsic dimensionality.\nA summary of the query times of various prior algorithms and the proposed algorithm is presented in Table 1 and their growth as a function of intrinsic dimensionality is illustrated in Figure 1."
  }, {
    "heading": "3. Prioritized DCI",
    "text": "DCI constructs a data structure consisting of multiple composite indices of data points, each of which in turn consists of a number of simple indices. Each simple index orders data points according to their projections along a particular random direction. Given a query, for every composite index, the algorithm finds points that are near the query in every constituent simple index, which are known as candidate points, and adds them to a set known as the candidate set. The true distances from the query to every candidate point are evaluated and the ones that are among the k clos-\nest to the query are returned.\nMore concretely, each simple index is associated with a random direction and stores the projections of every data point along the direction. They are implemented using standard data structures that maintain one-dimensional ordered sequences of elements, like self-balancing binary search trees (Bayer, 1972; Guibas & Sedgewick, 1978) or skip lists (Pugh, 1990). At query time, the algorithm projects the query along the projection directions associated with each simple index and finds the position where the query would have been inserted in each simple index, which takes logarithmic time. It then iterates over, or visits, data points in each simple index in the order of their distances to the query under projection, which takes constant time for each iteration. As it iterates, it keeps track of how many times each data point has been visited across all simple indices of each composite index. If a data point has been visited in every constituent simple index, it is added to the candidate set and is said to have been retrieved from the composite index.\nAlgorithm 1 Data structure construction procedure\nRequire: A dataset D of n points p1, . . . , pn, the number of simple indices m that constitute a composite index and the number of composite indices L function CONSTRUCT(D,m,L)\n{ujl}j2[m],l2[L] mL random unit vectors in Rd {Tjl}j2[m],l2[L] mL empty binary search trees or skip lists for j = 1 to m do\nfor l = 1 to L do for i = 1 to n do\npijl hpi, ujli Insert (pijl, i) into Tjl with p i jl being the key and\ni being the value end for\nend for\nend for\nreturn {(Tjl, ujl)}j2[m],l2[L] end function\nDCI has a number of appealing properties compared to methods based on space partitioning. Because points are visited by rank rather than location in space, DCI performs well on datasets with large variations in data density. It naturally skips over sparse regions of the space and concentrates more on dense regions of the space. Since construction of the data structure does not depend on the dataset, the algorithm supports dynamic updates to the dataset, while being able to automatically adapt to changes in data density. Furthermore, because data points are represented in the indices as continuous values without being discretized, the granularity of discretization does not need to be chosen at construction time. Consequently, the same data structure can support queries at varying desired levels of accuracy, which allows a different speed-vs-accuracy trade-off to be\nmade for each individual query.\nPrioritized DCI differs from standard DCI in the order in which points from different simple indices are visited. In standard DCI, the algorithm cycles through all constituent simple indices of a composite index at regular intervals and visits exactly one point from each simple index in each pass. In Prioritized DCI, the algorithm assigns a priority to each constituent simple index; in each iteration, it visits the upcoming point from the simple index with the highest priority and updates the priority at the end of the iteration. The priority of a simple index is set to the negative absolute difference between the query projection and the next data point projection in the index.\nAlgorithm 2 k-nearest neighbour querying procedure\nRequire: Query point q in Rd, binary search trees/skip lists and their associated projection vectors {(Tjl, ujl)}j2[m],l2[L], the number of points to retrieve k\n0 and the number of points to visit k 1\nin each composite index function QUERY(q, {(Tjl, ujl)}j,l, k0, k1)\nCl array of size n with entries initialized to 0 8l 2 [L] qjl hq, ujli 8j 2 [m], l 2 [L] Sl ; 8l 2 [L] Pl empty priority queue 8l 2 [L] for l = 1 to L do\nfor j = 1 to m do (p(1)jl , h (1)\njl ) the node in Tjl whose key is the closest to qjl\nInsert (p(1)jl , h (1) jl ) with priority |p (1) jl qjl| into Pl\nend for\nend for for i0 = 1 to k 1\n1 do for l = 1 to L do\nif |Sl| < k0 then (p(i)jl , h (i) jl ) the node with the highest priority\nin Pl Remove (p(i)jl , h (i) jl ) from Pl and insert the node\nin Tjl whose key is the next closest to qjl, which is denoted as (p(i+1)jl , h (i+1) jl ), with\npriority |p(i+1)jl qjl| into Pl Cl[h (i) jl ] Cl[h (i) jl ] + 1 if Cl[h (i) jl ] = m then\nSl Sl [ {h(i)jl } end if\nend if\nend for\nend for return k points in S\nl2[L] Sl that are the closest in Euclidean distance in Rd to q\nend function\nIntuitively, this ensures data points are visited in the order of their distances to the query under projection. Because data points are only retrieved from a composite index when they have been visited in all constituent simple indices, data\npoints are retrieved in the order of the maximum of their distances to the query along multiple projection directions. Since distance under projection forms a lower bound on the true distance, the maximum projected distance approaches the true distance as the number of projection directions increases. Hence, in the limit as the number of simple indices approaches infinity, data points are retrieved in the ideal order, that is, the order of their true distances to the query.\nThe construction and querying procedures of Prioritized DCI are presented formally in Algorithms 1 and 2. To ensure the algorithm retrieves the exact knearest neighbours with high probability, the analysis in the next section shows that one should choose k 0 2 ⌦(kmax(log(n/k), (n/k)1 m/d0)) and k 1\n2 ⌦(mkmax(log(n/k), (n/k)1 1/d 0 )), where d0 denotes the intrinsic dimensionality. Though because this assumes worst-case configuration of data points, it may be overly conservative in practice; so, these parameters may be chosen by cross-validation.\nWe summarize the time and space complexities of Prioritized DCI in Table 2. Notably, the first term of the query complexity, which dominates when the ambient dimensionality d is large, has a more favourable dependence on the intrinsic dimensionality d0 than the query complexity of standard DCI. In particular, a linear increase in the intrinsic dimensionality, which corresponds to an exponential increase in the expansion rate, can be mitigated by just a linear increase in the number of simple indices m. This suggests that Prioritized DCI can better handle datasets with high intrinsic dimensionality than standard DCI, which is confirmed by empirical evidence later in this paper."
  }, {
    "heading": "4. Analysis",
    "text": "We analyze the time and space complexities of Prioritized DCI below and derive the stopping condition of the algorithm. Because the algorithm uses standard data structures, analysis of the construction time, insertion time, deletion time and space complexity is straightforward. Hence, this section focuses mostly on analyzing the query time.\nIn high-dimensional space, query time is dominated by the\ntime spent on evaluating true distances between candidate points and the query. Therefore, we need to find the number of candidate points that must be retrieved to ensure the algorithm succeeds with high probability. To this end, we derive an upper bound on the failure probability for any given number of candidate points. The algorithm fails if sufficiently many distant points are retrieved from each composite index before some of the true k-nearest neighbours. We decompose this event into multiple (dependent) events, each of which is the event that a particular distant point is retrieved before some true k-nearest neighbours. Since points are retrieved in the order of their maximum projected distance, this event happens when the maximum projected distance of the distant point is less than that of a true k-nearest neighbour. We start by finding an upper bound on the probability of this event. To simplify notation, we initially consider displacement vectors from the query to each data point, and so relationships between projected distances of triplets of points translate relationships between projected lengths of pairs of displacement vectors.\nWe start by examining the event that a vector under random one-dimensional projection satisfies some geometric constraint. We then find an upper bound on the probability that some combinations of these events occur, which is related to the failure probability of the algorithm. Lemma 1. Let vl, vs 2 Rd be such that vl\n2\n> vs\n2\n,\nu0j M j=1 be i.i.d. unit vectors in Rd drawn uniformly\nat random. Then Pr\nmaxj hvl, u0ji  vs\n2\n=\n1 2⇡ cos 1\nvs\n2\n/ vl\n2\nM .\nProof. The event\nmaxj hvl, u0ji  kvsk 2 is equivalent to the event that\nhvl, u0ji  kvsk 2 8j , which is the intersection of the events\nhvl, u0ji  kvsk 2 . Because u0j’s are drawn independently, these events are independent.\nLet ✓j be the angle between vl and u0j , so that hvl, u0ji =\nvl\n2 cos ✓j . Since u0j is drawn uniformly, ✓j is uniformly distributed on [0, 2⇡]. Hence,\nPr\n✓\nmax\nj\nn\nhvl, u0ji\no\n kvsk 2\n◆\n=\nM Y\nj=1\nPr\n⇣\nhvl, u0ji  kvsk 2\n⌘\n=\nM Y\nj=1\nPr\n✓ |cos ✓j |  kvsk 2\nkvlk 2\n◆\n=\nM Y\nj=1\n✓\n2Pr\n✓ ✓j 2  cos 1 ✓ kvsk 2\nkvlk 2\n◆ ,⇡ cos 1 ✓ kvsk 2\nkvlk 2\n◆ ◆◆\n=\n✓\n1 2 ⇡ cos\n1 ✓ kvsk 2\nkvlk 2\n◆◆M\nLemma 2. For any set of events {Ei}Ni=1, the probability that at least k0 of them happen is at most 1k0 PN i=1 Pr (Ei).\nProof. For any set T ✓ [N ], define ˜ET to be the intersection of events indexed by T and complements of events not indexed by T , i.e. ˜ET = T i2T Ei \\ T i/2T Ei . Observe that n ˜ET o\nT✓[N ] are disjoint and that for any I ✓ [N ],\nT i2I Ei = S T◆I ˜ET . The event that at least k0 of Ei’s happen is S\nI✓[N ]:|I|=k0 T i2I Ei, which is equivalent to S\nI✓[N ]:|I|=k0 S T◆I ˜ET = S T✓[N ]:|T | k0 ˜ET . We will henceforth use T to denote {T ✓ [N ] : |T | k0}. Since T is a finite set, we can impose an ordering on its elements and denote the lth element as Tl. The event can therefore be rewritten as\nS|T | l=1 ˜ETl .\nDefine E0i,j to be Ei \\ ⇣ S|T | l=j+1 ˜ETl ⌘ . We claim\nthat PN\ni=1 Pr E0i,j\nk0 Pj\nl=1 Pr\n⇣\n˜ETl\n⌘\nfor all j 2 {0, . . . , |T |}. We will show this by induction on j.\nFor j = 0, the claim is vacuously true because probabilities are non-negative. For j > 0, we observe that E0i,j = ⇣\nE0i,j \\ ˜ETj ⌘ [ ⇣ E0i,j \\ ˜ETj ⌘ = E0i,j 1 [ ⇣ E0i,j \\ ˜ETj ⌘ for all i. Since E0i,j \\ ˜ETj and E0i,j \\ ˜ETj are disjoint, Pr\nE0i,j = Pr E0i,j 1 + Pr\n⇣ E0i,j \\ ˜ETj ⌘ .\nConsider the quantity P\ni2Tj Pr\nE0i,j , which is P\ni2Tj\n⇣\nPr E0i,j 1 + Pr\n⇣ E0i,j \\ ˜ETj ⌘⌘ by the above\nobservation. For each i 2 Tj , ˜ETj ✓ Ei, and so ˜ETj \\ ⇣ S|T | l=j+1 ˜ETl ⌘ ✓ Ei \\ ⇣ S|T | l=j+1 ˜ETl ⌘ = E0i,j . Be-\ncause n\n˜ETl\no|T |\nl=j are disjoint, ˜ETj \\\n⇣\nS|T | l=j+1 ˜ETl\n⌘\n= ˜ETj .\nHence, ˜ETj ✓ E0i,j and so E0i,j \\ ˜ETj = ˜ETj . Thus, P\ni2Tj Pr\nE0i,j = |Tj |Pr ⇣ ˜ETj ⌘ + P\ni2Tj Pr\nE0i,j 1 .\nIt follows that PN\ni=1 Pr E0i,j\n= |Tj |Pr ⇣ ˜ETj ⌘ +\nP\ni2Tj Pr\nE0i,j 1 + P\ni/2Tj Pr\nE0i,j . Because\nPr E0i,j\n= Pr E0i,j 1 + Pr\n⇣ E0i,j \\ ˜ETj ⌘\nPr E0i,j 1 and |Tj | k0, PN i=1 Pr E0i,j k0Pr ⇣\n˜ETj\n⌘\n+ PN i=1 Pr E0i,j 1 . By the inductive\nhypothesis, PN\ni=1 Pr E0i,j 1\nk0 Pj 1\nl=1 Pr\n⇣\n˜ETl\n⌘\n.\nTherefore, PN\ni=1 Pr E0i,j\nk0 Pj\nl=1 Pr\n⇣\n˜ETl\n⌘\n, which concludes the induction argument.\nThe lemma is a special case of this claim when j = |T |, since E0i,|T | = Ei and P|T | l=1 Pr ⇣ ˜ETl ⌘ = Pr ⇣ S|T | l=1 ˜ETl ⌘ .\nCombining the above yields the following theorem, the proof of which is found in the supplementary material.\nTheorem 1. Let vli N i=1 and vsi0 N 0 i0=1 be sets of vectors such that\nvli\n2\n>\nvsi0\n2 8i 2 [N ], i0 2 [N 0]. Furthermore, let\nu0ij i2[N ],j2[M ] be random uniformly distributed unit vectors such that u0i1, . . . , u0iM are independent for any given i. Consider the events\n9vsi0 s.t. maxj hvli, u0iji  vsi0\n2\nN i=1 . The prob-\nability that at least k0 of these events occur is at most 1k0 PN i=1 1 2⇡ cos 1 vs max\n2\n/ vli\n2\nM , where\nvs max\n2\n= maxi0 vsi0\n2\n. Furthermore, if k0 = N , it is\nat most mini2[N ] n\n1 2⇡ cos 1 vs max\n2\n/ vli\n2\nM o\n.\nWe now apply the results above to analyze specific properties of the algorithm. For convenience, instead of working directly with intrinsic dimensionality, we will analyze the query time in terms of a related quantity, global relative sparsity, as defined in (Li & Malik, 2016). We reproduce its definition below for completeness. Definition 1. Given a dataset D ✓ Rd, let Bp(r) be the set of points in D that are within a ball of radius r around a point p. A dataset D has global relative sparsity of (⌧, ) if for all r and p 2 Rd such that |Bp(r)| ⌧ , |Bp( r)|  2 |Bp(r)|, where 1.\nGlobal relative sparsity is related to the expansion rate (Karger & Ruhl, 2002) and intrinsic dimensionality in the following way: a dataset with global relative sparsity of (⌧, ) has (⌧, 2(1/ log2 ))-expansion and intrinsic dimensionality of 1/ log\n2\n.\nBelow we derive two upper bounds on the probability that some of the true k-nearest neighbours are missing from the set of candidate points retrieved from a given composite index, which are in expressed in terms of k\n0 and k 1 respectively. These results inform us how k\n0 and k 1 should be chosen to ensure the querying procedure returns the correct results with high probability. In the results that follow, we use {p(i)}ni=1 to denote a re-ordering of the points {pi}ni=1 so that p(i) is the ith closest point to the query q. Proofs are found in the supplementary material. Lemma 3. Consider points in the order they are retrieved from a composite index that consists of m simple indices. The probability that there are at least n\n0 points that are not the true k-nearest neighbours but are retrieved before some of them is at most\n1 n0 k Pn i=2k+1 1 2⇡ cos 1 p(k) q 2 / p(i) q 2 m . Lemma 4. Consider point projections in a composite index that consists of m simple indices in the order they are visited. The probability that n\n0 point projections that are not of the true k-nearest neighbours are visited before all true k-nearest neighbours have been retrieved is at most\nm n0 mk Pn i=2k+1 1 2⇡ cos 1 p(k) q 2 / p(i) q 2 .\nLemma 5. On a dataset with global relative sparsity (k, ), the quantity Pn\ni=2k+1 1 2⇡ cos 1\np(k) q\n2\n/ p(i) q\n2\nm is\nat most O kmax(log(n/k), (n/k)1 m log2 ) .\nLemma 6. For a dataset with global relative sparsity (k, ) and a given composite index consisting of m simple indices, there is some k\n0 2 ⌦(kmax(log(n/k), (n/k)1 m log2 )) such that the probability that the candidate points retrieved from the composite index do not include some of the true k-nearest neighbours is at most some constant ↵\n0\n< 1.\nLemma 7. For a dataset with global relative sparsity (k, ) and a given composite index consisting of m simple indices, there is some k\n1 2 ⌦(mkmax(log(n/k), (n/k)1 log2 )) such that the probability that the candidate points retrieved from the composite index do not include some of the true k-nearest neighbours is at most some constant ↵\n1\n< 1.\nTheorem 2. For a dataset with global relative sparsity (k, ), for any ✏ > 0, there is some L, k 0 2 ⌦(kmax(log(n/k), (n/k)1 m log2 )) and k 1\n2 ⌦(mkmax(log(n/k), (n/k)1 log2 )) such that the algorithm returns the correct set of k-nearest neighbours with probability of at least 1 ✏.\nNow that we have found a choice of k 0 and k 1 that suffices to ensure correctness with high probability, we can derive a bound on the query time that guarantees correctness. We then analyze the time complexity for construction, insertion and deletion and the space complexity. Proofs of the following are found in the supplementary material.\nTheorem 3. For a given number of simple indices m, the algorithm takes O ⇣ dkmax(log(n/k), (n/k)1 m/d 0 )+\nmk logm ⇣ max(log(n/k), (n/k)1 1/d 0 ) ⌘⌘\ntime to retrieve the k-nearest neighbours at query time, where d0 denotes the intrinsic dimensionality.\nTheorem 4. For a given number of simple indices m, the algorithm takes O(m(dn+n log n)) time to preprocess the data points in D at construction time.\nTheorem 5. The algorithm requires O(m(d+log n)) time to insert a new data point and O(m log n) time to delete a data point.\nTheorem 6. The algorithm requires O(mn) space in addition to the space used to store the data."
  }, {
    "heading": "5. Experiments",
    "text": "We compare the performance of Prioritized DCI to that of standard DCI (Li & Malik, 2016), product quantization (Jégou et al., 2011) and LSH (Datar et al., 2004), which is perhaps the algorithm that is most widely used\nin high-dimensional settings. Because LSH operates under the approximate setting, in which the performance metric of interest is how close the returned points are to the query rather than whether they are the true k-nearest neighbours. All algorithms are evaluated in terms of the time they would need to achieve varying levels of approximation quality.\nEvaluation is performed on two datasets, CIFAR100 (Krizhevsky & Hinton, 2009) and MNIST (LeCun et al., 1998). CIFAR-100 consists of 60, 000 colour images of 100 types of objects in natural scenes and MNIST consists of 70, 000 grayscale images of handwritten digits. The images in CIFAR-100 have a size of 32⇥ 32 and three colour channels, and the images in MNIST have a size of 28⇥ 28 and a single colour channel. We reshape each image into a vector whose entries represent pixel intensities at different locations and colour channels in the image. So, each vector has a dimensionality of 32⇥32⇥3 = 3072 for CIFAR-100 and 28 ⇥ 28 = 784 for MNIST. Note that the dimensionalities under consideration are much higher than those typically used to evaluate prior methods.\nFor the purposes of nearest neighbour search, MNIST is a more challenging dataset than CIFAR-100. This is because images in MNIST are concentrated around a few modes; consequently, data points form dense clusters, leading to higher intrinsic dimensionality. On the other hand, images in CIFAR-100 are more diverse, and so data points are more dispersed in space. Intuitively, it is much harder to find the closest digit to a query among 6999 other digits of the same category that are all plausible near neighbours than to find the most similar natural image among a few other natural images with similar appearance. Later results show that all algorithms need fewer distance evaluations to achieve the same level of approximation quality on CIFAR100 than on MNIST.\nWe evaluate performance of all algorithms using crossvalidation, where we randomly choose ten different splits of query vs. data points. Each split consists of 100 points from the dataset that serve as queries, with the remainder designated as data points. We use each algorithm to retrieve the 25 nearest neighbours at varying levels of approximation quality and report mean performance and standard deviation over all splits.\nApproximation quality is measured using the approximation ratio, which is defined to be the ratio of the radius of the ball containing the set of true k-nearest neighbours to the radius of the ball containing the set of approximate knearest neighbours returned by the algorithm. The closer the approximation ratio is to 1, the higher the approximation quality. In high dimensions, the time taken to compute true distances between the query and the candidate points dominates query time, so the number of distance evalua-\ntions can be used as an implementation-independent proxy for the query time.\nFor LSH, we used 24 hashes per table and 100 tables, which we found to achieve the best approximation quality given the memory constraints. For product quantization, we used a data-independent codebook with 256 entries so that the algorithm supports dynamic updates. For standard DCI, we used the same hyparameter settings used in (Li & Malik, 2016) (m = 25 and L = 2 on CIFAR-100 and m = 15 and L = 3 on MNIST). For Prioritized DCI, we used two different settings: one that matches the hyperparameter settings of standard DCI, and another that uses less space (m = 10 and L = 2 on both CIFAR-100 and MNIST).\nWe plot the number of distance evaluations that each algorithm requires to achieve each desired level of approximation ratio in Figure 2. As shown, on CIFAR-100, under the same hyperparameter setting used by standard DCI, Prioritized DCI requires 87.2% to 92.5% fewer distance evaluations than standard DCI, 91.7% to 92.8% fewer distance evaluations than product quantization, and 90.9% to 93.8% fewer distance evaluations than LSH to achieve same levels approximation quality, which represents a 14-fold reduction in the number of distance evaluations relative to LSH on average. Under the more space-efficient hyperparameter setting, Prioritized DCI achieves a 6-fold reduction compared to LSH. On MNIST, under the same hyperparameter setting used by standard DCI, Prioritized DCI requires 96.4% to 97.0% fewer distance evaluations than standard DCI, 87.1% to 89.8% fewer distance evaluations than product quantization, and 98.8% to 99.3% fewer distance evaluations than LSH, which represents a 116-fold reduction relative to LSH on average. Under the more space-efficient hyperparameter setting, Prioritized DCI achieves a 32-fold reduction compared to LSH.\nWe compare the space efficiency of Prioritized DCI to that\nof standard DCI and LSH. As shown in Figure 3 in the supplementary material, compared to LSH, Prioritized DCI uses 95.5% less space on CIFAR-100 and 95.3% less space on MNIST under the same hyperparameter settings used by standard DCI. This represents a 22-fold reduction in memory consumption on CIFAR-100 and a 21-fold reduction on MNIST. Under the more space-efficient hyperparameter setting, Prioritized DCI uses 98.2% less space on CIFAR-100 and 97.9% less space on MNIST relative to LSH, which represents a 55-fold reduction on CIFAR-100 and a 48-fold reduction on MNIST.\nIn terms of wall-clock time, our implementation of Prioritized DCI takes 1.18 seconds to construct the data structure and execute 100 queries on MNIST, compared to 104.71 seconds taken by LSH."
  }, {
    "heading": "6. Conclusion",
    "text": "In this paper, we presented a new exact randomized algorithm for k-nearest neighbour search, which we refer to as Prioritized DCI. We showed that Prioritized DCI achieves a significant improvement in terms of the dependence of query time complexity on intrinsic dimensionality compared to standard DCI. Specifically, Prioritized DCI can to a large extent counteract a linear increase in the intrinsic dimensionality, or equivalently, an exponential increase in the number of points near a query, using just a linear increase in the number of simple indices. Empirical results validated the effectiveness of Prioritized DCI in practice, demonstrating the advantages of Prioritized DCI over prior methods in terms of speed and memory usage.\nAcknowledgements. This work was supported by DARPA W911NF-16-1-0552. Ke Li thanks the Natural Sciences and Engineering Research Council of Canada (NSERC) for fellowship support."
  }],
  "year": 2017,
  "references": [{
    "title": "Low-quality dimension reduction and high-dimensional approximate nearest neighbor",
    "authors": ["Anagnostopoulos", "Evangelos", "Emiris", "Ioannis Z", "Psarros", "Ioannis"],
    "venue": "In 31st International Symposium on Computational Geometry (SoCG",
    "year": 2015
  }, {
    "title": "Near-optimal hashing algorithms for approximate nearest neighbor in high dimensions",
    "authors": ["Andoni", "Alexandr", "Indyk", "Piotr"],
    "venue": "In Foundations of Computer Science,",
    "year": 2006
  }, {
    "title": "Optimal datadependent hashing for approximate near neighbors",
    "authors": ["Andoni", "Alexandr", "Razenshteyn", "Ilya"],
    "venue": "In Proceedings of the Forty-Seventh Annual ACM on Symposium on Theory of Computing,",
    "year": 2015
  }, {
    "title": "Approximate nearest neighbor queries in fixed dimensions",
    "authors": ["Arya", "Sunil", "Mount", "David M"],
    "venue": "In SODA,",
    "year": 1993
  }, {
    "title": "An optimal algorithm for approximate nearest neighbor searching fixed dimensions",
    "authors": ["Arya", "Sunil", "Mount", "David M", "Netanyahu", "Nathan S", "Silverman", "Ruth", "Wu", "Angela Y"],
    "venue": "Journal of the ACM (JACM),",
    "year": 1998
  }, {
    "title": "Symmetric binary b-trees: Data structure and maintenance algorithms",
    "authors": ["Bayer", "Rudolf"],
    "venue": "Acta informatica,",
    "year": 1972
  }, {
    "title": "A geometric interpretation for local alignmentfree sequence comparison",
    "authors": ["Behnam", "Ehsan", "Waterman", "Michael S", "Smith", "Andrew D"],
    "venue": "Journal of Computational Biology,",
    "year": 2013
  }, {
    "title": "Multidimensional binary search trees used for associative searching",
    "authors": ["Bentley", "Jon Louis"],
    "venue": "Communications of the ACM,",
    "year": 1975
  }, {
    "title": "The X-tree: An index structure for highdimensional data",
    "authors": ["Berchtold", "Stefan", "Keim", "Daniel A", "peter Kriegel", "Hans"],
    "venue": "In Very Large Data Bases, pp",
    "year": 1996
  }, {
    "title": "Fast nearest neighbor search in high-dimensional space",
    "authors": ["Berchtold", "Stefan", "Ertl", "Bernhard", "Keim", "Daniel A", "Kriegel", "H-P", "Seidl", "Thomas"],
    "venue": "In Data Engineering,",
    "year": 1998
  }, {
    "title": "Cover trees for nearest neighbor",
    "authors": ["Beygelzimer", "Alina", "Kakade", "Sham", "Langford", "John"],
    "venue": "In Proceedings of the 23rd International Conference on Machine Learning,",
    "year": 2006
  }, {
    "title": "A weighted knearest neighbor density estimate for geometric inference",
    "authors": ["Biau", "Gérard", "Chazal", "Frédéric", "Cohen-Steiner", "David", "Devroye", "Luc", "Rodriguez", "Carlos"],
    "venue": "Electronic Journal of Statistics,",
    "year": 2011
  }, {
    "title": "Nearest neighbor queries in metric spaces",
    "authors": ["Clarkson", "Kenneth L"],
    "venue": "Discrete & Computational Geometry,",
    "year": 1999
  }, {
    "title": "Random projection trees and low dimensional manifolds",
    "authors": ["Dasgupta", "Sanjoy", "Freund", "Yoav"],
    "venue": "In Proceedings of the Fortieth Annual ACM Symposium on Theory of Computing,",
    "year": 2008
  }, {
    "title": "Randomized partition trees for nearest neighbor",
    "authors": ["Dasgupta", "Sanjoy", "Sinha", "Kaushik"],
    "venue": "search. Algorithmica,",
    "year": 2015
  }, {
    "title": "Locality-sensitive hashing scheme based on p-stable distributions",
    "authors": ["Datar", "Mayur", "Immorlica", "Nicole", "Indyk", "Piotr", "Mirrokni", "Vahab S"],
    "venue": "In Proceedings of the twentieth annual symposium on Computational geometry,",
    "year": 2004
  }, {
    "title": "SpatialHadoop: A MapReduce framework for spatial data",
    "authors": ["Eldawy", "Ahmed", "Mokbel", "Mohamed F"],
    "venue": "In Data Engineering (ICDE),",
    "year": 2015
  }, {
    "title": "A dichromatic framework for balanced trees",
    "authors": ["Guibas", "Leo J", "Sedgewick", "Robert"],
    "venue": "In Foundations of Computer Science,",
    "year": 1978
  }, {
    "title": "R-trees: a dynamic index structure for spatial searching",
    "authors": ["Guttman", "Antonin"],
    "venue": "In Proceedings of the 1984 ACM SIGMOD International Conference on Management of Data,",
    "year": 1984
  }, {
    "title": "Rank-based similarity search: Reducing the dimensional dependence",
    "authors": ["Houle", "Michael E", "Nett", "Michael"],
    "venue": "Pattern Analysis and Machine Intelligence, IEEE Transactions on,",
    "year": 2015
  }, {
    "title": "Approximate nearest neighbors: towards removing the curse of dimensionality",
    "authors": ["Indyk", "Piotr", "Motwani", "Rajeev"],
    "venue": "In Proceedings of the Thirtieth Annual ACM Symposium on Theory of Computing,",
    "year": 1998
  }, {
    "title": "Product quantization for nearest neighbor search",
    "authors": ["Jégou", "Hervé", "Douze", "Matthijs", "Schmid", "Cordelia"],
    "venue": "Pattern Analysis and Machine Intelligence, IEEE Transactions on,",
    "year": 2011
  }, {
    "title": "Finding nearest neighbors in growth-restricted metrics",
    "authors": ["Karger", "David R", "Ruhl", "Matthias"],
    "venue": "In Proceedings of the Thiry-fourth Annual ACM Symposium on Theory of Computing,",
    "year": 2002
  }, {
    "title": "Navigating nets: simple algorithms for proximity search",
    "authors": ["Krauthgamer", "Robert", "Lee", "James R"],
    "venue": "In Proceedings of the Fifteenth Annual ACM-SIAM Symposium on Discrete Algorithms,",
    "year": 2004
  }, {
    "title": "Learning multiple layers of features from tiny images",
    "authors": ["Krizhevsky", "Alex", "Hinton", "Geoffrey"],
    "venue": "Technical report, University of Toronto,",
    "year": 2009
  }, {
    "title": "Gradient-based learning applied to document recognition",
    "authors": ["LeCun", "Yann", "Bottou", "Léon", "Bengio", "Yoshua", "Haffner", "Patrick"],
    "venue": "Proceedings of the IEEE,",
    "year": 1998
  }, {
    "title": "Fast k-nearest neighbour search via Dynamic Continuous Indexing",
    "authors": ["Li", "Ke", "Malik", "Jitendra"],
    "venue": "In International Conference on Machine Learning,",
    "year": 2016
  }, {
    "title": "An investigation of practical approximate nearest neighbor algorithms",
    "authors": ["Liu", "Ting", "Moore", "Andrew W", "Yang", "Ke", "Gray", "Alexander G"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2004
  }, {
    "title": "Point location in arrangements of hyperplanes",
    "authors": ["Meiser", "Stefan"],
    "venue": "Information and Computation,",
    "year": 1993
  }, {
    "title": "Perceptrons: an introduction to computational geometry",
    "authors": ["Minsky", "Marvin", "Papert", "Seymour"],
    "venue": "pp. 222,",
    "year": 1969
  }, {
    "title": "A fast nearest-neighbor search algorithm",
    "authors": ["Orchard", "Michael T"],
    "venue": "In Acoustics, Speech, and Signal Processing,",
    "year": 1991
  }, {
    "title": "Locality sensitive hashing: A comparison of hash function types and querying mechanisms",
    "authors": ["Paulevé", "Loı̈c", "Jégou", "Hervé", "Amsaleg", "Laurent"],
    "venue": "Pattern Recognition Letters,",
    "year": 2010
  }, {
    "title": "Skip lists: a probabilistic alternative to balanced trees",
    "authors": ["Pugh", "William"],
    "venue": "Communications of the ACM,",
    "year": 1990
  }, {
    "title": "Spectral hashing",
    "authors": ["Weiss", "Yair", "Torralba", "Antonio", "Fergus", "Rob"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2009
  }],
  "id": "SP:d613295bd220b2878f4de539e7ce6e6ea288f1f5",
  "authors": [{
    "name": "Ke Li",
    "affiliations": []
  }, {
    "name": "Jitendra Malik",
    "affiliations": []
  }],
  "abstractText": "Most exact methods for k-nearest neighbour search suffer from the curse of dimensionality; that is, their query times exhibit exponential dependence on either the ambient or the intrinsic dimensionality. Dynamic Continuous Indexing (DCI) (Li & Malik, 2016) offers a promising way of circumventing the curse and successfully reduces the dependence of query time on intrinsic dimensionality from exponential to sublinear. In this paper, we propose a variant of DCI, which we call Prioritized DCI, and show a remarkable improvement in the dependence of query time on intrinsic dimensionality. In particular, a linear increase in intrinsic dimensionality, or equivalently, an exponential increase in the number of points near a query, can be mostly counteracted with just a linear increase in space. We also demonstrate empirically that Prioritized DCI significantly outperforms prior methods. In particular, relative to Locality-Sensitive Hashing (LSH), Prioritized DCI reduces the number of distance evaluations by a factor of 14 to 116 and the memory consumption by a factor of 21.",
  "title": "Fast k-Nearest Neighbour Search via Prioritized DCI"
}