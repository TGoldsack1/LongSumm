{
  "sections": [{
    "heading": "1. Introduction",
    "text": "Many autoregressive image models factorize the joint distribution of images into per-pixel factors:\np(x1:T ) = TY\nt=1\np(xt |x1:t 1) (1)\nFor example PixelCNN (van den Oord et al., 2016b) uses a deep convolutional network with carefully designed filter masking to preserve causal structure, so that all factors in equation 1 can be learned in parallel for a given image. However, a remaining di culty is that due to the learned causal structure, inference proceeds sequentially pixel-bypixel in raster order.\n1DeepMind. Correspondence to: Scott Reed <reedscot@google.com>.\nProceedings of the 34th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\nIn the naive case, this requires a full network evaluation per pixel. Caching hidden unit activations can be used to reduce the amount of computation per pixel, as in the 1D case for WaveNet (Oord et al., 2016; Ramachandran et al., 2017). However, even with this optimization, generation is still in serial order by pixel.\nIdeally we would generate multiple pixels in parallel, which could greatly accelerate sampling. In the autoregressive framework this only works if the pixels are modeled as independent. Thus we need a way to judiciously break weak dependencies among pixels; for example immediately neighboring pixels should not be modeled as independent since they tend to be highly correlated.\nMultiscale image generation provides one such way to break weak dependencies. In particular, we can model certain groups of pixels as conditionally independent given a lower resolution image and various types of context information, such as preceding frames in a video. The basic idea is obvious, but nontrivial design problems stand between the idea and a workable implementation.\nFirst, what is the right way to transmit global information from a low-resolution image to each generated pixel of the high-resolution image? Second, which pixels can we gen-\nerate in parallel? And given that choice, how can we avoid border artifacts when merging sets of pixels that were generated in parallel, blind to one another?\nIn this work we show how a very substantial portion of the spatial dependencies in PixelCNN can be cut, with only modest degradation in performance. Our formulation allows sampling in O(log N) time for N pixels, instead of O(N) as in the original PixelCNN, resulting in orders of magnitude speedup in practice. In the case of video, in which we have access to high-resolution previous frames, we can even sample in O(1) time, with much better performance than comparably-fast baselines.\nAt a high level, the proposed approach can be viewed as a way to merge per-pixel factors in equation 1. If we merge the factors for, e.g. xi and x j, then that dependency is “cut”, so the model becomes slightly less expressive. However, we get the benefit of now being able to sample xi and x j in parallel. If we divide the N pixels into G groups of T pixels each, the joint distribution can be written as a product of the corresponding G factors:\np(x1:G1:T ) = GY\ng=1\np(x(g)1:T |x (1:g 1) 1:T ) (2)\nAbove we assumed that each of the G groups contains exactly T pixels, but in practice the number can vary. In this work, we form pixel groups from successively higherresolution views of an image, arranged into a sub-sampling pyramid, such that G 2 O(log N). In section 3 we describe this group structure implemented as a deep convolutional network. In section 4 we show that the model excels in density estimation and can produce quality high-resolution samples at high speed."
  }, {
    "heading": "2. Related work",
    "text": "Deep neural autoregressive models have been applied to image generation for many years, showing promise as a tractable yet expressive density model (Larochelle & Murray, 2011; Uria et al., 2013). Autoregressive LSTMs have been shown to produce state-of-the-art performance in density estimation on large-scale datasets such as ImageNet (Theis & Bethge, 2015; van den Oord et al., 2016a).\nCausally-structured convolutional networks such as PixelCNN (van den Oord et al., 2016b) and WaveNet (Oord et al., 2016) improved the speed and scalability of training. These led to improved autoregressive models for video generation (Kalchbrenner et al., 2016b) and machine translation (Kalchbrenner et al., 2016a).\nNon-autoregressive convolutional generator networks have been successful and widely adopted for image generation as well. Instead of maximizing likelihood, Generative Ad-\nversarial Networks (GANs) train a generator network to fool a discriminator network adversary (Goodfellow et al., 2014). These networks have been used in a wide variety of conditional image generation schemes such as text and spatial structure to image (Mansimov et al., 2015; Reed et al., 2016b;a; Wang & Gupta, 2016).\nThe addition of multiscale structure has also been shown to be useful in adversarial networks. Denton et al. (2015) used a Laplacian pyramid to generate images in a coarse-to-fine manner. Zhang et al. (2016) composed a low-resolution and high-resolution text-conditional GAN, yielding higher quality 256 ⇥ 256 bird and flower images. Generator networks can be combined with a trained model, such as an image classifier or captioning network, to generate high-resolution images via optimization and sampling procedures (Nguyen et al., 2016). Wu et al. (2017) state that it is di cult to quantify GAN performance, and propose Monte Carlo methods to approximate the loglikelihood of GANs on MNIST images.\nBoth auto-regressive and non auto-regressive deep networks have recently been applied successfully to image super-resolution. Shi et al. (2016) developed a sub-pixel convolutional network well-suited to this problem. Dahl et al. (2017) use a PixelCNN as a prior for image superresolution with a convolutional neural network. Johnson et al. (2016) developed a perceptual loss function useful for both style transfer and super-resolution. GAN variants have also been successful in this domain (Ledig et al., 2016; Sønderby et al., 2017).\nSeveral other deep, tractable density models have recently been developed. Real NVP (Dinh et al., 2016) learns a mapping from images to a simple noise distribution, which is by construction trivially invertible. It is built from smaller invertible blocks called coupling layers whose Jacobian is lower-triangular, and also has a multiscale structure. Inverse Autoregressive Flows (Kingma & Salimans, 2016) use autoregressive structures in the latent space to learn more flexible posteriors for variational autoencoders. Autoregressive models have also been combined with VAEs as decoder models (Gulrajani et al., 2016).\nThe original PixelRNN paper (van den Oord et al., 2016a) actually included a multiscale autoregressive version, in which PixelRNNs or PixelCNNs were trained at multiple resolutions. The network producing a given resolution image was conditioned on the image at the next lower resolution. This work is similarly motivated by the usefulness of multiscale image structure (and the very long history of coarse-to-fine modeling).\nOur novel contributions in this work are (1) asymptotically and empirically faster inference by modeling conditional independence structure, (2) scaling to much higher reso-\nlution, (3) evaluating the model on a diverse set of challenging benchmarks including class-, text- and structureconditional image generation and video generation."
  }, {
    "heading": "3. Model",
    "text": "The main design principle that we follow in building the model is a coarse-to-fine ordering of pixels. Successively higher-resolution frames are generated conditioned on the previous resolution (See for example Figure 1). Pixels are grouped so as to exploit spatial locality at each resolution, which we describe in detail below.\nThe training objective is to maximize log P(x; ✓). Since the joint distribution factorizes over pixel groups and scales, the training can be trivially parallelized."
  }, {
    "heading": "3.1. Network architecture",
    "text": "Figure 2 shows how we divide an image into disjoint groups of pixels, with autoregressive structure among the groups. The key property to notice is that no two adjacent pixels of the high-resolution image are in the same group. Also, pixels can depend on other pixels below and to the right, which would have been inaccessible in the standard PixelCNN. Each group of pixels corresponds to a factor in the joint distribution of equation 2.\nConcretely, to create groups we tile the image with 2 ⇥ 2 blocks. The corners of these 2⇥2 blocks form the four pixel groups at a given scale; i.e. upper-left, upper-right, lowerleft, lower-right. Note that some pairs of pixels both within each block and also across blocks can still be dependent. These additional dependencies are important for capturing local textures and avoiding border artifacts.\nFigure 3 shows an instantiation of one of these factors as a neural network. Similar to the case of PixelCNN, at training time losses and gradients for all of the pixels within a group can be computed in parallel. At test time, inference proceeds sequentially over pixel groups, in parallel within each group. Also as in PixelCNN, we model the color channel dependencies - i.e. green sees red, blue sees red and green - using channel masking.\nIn the case of type-A upscaling networks (See Figure 3A), sampling each pixel group thus requires 3 network evaluations 1. In the case of type-B upscaling, the spatial feature map for predicting a group of pixels is divided into contiguous M ⇥ M patches for input to a shallow PixelCNN (See figure 3B). This entails M2 very small network evaluations, for each color channel. We used M = 4, and the shallow PixelCNN weights are shared across patches.\n1However, one could also use a discretized mixture of logistics as output instead of a softmax as in Salimans et al. (2017), in which case only one network evaluation is needed.\nThe division into non-overlapping patches may appear to risk border artifacts when merging. However, this does not occur for several reasons. First, each predicted pixel is directly adjacent to several context pixels fed into the upscaling network. Second, the generated patches are not directly adjacent in the 2K⇥2K output image; there is always a row or column of pixels on the border of any pair.\nNote that the only learnable portions of the upscaling module are (1) the ResNet encoder of context pixels, and (2) the shallow PixelCNN weights in the case of type-B upscaling. The “merge” and “split” operations shown in figure 3 only marshal data and are not associated with parameters.\nGiven the first group of pixels, the rest of the groups at a given scale can be generated autoregressively. The first group of pixels can be modeled using the same approach as detailed above, recursively, down to a base resolution at which we use a standard PixelCNN. At each scale, the number of evaluations is O(1), and the resolution doubles after each upscaling, so the overall complexity is O(log N) to produce images with N pixels."
  }, {
    "heading": "3.2. Conditional image modeling",
    "text": "Given some context information c, such as a text description, a segmentation, or previous video frames, we maximize the conditional likelihood log P(x|c; ✓). Each factor in equation 2 simply adds c as an additional conditioning variable. The upscaling neural network corresponding to each factor takes c as an additional input.\nFor encoding text we used a character-CNN-GRU as in (Reed et al., 2016a). For spatially structured data such as segmentation masks we used a standard convolutional network. For encoding previous frames in a video we used a ConvLSTM as in (Kalchbrenner et al., 2016b)."
  }, {
    "heading": "4. Experiments",
    "text": ""
  }, {
    "heading": "4.1. Datasets",
    "text": "We evaluate our model on ImageNet, Caltech-UCSD Birds (CUB), the MPII Human Pose dataset (MPII), the Microsoft Common Objects in Context dataset (MS-COCO), and the Google Robot Pushing dataset.\n• For ImageNet (Deng et al., 2009), we trained a classconditional model using the 1000 leaf node classes.\n• CUB (Wah et al., 2011) contains 11, 788 images across 200 bird species, with 10 captions per image. As conditioning information we used a 32⇥32 spatial encoding of the 15 annotated bird part locations.\n• MPII (Andriluka et al., 2014) has around 25K images of 410 human activities, with 3 captions per image.\nWe kept only the images depicting a single person, and cropped the image centered around the person, leaving us about 14K images. We used a 32 ⇥ 32 encoding of the 17 annotated human part locations.\n• MS-COCO (Lin et al., 2014) has 80K training images with 5 captions per image. As conditioning we used the 80-class segmentation scaled to 32 ⇥ 32.\n• Robot Pushing (Finn et al., 2016) contains sequences of 20 frames of size 64 ⇥ 64 showing a robotic arm pushing objects in a basket. There are 50, 000 training sequences and a validation set with the same objects but di↵erent arm trajectories. One test set involves a subset of the objects seen during training and another involving novel objects, both captured on an arm and camera viewpoint not seen during training.\nAll models for ImageNet, CUB, MPII and MS-COCO were trained using RMSprop with hyperparameter ✏ = 1e 8, with batch size 128 for 200K steps. The learning rate was\nset initially to 1e 4 and decayed to 1e 5. For all of the samples we show, the queries are drawn from the validation split of the corresponding data set. That is, the captions, key points, segmentation masks, and lowresolution images for super-resolution have not been seen by the model during training.\nWhen we evaluate negative log-likelihood, we only quantize pixel values to [0, ..., 255] at the target resolution, not separately at each scale. The lower resolution images are then created by sub-sampling this quantized image."
  }, {
    "heading": "4.2. Text and location-conditional generation",
    "text": "In this section we show results for CUB, MPII and MSCOCO. For each dataset we trained type-B upscaling networks with 12 ResNet layers and 4 PixelCNN layers, with 128 hidden units per layer. The base resolution at which we train a standard PixelCNN was set to 4 ⇥ 4. To encode the captions we padded to 201 characters, then\nfed into a character-level CNN with three convolutional layers, followed by a GRU and average pooling over time. Upscaling networks to 8 ⇥ 8, 16 ⇥ 16 and 32 ⇥ 32 shared a single text encoder. For higher-resolution upscaling networks we trained separate text encoders. In principle all upscalers could share an encoder, but we trained separably to save memory and time.\nFor CUB and MPII, we have body part keypoints for birds and humans, respectively. We encode these into a 32⇥32⇥ P binary feature map, where P is the number of parts; 17\nfor MPII and 15 for CUB. A 1 indicates the part is visible, and 0 indicates the part is not visible. For MS-COCO, we resize the class segmentation mask to 32 ⇥ 32 ⇥ 80. For comparing and replicating quantitative results, an important detail is the type of image resizing used. For CUB, MPII and MS-COCO we used the default TensorFlow bilinear interpolation resizing to the final image size, by calling tf.image.resize images. Using other resizing methods such as AREA resizing will still result in quality samples, but di↵erent likelihoods.\nFor all datasets, we then encode these spatial features using a 12-layer ResNet. These features are then depthconcatenated with the text encoding and resized with bilinear interpolation to the spatial size of the image. If the target resolution for an upscaler network is higher than 32 ⇥ 32, these conditioning features are randomly cropped along with the target image to a 32⇥ 32 patch. Because the network is fully convolutional, the network can still generate the full resolution at test time, but we can massively save on memory and computation during training.\nFigure 4 shows examples of text- and keypoint-to-bird image synthesis. Figure 5 shows examples of text- and keypoint-to-human image synthesis. Figure 6 shows examples of text- and segmentation-to-image synthesis.\nQuantitatively, the Multiscale PixelCNN results are not far from those obtained using the original PixelCNN (Reed et al., 2016c), as shown in Table 1. In addition, we in-\ncreased the sample resolution by 8⇥. Qualitatively, the sample quality appears to be on par, but with much greater realism due to the higher resolution.\nBased on reviewer feedback, we performed an additional experiment to study how much sample diversity arises from the upscaling networks, as opposed to the base PixelCNN. In the final appendix figure, we show for several 4 ⇥ 4 base images of birds, the resulting upscaled samples. Although the keypoints are fixed so the pose cannot change substantially, we observe a significant amount of variation in the textures, background, and support structure (e.g. tree branches and rocks that the bird stands on). The low-res sample produced by the base PixelCNN seems to strongly a↵ect the overall colour palette in the hi-res samples."
  }, {
    "heading": "4.3. Action-conditional video generation",
    "text": "In this section we present results on Robot Pushing videos. All models were trained to perform future frame prediction conditioned on 2 starting frames and also on the robot arm actions and state, which are each 5-dimensional vectors.\nWe trained two versions of the model, both versions using type-A upscaling networks (See Fig. 3). The first is designed to sample in O(T ) time, for T video frames. That is, the number of network evaluations per frame is constant with respect to the number of pixels.\nThe motivation for training the O(T ) model is that previous frames in a video provide very detailed cues for predicting the next frame, so that our pixel groups could be conditionally independent even without access to a low-resolution\nimage. Without the need to upscale from a low-resolution image, we can produce “group 1” pixels - i.e. the upper-left corner group - directly by conditioning on previous frames. Then a constant number of network evaluations are needed to sample the next three pixel groups at the final scale.\nThe second version is our multi-step upscaler used in previous experiments, conditioned on both previous frames and robot arm state and actions. The complexity of sampling from this model is O(T log N), because at every time step the upscaling procedure must be run, taking O(log N) time.\nThe models were trained for 200K steps with batch size 64, using the RMSprop optimizer with centering and ✏ = 1e 8. The learning rate was initialized to 1e 4 and decayed by factor 0.3 after 83K steps and after 113K steps. For the O(T ) model we used a mixture of discretized logistic outputs (Salimans et al., 2017) and for the O(T log N) model we used a softmax ouptut.\nTable 2 compares two variants of our model with the original VPN. Compared to the O(T ) baseline - a convolutional LSTM model without spatial dependencies - our O(T ) model performs dramatically better. On the validation set, in which the model needs to generalize to novel combinations of objects and arm trajectories, the O(T log N) model does much better than our O(T ) model, although not as well as the original O(T N) model.\nOn the testing sets, we observed that the O(T ) model performed as well as on the validation set, but the O(T log N) model showed a drop in performance. However, this drop\ndoes not occur due to the presence of novel objects (in fact this setting actually yields better results), but due to the novel arm and camera configuration used during testing 2. It appears that the O(T log N) model may have overfit to the background details and camera position of the 10 training arms, but not necessarily to the actual arm and object motions. It should be possible to overcome this e↵ect with better regularization and perhaps data augmentation such as mirroring and jittering frames, or simply training on data with more diverse camera positions.\nThe supplement contains example videos generated on the validation set arm trajectories from our O(T log N) model. We also trained 64 ! 128 and 128 ! 256 upscalers conditioned on low-resolution and a previous high-resolution frame, so that we can produce 256 ⇥ 256 videos."
  }, {
    "heading": "4.4. Class-conditional generation",
    "text": "To compare against other image density models, we trained our Multiscale PixelCNN on ImageNet. We used type-B upscaling networks (Seee figure 3) with 12 ResNet (He et al., 2016) layers and 4 PixelCNN layers, with 256 hidden units per layer. For all PixelCNNs in the model, we used the same architecture as in (van den Oord et al., 2016b). We generated images with a base resolution of 8 ⇥ 8 and trained four upscaling networks to produce up to 128⇥128 samples.At scales 64 ⇥ 64 and above, during training we randomly cropped the image to 32 ⇥ 32. This accelerates training but does not pose a problem at test time because\n2From communication with the Robot Pushing dataset author.\nall of the networks are fully convolutional.\nTable 3 shows the results. On both 32 ⇥ 32 and 64 ⇥ 64 ImageNet it achieves significantly better likelihood scores than have been reported for any non-pixel-autoregressive density models, such as ConvDRAW and Real NVP, that also allow e cient sampling.\nOf course, performance of these approaches varies considerably depending on the implementation details, especially in the design and capacity of deep neural networks used. But it is notable that the very simple and direct approach developed here can surpass the state-of-the-art among fastsampling density models.\nInterestingly, the model often produced quite realistic bird images from scratch when trained on CUB, and these samples looked more realistic than any animal image generated by our ImageNet models. One plausible explanation for this di↵erence is a lack of model capacity; a single network modeling the 1000 very diverse ImageNet categories can devote only very limited capacity to each one, compared to a network that only needs to model birds. This suggests that finding ways to increase capacity without slowing down training or sampling could be a promising direction.\nFigure 7 shows upscaling starting from ground-truth images of size 8⇥8, 16⇥16 and 32⇥32. We observe the largest diversity of samples in terms of global structure when starting from 8 ⇥ 8, but less realistic results due to the more challenging nature of the problem. Upscaling starting from 32 ⇥ 32 results in much more realistic images. Here the diversity is apparent in the samples (as in the data, conditioned on low-resolution) in the local details such as the dog’s fur patterns or the frog’s eye contours."
  }, {
    "heading": "4.5. Sampling time comparison",
    "text": "As expected, we observe a very large speedup of our model compared to sampling from a standard PixelCNN at the same resolution (see Table 4). Even at 32 ⇥ 32 we observe two orders of magnitude speedup, and the speedup is greater for higher resolution.\nSince our model only requires O(log N) network evaluations to sample, we can fit the entire computation graph for sampling into memory, for reasonable batch sizes. Ingraph computation in TensorFlow can further improve the speed of both image and video generation, due to reduced overhead by avoiding repeated calls to sess.run.\nSince our model has a PixelCNN at the lowest resolution, it can also be accelerated by caching PixelCNN hidden unit activations, recently implemented b by Ramachandran et al. (2017). This could allow one to use higher-resolution base PixelCNNs without sacrificing speed."
  }, {
    "heading": "5. Conclusions",
    "text": "In this paper, we developed a parallelized, multiscale version of PixelCNN. It achieves competitive density estimation results on CUB, MPII, MS-COCO, ImageNet, and Robot Pushing videos, surpassing all other density models that admit fast sampling. Qualitatively, it can achieve compelling results in text-to-image synthesis and video generation, as well as diverse super-resolution from very small images all the way to 512⇥ 512. Many more samples from all of our models can be found in the appendix and supplementary material."
  }],
  "year": 2017,
  "references": [{
    "title": "2d human pose estimation: New benchmark and state of the art analysis",
    "authors": ["Andriluka", "Mykhaylo", "Pishchulin", "Leonid", "Gehler", "Peter", "Schiele", "Bernt"],
    "venue": "In CVPR,",
    "year": 2014
  }, {
    "title": "Pixel recursive super resolution",
    "authors": ["Dahl", "Ryan", "Norouzi", "Mohammad", "Shlens", "Jonathon"],
    "venue": "arXiv preprint arXiv:1702.00783,",
    "year": 2017
  }, {
    "title": "ImageNet: A large-scale hierarchical image database",
    "authors": ["Deng", "Jia", "Dong", "Wei", "Socher", "Richard", "Li", "Li-Jia", "Kai", "Fei-Fei"],
    "venue": "In CVPR,",
    "year": 2009
  }, {
    "title": "Deep generative image models using a Laplacian pyramid of adversarial networks",
    "authors": ["Denton", "Emily L", "Chintala", "Soumith", "Szlam", "Arthur", "Fergus", "Rob"],
    "venue": "In NIPS,",
    "year": 2015
  }, {
    "title": "Density estimation using Real NVP",
    "authors": ["Dinh", "Laurent", "Sohl-Dickstein", "Jascha", "Bengio", "Samy"],
    "venue": "In NIPS,",
    "year": 2016
  }, {
    "title": "Unsupervised learning for physical interaction through video prediction",
    "authors": ["Finn", "Chelsea", "Goodfellow", "Ian", "Levine", "Sergey"],
    "venue": "In NIPS,",
    "year": 2016
  }, {
    "title": "Generative adversarial nets",
    "authors": ["Goodfellow", "Ian J", "Pouget-Abadie", "Jean", "Mirza", "Mehdi", "Xu", "Bing", "Warde-Farley", "David", "Ozair", "Sherjil", "Courville", "Aaron C", "Bengio", "Yoshua"],
    "venue": "In NIPS,",
    "year": 2014
  }, {
    "title": "PixelVAE: A latent variable model for natural images",
    "authors": ["Gulrajani", "Ishaan", "Kumar", "Kundan", "Ahmed", "Faruk", "Taiga", "Adrien Ali", "Visin", "Francesco", "Vazquez", "David", "Courville", "Aaron"],
    "venue": "arXiv preprint arXiv:1611.05013,",
    "year": 2016
  }, {
    "title": "Identity mappings in deep residual networks",
    "authors": ["He", "Kaiming", "Zhang", "Xiangyu", "Ren", "Shaoqing", "Sun", "Jian"],
    "venue": "In ECCV,",
    "year": 2016
  }, {
    "title": "Perceptual losses for real-time style transfer and superresolution",
    "authors": ["Johnson", "Justin", "Alahi", "Alexandre", "Fei-Fei", "Li"],
    "venue": "In ECCV,",
    "year": 2016
  }, {
    "title": "Neural machine translation in linear time",
    "authors": ["Kalchbrenner", "Nal", "Espeholt", "Lasse", "Simonyan", "Karen", "Oord", "Aaron van den", "Graves", "Alex", "Kavukcuoglu", "Koray"],
    "venue": "arXiv preprint arXiv:1610.10099,",
    "year": 2016
  }, {
    "title": "Video pixel networks",
    "authors": ["Kalchbrenner", "Nal", "Oord", "Aaron van den", "Simonyan", "Karen", "Danihelka", "Ivo", "Vinyals", "Oriol", "Graves", "Alex", "Kavukcuoglu", "Koray"],
    "venue": "Preprint arXiv:1610.00527,",
    "year": 2016
  }, {
    "title": "Improving variational inference with inverse autoregressive flow",
    "authors": ["Kingma", "Diederik P", "Salimans", "Tim"],
    "venue": "In NIPS,",
    "year": 2016
  }, {
    "title": "The neural autoregressive distribution estimator",
    "authors": ["Larochelle", "Hugo", "Murray", "Iain"],
    "venue": "In AISTATS,",
    "year": 2011
  }, {
    "title": "Photo-realistic single image superresolution using a generative adversarial network. 2016",
    "authors": ["Ledig", "Christian", "Theis", "Lucas", "Huszar", "Ferenc", "Caballero", "Jose", "Cunningham", "Andrew", "Acosta", "Alejandro", "Aitken", "Tejani", "Alykhan", "Totz", "Johannes", "Wang", "Zehan", "Shi", "Wenzhe"],
    "year": 2016
  }, {
    "title": "Microsoft COCO: Common objects in context",
    "authors": ["Lin", "Tsung-Yi", "Maire", "Michael", "Belongie", "Serge", "Hays", "James", "Perona", "Pietro", "Ramanan", "Deva", "Dollár", "Piotr", "Zitnick", "C Lawrence"],
    "venue": "In ECCV,",
    "year": 2014
  }, {
    "title": "Generating images from captions with attention",
    "authors": ["Mansimov", "Elman", "Parisotto", "Emilio", "Ba", "Jimmy Lei", "Salakhutdinov", "Ruslan"],
    "venue": "In ICLR,",
    "year": 2015
  }, {
    "title": "Plug & play generative networks: Conditional iterative generation of images in latent space",
    "authors": ["Nguyen", "Anh", "Yosinski", "Jason", "Bengio", "Yoshua", "Dosovitskiy", "Alexey", "Clune", "Je"],
    "venue": "arXiv preprint arXiv:1612.00005,",
    "year": 2016
  }, {
    "title": "Wavenet: A generative model for raw audio",
    "authors": ["Oord", "Aaron van den", "Dieleman", "Sander", "Zen", "Heiga", "Simonyan", "Karen", "Vinyals", "Oriol", "Graves", "Alex", "Kalchbrenner", "Nal", "Senior", "Andrew", "Kavukcuoglu", "Koray"],
    "venue": "arXiv preprint arXiv:1609.03499,",
    "year": 2016
  }, {
    "title": "Fast generation for convolutional autoregressive models",
    "authors": ["Ramachandran", "Prajit", "Paine", "Tom Le", "Khorrami", "Pooya", "Babaeizadeh", "Mohammad", "Chang", "Shiyu", "Zhang", "Yang", "Hasegawa-Johnson", "Mark", "Campbell", "Roy", "Huang", "Thomas"],
    "year": 2017
  }, {
    "title": "Learning what and where to draw",
    "authors": ["Reed", "Scott", "Akata", "Zeynep", "Mohan", "Santosh", "Tenka", "Samuel", "Schiele", "Bernt", "Lee", "Honglak"],
    "venue": "In NIPS,",
    "year": 2016
  }, {
    "title": "Generative adversarial text-to-image synthesis",
    "authors": ["Reed", "Scott", "Akata", "Zeynep", "Yan", "Xinchen", "Logeswaran", "Lajanugen", "Schiele", "Bernt", "Lee", "Honglak"],
    "venue": "In ICML,",
    "year": 2016
  }, {
    "title": "Generating interpretable images with controllable structure",
    "authors": ["Reed", "Scott", "van den Oord", "Aäron", "Kalchbrenner", "Nal", "Bapst", "Victor", "Botvinick", "Matt", "de Freitas", "Nando"],
    "venue": "Technical report,",
    "year": 2016
  }, {
    "title": "PixelCNN++: Improving the PixelCNN with discretized logistic mixture likelihood and other modifications",
    "authors": ["Salimans", "Tim", "Karpathy", "Andrej", "Chen", "Xi", "Kingma", "Diederik P"],
    "venue": "arXiv preprint arXiv:1701.05517,",
    "year": 2017
  }, {
    "title": "Real-time single image and video super-resolution using an e cient sub-pixel convolutional neural network",
    "authors": ["Shi", "Wenzhe", "Caballero", "Jose", "Huszár", "Ferenc", "Totz", "Johannes", "Aitken", "Andrew P", "Bishop", "Rob", "Rueckert", "Daniel", "Wang", "Zehan"],
    "year": 2016
  }, {
    "title": "Amortised MAP inference for image super-resolution",
    "authors": ["Sønderby", "Casper Kaae", "Caballero", "Jose", "Theis", "Lucas", "Shi", "Wenzhe", "Huszár", "Ferenc"],
    "year": 2017
  }, {
    "title": "Generative image modeling using spatial LSTMs",
    "authors": ["L. Theis", "M. Bethge"],
    "venue": "In NIPS,",
    "year": 2015
  }, {
    "title": "RNADE: The real-valued neural autoregressive densityestimator",
    "authors": ["Uria", "Benigno", "Murray", "Iain", "Larochelle", "Hugo"],
    "venue": "In NIPS,",
    "year": 2013
  }, {
    "title": "Pixel recurrent neural networks",
    "authors": ["van den Oord", "Aäron", "Kalchbrenner", "Nal", "Kavukcuoglu", "Koray"],
    "venue": "In ICML, pp",
    "year": 2016
  }, {
    "title": "Conditional image generation with PixelCNN decoders",
    "authors": ["van den Oord", "Aäron", "Kalchbrenner", "Nal", "Vinyals", "Oriol", "Espeholt", "Lasse", "Graves", "Alex", "Kavukcuoglu", "Koray"],
    "venue": "In NIPS,",
    "year": 2016
  }, {
    "title": "The Caltech-UCSD birds200-2011",
    "authors": ["Wah", "Catherine", "Branson", "Steve", "Welinder", "Peter", "Perona", "Pietro", "Belongie", "Serge"],
    "year": 2011
  }, {
    "title": "Generative image modeling using style and structure adversarial networks",
    "authors": ["Wang", "Xiaolong", "Gupta", "Abhinav"],
    "venue": "In ECCV,",
    "year": 2016
  }, {
    "title": "On the quantitative analysis of decoderbased generative models",
    "authors": ["Wu", "Yuhuai", "Burda", "Yuri", "Salakhutdinov", "Ruslan", "Grosse", "Roger"],
    "year": 2017
  }, {
    "title": "StackGAN: Text to photo-realistic image synthesis with stacked generative adversarial networks",
    "authors": ["Zhang", "Han", "Xu", "Tao", "Li", "Hongsheng", "Shaoting", "Huang", "Xiaolei", "Wang", "Xiaogang", "Metaxas", "Dimitris"],
    "venue": "arXiv preprint arXiv:1612.03242,",
    "year": 2016
  }],
  "id": "SP:8bab0f0cf30fe5acd8022f3ae922e8dbf9453fb7",
  "authors": [{
    "name": "Scott Reed",
    "affiliations": []
  }, {
    "name": "Aäron van den Oord",
    "affiliations": []
  }, {
    "name": "Nal Kalchbrenner",
    "affiliations": []
  }, {
    "name": "Sergio Gómez Colmenarejo",
    "affiliations": []
  }, {
    "name": "Ziyu Wang",
    "affiliations": []
  }, {
    "name": "Yutian Chen",
    "affiliations": []
  }, {
    "name": "Dan Belov",
    "affiliations": []
  }, {
    "name": "Nando de Freitas",
    "affiliations": []
  }],
  "abstractText": "PixelCNN achieves state-of-the-art results in density estimation for natural images. Although training is fast, inference is costly, requiring one network evaluation per pixel; O(N) for N pixels. This can be sped up by caching activations, but still involves generating each pixel sequentially. In this work, we propose a parallelized PixelCNN that allows more e cient inference by modeling certain pixel groups as conditionally independent. Our new PixelCNN model achieves competitive density estimation and orders of magnitude speedup O(log N) sampling instead of O(N) enabling the practical generation of 512⇥ 512 images. We evaluate the model on class-conditional image generation, text-toimage synthesis, and action-conditional video generation, showing that our model achieves the best results among non-pixel-autoregressive density models that allow e cient sampling.",
  "title": "Parallel Multiscale Autoregressive Density Estimation"
}