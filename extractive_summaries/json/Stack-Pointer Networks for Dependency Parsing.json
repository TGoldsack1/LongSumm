{
  "sections": [{
    "text": "Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Long Papers), pages 1403–1414 Melbourne, Australia, July 15 - 20, 2018. c©2018 Association for Computational Linguistics\n1403"
  }, {
    "heading": "1 Introduction",
    "text": "Dependency parsing, which predicts the existence and type of linguistic dependency relations between words, is a first step towards deep language understanding. Its importance is widely recognized in the natural language processing (NLP) community, with it benefiting a wide range of NLP applications, such as coreference resolution (Ng, 2010; Durrett and Klein, 2013; Ma et al.,\n∗Work done while at Carnegie Mellon University.\n2016), sentiment analysis (Tai et al., 2015), machine translation (Bastings et al., 2017), information extraction (Nguyen et al., 2009; Angeli et al., 2015; Peng et al., 2017), word sense disambiguation (Fauceglia et al., 2015), and low-resource languages processing (McDonald et al., 2013; Ma and Xia, 2014). There are two dominant approaches to dependency parsing (Buchholz and Marsi, 2006; Nivre et al., 2007): local and greedy transitionbased algorithms (Yamada and Matsumoto, 2003; Nivre and Scholz, 2004; Zhang and Nivre, 2011; Chen and Manning, 2014), and the globally optimized graph-based algorithms (Eisner, 1996; McDonald et al., 2005a,b; Koo and Collins, 2010).\nTransition-based dependency parsers read words sequentially (commonly from left-to-right) and build dependency trees incrementally by making series of multiple choice decisions. The advantage of this formalism is that the number of operations required to build any projective parse tree is linear with respect to the length of the sentence. The challenge, however, is that the decision made at each step is based on local information, leading to error propagation and worse performance compared to graph-based parsers on root and long dependencies (McDonald and Nivre, 2011). Previous studies have explored solutions to address this challenge. Stack LSTMs (Dyer et al., 2015; Ballesteros et al., 2015, 2016) are capable of learning representations of the parser state that are sensitive to the complete contents of the parser’s state. Andor et al. (2016) proposed a globally normalized transition model to replace the locally normalized classifier. However, the parsing accuracy is still behind state-of-the-art graph-based parsers (Dozat and Manning, 2017).\nGraph-based dependency parsers, on the other hand, learn scoring functions for parse trees and perform exhaustive search over all possible trees for a sentence to find the globally highest scoring\ntree. Incorporating this global search algorithm with distributed representations learned from neural networks, neural graph-based parsers (Kiperwasser and Goldberg, 2016; Wang and Chang, 2016; Kuncoro et al., 2016; Dozat and Manning, 2017) have achieved the state-of-the-art accuracies on a number of treebanks in different languages. Nevertheless, these models, while accurate, are usually slow (e.g. decoding is O(n3) time complexity for first-order models (McDonald et al., 2005a,b) and higher polynomials for higherorder models (McDonald and Pereira, 2006; Koo and Collins, 2010; Ma and Zhao, 2012b,a)).\nIn this paper, we propose a novel neural network architecture for dependency parsing, stackpointer networks (STACKPTR). STACKPTR is a transition-based architecture, with the corresponding asymptotic efficiency, but still maintains a global view of the sentence that proves essential for achieving competitive accuracy. Our STACKPTR parser has a pointer network (Vinyals et al., 2015) as its backbone, and is equipped with an internal stack to maintain the order of head words in tree structures. The STACKPTR parser performs parsing in an incremental, topdown, depth-first fashion; at each step, it generates an arc by assigning a child for the head word at the top of the internal stack. This architecture makes it possible to capture information from the whole sentence and all the previously derived subtrees, while maintaining a number of parsing steps linear in the sentence length.\nWe evaluate our parser on 29 treebanks across 20 languages and different dependency annotation schemas, and achieve state-of-the-art performance on 21 of them. The contributions of this work are summarized as follows:\n(i) We propose a neural network architecture for dependency parsing that is simple, effective, and efficient.\n(ii) Empirical evaluations on benchmark datasets over 20 languages show that our method achieves state-of-the-art performance on 21 different treebanks1.\n(iii) Comprehensive error analysis is conducted to compare the proposed method to a strong graph-based baseline using biaffine attention (Dozat and Manning, 2017).\n1Source code is publicly available at https:// github.com/XuezheMax/NeuroNLP2"
  }, {
    "heading": "2 Background",
    "text": "We first briefly describe the task of dependency parsing, setup the notation, and review Pointer Networks (Vinyals et al., 2015)."
  }, {
    "heading": "2.1 Dependency Parsing and Notations",
    "text": "Dependency trees represent syntactic relationships between words in the sentences through labeled directed edges between head words and their dependents. Figure 1 (a) shows a dependency tree for the sentence, “But there were no buyers”.\nIn this paper, we will use the following notation: Input: x = {w1, . . . , wn} represents a generic sentence, where wi is the ith word. Output: y = {p1, p2, · · · , pk} represents a generic (possibly non-projective) dependency tree, where each path pi = $, wi,1, wi,2, · · · , wi,li is a sequence of words from the root to a leaf. “$” is an universal virtual root that is added to each tree.\nStack: σ denotes a stack configuration, which is a sequence of words. We use σ|w to represent a stack configuration that pushes word w into the stack σ.\nChildren: ch(wi) denotes the list of all the children (modifiers) of word wi."
  }, {
    "heading": "2.2 Pointer Networks",
    "text": "Pointer Networks (PTR-NET) (Vinyals et al., 2015) are a variety of neural network capable of learning the conditional probability of an output sequence with elements that are discrete tokens corresponding to positions in an input sequence. This model cannot be trivially expressed by standard sequence-to-sequence networks (Sutskever et al., 2014) due to the variable number of input positions in each sentence. PTR-NET solves the problem by using attention (Bahdanau et al., 2015; Luong et al., 2015) as a pointer to select a member of the input sequence as the output.\nFormally, the words of the sentence x are fed one-by-one into the encoder (a multiple-layer bidirectional RNN), producing a sequence of encoder hidden states si. At each time step t, the decoder (a uni-directional RNN) receives the input from last step and outputs decoder hidden state ht. The attention vector at is calculated as follows:\neti = score(ht, si) at = softmax (et)\n(1)\nwhere score(·, ·) is the attention scoring function, which has several variations such as dot-product,\nconcatenation, and biaffine (Luong et al., 2015). PTR-NET regards the attention vector at as a probability distribution over the source words, i.e. it uses ati as pointers to select the input elements."
  }, {
    "heading": "3 Stack-Pointer Networks",
    "text": ""
  }, {
    "heading": "3.1 Overview",
    "text": "Similarly to PTR-NET, STACKPTR first reads the whole sentence and encodes each word into the encoder hidden state si. The internal stack σ is always initialized with the root symbol $. At each time step t, the decoder receives the input vector corresponding to the top element of the stack σ (the head wordwp where p is the word index), generates the hidden state ht, and computes the attention vector at using Eq. (1). The parser chooses a specific position c according to the attention scores in at to generate a new dependency arc (wh, wc) by selecting wc as a child of wh. Then the parser pushes wc onto the stack, i.e. σ → σ|wc, and goes to the next step. At one step if the parser points wh to itself, i.e. c = h, it indicates that all children of the head word wh have already been selected. Then the parser goes to the next step by popping wh out of σ.\nAt test time, in order to guarantee a valid dependency tree containing all the words in the input sentences exactly once, the decoder maintains a list of “available” words. At each decoding step, the parser selects a child for the current head word,\nand removes the child from the list of available words to make sure that it cannot be selected as a child of other head words.\nFor head words with multiple children, it is possible that there is more than one valid selection for each time step. In order to define a deterministic decoding process to make sure that there is only one ground-truth choice at each step (which is necessary for simple maximum likelihood estimation), a predefined order for each ch(wi) needs to be introduced. The predefined order of children can have different alternatives, such as leftto-right or inside-out2. In this paper, we adopt the inside-out order3 since it enables us to utilize second-order sibling information, which has been proven beneficial for parsing performance (McDonald and Pereira, 2006; Koo and Collins, 2010) (see § 3.4 for details). Figure 1 (b) depicts the architecture of STACKPTR and the decoding procedure for the example sentence in Figure 1 (a)."
  }, {
    "heading": "3.2 Encoder",
    "text": "The encoder of our parsing model is based on the bi-directional LSTM-CNN architecture (BLSTMCNNs) (Chiu and Nichols, 2016; Ma and Hovy, 2016) where CNNs encode character-level information of a word into its character-level repre-\n2Order the children by the distances to the head word on the left side, then the right side.\n3We also tried left-to-right order which obtained worse parsing accuracy than inside-out.\nsentation and BLSTM models context information of each word. Formally, for each word, the CNN, with character embeddings as inputs, encodes the character-level representation. Then the character-level representation vector is concatenated with the word embedding vector to feed into the BLSTM network. To enrich word-level information, we also use POS embeddings. Finally, the encoder outputs a sequence of hidden states si."
  }, {
    "heading": "3.3 Decoder",
    "text": "The decoder for our parser is a uni-directional LSTM. Different from previous work (Bahdanau et al., 2015; Vinyals et al., 2015) which uses word embeddings of the previous word as the input to the decoder, our decoder receives the encoder hidden state vector (si) of the top element in the stack σ (see Figure 1 (b)). Compared to word embeddings, the encoder hidden states contain more contextual information, benefiting both the training and decoding procedures. The decoder produces a sequence of decoder hidden states hi, one for each decoding step."
  }, {
    "heading": "3.4 Higher-order Information",
    "text": "As mentioned before, our parser is capable of utilizing higher-order information. In this paper, we incorporate two kinds of higher-order structures — grandparent and sibling. A sibling structure is a head word with two successive modifiers, and a grandparent structure is a pair of dependencies connected head-to-tail: !\" # ! # $%&' $' (& \" $' ) )*'+ & ' ' \"+ #'), )# \" # & * '- # ! # $%( ) & ' $ ./- # 0 # ! # $%! & & & $+*) '+ + + &'1&$) \"%& &)*. 234.56 789:7;<=>?@A BCDEF4.G25 H IJ /K4.5 &'+ & ')* \"' &$) ! ' ,\" - '+. #BCDEF4.G25 L \" ' &'+ L ''+ '' 2 &'+ \"%& &)*& ' $ .(B $ '+ $ # \"1 '%)*K4.5 )-& !) ' \"%- '+'+ \" '+)*'+ & ' $ /# $'\"%&)\"L FM( & ! $' $ \"( $) ) &' ' %/ #) -+ $+*) &'+ *)1$ &)*'+ &! ! / &')NOPQRS $+# ! # $%' ')& \"TOSQU/-+ $+$ , &$) # &)\" ' ) ( $') #! & $ , *) \" V # &*)\")-& BCDEF4.G256 WX=<BCDEFY EZ4.G[5Z+ ' &/- ' ''+ # ! # $%' 2 & & ')*! '&[/ $+)*-+ $+ \\ & & ! ' $) ' 1, ' ) ')'+ &$) )*2( ) $ ' * $') V ' ) &/ *0$ '! & \" ) '+ & &'*) &)\"L FM( (] # 0 '+ RŜ_S)* ! ' $$) # ')'+ , )*# ! # $ & '$) ' &/- '+ \")1 ) &' )\") %*) * $') V ' ) & #! & \"1 ) '+ &(̀ '+ # )*'+ &! ! /- *)$ &) * $') V ' ) & ' \" V '+ *)\")- ! '& a abbb b b cc c cc dd d efghgifgijk lmnomip pqrifjsmoftqmulmnomippqrifulmnomipB! $ 0$ \"%/B $' ) &v( /v(w/ #v(x# &$ , ! & &'+ '/ &! $' L \"%/* $') ' & ') #1$+ \"#! '&/ #1& ,\" ! '&/ # ' )* #1& ,\" #' 1& ,\" ! '&(y z{|}~| }| |~ }D -'+ #1) # # ! # $%! & &, \"#) # &* ) &' ! & \" ) '+ &( ̀'+ && $' ) /- ! )L # , $\\ ) #) '-) \" L '! & &* ) ! L ) &-) \\( H I H,I w Z+ #% $1! ) &' $' & ## L ' ) &)*'+ F & Hw I \" ) '+ (C) !\" ' &! & # ! $' # &' \" & # 1$) !\" ' &! & &' ! V) #&( ) , L '%/- \" # '+ &% ' $ +'1+ # #L & ) &(y | }~ ~ | ~| Z+ 0 &''%! )*! & - # &$ , & & 0 &'1) # * $') V ' ) /-+ $+# $) !)& & # ! 1# $%' ') '& # L # \"# ! # $ &(F &1 Hw I ' )# $ # - # \"%1 & ##% $1! ) \" ) '+ *) 0 &'1) # ! &   & ' &'+ , & &*) %! & &/ $\" # ) - \" ) '+ &/- & V '&# & + (Z+ F & Hw I \" ) '+ &, & #) '-) ' \" ' #'%! &)*#% $1! ) &' $1' & PR¡T¢_Q_&! &/-+ $+$) & &')* + #1-) # # '&# &$ # '&) ) & # / #£¤PR¡¥T¢_Q_&! &/-+ $+$) & &')* # ! # $% #'+ ) , '- '+ + # # )# 0 ( ) \"%/- # )' $) !\" ' &! &¦§̈©-+ ª #« '+ # $ &)*'+ &! ¬&+ #1-) # # #!) '( $) !\" ' &! &# 1 )' # &§̈® -+ ª #̄ '+ # )*'+ + # # )# 0 )* # ! # $%( ̀' ' L \"%/ $) !\" ' &! ! & '& + \"*1$) &' ' ' + # #,%ª/-+ & $) !\" ' &! &) \"% ! ' \"+ \"*1$) &' ' '/& $ '+ $) &' ' '$ , ' # #,% ## ) )# 0 &')̄ (F $+'%! )*&! &$ ' #,% $ & L \"%$) , '-)& \" / #° $ '&! & '+ $) 1&' $' ) & &! $ 0 # !+ $ \"% w( $) !\" ' &! &$) &' $' #* ) ! )*$) !\" ' &! &/ # $ ' '+ # L & ) )*'+ ±ªḠ ² ')$) &' ' '&+ # #,%ª #¯( $) !\" ' &! &$ ' #,% $) !\" '1 $) !\" ' &! - '+'+ )'+ + \"*)*¯¬&$) &' ' '(Z+ !) ')*$) $ ' ' ) $+$) &' $' ) ³¯ wH I)́ 1 wH,I³ &'+ UT¢£QTR£¤Q/ * # '+ ' &', ' #')0 #'+ )!' \"$) &' $' ) (̀) # ')! & & ' $ ./ '& *0$ &')0 #)!' \"$) &' $' ) &*) \"$) !\" ' # $) !\" ' &! &# 0 #) .( Z+ &$ , µ To utilize higher-order information, the decoder’s input at each step is the sum of the encoder hidden states of three ords: βt = sh + sg + ss where βt is the input vector of decoder at time t and h, g, s are the indices of the head word and its grandparent and sibling, respectively. Figure 1 (b) illustrates the details. Here we use the element-wise sum operation instead of concatenation because it does not increase the dimension of the input vector βt, thus introducing no additional model parameters."
  }, {
    "heading": "3.5 Biaffine Attention Mechanism",
    "text": "For attention score function (Eq. (1)), we adopt the biaffine attention mechanism (Luong et al., 2015; Dozat and Manning, 2017):\neti = h T t Wsi +U Tht +V T si + b\nwhere W,U,V, b are parameters, denoting the weight matrix of the bi-linear term, the two weight vectors of the linear terms, and the bias vector.\nAs discussed in Dozat and Manning (2017), applying a multilayer perceptron (MLP) to the output vectors of the BLSTM before the score function can both reduce the dimensionality and overfitting of the model. We follow this work by using a one-layer perceptron to si and hi with elu (Clevert et al., 2015) as its activation function.\nSimilarly, the dependency label classifier also uses a biaffine function to score each label, given the head word vector ht and child vector si as inputs. Again, we use MLPs to transform ht and si before feeding them into the classifier."
  }, {
    "heading": "3.6 Training Objectives",
    "text": "The STACKPTR parser is trained to optimize the probability of the dependency trees given sentences: Pθ(y|x), which can be factorized as:\nPθ(y|x) = k∏ i=1 Pθ(pi|p<i,x)\n= k∏ i=1 li∏ j=1 Pθ(ci,j |ci,<j , p<i,x), (2)\nwhere θ represents model parameters. p<i denotes the preceding paths that have already been generated. ci,j represents the jth word in pi and ci,<j denotes all the proceeding words on the path pi. Thus, the STACKPTR parser is an autoregressive model, like sequence-to-sequence models, but it factors the distribution according to a top-down tree structure as opposed to a left-to-right chain. We define Pθ(ci,j |ci,<j , p<i,x) = at, where attention vector at (of dimension n) is used as the distribution over the indices of words in a sentence.\nArc Prediction Our parser is trained by optimizing the conditional likelihood in Eq (2), which is implemented as the cross-entropy loss.\nLabel Prediction We train a separated multiclass classifier in parallel to predict the dependency labels. Following Dozat and Manning (2017), the classifier takes the information of the\nhead word and its child as features. The label classifier is trained simultaneously with the parser by optimizing the sum of their objectives."
  }, {
    "heading": "3.7 Discussion",
    "text": "Time Complexity. The number of decoding steps to build a parse tree for a sentence of length n is 2n−1, linear in n. Together with the attention mechanism (at each step, we need to compute the attention vector at, whose runtime is O(n)), the time complexity of decoding algorithm is O(n2), which is more efficient than graph-based parsers that have O(n3) or worse complexity when using dynamic programming or maximum spanning tree (MST) decoding algorithms.\nTop-down Parsing. When humans comprehend a natural language sentence, they arguably do it in an incremental, left-to-right manner. However, when humans consciously annotate a sentence with syntactic structure, they rarely ever process in fixed left-to-right order. Rather, they start by reading the whole sentence, then seeking the main predicates, jumping back-and-forth over the sentence and recursively proceeding to the subtree structures governed by certain head words. Our parser follows a similar kind of annotation process: starting from reading the whole sentence, and processing in a top-down manner by finding the main predicates first and only then search for sub-trees governed by them. When making latter decisions, the parser has access to the entire structure built in earlier steps."
  }, {
    "heading": "3.8 Implementation Details",
    "text": "Pre-trained Word Embeddings. For all the parsing models in different languages, we initialize word vectors with pretrained word embeddings. For Chinese, Dutch, English, German and Spanish, we use the structured-skipgram (Ling et al., 2015) embeddings. For other languages we use Polyglot embeddings (Al-Rfou et al., 2013).\nOptimization. Parameter optimization is performed with the Adam optimizer (Kingma and Ba, 2014) with β1 = β2 = 0.9. We choose an initial learning rate of η0 = 0.001. The learning rate η is annealed by multiplying a fixed decay rate ρ = 0.75 when parsing performance stops increasing on validation sets. To reduce the effects of “gradient exploding”, we use gradient clipping of 5.0 (Pascanu et al., 2013).\nDropout Training. To mitigate overfitting, we apply dropout (Srivastava et al., 2014; Ma et al., 2017). For BLSTM, we use recurrent dropout (Gal and Ghahramani, 2016) with a drop rate of 0.33 between hidden states and 0.33 between layers. Following Dozat and Manning (2017), we also use embedding dropout with a rate of 0.33 on all word, character, and POS embeddings.\nHyper-Parameters. Some parameters are chosen from those reported in Dozat and Manning (2017). We use the same hyper-parameters across the models on different treebanks and languages, due to time constraints. The details of the chosen hyper-parameters for all experiments are summarized in Appendix A."
  }, {
    "heading": "4 Experiments",
    "text": ""
  }, {
    "heading": "4.1 Setup",
    "text": "We evaluate our STACKPTR parser mainly on three treebanks: the English Penn Treebank (PTB version 3.0) (Marcus et al., 1993), the Penn Chinese Treebank (CTB version 5.1) (Xue et al., 2002), and the German CoNLL 2009 corpus (Hajič et al., 2009). We use the same experimental settings as Kuncoro et al. (2016).\nTo make a thorough empirical comparison with previous studies, we also evaluate our system on treebanks from CoNLL shared task and the Universal Dependency (UD) Treebanks4. For the CoNLL Treebanks, we use the English treebank from CoNLL-2008 shared task (Surdeanu et al., 2008) and all 13 treebanks from CoNLL-2006 shared task (Buchholz and Marsi, 2006). The experimental settings are the same as Ma and Hovy (2015). For UD Treebanks, we select 12 languages. The details of the treebanks and experimental settings are in § 4.5 and Appendix B.\nEvaluation Metrics Parsing performance is measured with five metrics: unlabeled attachment score (UAS), labeled attachment score (LAS), unlabeled complete match (UCM), labeled complete match (LCM), and root accuracy (RA). Following previous work (Kuncoro et al., 2016; Dozat and Manning, 2017), we report results excluding punctuations for Chinese and English. For each experiment, we report the mean values with corresponding standard deviations over 5 repetitions.\n4http://universaldependencies.org/\nBaseline For fair comparison of the parsing performance, we re-implemented the graph-based Deep Biaffine (BIAF) parser (Dozat and Manning, 2017), which achieved state-of-the-art results on a wide range of languages. Our re-implementation adds character-level information using the same LSTM-CNN encoder as our model (§ 3.2) to the original BIAF model, which boosts its performance on all languages."
  }, {
    "heading": "4.2 Main Results",
    "text": "We first conduct experiments to demonstrate the effectiveness of our neural architecture by comparing with the strong baseline BIAF. We compare the performance of four variations of our model with different decoder inputs — Org, +gpar, +sib and Full — where the Org model utilizes only the encoder hidden states of head words, while the +gpar and +sib models augments the original one with grandparent and sibling information, respectively. The Full model includes all the three information as inputs.\nFigure 2 illustrates the performance (five metrics) of different variations of our STACKPTR parser together with the results of baseline BIAF re-implemented by us, on the test sets of the three\nlanguages. On UAS and LAS, the Full variation of STACKPTR with decoding beam size 10 outperforms BIAF on Chinese, and obtains competitive performance on English and German. An interesting observation is that the Full model achieves the best accuracy on English and Chinese, while performs slightly worse than +sib on German. This shows that the importance of higher-order information varies in languages. On LCM and UCM, STACKPTR significantly outperforms BIAF on all languages, showing the superiority of our parser on complete sentence parsing. The results of our parser on RA are slightly worse than BIAF. More details of results are provided in Appendix C."
  }, {
    "heading": "4.3 Comparison with Previous Work",
    "text": "Table 1 illustrates the UAS and LAS of the four versions of our model (with decoding beam size 10) on the three treebanks, together with previous top-performing systems for comparison. Note that the results of STACKPTR and our reimplementation of BIAF are the average of 5 repetitions instead of a single run. Our Full model significantly outperforms all the transition-based parsers on all three languages, and achieves better results than most graph-based parsers. Our\nre-implementation of BIAF obtains better performance than the original one in Dozat and Manning (2017), demonstrating the effectiveness of the character-level information. Our model achieves state-of-the-art performance on both UAS and LAS on Chinese, and best UAS on English. On German, the performance is competitive with BIAF, and significantly better than other models."
  }, {
    "heading": "4.4 Error Analysis",
    "text": "In this section, we characterize the errors made by BIAF and STACKPTR by presenting a number of experiments that relate parsing errors to a set of linguistic and structural properties. For simplicity,\nwe follow McDonald and Nivre (2011) and report labeled parsing metrics (either accuracy, precision, or recall) for all experiments."
  }, {
    "heading": "4.4.1 Length and Graph Factors",
    "text": "Following McDonald and Nivre (2011), we analyze parsing errors related to structural factors.\nSentence Length. Figure 3 (a) shows the accuracy of both parsing models relative to sentence lengths. Consistent with the analysis in McDonald and Nivre (2011), STACKPTR tends to perform better on shorter sentences, which make fewer parsing decisions, significantly reducing the chance of error propagation.\nDependency Length. Figure 3 (b) measures the precision and recall relative to dependency lengths. While the graph-based BIAF parser still performs better for longer dependency arcs and transition-based STACKPTR parser does better for shorter ones, the gap between the two systems is marginal, much smaller than that shown\nin McDonald and Nivre (2011). One possible reason is that, unlike traditional transition-based parsers that scan the sentence from left to right, STACKPTR processes in a top-down manner, thus sometimes unnecessarily creating shorter dependency arcs first.\nRoot Distance. Figure 3 (c) plots the precision and recall of each system for arcs of varying distance to the root. Different from the observation in McDonald and Nivre (2011), STACKPTR does not show an obvious advantage on the precision for arcs further away from the root. Furthermore, the STACKPTR parser does not have the tendency to over-predict root modifiers reported in McDonald and Nivre (2011). This behavior can be explained using the same reasoning as above: the fact that arcs further away from the root are usually constructed early in the parsing algorithm of traditional transition-based parsers is not true for the STACKPTR parser."
  }, {
    "heading": "4.4.2 Effect of POS Embedding",
    "text": "The only prerequisite information that our parsing model relies on is POS tags. With the goal of achieving an end-to-end parser, we explore the effect of POS tags on parsing performance. We run experiments on PTB using our STACKPTR parser with gold-standard and predicted POS tags, and without tags, respectively. STACKPTR in these experiments is the Full model with beam=10.\nTable 2 gives results of the parsers with different versions of POS tags on the test data of PTB.\nThe parser with gold-standard POS tags significantly outperforms the other two parsers, showing that dependency parsers can still benefit from accurate POS information. The parser with predicted (imperfect) POS tags, however, performs even slightly worse than the parser without using POS tags. It illustrates that an end-to-end parser that doesn’t rely on POS information can obtain competitive (or even better) performance than parsers using imperfect predicted POS tags, even if the POS tagger is relative high accuracy (accuracy > 97% in this experiment on PTB)."
  }, {
    "heading": "4.5 Experiments on Other Treebanks",
    "text": ""
  }, {
    "heading": "4.5.1 CoNLL Treebanks",
    "text": "Table 3 summarizes the parsing results of our model on the test sets of 14 treebanks from the CoNLL shared task, along with the state-of-theart baselines. Along with BIAF, we also list the performance of the bi-directional attention based Parser (Bi-Att) (Cheng et al., 2016) and the neural MST parser (NeuroMST) (Ma and Hovy, 2017) for comparison. Our parser achieves state-of-theart performance on both UAS and LAS on eight languages — Arabic, Czech, English, German, Portuguese, Slovene, Spanish, and Swedish. On Bulgarian and Dutch, our parser obtains the best UAS. On other languages, the performance of our parser is competitive with BIAF, and significantly better than others. The only exception is Japanese, on which NeuroMST obtains the best scores."
  }, {
    "heading": "4.5.2 UD Treebanks",
    "text": "For UD Treebanks, we select 12 languages — Bulgarian, Catalan, Czech, Dutch, English, French, German, Italian, Norwegian, Romanian, Russian and Spanish. For all the languages, we adopt the standard training/dev/test splits, and use the universal POS tags (Petrov et al., 2012) provided in each treebank. The statistics of these corpora are provided in Appendix B.\nTable 4 summarizes the results of the STACKPTR parser, along with BIAF for comparison, on both the development and test datasets for each language. First, both BIAF and STACKPTR parsers achieve relatively high parsing accuracies on all the 12 languages — all with UAS are higher than 90%. On nine languages — Catalan, Czech, Dutch, English, French, German, Norwegian, Russian and Spanish — STACKPTR outperforms BIAF for both UAS and LAS. On Bulgarian, STACKPTR achieves slightly better UAS while LAS is slightly worse than BIAF. On Italian and Romanian, BIAF obtains marginally better parsing performance than STACKPTR."
  }, {
    "heading": "5 Conclusion",
    "text": "In this paper, we proposed STACKPTR, a transition-based neural network architecture, for dependency parsing. Combining pointer networks with an internal stack to track the status of the top-down, depth-first search in the decoding procedure, the STACKPTR parser is able to capture information from the whole sentence and all the previously derived subtrees, removing the leftto-right restriction in classical transition-based parsers, while maintaining linear parsing steps, w.r.t the length of the sentences. Experimental re-\nsults on 29 treebanks show the effectiveness of our parser across 20 languages, by achieving state-ofthe-art performance on 21 corpora.\nThere are several potential directions for future work. First, we intend to consider how to conduct experiments to improve the analysis of parsing errors qualitatively and quantitatively. Another interesting direction is to further improve our model by exploring reinforcement learning approaches to learn an optimal order for the children of head words, instead of using a predefined fixed order."
  }, {
    "heading": "Acknowledgements",
    "text": "The authors thank Chunting Zhou, Di Wang and Zhengzhong Liu for their helpful discussions. This research was supported in part by DARPA grant FA8750-18-2-0018 funded under the AIDA program. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of DARPA."
  }],
  "year": 2018,
  "references": [{
    "title": "Polyglot: Distributed word representations for multilingual nlp",
    "authors": ["Rami Al-Rfou", "Bryan Perozzi", "Steven Skiena."],
    "venue": "Proceedings of CoNLL2013. Sofia, Bulgaria, pages 183–192.",
    "year": 2013
  }, {
    "title": "Globally normalized transition-based neural networks",
    "authors": ["Daniel Andor", "Chris Alberti", "David Weiss", "Aliaksei Severyn", "Alessandro Presta", "Kuzman Ganchev", "Slav Petrov", "Michael Collins."],
    "venue": "Proceedings of ACL-2016 (Volume 1: Long Papers).",
    "year": 2016
  }, {
    "title": "Leveraging linguistic structure for open domain information extraction",
    "authors": ["Gabor Angeli", "Melvin Jose Johnson Premkumar", "Christopher D. Manning"],
    "year": 2015
  }, {
    "title": "Neural machine translation by jointly learning to align and translate",
    "authors": ["Dzmitry Bahdanau", "Kyunghyun Cho", "Yoshua Bengio."],
    "venue": "Proceedings of ICLR-2015.",
    "year": 2015
  }, {
    "title": "Improved transition-based parsing by modeling characters instead of words with lstms",
    "authors": ["Miguel Ballesteros", "Chris Dyer", "Noah A. Smith."],
    "venue": "Proceedings of EMNLP-2015. Lisbon, Portugal, pages 349–359.",
    "year": 2015
  }, {
    "title": "Training with exploration improves a greedy stack lstm parser",
    "authors": ["Miguel Ballesteros", "Yoav Goldberg", "Chris Dyer", "Noah A. Smith."],
    "venue": "Proceedings of EMNLP-2016. Austin, Texas, pages 2005–2010.",
    "year": 2016
  }, {
    "title": "Graph convolutional encoders for syntax-aware neural machine translation",
    "authors": ["Joost Bastings", "Ivan Titov", "Wilker Aziz", "Diego Marcheggiani", "Khalil Simaan."],
    "venue": "Proceedings of EMNLP-2017. Copenhagen, Denmark, pages 1957–1967.",
    "year": 2017
  }, {
    "title": "A transitionbased system for joint part-of-speech tagging and labeled non-projective dependency parsing",
    "authors": ["Bernd Bohnet", "Joakim Nivre."],
    "venue": "Proceedings of EMNLP-2012. Jeju Island, Korea, pages 1455–1465.",
    "year": 2012
  }, {
    "title": "CoNLL-X shared task on multilingual dependency parsing",
    "authors": ["Sabine Buchholz", "Erwin Marsi."],
    "venue": "Proceeding of CoNLL-2006. New York, NY, pages 149–164.",
    "year": 2006
  }, {
    "title": "A fast and accurate dependency parser using neural networks",
    "authors": ["Danqi Chen", "Christopher Manning."],
    "venue": "Proceedings of EMNLP-2014. Doha, Qatar, pages 740–750.",
    "year": 2014
  }, {
    "title": "Bi-directional attention with agreement for dependency parsing",
    "authors": ["Hao Cheng", "Hao Fang", "Xiaodong He", "Jianfeng Gao", "Li Deng."],
    "venue": "Proceedings of EMNLP-2016. Austin, Texas, pages 2204–2214.",
    "year": 2016
  }, {
    "title": "Named entity recognition with bidirectional lstm-cnns",
    "authors": ["Jason Chiu", "Eric Nichols."],
    "venue": "Transactions of the Association for Computational Linguistics 4:357–370.",
    "year": 2016
  }, {
    "title": "Fast and accurate deep network learning by exponential linear units (elus)",
    "authors": ["Djork-Arné Clevert", "Thomas Unterthiner", "Sepp Hochreiter."],
    "venue": "arXiv preprint arXiv:1511.07289 .",
    "year": 2015
  }, {
    "title": "Deep biaffine attention for neural dependency parsing",
    "authors": ["Timothy Dozat", "Christopher D. Manning."],
    "venue": "Proceedings of ICLR-2017 (Volume 1: Long Papers). Toulon, France.",
    "year": 2017
  }, {
    "title": "Easy victories and uphill battles in coreference resolution",
    "authors": ["Greg Durrett", "Dan Klein."],
    "venue": "Proceedings of EMNLP-2013. Seattle, Washington, USA, pages 1971–1982.",
    "year": 2013
  }, {
    "title": "Transitionbased dependency parsing with stack long shortterm memory",
    "authors": ["Chris Dyer", "Miguel Ballesteros", "Wang Ling", "Austin Matthews", "Noah A. Smith."],
    "venue": "Proceedings of ACL-2015 (Volume 1: Long Papers). Beijing, China, pages 334–343.",
    "year": 2015
  }, {
    "title": "Three new probabilistic models for dependency parsing: An exploration",
    "authors": ["Jason M Eisner."],
    "venue": "Proceedings of COLING-1996 (Volume 1). Association for Computational Linguistics, pages 340–345.",
    "year": 1996
  }, {
    "title": "Word sense disambiguation via propstore and ontonotes for event mention detection",
    "authors": ["Nicolas R Fauceglia", "Yiu-Chang Lin", "Xuezhe Ma", "Eduard Hovy."],
    "venue": "Proceedings of the The 3rd Workshop on EVENTS: Definition, Detection, Coreference, and",
    "year": 2015
  }, {
    "title": "A theoretically grounded application of dropout in recurrent neural networks",
    "authors": ["Yarin Gal", "Zoubin Ghahramani."],
    "venue": "Advances in Neural Information Processing Systems.",
    "year": 2016
  }, {
    "title": "Adam: A method for stochastic optimization",
    "authors": ["Diederik Kingma", "Jimmy Ba."],
    "venue": "arXiv preprint arXiv:1412.6980 .",
    "year": 2014
  }, {
    "title": "Simple and accurate dependency parsing using bidirectional lstm feature representations",
    "authors": ["Eliyahu Kiperwasser", "Yoav Goldberg."],
    "venue": "Transactions of the Association for Computational Linguistics 4:313–327.",
    "year": 2016
  }, {
    "title": "Efficient thirdorder dependency parsers",
    "authors": ["Terry Koo", "Michael Collins."],
    "venue": "Proceedings of ACL2010. Uppsala, Sweden, pages 1–11.",
    "year": 2010
  }, {
    "title": "Dual decomposition for parsing with non-projective head automata",
    "authors": ["Terry Koo", "Alexander M. Rush", "Michael Collins", "Tommi Jaakkola", "David Sontag."],
    "venue": "Proceedings of EMNLP-2010. Cambridge, MA, pages 1288–1298.",
    "year": 2010
  }, {
    "title": "Distilling an ensemble of greedy dependency parsers into one mst parser",
    "authors": ["Adhiguna Kuncoro", "Miguel Ballesteros", "Lingpeng Kong", "Chris Dyer", "Noah A. Smith."],
    "venue": "Proceedings of EMNLP2016. Austin, Texas, pages 1744–1753.",
    "year": 2016
  }, {
    "title": "Low-rank tensors for scoring dependency structures",
    "authors": ["Tao Lei", "Yu Xin", "Yuan Zhang", "Regina Barzilay", "Tommi Jaakkola."],
    "venue": "Proceedings of ACL2014 (Volume 1: Long Papers). Baltimore, Maryland, pages 1381–1391.",
    "year": 2014
  }, {
    "title": "Two/too simple adaptations of word2vec for syntax problems",
    "authors": ["Wang Ling", "Chris Dyer", "Alan W Black", "Isabel Trancoso."],
    "venue": "Proceedings of NAACL-2015. Denver, Colorado, pages 1299–1304.",
    "year": 2015
  }, {
    "title": "Effective approaches to attentionbased neural machine translation",
    "authors": ["Thang Luong", "Hieu Pham", "Christopher D. Manning."],
    "venue": "Proceedings of EMNLP-2015. Lisbon, Portugal, pages 1412–1421.",
    "year": 2015
  }, {
    "title": "Dropout with expectation-linear regularization",
    "authors": ["Xuezhe Ma", "Yingkai Gao", "Zhiting Hu", "Yaoliang Yu", "Yuntian Deng", "Eduard Hovy."],
    "venue": "Proceedings of the 5th International Conference on Learning Representations (ICLR-2017). Toulon, France.",
    "year": 2017
  }, {
    "title": "Efficient inner-toouter greedy algorithm for higher-order labeled dependency parsing",
    "authors": ["Xuezhe Ma", "Eduard Hovy."],
    "venue": "Proceedings of EMNLP-2015. Lisbon, Portugal, pages 1322–1328.",
    "year": 2015
  }, {
    "title": "End-to-end sequence labeling via bi-directional lstm-cnns-crf",
    "authors": ["Xuezhe Ma", "Eduard Hovy."],
    "venue": "Proceedings of ACL-2016 (Volume 1: Long Papers). Berlin, Germany, pages 1064–1074.",
    "year": 2016
  }, {
    "title": "Neural probabilistic model for non-projective mst parsing",
    "authors": ["Xuezhe Ma", "Eduard Hovy."],
    "venue": "Proceedings of IJCNLP-2017 (Volume 1: Long Papers). Taipei, Taiwan, pages 59–69.",
    "year": 2017
  }, {
    "title": "Unsupervised ranking model for entity coreference resolution",
    "authors": ["Xuezhe Ma", "Zhengzhong Liu", "Eduard Hovy."],
    "venue": "Proceedings of NAACL-2016. San Diego, California, USA.",
    "year": 2016
  }, {
    "title": "Unsupervised dependency parsing with transferring distribution via parallel guidance and entropy regularization",
    "authors": ["Xuezhe Ma", "Fei Xia."],
    "venue": "Proceedings of ACL-2014. Baltimore, Maryland, pages 1337–1348.",
    "year": 2014
  }, {
    "title": "Fourth-order dependency parsing",
    "authors": ["Xuezhe Ma", "Hai Zhao."],
    "venue": "Proceedings of COLING 2012: Posters. Mumbai, India, pages 785–796.",
    "year": 2012
  }, {
    "title": "Probabilistic models for high-order projective dependency parsing",
    "authors": ["Xuezhe Ma", "Hai Zhao."],
    "venue": "Technical Report, arXiv:1502.04174 .",
    "year": 2012
  }, {
    "title": "Building a large annotated corpus of English: the Penn Treebank",
    "authors": ["Mitchell Marcus", "Beatrice Santorini", "Mary Ann Marcinkiewicz."],
    "venue": "Computational Linguistics 19(2):313–330.",
    "year": 1993
  }, {
    "title": "Turning on the turbo: Fast third-order nonprojective turbo parsers",
    "authors": ["Andre Martins", "Miguel Almeida", "Noah A. Smith."],
    "venue": "Proceedings of ACL2013 (Volume 2: Short Papers). Sofia, Bulgaria, pages 617–622.",
    "year": 2013
  }, {
    "title": "Dual decomposition with many overlapping components",
    "authors": ["Andre Martins", "Noah Smith", "Mario Figueiredo", "Pedro Aguiar."],
    "venue": "Proceedings of EMNLP-2011. Edinburgh, Scotland, UK., pages 238–249.",
    "year": 2011
  }, {
    "title": "Online large-margin training of dependency parsers",
    "authors": ["Ryan McDonald", "Koby Crammer", "Fernando Pereira."],
    "venue": "Proceedings of ACL-2005. Ann Arbor, Michigan, USA, pages 91–98.",
    "year": 2005
  }, {
    "title": "Analyzing and integrating dependency parsers",
    "authors": ["Ryan McDonald", "Joakim Nivre."],
    "venue": "Computational Linguistics 37(1):197–230.",
    "year": 2011
  }, {
    "title": "Online learning of approximate dependency parsing algorithms",
    "authors": ["Ryan McDonald", "Fernando Pereira."],
    "venue": "Proceeding of EACL-2006.",
    "year": 2006
  }, {
    "title": "Non-projective dependency parsing using spanning tree algorithms",
    "authors": ["Ryan McDonald", "Fernando Pereira", "Kiril Ribarov", "Jan Hajic."],
    "venue": "Proceedings of HLT/EMNLP-2005. Vancouver, Canada, pages 523–530.",
    "year": 2005
  }, {
    "title": "Supervised noun phrase coreference research: The first fifteen years",
    "authors": ["Vincent Ng."],
    "venue": "Proceedings of ACL-2010. Association for Computational Linguistics, Uppsala, Sweden, pages 1396–1411.",
    "year": 2010
  }, {
    "title": "Convolution kernels on constituent, dependency and sequential structures for relation extraction",
    "authors": ["Truc-Vien T. Nguyen", "Alessandro Moschitti", "Giuseppe Riccardi."],
    "venue": "Proceedings of EMNLP2009. Singapore, pages 1378–1387.",
    "year": 2009
  }, {
    "title": "The CoNLL 2007 shared task on dependency parsing",
    "authors": ["Joakim Nivre", "Johan Hall", "Sandra Kübler", "Ryan McDonald", "Jens Nilsson", "Sebastian Riedel", "Deniz Yuret."],
    "venue": "Proceedings of the CoNLL Shared Task Session of EMNLP-CoNLL",
    "year": 2007
  }, {
    "title": "Deterministic dependency parsing of English text",
    "authors": ["Joakim Nivre", "Mario Scholz."],
    "venue": "Proceedings of COLING-2004. Geneva, Switzerland, pages 64–",
    "year": 2004
  }, {
    "title": "On the difficulty of training recurrent neural networks",
    "authors": ["Razvan Pascanu", "Tomas Mikolov", "Yoshua Bengio."],
    "venue": "Proceedings of ICML-2013. pages 1310–1318.",
    "year": 2013
  }, {
    "title": "Cross-sentence n-ary relation extraction with graph lstms",
    "authors": ["Nanyun Peng", "Hoifung Poon", "Chris Quirk", "Kristina Toutanova", "Wen-tau Yih."],
    "venue": "Transactions of the Association for Computational Linguistics 5:101–115.",
    "year": 2017
  }, {
    "title": "A universal part-of-speech tagset",
    "authors": ["Slav Petrov", "Dipanjan Das", "Ryan McDonald."],
    "venue": "Proceedings of LREC-2012. Istanbul, Turkey, pages 2089–2096.",
    "year": 2012
  }, {
    "title": "A linear-time transition system for crossing interval trees",
    "authors": ["Emily Pitler", "Ryan McDonald."],
    "venue": "Proceedings of NAACL-2015. Denver, Colorado, pages 662–671.",
    "year": 2015
  }, {
    "title": "Dropout: A simple way to prevent neural networks from overfitting",
    "authors": ["Nitish Srivastava", "Geoffrey Hinton", "Alex Krizhevsky", "Ilya Sutskever", "Ruslan Salakhutdinov."],
    "venue": "The Journal of Machine Learning Research 15(1):1929–1958.",
    "year": 2014
  }, {
    "title": "The conll2008 shared task on joint parsing of syntactic and semantic dependencies",
    "authors": ["Mihai Surdeanu", "Richard Johansson", "Adam Meyers", "Lluı́s Màrquez", "Joakim Nivre"],
    "venue": "In Proceedings of CoNLL2008",
    "year": 2008
  }, {
    "title": "Sequence to sequence learning with neural networks",
    "authors": ["Ilya Sutskever", "Oriol Vinyals", "Quoc V Le."],
    "venue": "Advances in neural information processing systems. pages 3104–3112.",
    "year": 2014
  }, {
    "title": "Improved semantic representations from tree-structured long short-term memory networks",
    "authors": ["Kai Sheng Tai", "Richard Socher", "Christopher D. Manning."],
    "venue": "Proceedings ACL-2015 (Volume 1: Long Papers). Beijing, China, pages 1556–1566.",
    "year": 2015
  }, {
    "title": "Pointer networks",
    "authors": ["Oriol Vinyals", "Meire Fortunato", "Navdeep Jaitly."],
    "venue": "Advances in Neural Information Processing Systems. pages 2692–2700.",
    "year": 2015
  }, {
    "title": "Graph-based dependency parsing with bidirectional lstm",
    "authors": ["Wenhui Wang", "Baobao Chang."],
    "venue": "Proceedings of ACL-2016 (Volume 1: Long Papers). Berlin, Germany, pages 2306–2315.",
    "year": 2016
  }, {
    "title": "Structured training for neural network transition-based parsing",
    "authors": ["David Weiss", "Chris Alberti", "Michael Collins", "Slav Petrov."],
    "venue": "Proceedings of ACL-2015 (Volume 1: Long Papers). Beijing, China, pages 323–333.",
    "year": 2015
  }, {
    "title": "Building a large-scale annotated chinese corpus",
    "authors": ["Nianwen Xue", "Fu-Dong Chiou", "Martha Palmer."],
    "venue": "Proceedings of COLING-2002. pages 1–8.",
    "year": 2002
  }, {
    "title": "Statistical dependency analysis with support vector machines",
    "authors": ["Hiroyasu Yamada", "Yuji Matsumoto."],
    "venue": "Proceedings of IWPT . Nancy, France, volume 3, pages 195–206.",
    "year": 2003
  }, {
    "title": "Enforcing structural diversity in cube-pruned dependency parsing",
    "authors": ["Hao Zhang", "Ryan McDonald."],
    "venue": "Proceedings of ACL-2014 (Volume 2: Short Papers). Baltimore, Maryland, pages 656–661.",
    "year": 2014
  }, {
    "title": "Greed is good if randomized: New inference for dependency parsing",
    "authors": ["Yuan Zhang", "Tao Lei", "Regina Barzilay", "Tommi Jaakkola."],
    "venue": "Proceedings of EMNLP-2014. Doha, Qatar, pages 1013–1024.",
    "year": 2014
  }, {
    "title": "Transition-based dependency parsing with rich non-local features",
    "authors": ["Yue Zhang", "Joakim Nivre."],
    "venue": "Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies. Portland, Oregon, USA, pages",
    "year": 2011
  }],
  "id": "SP:c7dad5f12da359f16d8b031c2920db1cc37d1f64",
  "authors": [{
    "name": "Xuezhe Ma",
    "affiliations": []
  }, {
    "name": "Zecong Hu",
    "affiliations": []
  }, {
    "name": "Jingzhou Liu",
    "affiliations": []
  }, {
    "name": "Nanyun Peng",
    "affiliations": []
  }, {
    "name": "Graham Neubig",
    "affiliations": []
  }],
  "abstractText": "We introduce a novel architecture for dependency parsing: stack-pointer networks (STACKPTR). Combining pointer networks (Vinyals et al., 2015) with an internal stack, the proposed model first reads and encodes the whole sentence, then builds the dependency tree top-down (from root-to-leaf) in a depth-first fashion. The stack tracks the status of the depthfirst search and the pointer networks select one child for the word at the top of the stack at each step. The STACKPTR parser benefits from the information of the whole sentence and all previously derived subtree structures, and removes the leftto-right restriction in classical transitionbased parsers. Yet, the number of steps for building any (including non-projective) parse tree is linear in the length of the sentence just as other transition-based parsers, yielding an efficient decoding algorithm with O(n2) time complexity. We evaluate our model on 29 treebanks spanning 20 languages and different dependency annotation schemas, and achieve state-of-theart performance on 21 of them.",
  "title": "Stack-Pointer Networks for Dependency Parsing"
}