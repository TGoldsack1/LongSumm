{
  "sections": [{
    "text": "Proceedings of NAACL-HLT 2018, pages 355–364 New Orleans, Louisiana, June 1 - 6, 2018. c©2018 Association for Computational Linguistics"
  }, {
    "heading": "1 Introduction",
    "text": "Sequence to sequence models are usually trained with a simple token-level likelihood loss (Sutskever et al., 2014; Bahdanau et al., 2014). However, at test time, these models do not produce a single token but a whole sequence. In order to resolve this inconsistency and to potentially improve generation, recent work has focused on training these models at the sequence-level, for instance using REINFORCE (Ranzato et al., 2015), actor-critic (Bahdanau et al., 2016), or with beam search optimization (Wiseman and Rush, 2016).\nBefore the recent work on sequence level training for neural networks, there has been a large body of research on training linear models at the\n∗Equal contribution. 1An implementation of the losses is available as part of fairseq at https://github.com/ facebookresearch/fairseq-py/tree/ classic_seqlevel\nsequence level. For example, direct loss optimization has been popularized in machine translation with the Minimum Error Rate Training algorithm (MERT; Och 2003) and expected risk minimization has an extensive history in NLP (Smith and Eisner, 2006; Rosti et al., 2010; Green et al., 2014). This paper revisits several objective functions that have been commonly used for structured prediction tasks in NLP (Gimpel and Smith, 2010) and apply them to a neural sequence to sequence model (Gehring et al., 2017b) (§2). Specifically, we consider likelihood training at the sequencelevel, a margin loss as well as expected risk training. We also investigate several combinations of global losses with token-level likelihood. This is, to our knowledge, the most comprehensive comparison of structured losses in the context of neural sequence to sequence models (§3).\nWe experiment on the IWSLT’14 GermanEnglish translation task (Cettolo et al., 2014) as well as the Gigaword abstractive summarization task (Rush et al., 2015). We achieve the best reported accuracy to date on both tasks. We find that the sequence level losses we survey perform similarly to one another and outperform beam search optimization (Wiseman and Rush, 2016) on a comparable setup. On WMT’14 English-French, we also illustrate the effectiveness of risk minimization on a larger translation task. Classical losses for structured prediction are still very competitive and effective for neural models (§5, §6)."
  }, {
    "heading": "2 Sequence to Sequence Learning",
    "text": "The general architecture of our sequence to sequence models follows the encoder-decoder approach with soft attention first introduced in (Bahdanau et al., 2014). As a main difference, in most of our experiments we parameterize the encoder and the decoder as convolutional neural\n355\nnetworks instead of recurrent networks (Gehring et al., 2017a,b). Our use of convolution is motivated by computational and accuracy considerations. However, the objective functions we present are model agnostic and equally applicable to recurrent and convolutional models. We demonstrate the applicability of our objective functions to recurrent models (LSTM) in our comparison to Wiseman and Rush (2016) in §6.6. Notation. We denote the source sentence as x, an output sentence of our model as u, and the reference or target sentence as t. For some objectives, we choose a pseudo reference u∗ instead, such as a model output with the highest BLEU or ROUGE score among a set of candidate outputs, U , generated by our model.\nConcretely, the encoder processes a source sentence x = (x1, . . . , xm) containing m words and outputs a sequence of states z = (z1. . . . , zm). The decoder takes z and generates the output sequence u = (u1, . . . , un) left to right, one element at a time. For each output ui, the decoder computes hidden state hi based on the previous state hi−1, an embedding gi−1 of the previous target language word ui−1, as well as a conditional input ci derived from the encoder output z. The attention context ci is computed as a weighted sum of (z1, . . . , zm) at each time step. The weights of this sum are referred to as attention scores and allow the network to focus on the most relevant parts of the input at each generation step. Attention scores are computed by comparing each encoder state zj to a combination of the previous decoder state hi and the last prediction ui; the result is normalized to be a distribution over input elements. At each generation step, the model scores for the V possible next target words ui by transforming the decoder output hi via a linear layer with weights Wo and bias bo: si = Wohi + bo. This is turned into a distribution via a softmax: p(ui|u1, . . . , ui−1,x) = softmax(si).\nOur encoder and decoder use gated convolutional neural networks which enable fast and accurate generation (Gehring et al., 2017b). Fast generation is essential to efficiently train on the model output as is done in this work as sequence-level losses require generating at training time. Both encoder and decoder networks share a simple block structure that computes intermediate states based on a fixed number of input tokens and we stack several blocks on top of each other. Each block\ncontains a 1-D convolution that takes as input k feature vectors and outputs another vector; subsequent layers operate over the k output elements of the previous layer. The output of the convolution is then fed into a gated linear unit (Dauphin et al., 2017). In the decoder network, we rely on causal convolution which rely only on states from the previous time steps. The parameters θ of our model are all the weight matrices in the encoder and decoder networks. Further details can be found in Gehring et al. (2017b)."
  }, {
    "heading": "3 Objective Functions",
    "text": "We compare several objective functions for training the model architecture described in §2. The corresponding loss functions are either computed over individual tokens (§3.1), over entire sequences (§3.2) or over a combination of tokens and sequences (§3.3). An overview of these loss functions is given in Figure 1."
  }, {
    "heading": "3.1 Token-Level Objectives",
    "text": "Most prior work on sequence to sequence learning has focused on optimizing token-level loss functions, i.e., functions for which the loss is computed additively over individual tokens.\nToken Negative Log Likelihood (TokNLL) Token-level likelihood (TokNLL, Equation 1) minimizes the negative log likelihood of individual reference tokens t = (t1, . . . , tn). It is the most common loss function optimized in related work and serves as a baseline for our comparison.\nToken NLL with Label Smoothing (TokLS) Likelihood training forces the model to make extreme zero or one predictions to distinguish between the ground truth and alternatives. This may result in a model that is too confident in its training predictions, which may hurt its generalization performance. Label smoothing addresses this by acting as a regularizer that makes the model less confident in its predictions. Specifically, we smooth the target distribution with a prior distribution f that is independent of the current input x (Szegedy et al., 2015; Pereyra et al., 2017; Vaswani et al., 2017). We use a uniform prior distribution over all words in the vocabulary, f = 1V . One may also use a unigram distribution which has been shown to work better on some tasks (Pereyra et al., 2017). Label smoothing is equivalent to adding the KL divergence between f and the model prediction\np(u|x) to the negative log likelihood (TokLS, Equation 2). In practice, we implement label smoothing by modifying the ground truth distribution for word u to be q(u) = 1− and q(u′) = V for u′ 6= u instead of q(u) = 1 and q(u′) = 0 where is a smoothing parameter."
  }, {
    "heading": "3.2 Sequence-Level Objectives",
    "text": "We also consider a class of objective functions that are computed over entire sequences, i.e., sequence-level objectives. Training with these objectives requires generating and scoring multiple candidate output sequences for each input sequence during training, which is computationally expensive but allows us to directly optimize taskspecific metrics such as BLEU or ROUGE.\nUnfortunately, these objectives are also typically defined over the entire space of possible output sequences, which is intractable to enumerate or score with our models. Instead, we compute our sequence losses over a subset of the output space, U(x), generated by the model. We discuss approaches for generating this subset in §4.\nSequence Negative Log Likelihood (SeqNLL) Similar to TokNLL, we can minimize the negative log likelihood of an entire sequence rather than individual tokens (SeqNLL, Equation 3). The log-\nlikelihood of sequence u is the sum of individual token log probabilities, normalized by the number of tokens to avoid bias towards shorter sequences:\np(u|x) = exp 1 n\nn∑\ni=1\nlog p(ui|u1, . . . , ui−1,x)\nAs target we choose a pseudo reference2 amongst the candidates which maximizes either BLEU or ROUGE with respect to t, the gold reference:\nu∗(x) = arg max u∈U(x) BLEU(t,u)\nAs is common practice when computing BLEU at the sentence-level, we smooth all initial counts to one (except for unigram counts) so that the geometric mean is not dominated by zero-valued ngram match counts (Lin and Och, 2004).\nExpected Risk Minimization (Risk) This objective minimizes the expected value of a given cost function over the space of candidate sequences (Risk, Equation 4). In this work we use task-specific cost functions designed to maximize BLEU or ROUGE (Lin, 2004), e.g., cost(t,u) =\n2Another option is to use the gold reference target, t, but in practice this can lead to degenerate solutions in which the model assigns low probabilities to nearly all outputs. This is discussed further in §4.\n1−BLEU(t,u), for a given a candidate sequence u and target t. Different to SeqNLL (§3.2), this loss may increase the score of several candidates that have low cost, instead of focusing on a single sequence which may only be marginally better than any alternatives. Optimizing this loss is a particularly good strategy if the reference is not always reachable, although compared to classical phrase-based models, this is less of an issue with neural sequence to sequence models that predict individual words or even sub-word units.\nThe Risk objective is similar to the REINFORCE objective used in Ranzato et al. (2015), since both objectives optimize an expected cost or reward (Williams, 1992). However, there are a few important differences: (1) whereas REINFORCE typically approximates the expectation with a single sampled sequence, the Risk objective considers multiple sequences; (2) whereas REINFORCE relies on a baseline reward3 to determine the sign of the gradients for the current sequence, for the Risk objective we instead estimate the expected cost over a set of candidate output sequences (see §4); and (3) while the baseline reward is different for every word in REINFORCE, the expected cost is the same for every word in risk minimization since it is computed on the sequence level based on the actual cost.\nMax-Margin MaxMargin (Equation 5) is a classical margin loss for structured prediction (Taskar et al., 2003; Tsochantaridis et al., 2005) which enforces a margin between the model scores of the highest scoring candidate sequence û and a reference sequence. We replace the human reference t with a pseudo-reference u∗ since this setting performed slightly better in early experiments; u∗ is the candidate sequence with the highest BLEU score. The size of the margin varies between samples and is given by the difference between the cost of u∗ and the cost of û. In practice, we scale the margin by a hyper-parameter β determined on the validation set: β(cost(t, û)− cost(t,u∗)). For this loss we use the unnormalized scores computed by the model before the final softmax:\ns(u|x) = 1 n\nn∑\ni=1\ns(ui|u1, . . . , ui−1,x)\n3Ranzato et al. (2015) estimate the baseline reward for REINFORCE with a separate linear regressor over the model’s current hidden state.\nMulti-Margin MaxMargin only updates two elements in the candidate set. We therefore consider MultiMargin (Equation 6) which enforces a margin between every candidate sequence u and a reference sequence (Herbrich et al., 1999), hence the name Multi-Margin. Similar to MaxMargin, we replace the reference t with the pseudoreference u∗.\nSoftmax-Margin Finally, SoftmaxMargin (Equation 7) is another classic loss that has been proposed by Gimpel and Smith (2010) as another way to optimize task-specific costs. The loss augments the scores inside the exp of SeqNLL (Equation 3) by a cost. The intuition is that we want to penalize high cost outputs proportional to their cost."
  }, {
    "heading": "3.3 Combined Objectives",
    "text": "We also experiment with two variants of combining sequence-level objectives (§3.2) with tokenlevel objectives (§3.1). First, we consider a weighted combination (Weighted) of both a sequence-level and token-level objective (Wu et al., 2016), e.g., for TokLS and Risk we have:\nLWeighted = αLTokLS + (1− α)LRisk (8)\nwhere α is a scaling constant that is tuned on a held-out validation set.\nSecond, we consider a constrained combination (Constrained), where for any given input we use either the token-level or sequence-level loss, but not both. The motivation is to maintain good token-level accuracy while optimizing on the sequence-level. In particular, a sample is processed with the sequence loss if the token loss under the current model is at least as good as the token loss of a baseline model LbTokLS. Otherwise, we update according to the token loss:\nLConstrained = { LRisk LTokLS ≤ LbTokLS LTokLS otherwise\n(9) In this work we use a fixed baseline model that was trained with a token-level loss to convergence."
  }, {
    "heading": "4 Candidate Generation Strategies",
    "text": "The sequence-level objectives we consider (§3.2) are defined over the entire space of possible output sequences, which is intractable to enumerate or\nscore with our models. We therefore use a subset of K candidate sequences U(x) = {u1, . . . , uK}, which we generate with our models.\nWe consider two search strategies for generating the set of candidate sequences. The first is beam search, a greedy breadth-first search that maintains a “beam” of the top-K scoring candidates at each generation step. Beam search is the de facto decoding strategy for achieving state-ofthe-art results in machine translation. The second strategy is sampling (Chatterjee and Cancedda, 2010), which produces K independent output sequences by sampling from the model’s conditional distribution. Whereas beam search focuses on high probability candidates, sampling introduces more diverse candidates (see comparison in §6.5).\nWe also consider both online and offline candidate generation settings in §6.4. In the online setting, we regenerate the candidate set every time we encounter an input sentence x during training. In the offline setting, candidates are generated before training and are never regenerated. Offline generation is also embarrassingly parallel because all samples use the same model. The disadvantage is that the candidates become stale. Our model may perfectly be able to discriminate between them after only a single update, hindering the ability of the loss to correct eventual search errors.4\nFinally, while some past work has added the reference target to the candidate set, i.e., U ′(x) = U(x) ∪ {t}, we find this can destabilize training since the model learns to assign low probabilities nearly everywhere, ruining the candidates generated by the model, while still assigning a slightly higher score to the reference (cf. Shen et al. (2016)). Accordingly we do not add the reference translation to our candidate sets."
  }, {
    "heading": "5 Experimental Setup",
    "text": ""
  }, {
    "heading": "5.1 Translation",
    "text": "We experiment on the IWSLT’14 German to English (Cettolo et al., 2014) task using a similar setup as Ranzato et al. (2015), which allows us to compare to other recent studies that also adopted this setup, e.g., Wiseman and Rush (2016).5 The training data consists of 160K sentence pairs and the validation set comprises 7K sentences ran-\n4We can mitigate this issue by regenerating infrequently, i.e., once every b batches but we leave this to future work.\n5Different to Ranzato et al. (2015) we train on sentences of up to 175 rather than 50 tokens.\ndomly sampled and held-out from the train data. We test on the concatenation of tst2010, tst2011, tst2012, tst2013 and dev2010 which is of similar size to the validation set. All data is lowercased and tokenized with a byte-pair encoding (BPE) of 14,000 types (Sennrich et al., 2016) and we evaluate with case-insensitive BLEU.\nWe also experiment on the much larger WMT’14 English-French task. We remove sentences longer than 175 words as well as pairs with a source/target length ratio exceeding 1.5 resulting in 35.5M sentence-pairs for training. The source and target vocabulary is based on 40K BPE types. Results are reported on both newstest2014 and a validation set held-out from the training data comprising 26,658 sentence pairs.\nWe modify the fairseq-py toolkit to implement the objectives described in §3.6 Our translation models have four convolutional encoder layers and three convolutional decoder layers with a kernel width of 3 and 256 dimensional hidden states and word embeddings. We optimize these models using Nesterov’s accelerated gradient method (Sutskever et al., 2013) with a learning rate of 0.25 and momentum of 0.99. Gradient vectors are renormalized to norm 0.1 (Pascanu et al., 2013).\nWe train our baseline token-level models for 200 epochs and then anneal the learning by shrinking it by a factor of 10 after each subsequent epoch until the learning rate falls below 10−4. All sequence-level models are initialized with parameters of a token-level model before annealing. We then train sequence-level models for another 10 to 20 epochs depending on the objective. Our batches contain 8K tokens and we normalize gradients by the number of non-padding tokens per mini-batch. We use weight normalization for all layers except for lookup tables (Salimans and Kingma, 2016). Besides dropout on the embeddings and the decoder output, we also apply dropout to the input of the convolutional blocks at a rate of 0.3 (Srivastava et al., 2014). We tuned the various parameters above and report accuracy on the test set by choosing the best configuration based on the validation set.\nWe length normalize all scores and probabilities in the sequence-level losses by dividing by the number of tokens in the sequence so that scores are comparable between different lengths. Ad-\n6https://github.com/facebookresearch/ fairseq-py.\nditionally, when generating candidate output sequences during training we limit the output sequence length to be less than 200 tokens for efficiency. We generally use 16 candidate sequences per training example, except for the ablations where we use 5 for faster experimental turnaround."
  }, {
    "heading": "5.2 Abstractive Summarization",
    "text": "For summarization we use the Gigaword corpus as training data (Graff et al., 2003) and pre-process it identically to Rush et al. (2015) resulting in 3.8M training and 190K validation examples. We evaluate on a Gigaword test set of 2,000 pairs identical to the one used by Rush et al. (2015) and report F1 ROUGE similar to prior work. Our results are in terms of three variants of ROUGE (Lin, 2004), namely, ROUGE-1 (RG-1, unigrams), ROUGE-2 (RG-2, bigrams), and ROUGE-L (RG-L, longestcommon substring). Similar to Ayana et al. (2016) we use a source and target vocabulary of 30k words. Our models for this task have 12 layers in the encoder and decoder each with 256 hidden units and kernel width 3. We train on batches of 8,000 tokens with a learning rate of 0.25 for 20 epochs and then anneal as in §5.1."
  }, {
    "heading": "6 Results",
    "text": ""
  }, {
    "heading": "6.1 Comparison of Sequence Level Losses",
    "text": "First, we compare all objectives based on a weighted combination with token-level label smoothing (Equation 8). We also show the likelihood baseline (MLE) of Wiseman and Rush (2016), their beam search optimization method (BSO), the actor critic result of Bahdanau et al. (2016) as well as the best reported result on this dataset to date by Huang et al. (2017). We show a like-for-like comparison to Wiseman and Rush (2016) with a similar baseline model below (§6.6).\nTable 1 shows that all sequence-level losses outperform token-level losses. Our baseline tokenlevel results are several points above other figures in the literature and we further improve these results by up to 0.61 BLEU with Risk training."
  }, {
    "heading": "6.2 Combination with Token-Level Loss",
    "text": "Next, we compare various strategies to combine sequence-level and token-level objectives (cf. §3.3). For these experiments we use 5 candidate sequences per training example for faster experimental turnaround. We consider Risk as\nsequence-level loss and label smoothing as tokenlevel loss. Table 2 shows that combined objectives perform better than pure Risk. The weighted combination (Equation 8) with α = 0.3 performs best, outperforming constrained combination (Equation 9). We also compare to randomly choosing between token-level and sequence-level updates and find it underperforms the more principled constrained strategy. In the remaining experiments we use the weighted strategy."
  }, {
    "heading": "6.3 Effect of initialization",
    "text": "So far we initialized sequence-level models with parameters from a token-level model trained with label smoothing. Table 3 shows that initializing weighted Risk with token-level label smoothing\nachieves 0.7-0.8 better BLEU compared to initializing with parameters from token-level likelihood. The improvement of initializing with TokNLL is only 0.3 BLEU with respect to the TokNLL baseline, whereas, the improvement from initializing with TokLS is 0.6-0.8 BLEU. We believe that the regularization provided by label smoothing leads to models with less sharp distributions that are a better starting point for sequence-level training."
  }, {
    "heading": "6.4 Online vs. Offline Candidate Generation",
    "text": "Next, we consider the question if refreshing the candidate subset at every training step (online) results in better accuracy compared to generating candidates before training and keeping the set static throughout training (offline). Table 4 shows that offline generation gives lower accuracy. However the online setting is much slower, since regenerating the candidate set requires incremental (left to right) inference with our model which is very slow compared to efficient forward/backward over large batches of pre-generated hypothesis. In our setting, offline generation has 26 times higher throughput than the online generation setting, despite the high inference speed of fairseq (Gehring et al., 2017b)."
  }, {
    "heading": "6.5 Beam Search vs. Sampling and Candidate Set Size",
    "text": "So far we generated candidates with beam search, however, we may also sample to obtain a more diverse set of candidates (Shen et al., 2016). Fig-\nure 2 compares beam search and sampling for various candidate set sizes on the validation set. Beam search performs better for all candidate set sizes considered. In other experiments, we rely on a candidate set size of 16 which strikes a good balance between efficiency and accuracy."
  }, {
    "heading": "6.6 Comparison to Beam-Search Optimization",
    "text": "Next, we compare classical sequence-level training to the recently proposed Beam Search Optimization (Wiseman and Rush, 2016). To enable a fair comparison, we re-implement their baseline, a single layer LSTM encoder/decoder model with 256-dimensional hidden layers and word embeddings as well as attention and input feeding (Luong et al., 2015). This baseline is trained with Adagrad (Duchi et al., 2011) using a learning rate of 0.05 for five epochs, with batches of 64 sequences. For sequence-level training we initialize weights with the baseline parameters and train\nwith Adam (Kingma and Ba, 2014) for another 10 epochs with learning rate 0.00003 and 16 candidate sequences per training example. We conduct experiments with Risk since it performed best in trial experiments.\nDifferent from other sequence-level experiments (§5), we rescale the BLEU scores in each candidate set by the difference between the maximum and minimum scores of each sentence. This avoids short sentences dominating the sequence updates, since candidate sets for short sentences have a wider range of BLEU scores compared to longer sentences; a similar rescaling was used by Bahdanau et al. (2016).\nTable 5 shows the results from Wiseman and Rush (2016) for their token-level likelihood baseline (MLE), best beam search optimization results (BSO), as well as our reimplemented baseline. Risk significantly improves BLEU compared to our baseline at +2.75 BLEU, which is slightly better than the +2.33 BLEU improvement reported for Beam Search Optimization (cf. Wiseman and Rush (2016)). This shows that classical objectives for structured prediction are still very competitive."
  }, {
    "heading": "6.7 WMT’14 English-French results",
    "text": "Next, we experiment on the much larger WMT’14 English-French task using the same model setup as Gehring et al. (2017b). We TokLSfor 15 epochs\nand then switch to sequence-level training for another epoch. Table 7 shows that sequence-level training can improve an already very strong model by another +0.37 BLEU. Next, we improve the baseline by adding self-attention (Paulus et al., 2017; Vaswani et al., 2017) to the decoder network (TokLS + selfatt) which results in a smaller gain of +0.2 BLEU by Risk. If we train Risk only on the news-commentary portion of the training data, then we achieve state of the art accuracy on this dataset of 41.5 BLEU (Xia et al., 2017)."
  }, {
    "heading": "6.8 Abstractive Summarization",
    "text": "Our final experiment evaluates sequence-level training on Gigaword headline summarization. There has been much prior art on this dataset originally introduced by Rush et al. (2015) who experiment with a feed-forward network (ABS+). Ayana et al. (2016) report a likelihood baseline (RNN MLE) and also experiment with risk training (RNN MRT). Different to their setup we did not find a softmax temperature to be beneficial, and we use beam search instead of sampling to obtain the candidate set (cf. §6.5). Suzuki and Nagata (2017) improve over an MLE RNN baseline by limiting generation of repeated phrases. Zhou et al. (2017) also consider an MLE RNN baseline and add an additional gating mechanism for the encoder. Li et al. (2017) equip the decoder of a similar network with additional latent variables to accommodate the uncertainty of this task.\nTable 6 shows that our baseline (TokLS) outperforms all prior approaches in terms of ROUGE2 and ROUGE-L and it is on par to the best previous result for ROUGE-1. We optimize all three ROUGE metrics separately and find that Risk can further improve our strong baseline. We also compared Risk only training to Weighted on this dataset (cf. §6.2) but accuracy was generally lower on the validation set: RG-1\n(36.59 Risk only vs. 36.67 Weighted), RG-2 (17.34 vs. 18.05), and RG-L (33.66 vs. 33.98)."
  }, {
    "heading": "7 Conclusion",
    "text": "We present a comprehensive comparison of classical losses for structured prediction and apply them to a strong neural sequence to sequence model. We found that combining sequence-level and tokenlevel losses is necessary to perform best, and so is training on candidates decoded with the current model.\nWe show that sequence-level training improves state-of-the-art baselines both for IWSLT’14 German-English translation and Gigaword abstractive sentence summarization. Structured prediction losses are very competitive to recent work on reinforcement or beam optimization. Classical expected risk can slightly outperform beam search optimization (Wiseman and Rush, 2016) in a likefor-like setup. Future work may investigate better use of already generated candidates since invoking generation for each batch slows down training by a large factor, e.g., mixing with fresh and older candidates inspired by MERT (Och, 2003)."
  }],
  "year": 2018,
  "references": [{
    "title": "Neural headline generation with sentence-wise optimization",
    "authors": ["Ayana", "Shiqi Shen", "Yu Zhao", "Zhiyuan Liu", "Maosong Sun"],
    "year": 2016
  }, {
    "title": "An ActorCritic Algorithm for Sequence Prediction",
    "authors": ["Dzmitry Bahdanau", "Philemon Brakel", "Kelvin Xu", "Anirudh Goyal", "Ryan Lowe", "Joelle Pineau", "Aaron Courville", "Yoshua Bengio."],
    "venue": "arXiv preprint arXiv:1607.07086.",
    "year": 2016
  }, {
    "title": "Neural machine translation by jointly learning to align and translate",
    "authors": ["Dzmitry Bahdanau", "Kyunghyun Cho", "Yoshua Bengio."],
    "venue": "arXiv preprint arXiv:1409.0473 .",
    "year": 2014
  }, {
    "title": "Report on the 11th IWSLT evaluation campaign",
    "authors": ["Mauro Cettolo", "Jan Niehues", "Sebastian Stüker", "Luisa Bentivogli", "Marcello Federico."],
    "venue": "Proc. of IWSLT .",
    "year": 2014
  }, {
    "title": "Minimum error rate training by sampling the translation lattice",
    "authors": ["Samidh Chatterjee", "Nicola Cancedda"],
    "year": 2010
  }, {
    "title": "Language Modeling with Gated Convolutional Networks",
    "authors": ["Yann N. Dauphin", "Angela Fan", "Michael Auli", "David Grangier."],
    "venue": "Proc. of ICML.",
    "year": 2017
  }, {
    "title": "Adaptive subgradient methods for online learning",
    "authors": ["John Duchi", "Elad Hazan", "Yoram Singer"],
    "year": 2011
  }, {
    "title": "A Convolutional Encoder Model for Neural Machine Translation",
    "authors": ["Jonas Gehring", "Michael Auli", "David Grangier", "Yann N Dauphin."],
    "venue": "Proc. of ACL.",
    "year": 2017
  }, {
    "title": "Convolutional Sequence to Sequence Learning",
    "authors": ["Jonas Gehring", "Michael Auli", "David Grangier", "Denis Yarats", "Yann N. Dauphin."],
    "venue": "Proc. of ICML.",
    "year": 2017
  }, {
    "title": "Softmax-margin crfs: Training log-linear models with cost functions",
    "authors": ["Kevin Gimpel", "Noah Smith."],
    "venue": "Proc. of ACL.",
    "year": 2010
  }, {
    "title": "English gigaword",
    "authors": ["David Graff", "Junbo Kong", "Ke Chen", "Kazuaki Maeda."],
    "venue": "Linguistic Data Consortium, Philadelphia .",
    "year": 2003
  }, {
    "title": "An Empirical Comparison of Features and Tuning for Phrase-based Machine Translation",
    "authors": ["Spence Green", "Daniel Cer", "Christopher Manning."],
    "venue": "Proc. of WMT . Association for Computational Linguistics.",
    "year": 2014
  }, {
    "title": "Support vector learning for ordinal regression",
    "authors": ["Ralf Herbrich", "Thore Graepel", "Klaus Obermayer"],
    "year": 1999
  }, {
    "title": "Neural Phrase-based Machine Translation",
    "authors": ["Po-Sen Huang", "Chong Wang", "Dengyong Zhou", "Li Deng."],
    "venue": "arXiv preprint arXiv:1706.05565.",
    "year": 2017
  }, {
    "title": "Adam: A Method for Stochastic Optimization",
    "authors": ["Diederik P. Kingma", "Jimmy Ba."],
    "venue": "Proc. of ICLR .",
    "year": 2014
  }, {
    "title": "Deep recurrent generative decoder for abstractive text summarization",
    "authors": ["Piji Li", "Wai Lam", "Lidong Bing", "Zihao Wang."],
    "venue": "arXiv .",
    "year": 2017
  }, {
    "title": "Rouge: A package for automatic evaluation of summaries",
    "authors": ["Chin-Yew Lin."],
    "venue": "Text Summarization Branches Out: Proceedings of the ACL-04 Workshop.",
    "year": 2004
  }, {
    "title": "Orange: a method for evaluating automatic evaluation metrics for machine translation",
    "authors": ["Chin-Yew Lin", "Franz Josef Och."],
    "venue": "Proc. of COLING.",
    "year": 2004
  }, {
    "title": "Effective approaches to attentionbased neural machine translation",
    "authors": ["Minh-Thang Luong", "Hieu Pham", "Christopher D Manning."],
    "venue": "Proc. of EMNLP.",
    "year": 2015
  }, {
    "title": "Minimum Error Rate Training in Statistical Machine Translation",
    "authors": ["Franz Josef Och."],
    "venue": "Sapporo, Japan, pages 160–167.",
    "year": 2003
  }, {
    "title": "On the difficulty of training recurrent neural networks",
    "authors": ["Razvan Pascanu", "Tomas Mikolov", "Yoshua Bengio."],
    "venue": "Proceedings of The 30th International Conference on Machine Learning. pages 1310–1318.",
    "year": 2013
  }, {
    "title": "A deep reinforced model for abstractive summarization",
    "authors": ["Romain Paulus", "Caiming Xiong", "Richard Socher."],
    "venue": "arXiv preprint arXiv:1705.04304 .",
    "year": 2017
  }, {
    "title": "Regularizing neural networks by penalizing confident output distributions",
    "authors": ["Gabriel Pereyra", "George Tucker", "Jan Chorowski", "Lukasz Kaiser", "Geoffrey E. Hinton."],
    "venue": "Proc. of ICLR Workshop.",
    "year": 2017
  }, {
    "title": "Sequence level Training with Recurrent Neural Networks",
    "authors": ["Marc’Aurelio Ranzato", "Sumit Chopra", "Michael Auli", "Wojciech Zaremba"],
    "venue": "In Proc. of ICLR",
    "year": 2015
  }, {
    "title": "BBN System Description for WMT10 System Combination Task",
    "authors": ["Antti-Veikko I Rosti", "Bing Zhang", "Spyros Matsoukas", "Richard Schwartz."],
    "venue": "Proc. of WMT . Association for Computational Linguistics, pages 321–326.",
    "year": 2010
  }, {
    "title": "A neural attention model for abstractive sentence summarization",
    "authors": ["Alexander M Rush", "Sumit Chopra", "Jason Weston."],
    "venue": "Proc. of EMNLP.",
    "year": 2015
  }, {
    "title": "Weight normalization: A simple reparameterization to accelerate training of deep neural networks",
    "authors": ["Tim Salimans", "Diederik P Kingma."],
    "venue": "arXiv preprint arXiv:1602.07868 .",
    "year": 2016
  }, {
    "title": "Neural Machine Translation of Rare Words with Subword Units",
    "authors": ["Rico Sennrich", "Barry Haddow", "Alexandra Birch."],
    "venue": "Proc. of ACL.",
    "year": 2016
  }, {
    "title": "Minimum Risk Training for Neural Machine Translation",
    "authors": ["Shiqi Shen", "Yong Cheng", "Zhongjun He", "Wei He", "Hua Wu", "Maosong Sun", "Yang Liu."],
    "venue": "Proc. of ACL.",
    "year": 2016
  }, {
    "title": "Minimum Risk Annealing for Training Log-Linear Models",
    "authors": ["David A. Smith", "Jason Eisner."],
    "venue": "Proc. of ACL.",
    "year": 2006
  }, {
    "title": "Dropout: a simple way to prevent Neural Networks from overfitting",
    "authors": ["Nitish Srivastava", "Geoffrey E. Hinton", "Alex Krizhevsky", "Ilya Sutskever", "Ruslan Salakhutdinov."],
    "venue": "JMLR 15:1929–1958.",
    "year": 2014
  }, {
    "title": "On the importance of initialization and momentum in deep learning",
    "authors": ["Ilya Sutskever", "James Martens", "George E. Dahl", "Geoffrey E. Hinton."],
    "venue": "ICML.",
    "year": 2013
  }, {
    "title": "Sequence to Sequence Learning with Neural Networks",
    "authors": ["Ilya Sutskever", "Oriol Vinyals", "Quoc V Le."],
    "venue": "Proc. of NIPS. pages 3104–3112.",
    "year": 2014
  }, {
    "title": "Cutting-off redundant repeating generations for neural abstractive summarization",
    "authors": ["Jun Suzuki", "Masaaki Nagata."],
    "venue": "arXiv preprint arXiv:1701.00138 .",
    "year": 2017
  }, {
    "title": "Rethinking the inception architecture for computer vision",
    "authors": ["Christian Szegedy", "Vincent Vanhoucke", "Sergey Ioffe", "Jonathon Shlens", "Zbigniew Wojna."],
    "venue": "arXiv .",
    "year": 2015
  }, {
    "title": "Max-margin markov networks",
    "authors": ["Ben Taskar", "Carlos Guestrin", "Daphne Koller."],
    "venue": "NIPS.",
    "year": 2003
  }, {
    "title": "Large margin methods for structured and interdependent output variables",
    "authors": ["Ioannis Tsochantaridis", "Thorsten Joachims", "Thomas Hofmann", "Yasemin Altun."],
    "venue": "Journal of Machine Learning Research 6:1453—-1484.",
    "year": 2005
  }, {
    "title": "Attention is all you need",
    "authors": ["Ashish Vaswani", "Noam Shazeer", "Niki Parmar", "Jakob Uszkoreit", "Llion Jones", "Aidan N. Gomez", "Lukasz Kaiser", "Illia Polosukhin."],
    "venue": "arXiv .",
    "year": 2017
  }, {
    "title": "Simple statistical gradientfollowing algorithms for connectionist reinforcement learning",
    "authors": ["R.J. Williams."],
    "venue": "Machine Learning 8:229—-256.",
    "year": 1992
  }, {
    "title": "Sequence-to-sequence learning as beam-search optimization",
    "authors": ["Sam Wiseman", "Alexander M. Rush."],
    "venue": "Proc. of ACL.",
    "year": 2016
  }, {
    "title": "Deliberation networks: Sequence generation beyond one-pass decoding",
    "authors": ["Yingce Xia", "Fei Tian", "Lijun Wu", "Jianxin Lin", "Tao Qin", "Nenghai Yu", "Tie-Yan Liu."],
    "venue": "Proc. of NIPS.",
    "year": 2017
  }, {
    "title": "Selective encoding for abstractive sentence summarization",
    "authors": ["Qingyu Zhou", "Nan Yang", "Furu Wei", "Ming Zhou."],
    "venue": "arXiv .",
    "year": 2017
  }],
  "id": "SP:c2c6e50c4dfbe2d4ae69e95aa866aa37bf00aeac",
  "authors": [{
    "name": "Sergey Edunov",
    "affiliations": []
  }, {
    "name": "Myle Ott",
    "affiliations": []
  }, {
    "name": "Michael Auli",
    "affiliations": []
  }, {
    "name": "David Grangier",
    "affiliations": []
  }, {
    "name": "Marc’Aurelio Ranzato",
    "affiliations": []
  }],
  "abstractText": "There has been much recent work on training neural attention models at the sequencelevel using either reinforcement learning-style methods or by optimizing the beam. In this paper, we survey a range of classical objective functions that have been widely used to train linear models for structured prediction and apply them to neural sequence to sequence models. Our experiments show that these losses can perform surprisingly well by slightly outperforming beam search optimization in a like for like setup. We also report new state of the art results on both IWSLT’14 German-English translation as well as Gigaword abstractive summarization. On the large WMT’14 English-French task, sequence-level training achieves 41.5 BLEU which is on par with the state of the art.1",
  "title": "Classical Structured Prediction Losses for Sequence to Sequence Learning"
}