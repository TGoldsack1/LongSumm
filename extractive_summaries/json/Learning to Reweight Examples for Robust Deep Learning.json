{
  "sections": [{
    "heading": "1. Introduction",
    "text": "Deep neural networks (DNNs) have been widely used for machine learning applications due to their powerful capacity for modeling complex input patterns. Despite their success, it has been shown that DNNs are prone to training set biases, i.e. the training set is drawn from a joint distribution p(x, y) that is different from the distribution p(xv, yv) of the evaluation set. This distribution mismatch could have many\n1Uber Advanced Technologies Group, Toronto ON, CANADA 2Department of Computer Science, University of Toronto, Toronto ON, CANADA. Correspondence to: Mengye Ren <mren3@uber.com>.\nProceedings of the 35 th International Conference on Machine Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018 by the author(s).\ndifferent forms. Class imbalance in the training set is a very common example. In applications such as object detection in the context of autonomous driving, the vast majority of the training data is composed of standard vehicles but models also need to recognize rarely seen classes such as emergency vehicles or animals with very high accuracy. This will sometime lead to biased training models that do not perform well in practice.\nAnother popular type of training set bias is label noise. To train a reasonable supervised deep model, we ideally need a large dataset with high-quality labels, which require many passes of expensive human quality assurance (QA). Although coarse labels are cheap and of high availability, the presence of noise will hurt the model performance, e.g. Zhang et al. (2017) has shown that a standard CNN can fit any ratio of label flipping noise in the training set and eventually leads to poor generalization performance.\nTraining set biases and misspecification can sometimes be addressed with dataset resampling (Chawla et al., 2002), i.e. choosing the correct proportion of labels to train a network on, or more generally by assigning a weight to each example and minimizing a weighted training loss. The example weights are typically calculated based on the training loss, as in many classical algorithms such as AdaBoost (Freund & Schapire, 1997), hard negative mining (Malisiewicz et al., 2011), self-paced learning (Kumar et al., 2010), and other more recent work (Chang et al., 2017; Jiang et al., 2017).\nHowever, there exist two contradicting ideas in training loss based approaches. In noisy label problems, we prefer examples with smaller training losses as they are more likely to be clean images; yet in class imbalance problems, algorithms such as hard negative mining (Malisiewicz et al., 2011) prioritize examples with higher training loss since they are more likely to be the minority class. In cases when the training set is both imbalanced and noisy, these existing methods would have the wrong model assumptions. In fact, without a proper definition of an unbiased test set, solving the training set bias problem is inherently ill-defined. As the model cannot distinguish the right from the wrong, stronger regularization can usually work surprisingly well in certain synthetic noise settings. Here we argue that in order to learn general forms of training set biases, it is necessary to have a small unbiased validation to guide training. It is actually\nnot uncommon to construct a dataset with two parts - one relatively small but very accurately labeled, and another massive but coarsely labeled. Coarse labels can come from inexpensive crowdsourcing services or weakly supervised data (Cordts et al., 2016; Russakovsky et al., 2015; Chen & Gupta, 2015).\nDifferent from existing training loss based approaches, we follow a meta-learning paradigm and model the most basic assumption instead: the best example weighting should minimize the loss of a set of unbiased clean validation examples that are consistent with the evaluation procedure. Traditionally, validation is performed at the end of training, which can be prohibitively expensive if we treat the example weights as some hyperparameters to optimize; to circumvent this, we perform validation at every training iteration to dynamically determine the example weights of the current batch. Towards this goal, we propose an online reweighting method that leverages an additional small validation set and adaptively assigns importance weights to examples in every iteration. We experiment with both class imbalance and corrupted label problems and find that our approach significantly increases the robustness to training set biases."
  }, {
    "heading": "2. Related Work",
    "text": "The idea of weighting each training example has been well studied in the literature. Importance sampling (Kahn & Marshall, 1953), a classical method in statistics, assigns weights to samples in order to match one distribution to another. Boosting algorithms such as AdaBoost (Freund & Schapire, 1997), select harder examples to train subsequent classifiers. Similarly, hard example mining (Malisiewicz et al., 2011), downsamples the majority class and exploits the most difficult examples. Focal loss (Lin et al., 2017) adds a soft weighting scheme that emphasizes harder examples.\nHard examples are not always preferred in the presence of outliers and noise processes. Robust loss estimators typically downweigh examples with high loss. In selfpaced learning (Kumar et al., 2010), example weights are obtained through optimizing the weighted training loss encouraging learning easier examples first. In each step, the learning algorithm jointly solves a mixed integer program that iterates optimizing over model parameters and binary example weights. Various regularization terms on the example weights have since been proposed to prevent overfitting and trivial solutions of assigning weights to be all zeros (Kumar et al., 2010; Ma et al., 2017; Jiang et al., 2015). Wang et al. (2017) proposed a Bayesian method that infers the example weights as latent variables. More recently, Jiang et al. (2017) proposed to use a meta-learning LSTM to output the weights of the examples based on the training loss. Reweighting examples is also related to curriculum learning (Bengio et al., 2009), where the model reweights\namong many available tasks. Similar to self-paced learning, typically it is beneficial to start with easier examples.\nOne crucial advantage of reweighting examples is robustness against training set bias. There has also been a multitude of prior studies on class imbalance problems, including using dataset resampling (Chawla et al., 2002; Dong et al., 2017), cost-sensitive weighting (Ting, 2000; Khan et al., 2015), and structured margin based objectives (Huang et al., 2016). Meanwhile, the noisy label problem has been thoroughly studied by the learning theory community (Natarajan et al., 2013; Angluin & Laird, 1988) and practical methods have also been proposed (Reed et al., 2014; Sukhbaatar & Fergus, 2014; Xiao et al., 2015; Azadi et al., 2016; Goldberger & Ben-Reuven, 2017; Li et al., 2017; Jiang et al., 2017; Vahdat, 2017; Hendrycks et al., 2018). In addition to corrupted data, Koh & Liang (2017); Muñoz-González et al. (2017) demonstrate the possibility of a dataset adversarial attack (i.e. dataset poisoning).\nOur method improves the training objective through a weighted loss rather than an average loss and is an instantiation of meta-learning (Thrun & Pratt, 1998; Lake et al., 2017; Andrychowicz et al., 2016), i.e. learning to learn better. Using validation loss as the meta-objective has been explored in recent meta-learning literature for few-shot learning (Ravi & Larochelle, 2017; Ren et al., 2018; Lorraine & Duvenaud, 2018), where only a handful of examples are available for each class. Our algorithm also resembles MAML (Finn et al., 2017) by taking one gradient descent step on the meta-objective for each iteration. However, different from these meta-learning approaches, our reweighting method does not have any additional hyperparameters and circumvents an expensive offline training stage. Hence, our method can work in an online fashion during regular training."
  }, {
    "heading": "3. Learning to Reweight Examples",
    "text": "In this section, we derive our model from a meta-learning objective towards an online approximation that can fit into any regular supervised training. We give a practical implementation suitable for any deep network type and provide theoretical guarantees under mild conditions that our algorithm has a convergence rate of O(1/ 2). Note that this is the same as that of stochastic gradient descent (SGD)."
  }, {
    "heading": "3.1. From a meta-learning objective to an online approximation",
    "text": "Let (x, y) be an input-target pair, and {(xi, yi), 1 ≤ i ≤ N} be the training set. We assume that there is a small unbiased and clean validation set {(xvi , yvi ), 1 ≤ i ≤M}, and M N . Hereafter, we will use superscript v to denote validation set and subscript i to denote the ith data. We also assume\nthat the training set contains the validation set; otherwise, we can always add this small validation set into the training set and leverage more information during training.\nLet Φ(x, θ) be our neural network model, and θ be the model parameters. We consider a loss function C(ŷ, y) to minimize during training, where ŷ = Φ(x, θ).\nIn standard training, we aim to minimize the expected loss for the training set: 1N ∑N i=1 C(ŷi, yi) = 1 N ∑N i=1 fi(θ), where each input example is weighted equally, and fi(θ) stands for the loss function associating with data xi. Here we aim to learn a reweighting of the inputs, where we minimize a weighted loss:\nθ∗(w) = arg min θ N∑ i=1 wifi(θ), (1)\nwith wi unknown upon beginning. Note that {wi}Ni=1 can be understood as training hyperparameters, and the optimal selection of w is based on its validation performance:\nw∗ = arg min w,w≥0\n1\nM M∑ i=1 fvi (θ ∗(w)). (2)\nIt is necessary that wi ≥ 0 for all i, since minimizing the negative training loss can usually result in unstable behavior.\nOnline approximation Calculating the optimal wi requires two nested loops of optimization, and every single loop can be very expensive. The motivation of our approach is to adapt online w through a single optimization loop. For each training iteration, we inspect the descent direction of some training examples locally on the training loss surface and reweight them according to their similarity to the descent direction of the validation loss surface.\nFor most training of deep neural networks, SGD or its variants are used to optimize such loss functions. At every step t of training, a mini-batch of training examples {(xi, yi), 1 ≤ i ≤ n} is sampled, where n is the mini-batch size, n N . Then the parameters are adjusted according to the descent direction of the expected loss on the mini-batch. Let’s consider vanilla SGD:\nθt+1 = θt − α∇\n( 1\nn n∑ i=1 fi(θt)\n) , (3)\nwhere α is the step size.\nWe want to understand what would be the impact of training example i towards the performance of the validation set at training step t. Following a similar analysis to Koh & Liang (2017), we consider perturbing the weighting by i for each\ntraining example in the mini- batch,\nfi, (θ) = ifi(θ), (4)\nθ̂t+1( ) = θt − α∇ n∑ i=1 fi, (θ) ∣∣∣ θ=θt . (5)\nWe can then look for the optimal ∗ that minimizes the validation loss fv locally at step t:\n∗t = arg min\n1\nM M∑ i=1 fvi (θt+1( )). (6)\nUnfortunately, this can still be quite time-consuming. To get a cheap estimate of wi at step t, we take a single gradient descent step on a mini-batch of validation samples wrt. t, and then rectify the output to get a non-negative weighting:\nui,t = −η ∂\n∂ i,t\n1\nm m∑ j=1 fvj (θt+1( )) ∣∣∣ i,t=0 , (7)\nw̃i,t = max(ui,t, 0). (8)\nwhere η is the descent step size on .\nTo match the original training step size, in practice, we can consider normalizing the weights of all examples in a training batch so that they sum up to one. In other words, we choose to have a hard constraint within the set {w : ‖w‖1 = 1} ∪ {0}.\nwi,t = w̃i,t ( ∑ j w̃j,t) + δ( ∑ j w̃j,t) , (9)\nwhere δ(·) is to prevent the degenerate case when all wi’s in a mini-batch are zeros, i.e. δ(a) = 1 if a = 0, and equals to 0 otherwise. Without the batch-normalization step, it is possible that the algorithm modifies its effective learning rate of the training progress, and our one-step look ahead may be too conservative in terms of the choice of learning rate (Wu et al., 2018). Moreover, with batch normalization, we effectively cancel the meta learning rate parameter η."
  }, {
    "heading": "3.2. Example: learning to reweight examples in a multi-layer perceptron network",
    "text": "In this section, we study how to compute wi,t in a multilayer perceptron (MLP) network. One of the core steps is to compute the gradients of the validation loss wrt. the local perturbation , We can consider a multi-layered network where we have parameters for each layer θ = {θl}Ll=1, and at every layer, we first compute zl the pre-activation, a weighted sum of inputs to the layer, and afterwards we apply a non-linear activation function σ to obtain z̃l the post-activation:\nzl = θ > l z̃l−1, (10)\nz̃l = σ(zl). (11)\nDuring backpropagation, let gl be the gradients of loss wrt. zl, and the gradients wrt. θl is given by z̃l−1g>l . We can further express the gradients towards as a sum of local dot products.\n∂ ∂ i,t E [ fv(θt+1( )) ∣∣∣ i,t=0 ] ∝− 1\nm m∑ j=1 ∂fvj (θ) ∂θ ∣∣∣> θ=θt ∂fi(θ) ∂θ ∣∣∣ θ=θt\n=− 1 m m∑ j=1 L∑ l=1 (z̃vj,l−1 >z̃i,l−1)(g v j,l >gi,l).\n(12)\nDetailed derivations can be found in Supplementary Materials. Eq. 12 suggests that the meta-gradient on is composed of the sum of the products of two terms: z>zv and g>gv. The first dot product computes the similarity between the training and validation inputs to the layer, while the second computes the similarity between the training and validation gradient directions. In other words, suppose that a pair of training and validation examples are very similar, and they also provide similar gradient directions, then this training example is helpful and should be up-weighted, and conversely, if they provide opposite gradient directions, this training example is harmful and should be downweighed."
  }, {
    "heading": "3.3. Implementation using automatic differentiation",
    "text": "In an MLP and a CNN, the unnormalized weights can be calculated based on the sum of the correlations of layerwise activation gradients and input activations. In more general networks, we can leverage automatic differentiation techniques to compute the gradient of the validation loss wrt. the example weights of the current batch. As shown in Figure 1, to get the gradients of the example weights, one needs to first unroll the gradient graph of the training batch, and then use backward-on-backward automatic differentiation to take a second order gradient\npass (see Step 5 in Figure 1). We list detailed step-bystep pseudo-code in Algorithm 1. This implementation can be generalized to any deep learning architectures and can be very easily implemented using popular deep learning frameworks such as TensorFlow (Abadi et al., 2016).\nAlgorithm 1 Learning to Reweight Examples using Automatic Differentiation Require: θ0, Df , Dg , n, m Ensure: θT\n1: for t = 0 ... T − 1 do 2: {Xf , yf} ← SampleMiniBatch(Df , n) 3: {Xg, yg} ← SampleMiniBatch(Dg , m) 4: ŷf ← Forward(Xf , yf , θt) 5: ← 0; lf ← ∑n i=1 iC(yf,i, ŷf,i) 6: ∇θt ← BackwardAD(lf , θt) 7: θ̂t ← θt − α∇θt 8: ŷg ← Forward(Xg, yg, θ̂t) 9: lg ← 1m ∑m i=1 C(yg,i, ŷg,i)\n10: ∇ ← BackwardAD(lg, ) 11: w̃ ← max(−∇ , 0); w ← w̃∑\nj w̃+δ( ∑ j w̃)\n12: l̂f ← ∑n i=1 wiC(yi, ŷf,i) 13: ∇θt ← BackwardAD(l̂f , θt) 14: θt+1 ← OptimizerStep(θt,∇θt) 15: end for\nTraining time Our automatic reweighting method will introduce a constant factor of overhead. First, it requires two full forward and backward passes of the network on training and validation respectively, and then another backward on backward pass (Step 5 in Figure 1), to get the gradients to the example weights, and finally a backward pass to minimize the reweighted objective. In modern networks, a backwardon-backward pass usually takes about the same time as a forward pass, and therefore compared to regular training, our method needs approximately 3× training time; it is also possible to reduce the batch size of the validation pass for speedup. We expect that it is worthwhile to spend the extra time to avoid the irritation of choosing early stopping, finetuning schedules, and other hyperparameters."
  }, {
    "heading": "3.4. Analysis: convergence of the reweighted training",
    "text": "Convergence results of SGD based optimization methods are well-known (Reddi et al., 2016). However it is still meaningful to establish a convergence result about our method since it involves optimization of two-level objectives (Eq. 1, 2) rather than one, and we further make some firstorder approximation by introducing Eq. 7. Here, we show theoretically that our method converges to the critical point of the validation loss function under some mild conditions, and we also give its convergence rate. More detailed proofs can be found in the Supplementary Materials.\nDefinition 1. A function f(x) : Rd → R is said to be Lipschitz-smooth with constant L if\n‖∇f(x)−∇f(y)‖ ≤ L‖x− y‖,∀x, y ∈ Rd.\nDefinition 2. f(x) has σ-bounded gradients if ‖∇f(x)‖ ≤ σ for all x ∈ Rd.\nIn most real-world cases, the high-quality validation set is really small, and thus we could set the mini-batch size m to be the same as the size of the validation set M . Under this condition, the following lemma shows that our algorithm always converges to a critical point of the validation loss. However, our method is not equivalent to training a model only on this small validation set. Because directly training a model on a small validation set will lead to severe overfitting issues. On the contrary, our method can leverage useful information from a larger training set, and still converge to an appropriate distribution favored by this clean and balanced validation dataset. This helps both generalization and robustness to biases in the training set, which will be shown in our experiments.\nLemma 1. Suppose the validation loss function is Lipschitzsmooth with constant L, and the train loss function fi of training data xi have σ-bounded gradients. Let the learning rate αt satisfies αt ≤ 2nLσ2 , where n is the training batch size. Then, following our algorithm, the validation loss always monotonically decreases for any sequence of training batches, namely,\nG(θt+1) ≤ G(θt), (13)\nwhere G(θ) is the total validation loss\nG(θ) = 1\nM M∑ i=1 fvi (θt+1( )). (14)\nFurthermore, in expectation, the equality in Eq. 13 holds only when the gradient of validation loss becomes 0 at some time step t, namely Et [G(θt+1)] = G(θt) if and only if ∇G(θt) = 0, where the expectation is taking over possible training batches at time step t.\nMoreover, we can prove the convergence rate of our method to be O(1/ 2).\nTheorem 2. Suppose G, fi and αt satisfy the aforementioned conditions, then Algorithm 1 achieves E [ ‖∇G(θt)‖2 ] ≤ in O(1/ 2) steps. More specifically,\nmin 0<t<T\nE [ ‖∇G(θt)‖2 ] ≤ C√\nT , (15)\nwhere C is some constant independent of the convergence process."
  }, {
    "heading": "4. Experiments",
    "text": "To test the effectiveness of our reweighting algorithm, we designed both class imbalance and noisy label settings, and a combination of both, on standard MNIST and CIFAR benchmarks for image classification using deep CNNs."
  }, {
    "heading": "4.1. MNIST data imbalance experiments",
    "text": "We use the standard MNIST handwritten digit classification dataset and subsample the dataset to generate a class imbalance binary classification task. We select a total of 5,000 images of size 28×28 on class 4 and 9, where 9 dominates the training data distribution. We train a standard LeNet on this task and we compare our method with a suite of commonly used tricks for class imbalance: 1) PROPORTION weights each example by the inverse frequency 2) RESAMPLE samples a class-balanced minibatch for each iteration 3) HARD MINING selects the highest loss examples from the majority class and 4) RANDOM is a random example weight baseline that assigns weights based on a rectified Gaussian distribution:\nwrndi = max(zi, 0)∑ i max(zi, 0) , where zi ∼ N (0, 1). (16)\nTo make sure that our method does not have the privilege of training on more data, we split the balanced validation set of 10 images directly from the training set. The network is trained with SGD with a learning rate of 1e-3 and mini-batch size of 100 for a total of 8,000 steps.\nFigure 2 plots the test error rate across various imbalance ratios averaged from 10 runs with random splits. Note that our method significantly outperforms all the baselines. With class imbalance ratio of 200:1, our method only reports a small increase of error rate around 2%, whereas other methods suffer terribly under this setting. Compared with resampling and hard negative mining baselines, our approach does not throw away samples based on its class or training loss - as long as a sample is helpful towards the validation loss, it will be included as a part of the training loss."
  }, {
    "heading": "4.2. CIFAR noisy label experiments",
    "text": "Reweighting algorithm can also be useful on datasets where the labels are noisy. We study two settings of label noise here:\n• UNIFORMFLIP: All label classes can uniformly flip to any other label classes, which is the most studied in the literature. • BACKGROUNDFLIP: All label classes can flip to a single background class. This noise setting is very realistic. For instance, human annotators may not have recognized all the positive instances, while the\nrest remain in the background class. This is also a combination of label imbalance and label noise since the background class usually dominates the label distribution.\nWe compare our method with prior work on the noisy label problem.\n• REED, proposed by Reed et al. (2014), is a bootstrapping technique where the training target is a convex combination of the model prediction and the label.\n• S-MODEL, proposed by Goldberger & Ben-Reuven (2017), adds a fully connected softmax layer after the regular classification output layer to model the noise transition matrix.\n• MENTORNET, proposed by Jiang et al. (2017), is an RNN-based meta-learning model that takes in a sequence of loss values and outputs the example weights. We compare numbers reported in their paper with a base model that achieves similar test accuracy under 0% noise.\nIn addition, we propose two simple baselines: 1) RANDOM, which assigns weights according to a rectified Gaussian (see Eq. 16); 2) WEIGHTED, designed for BACKGROUNDFLIP, where the model knows the oracle noise ratio for each class and reweights the training loss proportional to the percentage of clean images of that label class.\nClean validation set For UNIFORMFLIP, we use 1,000 clean images in the validation set; for BACKGROUNDFLIP, we use 10 clean images per label class. Since our method uses information from the clean validation, for a fair comparison, we conduct an additional finetuning on the clean data based on the pre-trained baselines. We also study the effect on the size of the clean validation set in an ablation study.\nHyper-validation set For monitoring training progress and tuning baseline hyperparameters, we split out another\n5,000 hyper-validation set from the 50,000 training images. We also corrupt the hyper-validation set with the same noise type.\nExperimental details For REED model, we use the best β reported in Reed et al. (2014) (β = 0.8 for hard bootstrapping and β = 0.95 for soft bootstrapping). For the S-MODEL, we explore two versions to initialize the transition weights: 1) a smoothed identity matrix; 2) in background flip experiments we consider initializing the transition matrix with the confusion matrix of a pre-trained baseline model (S-MODEL +CONF). We find baselines can easily overfit the training noise, and therefore we also study early stopped versions of the baselines to provide a stronger comparison. In contrast, we find early stopping not necessary for our method.\nTo make our results comparable with the ones reported in MENTORNET and to save computation time, we exchange their Wide ResNet-101-10 with a Wide ResNet28-10 (WRN-28-10) (Zagoruyko & Komodakis, 2016) with dropout 0.3 as our base model in the UNIFORMFLIP experiments. We find that test accuracy differences between the two base models are within 0.5% on CIFAR datasets under 0% noise. In the BACKGROUNDFLIP experiments, we use a ResNet-32 (He et al., 2016) as our base model.\nWe train the models with SGD with momentum, at an initial learning rate 0.1 and a momentum 0.9 with mini-batch size 100. For ResNet-32 models, the learning rate decays×0.1 at 40K and 60K steps, for a total of 80K steps. For WRN and early stopped versions of ResNet-32 models, the learning rate decays at 40K and 50K steps, for a total of 60K steps. Under regular 0% noise settings, our base ResNet-32 gets 92.5% and 68.1% classification accuracy on CIFAR-10 and 100, and the WRN-28-10 gets 95.5% and 78.2%. For the finetuning stage, we run extra 5K steps of training on the\nCLEAN ONLY 15.90 ± 3.32 8.06 ± 0.76 BASELINE +FT 82.82 ± 0.93 54.23 ± 1.75 BASELINE +ES +FT 85.19 ± 0.46 55.22 ± 1.40 WEIGHTED +FT 85.98 ± 0.47 53.99 ± 1.62 S-MODEL +CONF +FT 81.90 ± 0.85 53.11 ± 1.33 S-MODEL +CONF +ES +FT 85.86 ± 0.63 55.75 ± 1.26\nOURS 86.73 ± 0.48 59.30 ± 0.60\nlimited clean data.\nWe report the average test accuracy for 5 different random splits of clean and noisy labels, with 95% confidence interval in Table 1 and 2. The background classes for the 5 trials are [0, 1, 3, 5, 7] (CIFAR-10) and [7, 12, 41, 62, 85] (CIFAR-100)."
  }, {
    "heading": "4.3. Results and Discussion",
    "text": "The first result that draws our attention is that “Random” performs surprisingly well on the UNIFORMFLIP benchmark, outperforming all historical methods that we compared. Given that its performance is comparable with Baseline on BACKGROUNDFLIP and MNIST class imbalance, we hypothesize that random example weights act as a strong regularizer and under which the learning objective on UNIFORMFLIP is still consistent.\nRegardless of the strong baseline, our method ranks the top on both UNIFORMFLIP and BACKGROUNDFLIP, showing our method is less affected by the changes in the noise type. On CIFAR-100, our method wins more than 3% compared to the state-of-the-art method.\nUnderstanding the reweighting mechanism It is beneficial to understand how our reweighting algorithm contributes to learning more robust models during training. First, we use a pre-trained model (trained at half of the total iterations without learning rate decay) and measure the example weight distribution of a randomly sampled batch of validation images, which the model has never seen. As shown in the left figure of Figure 3, our model correctly\npushes most noisy images to zero weights. Secondly, we conditioned the input mini-batch to be a single nonbackground class and randomly flip 40% of the images to the background, and we would like to see how well our model can distinguish clean and noisy images. As shown in Figure 3 right, the model is able to reliably detect images that are flipped to the background class.\nRobustness to overfitting noise Throughout experimentation, we find baseline models can easily overfit to the noise in the training set. For example, shown in Table 2, applying early stopping (“ES”) helps the classification performance of “S-Model” by over 10% on CIFAR-10. Figure 6 compares the final confusion matrices of the baseline and the proposed algorithm, where a large proportion of noise transition probability is cleared in the final prediction. Figure 7 shows training curves on the BACKGROUNDFLIP experiments. After the first learning rate decay, both “Baseline” and “SModel” quickly degrade their validation performance due to overfitting, while our model remains the same validation accuracy until termination. Note that here “S-Model” knows the oracle noise ratio in each class, and this information is\nnot available in our method.\nImpact of the noise level We would like to investigate how strongly our method can perform on a variety of noise levels. Shown in Figure 5, our method only drops 6% accuracy when the noise ratio increased from 0% to 50%;\nwhereas the baseline has dropped more than 40%. At 0% noise, our method only slightly underperforms baseline. This is reasonable since we are optimizing on the validation set, which is strictly a subset of the full training set, and therefore suffers from its own subsample bias.\nSize of the clean validation set When the size of the clean validation set grows larger, fine-tuning on the validation set will be a reasonble approach. Here, we make an attempt to explore the tradeoff and understand when fine-tuning becomes beneficial. Figure 4 plots the classification performance when we varied the size of the clean validation on BACKGROUNDFLIP. Surprisingly, using 15 validation images for all classes only results in a 2% drop in performance, and the overall classification performance does not grow after having more than 100 validation images. In comparison, we observe a significant drop in performance when only fine-tuning on these 15 validation images for the baselines, and the performance catches up around using 1,000 validation images (100 per class). This phenomenon suggests that in our method the clean validation acts more like a regularizer rather than a data source for parameter finetuning, and potentially our method can be complementary with fine-tuning based method when the size of the clean set grows larger."
  }, {
    "heading": "5. Conclusion",
    "text": "In this work, we propose an online meta-learning algorithm for reweighting training examples and training more robust deep learning models. While various types of training set biases exist and manually designed reweighting objectives have their own bias, our automatic reweighting algorithm shows superior performance dealing with class imbalance, noisy labels, and both. Our method can be directly applied to any deep learning architecture and is expected to train end-to-end without any additional hyperparameter search. Validating on every training step is a novel setting and we show that it has links with model regularization, which can be a fruitful future research direction."
  }],
  "year": 2018,
  "references": [{
    "title": "Tensorflow: A system for largescale machine learning",
    "authors": ["Vasudevan", "Vijay", "Warden", "Pete", "Wicke", "Martin", "Yu", "Yuan", "Zheng", "Xiaoqiang"],
    "venue": "In 12th USENIX Symposium on Operating Systems Design and Implementation,",
    "year": 2016
  }, {
    "title": "Learning to learn by gradient descent by gradient descent",
    "authors": ["Andrychowicz", "Marcin", "Denil", "Misha", "Colmenarejo", "Sergio Gomez", "Hoffman", "Matthew W", "Pfau", "David", "Schaul", "Tom", "de Freitas", "Nando"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2016
  }, {
    "title": "Learning from noisy examples",
    "authors": ["Angluin", "Dana", "Laird", "Philip"],
    "venue": "Machine Learning,",
    "year": 1988
  }, {
    "title": "Auxiliary image regularization for deep cnns with noisy labels",
    "authors": ["Azadi", "Samaneh", "Feng", "Jiashi", "Jegelka", "Stefanie", "Darrell", "Trevor"],
    "venue": "In Proceedings of the 4th International Conference on Learning Representation,",
    "year": 2016
  }, {
    "title": "Curriculum learning",
    "authors": ["Bengio", "Yoshua", "Louradour", "Jérôme", "Collobert", "Ronan", "Weston", "Jason"],
    "venue": "In Proceedings of the 26th Annual International Conference on Machine Learning,",
    "year": 2009
  }, {
    "title": "Active bias: Training more accurate neural networks by emphasizing high variance samples",
    "authors": ["Chang", "Haw-Shiuan", "Learned-Miller", "Erik G", "McCallum", "Andrew"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2017
  }, {
    "title": "SMOTE: synthetic minority over-sampling technique",
    "authors": ["Chawla", "Nitesh V", "Bowyer", "Kevin W", "Hall", "Lawrence O", "Kegelmeyer", "W. Philip"],
    "venue": "J. Artif. Intell. Res.,",
    "year": 2002
  }, {
    "title": "Webly supervised learning of convolutional networks",
    "authors": ["Chen", "Xinlei", "Gupta", "Abhinav"],
    "venue": "In Proceedings of the 2015 IEEE International Conference on Computer Vision, ICCV,",
    "year": 2015
  }, {
    "title": "Modelagnostic meta-learning for fast adaptation of deep networks",
    "authors": ["Finn", "Chelsea", "Abbeel", "Pieter", "Levine", "Sergey"],
    "venue": "In Proceedings of the 34th International Conference on Machine Learning,",
    "year": 2017
  }, {
    "title": "A decision-theoretic generalization of on-line learning and an application to boosting",
    "authors": ["Freund", "Yoav", "Schapire", "Robert E"],
    "venue": "J. Comput. Syst. Sci.,",
    "year": 1997
  }, {
    "title": "Training deep neural-networks using a noise adaptation layer",
    "authors": ["Goldberger", "Jacob", "Ben-Reuven", "Ehud"],
    "venue": "In Proceedings of the 5th International Conference on Learning Representation,",
    "year": 2017
  }, {
    "title": "Deep residual learning for image recognition",
    "authors": ["He", "Kaiming", "Zhang", "Xiangyu", "Ren", "Shaoqing", "Sun", "Jian"],
    "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
    "year": 2016
  }, {
    "title": "Using trusted data to train deep networks on labels corrupted by severe",
    "authors": ["Hendrycks", "Dan", "Mazeika", "Mantas", "Wilson", "Duncan", "Gimpel", "Kevin"],
    "venue": "noise. CoRR,",
    "year": 2018
  }, {
    "title": "Learning deep representation for imbalanced classification",
    "authors": ["Huang", "Chen", "Li", "Yining", "Loy", "Chen Change", "Tang", "Xiaoou"],
    "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
    "year": 2016
  }, {
    "title": "Self-paced curriculum learning",
    "authors": ["Jiang", "Lu", "Meng", "Deyu", "Zhao", "Qian", "Shan", "Shiguang", "Hauptmann", "Alexander G"],
    "venue": "In Proceedings of the 29th AAAI Conference on Artificial Intelligence,",
    "year": 2015
  }, {
    "title": "Mentornet: Regularizing very deep neural networks on corrupted",
    "authors": ["Jiang", "Lu", "Zhou", "Zhengyuan", "Leung", "Thomas", "Li", "Li-Jia", "Fei-Fei"],
    "venue": "labels. CoRR,",
    "year": 2017
  }, {
    "title": "Methods of reducing sample size in monte carlo computations",
    "authors": ["Kahn", "Herman", "Marshall", "Andy W"],
    "venue": "Journal of the Operations Research Society of America,",
    "year": 1953
  }, {
    "title": "Cost sensitive learning of deep feature representations from imbalanced data",
    "authors": ["Khan", "Salman Hameed", "Bennamoun", "Mohammed", "Sohel", "Ferdous Ahmed", "Togneri", "Roberto"],
    "venue": "CoRR, abs/1508.03422,",
    "year": 2015
  }, {
    "title": "Understanding black-box predictions via influence functions",
    "authors": ["Koh", "Pang Wei", "Liang", "Percy"],
    "venue": "In Proceedings of the 34th International Conference on Machine Learning,",
    "year": 2017
  }, {
    "title": "Building machines that learn and think like people",
    "authors": ["Lake", "Brenden M", "Ullman", "Tomer D", "Tenenbaum", "Joshua B", "Gershman", "Samuel J"],
    "venue": "Behav Brain Sci,",
    "year": 2017
  }, {
    "title": "Learning from noisy labels with distillation",
    "authors": ["Li", "Yuncheng", "Yang", "Jianchao", "Song", "Yale", "Cao", "Liangliang", "Luo", "Jiebo", "Li-Jia"],
    "venue": "In Proceedings of the IEEE International Conference on Computer Vision,",
    "year": 2017
  }, {
    "title": "Focal loss for dense object detection",
    "authors": ["Lin", "Tsung-Yi", "Goyal", "Priya", "Girshick", "Ross B", "He", "Kaiming", "Dollár", "Piotr"],
    "venue": "In Proceedings of the IEEE International Conference on Computer Vision,",
    "year": 2017
  }, {
    "title": "Stochastic hyperparameter optimization through hypernetworks",
    "authors": ["Lorraine", "Jonathan", "Duvenaud", "David"],
    "venue": "CoRR, abs/1802.09419,",
    "year": 2018
  }, {
    "title": "Self-paced co-training",
    "authors": ["Ma", "Fan", "Meng", "Deyu", "Xie", "Qi", "Li", "Zina", "Dong", "Xuanyi"],
    "venue": "In Proceedings of the 34th International Conference on Machine Learning,",
    "year": 2017
  }, {
    "title": "Ensemble of exemplar-svms for object detection and beyond",
    "authors": ["Malisiewicz", "Tomasz", "Gupta", "Abhinav", "Efros", "Alexei A"],
    "venue": "In Proceedings of the IEEE International Conference on Computer Vision, ICCV,",
    "year": 2011
  }, {
    "title": "Learning with noisy labels",
    "authors": ["Natarajan", "Nagarajan", "Dhillon", "Inderjit S", "Ravikumar", "Pradeep", "Tewari", "Ambuj"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2013
  }, {
    "title": "Optimization as a model for few-shot learning",
    "authors": ["Ravi", "Sachin", "Larochelle", "Hugo"],
    "venue": "In Proceedings of the 5th International Conference on Learning Representations,",
    "year": 2017
  }, {
    "title": "Stochastic variance reduction for nonconvex optimization",
    "authors": ["Reddi", "Sashank J", "Hefny", "Ahmed", "Sra", "Suvrit", "Póczos", "Barnabás", "Smola", "Alexander J"],
    "venue": "In Proceedings of the 33rd International Conference on Machine Learning,",
    "year": 2016
  }, {
    "title": "Learning from noisy labels with deep neural networks",
    "authors": ["Sukhbaatar", "Sainbayar", "Fergus", "Rob"],
    "venue": "CoRR, abs/1406.2080,",
    "year": 2014
  }, {
    "title": "A comparative study of cost-sensitive boosting algorithms",
    "authors": ["Ting", "Kai Ming"],
    "venue": "In Proceedings of the 17th International Conference on Machine Learning,",
    "year": 2000
  }, {
    "title": "Toward robustness against label noise in training deep discriminative neural networks",
    "authors": ["Vahdat", "Arash"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2017
  }, {
    "title": "Robust probabilistic modeling with bayesian data reweighting",
    "authors": ["Wang", "Yixin", "Kucukelbir", "Alp", "Blei", "David M"],
    "venue": "In Proceedings of the 34th International Conference on Machine Learning,",
    "year": 2017
  }, {
    "title": "Understanding short-horizon bias in stochastic meta-optimization",
    "authors": ["Wu", "Yuhuai", "Ren", "Mengye", "Liao", "Renjie", "Grosse", "Roger B"],
    "venue": "In Proceedings of the 6th International Conference on Learning Representations,",
    "year": 2018
  }, {
    "title": "Learning from massive noisy labeled data for image classification",
    "authors": ["Xiao", "Tong", "Xia", "Tian", "Yang", "Yi", "Huang", "Chang", "Wang", "Xiaogang"],
    "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
    "year": 2015
  }, {
    "title": "Wide residual networks",
    "authors": ["Zagoruyko", "Sergey", "Komodakis", "Nikos"],
    "venue": "In Proceedings of the British Machine Vision Conference,",
    "year": 2016
  }, {
    "title": "Understanding deep learning requires rethinking generalization",
    "authors": ["Zhang", "Chiyuan", "Bengio", "Samy", "Hardt", "Moritz", "Recht", "Benjamin", "Vinyals", "Oriol"],
    "venue": "In Proceedings of the 5th International Conference on Learning Representations,",
    "year": 2017
  }],
  "id": "SP:c5420ef59d7508d82e53671b0d623027eb58e6ed",
  "authors": [{
    "name": "Mengye Ren",
    "affiliations": []
  }, {
    "name": "Wenyuan Zeng",
    "affiliations": []
  }, {
    "name": "Bin Yang",
    "affiliations": []
  }, {
    "name": "Raquel Urtasun",
    "affiliations": []
  }],
  "abstractText": "Deep neural networks have been shown to be very powerful modeling tools for many supervised learning tasks involving complex input patterns. However, they can also easily overfit to training set biases and label noises. In addition to various regularizers, example reweighting algorithms are popular solutions to these problems, but they require careful tuning of additional hyperparameters, such as example mining schedules and regularization hyperparameters. In contrast to past reweighting methods, which typically consist of functions of the cost value of each example, in this work we propose a novel meta-learning algorithm that learns to assign weights to training examples based on their gradient directions. To determine the example weights, our method performs a meta gradient descent step on the current mini-batch example weights (which are initialized from zero) to minimize the loss on a clean unbiased validation set. Our proposed method can be easily implemented on any type of deep network, does not require any additional hyperparameter tuning, and achieves impressive performance on class imbalance and corrupted label problems where only a small amount of clean validation data is available.",
  "title": "Learning to Reweight Examples for Robust Deep Learning"
}