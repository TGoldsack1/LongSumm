{
  "sections": [{
    "text": "Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Long Papers), pages 1884–1895 Melbourne, Australia, July 15 - 20, 2018. c©2018 Association for Computational Linguistics\n1884"
  }, {
    "heading": "1 Introduction",
    "text": "The standard protocol for obtaining a labeled dataset is to have a human annotator view each example, assess its relevance, and provide a label (e.g., positive or negative for binary classification). However, this only provides one bit of information per example. This invites the question: how can we get more information per example, given that the annotator has already spent the effort reading and understanding an example?\nPrevious works have relied on identifying relevant parts of the input such as labeling features (Druck et al., 2009; Raghavan et al., 2005; Liang et al., 2009), highlighting rationale phrases in\ntext (Zaidan and Eisner, 2008; Arora and Nyberg, 2009), or marking relevant regions in images (Ahn et al., 2006). But there are certain types of information which cannot be easily reduced to annotating a portion of the input, such as the absence of a certain word, or the presence of at least two words. In this work, we tap into the power of natural language and allow annotators to provide supervision to a classifier via natural language explanations.\nSpecifically, we propose a framework in which annotators provide a natural language explanation for each label they assign to an example (see Figure 1). These explanations are parsed into logical forms representing labeling functions (LFs), functions that heuristically map examples to labels (Ratner et al., 2016). The labeling functions are\nthen executed on many unlabeled examples, resulting in a large, weakly-supervised training set that is then used to train a classifier.\nSemantic parsing of natural language into logical forms is recognized as a challenging problem and has been studied extensively (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Liang et al., 2011; Liang, 2016). One of our major findings is that in our setting, even a simple rule-based semantic parser suffices for three reasons: First, we find that the majority of incorrect LFs can be automatically filtered out either semantically (e.g., is it consistent with the associated example?) or pragmatically (e.g., does it avoid assigning the same label to the entire training set?). Second, LFs near the gold LF in the space of logical forms are often just as accurate (and sometimes even more accurate). Third, techniques for combining weak supervision sources are built to tolerate some noise (Alfonseca et al., 2012; Takamatsu et al., 2012; Ratner et al., 2018). The significance of this is that we can deploy the same semantic parser across tasks without task-specific training. We show how we can tackle a real-world biomedical application with the same semantic parser used to extract instances of spouses.\nOur work is most similar to that of Srivastava et al. (2017), who also use natural language explanations to train a classifier, but with two important differences. First, they jointly train a task-specific semantic parser and classifier, whereas we use a\nsimple rule-based parser. In Section 4, we find that in our weak supervision framework, the rule-based semantic parser and the perfect parser yield nearly identical downstream performance. Second, while they use the logical forms of explanations to produce features that are fed directly to a classifier, we use them as functions for labeling a much larger training set. In Section 4, we show that using functions yields a 9.5 F1 improvement (26% relative improvement) over features, and that the F1 score scales with the amount of available unlabeled data.\nWe validate our approach on two existing datasets from the literature (extracting spouses from news articles and disease-causing chemicals from biomedical abstracts) and one real-world use case with our biomedical collaborators at OccamzRazor to extract protein-kinase interactions related to Parkinson’s disease from text. We find empirically that users are able to train classifiers with comparable F1 scores up to two orders of magnitude faster when they provide natural language explanations instead of individual labels. Our code and data can be found at https:// github.com/HazyResearch/babble.\n2 The BabbleLabble Framework\nThe BabbleLabble framework converts natural language explanations and unlabeled data into a noisily-labeled training set (see Figure 2). There are three key components: a semantic parser, a filter bank, and a label aggregator. The semantic\nparser converts natural language explanations into a set of logical forms representing labeling functions (LFs). The filter bank removes as many incorrect LFs as possible without requiring ground truth labels. The remaining LFs are applied to unlabeled examples to produce a matrix of labels. This label matrix is passed into the label aggregator, which combines these potentially conflicting and overlapping labels into one label for each example. The resulting labeled examples are then used to train an arbitrary discriminative model."
  }, {
    "heading": "2.1 Explanations",
    "text": "To create the input explanations, the user views a subset S of an unlabeled dataset D (where |S| |D|) and provides for each input xi ∈ S a label yi and a natural language explanation ei, a sentence explaining why the example should receive that label. The explanation ei generally refers to specific aspects of the example (e.g., in Figure 2, the location of a specific string “his wife”)."
  }, {
    "heading": "2.2 Semantic Parser",
    "text": "The semantic parser takes a natural language explanation ei and returns a set of LFs (logical forms or labeling functions) {f1, . . . , fk} of the form fi : X → {−1, 0, 1} in a binary classification setting, with 0 representing abstention. We emphasize that the goal of this semantic parser is not to generate the single correct parse, but rather to have coverage over many potentially useful LFs.1\n1Indeed, we find empirically that an incorrect LF nearby the correct one in the space of logical forms actually has higher end-task accuracy 57% of the time (see Section 4.2).\nWe choose a simple rule-based semantic parser that can be used without any training. Formally, the parser uses a set of rules of the form α → β, where α can be replaced by the token(s) in β (see Figure 3 for example rules). To identify candidate LFs, we recursively construct a set of valid parses for each span of the explanation, based on the substitutions defined by the grammar rules. At the end, the parser returns all valid parses (LFs in our case) corresponding to the entire explanation.\nWe also allow an arbitrary number of tokens in a given span to be ignored when looking for a matching rule. This improves the ability of the parser to handle unexpected input, such as unknown words or typos, since the portions of the input that are parseable can still result in a valid parse. For example, in Figure 3, the word “person” is ignored.\nAll predicates included in our grammar (summarized in Table 1) are provided to annotators, with minimal examples of each in use (Appendix A). Importantly, all rules are domain independent (e.g., all three relation extraction tasks that we tested used the same grammar), making the semantic parser easily transferrable to new domains. Additionally, while this paper focuses on the task of relation extraction, in principle the BabbleLabble framework can be applied to other tasks or settings by extending the grammar with the necessary primitives (e.g., adding primitives for rows and columns to enable explanations about the alignments of words in tables). To guide the construction of the grammar, we collected 500 explanations for the Spouse domain from workers\non Amazon Mechanical Turk and added support for the most commonly used predicates. These were added before the experiments described in Section 4. Altogether the grammar contains 200 rule templates."
  }, {
    "heading": "2.3 Filter Bank",
    "text": "The input to the filter bank is a set of candidate LFs produced by the semantic parser. The purpose of the filter bank is to discard as many incorrect LFs as possible without requiring additional labels. It consists of two classes of filters: semantic and pragmatic.\nRecall that each explanation ei is collected in the context of a specific labeled example (xi, yi). The semantic filter checks for LFs that are inconsistent with their corresponding example; formally, any LF f for which f(xi) 6= yi is discarded. For example, in the first explanation in Figure 2, the word “right” can be interpreted as either “immediately” (as in “right before”) or simply “to the\nright.” The latter interpretation results in a function that is inconsistent with the associated example (since “his wife” is actually to the left of person 2), so it can be safely removed.\nThe pragmatic filters removes LFs that are constant, redundant, or correlated. For example, in Figure 2, LF 2a is constant, as it labels every example positively (since all examples contain two people from the same sentence). LF 3b is redundant, since even though it has a different syntax tree from LF 3a, it labels the training set identically and therefore provides no new signal.\nFinally, out of all LFs from the same explanation that pass all the other filters, we keep only the most specific (lowest coverage) LF. This prevents multiple correlated LFs from a single example from dominating.\nAs we show in Section 4, over three tasks, the filter bank removes 86% of incorrect parses, and the incorrect ones that remain have average endtask accuracy within 2.5% of the corresponding correct parses."
  }, {
    "heading": "2.4 Label Aggregator",
    "text": "The label aggregator combines multiple (potentially conflicting) suggested labels from the LFs and combines them into a single probabilistic label per example. Concretely, if m LFs pass the filter bank and are applied to n examples, the label aggregator implements a function f : {−1, 0, 1}m×n → [0, 1]n.\nA naive solution would be to use a simple majority vote, but this fails to account for the fact that LFs can vary widely in accuracy and coverage. Instead, we use data programming (Ratner et al., 2016), which models the relationship between the true labels and the output of the labeling functions as a factor graph. More specifically, given the true labels Y ∈ {−1, 1}n (latent) and label matrix Λ ∈ {−1, 0, 1}m×n (observed) where Λi,j = LFi(xj), we define two types of factors representing labeling propensity and accuracy:\nφLabi,j (Λ, Y ) = 1{Λi,j 6= 0} (1) φAcci,j (Λ, Y ) = 1{Λi,j = yj}. (2)\nDenoting the vector of factors pertaining to a given data point xj as φj(Λ, Y ) ∈ Rm, define the model:\npw(Λ, Y ) = Z −1 w exp ( n∑ j=1 w · φj(Λ, Y ) ) , (3)\nwhere w ∈ R2m is the weight vector and Zw is the normalization constant. To learn this model without knowing the true labels Y , we minimize the negative log marginal likelihood given the observed labels Λ:\nŵ = arg min w − log ∑ Y pw(Λ, Y ) (4)\nusing SGD and Gibbs sampling for inference, and then use the marginals pŵ(Y | Λ) as probabilistic training labels.\nIntuitively, we infer accuracies of the LFs based on the way they overlap and conflict with one another. Since noisier LFs are more likely to have high conflict rates with others, their corresponding accuracy weights in w will be smaller, reducing their influence on the aggregated labels."
  }, {
    "heading": "2.5 Discriminative Model",
    "text": "The noisily-labeled training set that the label aggregator outputs is used to train an arbitrary discriminative model. One advantage of training a discriminative model on the task instead of using the label aggregator as a classifier directly is that the label aggregator only takes into account those signals included in the LFs. A discriminative model, on the other hand, can incorporate features that were not identified by the user but are nevertheless informative.2 Consequently, even examples for which all LFs abstained can still be classified correctly. On the three tasks we evaluate, using the discriminative model averages 4.3 F1 points higher than using the label aggregator directly.\nFor the results reported in this paper, our discriminative model is a simple logistic regression classifier with generic features defined over dependency paths.3 These features include unigrams,\n2We give an example of two such features in Section 4.3. 3https://github.com/HazyResearch/treedlib\nbigrams, and trigrams of lemmas, dependency labels, and part of speech tags found in the siblings, parents, and nodes between the entities in the dependency parse of the sentence. We found this to perform better on average than a biLSTM, particularly for the traditional supervision baselines with small training set sizes; it also provided easily interpretable features for analysis."
  }, {
    "heading": "3 Experimental Setup",
    "text": "We evaluate the accuracy of BabbleLabble on three relation extraction tasks, which we refer to as Spouse, Disease, and Protein. The goal of each task is to train a classifier for predicting whether the two entities in an example are participating in the relationship of interest, as described below."
  }, {
    "heading": "3.1 Datasets",
    "text": "Statistics for each dataset are reported in Table 2, with one example and one explanation for each given in Figure 4 and additional explanations shown in Appendix B.\nIn the Spouse task, annotators were shown a sentence with two highlighted names and asked to label whether the sentence suggests that the two people are spouses. Sentences were pulled from the Signal Media dataset of news articles (Corney\net al., 2016). Ground truth data was collected from Amazon Mechanical Turk workers, accepting the majority label over three annotations. The 30 explanations we report on were sampled randomly from a pool of 200 that were generated by 10 graduate students unfamiliar with BabbleLabble.\nIn the Disease task, annotators were shown a sentence with highlighted names of a chemical and a disease and asked to label whether the sentence suggests that the chemical causes the disease. Sentences and ground truth labels came from a portion of the 2015 BioCreative chemical-disease relation dataset (Wei et al., 2015), which contains abstracts from PubMed. Because this task requires specialized domain expertise, we obtained explanations by having someone unfamiliar with BabbleLabble translate from Python to natural language labeling functions from an existing publication that explored applying weak supervision to this task (Ratner et al., 2018).\nThe Protein task was completed in conjunction with OccamzRazor, a neuroscience company targeting biological pathways of Parkinson’s disease. For this task, annotators were shown a sentence from the relevant biomedical literature with highlighted names of a protein and a kinase and asked to label whether or not the kinase influences the protein in terms of a physical interaction or phosphorylation. The annotators had domain expertise but minimal programming experience, making BabbleLabble a natural fit for their use case."
  }, {
    "heading": "3.2 Experimental Settings",
    "text": "Text documents are tokenized with spaCy.4 The semantic parser is built on top of the Python-based\n4https://github.com/explosion/spaCy\nimplementation SippyCup.5 On a single core, parsing 360 explanations takes approximately two seconds. We use existing implementations of the label aggregator, feature library, and discriminative classifier described in Sections 2.4–2.5 provided by the open-source project Snorkel (Ratner et al., 2018).\nHyperparameters for all methods we report were selected via random search over thirty configurations on the same held-out development set. We searched over learning rate, batch size, L2 regularization, and the subsampling rate (for improving balance between classes).6 All reported F1 scores are the average value of 40 runs with random seeds and otherwise identical settings."
  }, {
    "heading": "4 Experimental Results",
    "text": "We evaluate the performance of BabbleLabble with respect to its rate of improvement by number of user inputs, its dependence on correctly parsed logical forms, and the mechanism by which it utilizes logical forms."
  }, {
    "heading": "4.1 High Bandwidth Supervision",
    "text": "In Table 3 we report the average F1 score of a classifier trained with BabbleLabble using 30 explanations or traditional supervision with the indicated number of labels. On average, it took the same amount of time to collect 30 explanations as 60 labels.7 We observe that in all three tasks, BabbleLabble achieves a given F1 score with far fewer user inputs than traditional supervision, by\n5https://github.com/wcmac/sippycup 6Hyperparameter ranges: learning rate (1e-2 to 1e-4), batch size (32 to 128), L2 regularization (0 to 100), subsampling rate (0 to 0.5)\n7Zaidan and Eisner (2008) also found that collecting annotator rationales in the form of highlighted substrings from the sentence only doubled annotation time.\nas much as 100 times in the case of the Spouse task. Because explanations are applied to many unlabeled examples, each individual input from the user can implicitly contribute many (noisy) labels to the learning algorithm.\nWe also observe, however, that once the number of labeled examples is sufficiently large, traditional supervision once again dominates, since ground truth labels are preferable to noisy ones generated by labeling functions. However, in domains where there is much more unlabeled data available than labeled data (which in our experience is most domains), we can gain in supervision efficiency from using BabbleLabble.\nOf those explanations that did not produce a correct LF, 4% were caused by the explanation referring to unsupported concepts (e.g., one explanation referred to “the subject of the sentence,” which our simple parser doesn’t support). Another 2% were caused by human errors (the correct LF for the explanation was inconsistent with the example). The remainder were due to unrecognized paraphrases (e.g., the explanation said “the order of appearance is X, Y” instead of a supported phrasing like “X comes before Y”)."
  }, {
    "heading": "4.2 Utility of Incorrect Parses",
    "text": "In Table 4, we report LF summary statistics before and after filtering. LF correctness is based on exact match with a manually generated parse for each explanation. Surprisingly, the simple heuristic-based filter bank successfully removes over 95% of incorrect LFs in all three tasks, resulting in final LF sets that are 86% correct on average. Furthermore, among those LFs that pass through the filter bank, we found that the average difference in end-task accuracy between correct and incorrect parses is less than 2.5%. Intuitively, the filters are effective because it is quite difficult for an LF to be parsed from the explana-\ntion, label its own example correctly (passing the semantic filter), and not label all examples in the training set with the same label or identically to another LF (passing the pragmatic filter).\nWe went one step further: using the LFs that would be produced by a perfect semantic parser as starting points, we searched for “nearby” LFs (LFs differing by only one predicate) with higher endtask accuracy on the test set and succeeded 57% of the time (see Figure 5 for an example). In other words, when users provide explanations, the signals they describe provide good starting points, but they are actually unlikely to be optimal. This observation is further supported by Table 5, which shows that the filter bank is necessary to remove clearly irrelevant LFs, but with that in place, the simple rule-based semantic parser and a perfect parser have nearly identical average F1 scores."
  }, {
    "heading": "4.3 Using LFs as Functions or Features",
    "text": "Once we have relevant logical forms from userprovided explanations, we have multiple options for how to use them. Srivastava et al. (2017) propose using these logical forms as features in a linear classifier. We choose instead to use them as functions for weakly supervising the creation of a larger training set via data programming (Ratner et al., 2016). In Table 6, we compare the two approaches directly, finding that the the data programming approach outperforms a feature-based one by 9.5 F1 points with the rule-based parser, and by 4.5 points with a perfect parser.\nWe attribute this difference primarily to the ability of data programming to utilize unlabeled data. In Figure 6, we show how the data programming approach improves with the number of unlabeled examples, even as the number of LFs remains constant. We also observe qualitatively that data programming exposes the classifier to additional patterns that are correlated with our explanations but not mentioned directly. For example, in the Disease task, two of the features weighted most\nhighly by the discriminative model were the presence of the trigrams “could produce a” or “support diagnosis of” between the chemical and disease, despite none of these words occurring in the explanations for that task. In Table 6 we see a 4.3 F1 point improvement (10%) when we use the discriminative model that can take advantage of these features rather than applying the LFs directly to the test set and making predictions based on the output of the label aggregator."
  }, {
    "heading": "5 Related Work and Discussion",
    "text": "Our work has two themes: modeling natural language explanations/instructions and learning from weak supervision. The closest body of work is on “learning from natural language.” As mentioned earlier, Srivastava et al. (2017) convert natural language explanations into classifier features (whereas we convert them into labeling functions). Goldwasser and Roth (2011) convert natural lan-\nguage into concepts (e.g., the rules of a card game). Ling and Fidler (2017) use natural language explanations to assist in supervising an image captioning model. Weston (2016); Li et al. (2016) learn from natural language feedback in a dialogue. Wang et al. (2017) convert natural language definitions to rules in a semantic parser to build up progressively higher-level concepts.\nWe lean on the formalism of semantic parsing (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Liang, 2016). One notable trend is to learn semantic parsers from weak supervision (Clarke et al., 2010; Liang et al., 2011), whereas our goal is to obtain weak supervision signal from semantic parsers.\nThe broader topic of weak supervision has received much attention; we mention some works most related to relation extraction. In distant supervision (Craven et al., 1999; Mintz et al., 2009) and multi-instance learning (Riedel et al., 2010; Hoffmann et al., 2011), an existing knowledge base is used to (probabilistically) impute a training set. Various extensions have focused on aggregating a variety of supervision sources by learning generative models from noisy labels (Alfonseca et al., 2012; Takamatsu et al., 2012; Roth and Klakow, 2013; Ratner et al., 2016; Varma et al., 2017).\nFinally, while we have used natural language explanations as input to train models, they can also be output to interpret models (Krening et al., 2017; Lei et al., 2016). More generally, from a machine learning perspective, labels are the primary asset, but they are a low bandwidth signal between annotators and the learning algorithm. Natural language opens up a much higher-bandwidth communication channel. We have shown promising results in relation extraction (where one explanation can be “worth” 100 labels), and it would be interesting to extend our framework to other tasks and more interactive settings."
  }, {
    "heading": "Reproducibility",
    "text": "The code, data, and experiments for this paper are available on the CodaLab platform at https: //worksheets.codalab.org/worksheets/ 0x900e7e41deaa4ec5b2fe41dc50594548/."
  }, {
    "heading": "Acknowledgments",
    "text": "We gratefully acknowledge the support of the following organizations: DARPA under No. N66001-15-C-4043 (SIMPLEX), No. FA8750-17-2-0095 (D3M), No. FA8750-122-0335 (XDATA), and No. FA8750-13-2-0039 (DEFT), DOE under No. 108845, NIH under No. U54EB020405 (Mobilize), ONR under No. N000141712266 and No. N000141310129, AFOSR under No. 580K753, the Intel/NSF CPS Security grant No. 1505728, the Michael J. Fox Foundation for Parkinsons Research under Grant No. 14672, the Secure Internet of Things Project, Qualcomm, Ericsson, Analog Devices, the Moore Foundation, the Okawa Research Grant, American Family Insurance, Accenture, Toshiba, the National Science Foundation Graduate Research Fellowship under Grant No. DGE-114747, the Stanford Finch Family Fellowship, the Joseph W. and Hon Mai Goodman Stanford Graduate Fellowship, an NSF CAREER Award IIS-1552635, and the members of the Stanford DAWN project: Facebook, Google, Intel, Microsoft, NEC, Teradata, and VMware.\nWe thank Alex Ratner and the developers of Snorkel for their assistance with data programming, as well as the many members of the Hazy Research group and Stanford NLP group who provided feedback and tested early prototyptes. Thanks as well to the OccamzRazor team: Tarik Koc, Benjamin Angulo, Katharina S. Volz, and Charlotte Brzozowski.\nThe U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views, policies, or endorsements, either expressed or implied, of DARPA, DOE, NIH, ONR, AFOSR, NSF, or the U.S. Government."
  }, {
    "heading": "A Predicate Examples",
    "text": "Below are the predicates in the rule-based semantic parser grammar, each of which may have many supported paraphrases, only one of which is listed here in a minimal example."
  }, {
    "heading": "Logic",
    "text": "and: X is true and Y is true or: X is true or Y is true not: X is not true any: Any of X or Y or Z is true all: All of X and Y and Z are true none: None of X or Y or Z is true"
  }, {
    "heading": "Comparison",
    "text": "=: X is equal to Y 6=: X is not Y <: X is smaller than Y ≤: X is no more than Y >: X is larger than Y ≥: X is at least Y"
  }, {
    "heading": "Syntax",
    "text": "lower: X is lowercase upper: X is upper case capital: X is capitalized all caps: X is in all caps starts with: X starts with \"cardio\" ends with: X ends with \"itis\" substring: X contains \"-induced\""
  }, {
    "heading": "Named-entity Tags",
    "text": "person: A person is between X and Y location: A place is within two words of X date: A date is between X and Y number: There are three numbers in the sentence organization: An organization is right after X"
  }, {
    "heading": "Lists",
    "text": "list: (X, Y) is in Z set: X, Y, and Z are true count: There is one word between X and Y contains: X is in Y intersection: At least two of X are in Y map: X is at the start of a word in Y filter: There are three capitalized words to the left of X alias: A spouse word is in the sentence (“spouse” is a predefined list from the user)"
  }, {
    "heading": "Position",
    "text": "word distance: X is two words before Y char distance: X is twenty characters after Y left: X is before Y right: X is after Y between: X is between Y and Z within: X is within five words of Y"
  }, {
    "heading": "B Sample Explanations",
    "text": "The following are a sample of the explanations provided by users for each task."
  }, {
    "heading": "Spouse",
    "text": "Users referred to the first person in the sentence as “X” and the second as “Y”.\nLabel true because \"and\" occurs between X and Y and \"marriage\" occurs one word after person1.\nLabel true because person Y is preceded by ‘beau’.\nLabel false because the words \"married\", \"spouse\", \"husband\", and \"wife\" do not occur in the sentence.\nLabel false because there are more than 2 people in the sentence and \"actor\" or \"actress\" is left of person1 or person2."
  }, {
    "heading": "Disease",
    "text": "Label true because the disease is immediately after the chemical and ’induc’ or ’assoc’ is in the chemical name.\nLabel true because a word containing ’develop’ appears somewhere before the chemical, and the word ’following’ is between the disease and the chemical.\nLabel true because \"induced by\", \"caused by\", or \"due to\" appears between the chemical and the disease.\"\nLabel false because \"none\", \"not\", or \"no\" is within 30 characters to the left of the disease."
  }, {
    "heading": "Protein",
    "text": "Label true because \"Ser\" or \"Tyr\" are within 10 characters of the protein.\nLabel true because the words \"by\" or \"with\" are between the protein and kinase and the words \"no\", \"not\" or \"none\" are not in between the protein and kinase and the total number of words between them is smaller than 10.\nLabel false because the sentence contains \"mRNA\", \"DNA\", or \"RNA\".\nLabel false because there are two \",\" between the protein and the kinase with less than 30 characters between them."
  }],
  "year": 2018,
  "references": [{
    "title": "Peekaboom: a game for locating objects in images",
    "authors": ["L.V. Ahn", "R. Liu", "M. Blum."],
    "venue": "Conference on Human Factors in Computing Systems (CHI). pages 55–64.",
    "year": 2006
  }, {
    "title": "Pattern learning for relation extraction with a hierarchical",
    "authors": ["E. Alfonseca", "K. Filippova", "J. Delort", "G. Garrido"],
    "year": 2012
  }, {
    "title": "Interactive annotation learning with indirect feature voting",
    "authors": ["S. Arora", "E. Nyberg."],
    "venue": "Association for Computational Linguistics (ACL). pages 55–60.",
    "year": 2009
  }, {
    "title": "Driving semantic parsing from the world’s response",
    "authors": ["J. Clarke", "D. Goldwasser", "M. Chang", "D. Roth."],
    "venue": "Computational Natural Language Learning (CoNLL). pages 18–27.",
    "year": 2010
  }, {
    "title": "What do a million news articles look like? In NewsIR@ ECIR",
    "authors": ["D. Corney", "D. Albakour", "M. Martinez-Alvarez", "S. Moussa."],
    "venue": "pages 42–47.",
    "year": 2016
  }, {
    "title": "Constructing biological knowledge bases by extracting information from text sources",
    "authors": ["M. Craven", "J. Kumlien"],
    "venue": "In ISMB",
    "year": 1999
  }, {
    "title": "Active learning by labeling features",
    "authors": ["G. Druck", "B. Settles", "A. McCallum."],
    "venue": "Empirical Methods in Natural Language Processing (EMNLP). pages 81–90.",
    "year": 2009
  }, {
    "title": "Learning from natural instructions",
    "authors": ["D. Goldwasser", "D. Roth."],
    "venue": "International Joint Conference on Artificial Intelligence (IJCAI). pages 1794–1800.",
    "year": 2011
  }, {
    "title": "Knowledge-based weak supervision for information extraction of overlapping relations",
    "authors": ["R. Hoffmann", "C. Zhang", "X. Ling", "L.S. Zettlemoyer", "D.S. Weld."],
    "venue": "Association for Computational Linguistics (ACL). pages 541–550.",
    "year": 2011
  }, {
    "title": "Learning from explanations using sentiment and advice in RL",
    "authors": ["S. Krening", "B. Harrison", "K.M. Feigh", "C.L. Isbell", "M. Riedl", "A. Thomaz."],
    "venue": "IEEE Transactions on Cognitive and Developmental Systems 9(1):44–55.",
    "year": 2017
  }, {
    "title": "Rationalizing neural predictions",
    "authors": ["T. Lei", "R. Barzilay", "T. Jaakkola."],
    "venue": "Empirical Methods in Natural Language Processing (EMNLP).",
    "year": 2016
  }, {
    "title": "Learning through dialogue interactions",
    "authors": ["J. Li", "A.H. Miller", "S. Chopra", "M. Ranzato", "J. Weston."],
    "venue": "arXiv preprint arXiv:1612.04936 .",
    "year": 2016
  }, {
    "title": "Learning executable semantic parsers for natural language understanding",
    "authors": ["P. Liang."],
    "venue": "Communications of the ACM 59.",
    "year": 2016
  }, {
    "title": "Learning from measurements in exponential families",
    "authors": ["P. Liang", "M.I. Jordan", "D. Klein."],
    "venue": "International Conference on Machine Learning (ICML).",
    "year": 2009
  }, {
    "title": "Learning dependency-based compositional semantics",
    "authors": ["P. Liang", "M.I. Jordan", "D. Klein."],
    "venue": "Association for Computational Linguistics (ACL). pages 590–599.",
    "year": 2011
  }, {
    "title": "Teaching machines to describe images via natural language feedback",
    "authors": ["H. Ling", "S. Fidler."],
    "venue": "Advances in Neural Information Processing Systems (NIPS).",
    "year": 2017
  }, {
    "title": "Distant supervision for relation extraction without labeled data",
    "authors": ["M. Mintz", "S. Bills", "R. Snow", "D. Jurafsky."],
    "venue": "Association for Computational Linguistics (ACL). pages 1003–1011.",
    "year": 2009
  }, {
    "title": "Interactive feature selection",
    "authors": ["H. Raghavan", "O. Madani", "R. Jones."],
    "venue": "International Joint Conference on Artificial Intelligence (IJCAI). volume 5, pages 841–846.",
    "year": 2005
  }, {
    "title": "Snorkel: Rapid training data creation with weak supervision",
    "authors": ["A.J. Ratner", "S.H. Bach", "H. Ehrenberg", "J. Fries", "S. Wu", "C. R’e"],
    "venue": "In Very Large Data Bases (VLDB)",
    "year": 2018
  }, {
    "title": "Data programming: Creating large training sets, quickly",
    "authors": ["A.J. Ratner", "C.M.D. Sa", "S. Wu", "D. Selsam", "C. R’e"],
    "venue": "In Advances in Neural Information Processing Systems (NIPS)",
    "year": 2016
  }, {
    "title": "Modeling relations and their mentions without labeled text",
    "authors": ["S. Riedel", "L. Yao", "A. McCallum."],
    "venue": "Machine Learning and Knowledge Discovery in Databases (ECML PKDD). pages 148–163.",
    "year": 2010
  }, {
    "title": "Combining generative and discriminative model scores for distant supervision",
    "authors": ["B. Roth", "D. Klakow."],
    "venue": "Empirical Methods in Natural Language Processing (EMNLP). pages 24–29.",
    "year": 2013
  }, {
    "title": "Joint concept learning and semantic parsing from natural language explanations",
    "authors": ["S. Srivastava", "I. Labutov", "T. Mitchell."],
    "venue": "Empirical Methods in Natural Language Processing (EMNLP). pages 1528–1537.",
    "year": 2017
  }, {
    "title": "Reducing wrong labels in distant supervision for relation extraction",
    "authors": ["S. Takamatsu", "I. Sato", "H. Nakagawa."],
    "venue": "Association for Computational Linguistics (ACL). pages 721–729.",
    "year": 2012
  }, {
    "title": "Socratic learning: Augmenting generative models to incorporate latent subsets in training data",
    "authors": ["P. Varma", "B. He", "D. Iter", "P. Xu", "R. Yu", "C.D. Sa", "C. R’e"],
    "year": 2017
  }, {
    "title": "Naturalizing a programming language via interactive learning",
    "authors": ["S.I. Wang", "S. Ginn", "P. Liang", "C.D. Manning."],
    "venue": "Association for Computational Linguistics (ACL).",
    "year": 2017
  }, {
    "title": "Overview of the biocreative V chemical disease relation (cdr) task",
    "authors": ["C. Wei", "Y. Peng", "R. Leaman", "A.P. Davis", "C.J. Mattingly", "J. Li", "T.C. Wiegers", "Z. Lu."],
    "venue": "Proceedings of the fifth BioCreative challenge evaluation workshop. pages 154–166.",
    "year": 2015
  }, {
    "title": "Dialog-based language learning",
    "authors": ["J.E. Weston."],
    "venue": "Advances in Neural Information Processing Systems (NIPS). pages 829–837.",
    "year": 2016
  }, {
    "title": "Modeling annotators: A generative approach to learning from annotator rationales",
    "authors": ["O.F. Zaidan", "J. Eisner."],
    "venue": "Empirical Methods in Natural Language Processing (EMNLP).",
    "year": 2008
  }, {
    "title": "Learning to parse database queries using inductive logic programming",
    "authors": ["M. Zelle", "R.J. Mooney."],
    "venue": "Association for the Advancement of Artificial Intelligence (AAAI). pages 1050–1055.",
    "year": 1996
  }, {
    "title": "Learning to map sentences to logical form: Structured classification with probabilistic categorial grammars",
    "authors": ["L.S. Zettlemoyer", "M. Collins."],
    "venue": "Uncertainty in Artificial Intelligence (UAI). pages 658–666.",
    "year": 2005
  }],
  "id": "SP:b2cede3736778279ab52b7832012a7af2b69f8d9",
  "authors": [{
    "name": "Braden Hancock",
    "affiliations": []
  }, {
    "name": "Stephanie Wang",
    "affiliations": []
  }, {
    "name": "Martin Bringmann",
    "affiliations": []
  }, {
    "name": "Percy Liang",
    "affiliations": []
  }, {
    "name": "Christopher Ré",
    "affiliations": []
  }],
  "abstractText": "Training accurate classifiers requires many labels, but each label provides only limited information (one bit for binary classification). In this work, we propose BabbleLabble, a framework for training classifiers in which an annotator provides a natural language explanation for each labeling decision. A semantic parser converts these explanations into programmatic labeling functions that generate noisy labels for an arbitrary amount of unlabeled data, which is used to train a classifier. On three relation extraction tasks, we find that users are able to train classifiers with comparable F1 scores from 5–100 faster by providing explanations instead of just labels. Furthermore, given the inherent imperfection of labeling functions, we find that a simple rule-based semantic parser suffices.",
  "title": "Training Classifiers with Natural Language Explanations"
}