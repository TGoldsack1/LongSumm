{
  "sections": [{
    "heading": "1. Introduction",
    "text": "Signal reconstruction from corrupted or incomplete measurements is an important subfield of statistical data analysis. Recent advances in deep neural networks have sparked significant interest in avoiding the traditional, explicit a priori statistical modeling of signal corruptions, and instead learning to map corrupted observations to the unobserved clean versions. This happens by training a regression model, e.g., a convolutional neural network (CNN), with a large number of pairs (x̂i, yi) of corrupted inputs x̂i and clean targets yi and minimizing the empirical risk\nargmin θ ∑ i L (fθ(x̂i), yi) , (1)\nwhere fθ is a parametric family of mappings (e.g., CNNs), under the loss function L. We use the notation x̂ to underline the fact that the corrupted input x̂ ∼ p(x̂|yi) is a random variable distributed according to the clean target. Training data may include, for example, pairs of short and long exposure photographs of the same scene, incomplete and complete k-space samplings of magnetic resonance images, fast-but-noisy and slow-but-converged ray-traced\n1NVIDIA 2Aalto University 3MIT CSAIL. Correspondence to: Jaakko Lehtinen <jlehtinen@nvidia.com>.\nProceedings of the 35 th International Conference on Machine Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018 by the author(s).\nrenderings of a synthetic scene, etc. Significant advances have been reported in several applications, including Gaussian denoising, de-JPEG, text removal (Mao et al., 2016), super-resolution (Ledig et al., 2017), colorization (Zhang et al., 2016), and image inpainting (Iizuka et al., 2017). Yet, obtaining clean training targets is often difficult or tedious: a noise-free photograph requires a long exposure; full MRI sampling precludes dynamic subjects; etc.\nIn this work, we observe that we can often learn to turn bad images into good images by only looking at bad images, and do this just as well – sometimes even better – as if we were using clean examples. Further, we require neither an explicit statistical likelihood model of the corruption nor an image prior, and instead learn these indirectly from the training data. (Indeed, in one of our examples, synthetic Monte Carlo renderings, the non-stationary noise cannot be characterized analytically.) In addition to denoising, our observation is directly applicable to inverse problems such as MRI reconstruction from undersampled data. While our conclusion is almost trivial from a statistical perspective, it significantly eases practical learned signal reconstruction by lifting requirements on availability of training data."
  }, {
    "heading": "2. Theoretical Background",
    "text": "Assume that we have a set of unreliable measurements (y1, y2, ...) of the room temperature. A common strategy for estimating the true unknown temperature is to find a number z that has the smallest average deviation from the measurements according to some loss function L:\nargmin z\nEy{L(z, y)}. (2)\nFor the L2 loss L(z, y) = (z − y)2, this minimum is found at the arithmetic mean of the observations:\nz = Ey{y}. (3)\nThe L1 loss, the sum of absolute deviations L(z, y) = |z − y|, in turn, has its optimum at the median of the observations. The general class of deviation-minimizing estimators are known as M-estimators (Huber, 1964). From a statistical viewpoint, summary estimation using these common loss functions can be seen as ML estimation by interpreting the loss function as the negative log likelihood.\nTraining neural network regressors is a generalization of this point estimation procedure. Observe the form of the typical training task for a set of input-target pairs (xi, yi), where the network function fθ(x) is parameterized by θ:\nargmin θ\nE(x,y){L(fθ(x), y)}. (4)\nIndeed, if we remove the dependency on input data, and use a trivial fθ that merely outputs a learned scalar, the task reduces to (2). Conversely, the full training task decomposes to the same minimization problem at every training sample; simple manipulations show that (4) is equivalent to\nargmin θ\nEx{Ey|x{L(fθ(x), y)}}. (5)\nThe network can, in theory, minimize this loss by solving the point estimation problem separately for each input sample. Hence, the properties of the underlying loss are inherited by neural network training.\nThe usual process of training regressors by Equation 1 over a finite number of input-target pairs (xi, yi) hides a subtle point: instead of the 1:1 mapping between inputs and targets (falsely) implied by that process, in reality the mapping is multiple-valued. For example, in a superresolution task (Ledig et al., 2017) over all natural images, a low-resolution image x can be explained by many different high-resolution images y, as knowledge about the exact positions and orientations of the edges and texture is lost in decimation. In other words, p(y|x) is the highly complex distribution of natural images consistent with the low-resolution x. Training a neural network regressor using training pairs of lowand high-resolution images using the L2 loss, the network learns to output the average of all plausible explanations (e.g., edges shifted by different amounts), which results in spatial blurriness for the network’s predictions. A significant amount of work has been done to combat this well known tendency, for example by using learned discriminator functions as losses (Ledig et al., 2017; Isola et al., 2017).\nOur observation is that for certain problems this tendency has an unexpected benefit. A trivial, and, at first sight, useless, property of L2 minimization is that on expectation, the estimate remains unchanged if we replace the targets with random numbers whose expectations match the targets. This is easy to see: Equation (3) holds, no matter what particular distribution the ys are drawn from. Consequently, the optimal network parameters θ of Equation (5) also remain unchanged, if input-conditioned target distributions p(y|x) are replaced with arbitrary distributions that have the same conditional expected values. This implies that we can, in principle, corrupt the training targets of a neural network with zero-mean noise without changing what the network learns. Combining this with the corrupted inputs from Equation 1, we are left with the empirical risk minimization task\nargmin θ ∑ i L (fθ(x̂i), ŷi) , (6)\nwhere both the inputs and the targets are now drawn from a corrupted distribution (not necessarily the same), conditioned on the underlying, unobserved clean target yi such that E{ŷi|x̂i} = yi. Given infinite data, the solution is the same as that of (1). For finite data, the variance is the average variance of the corruptions in the targets, divided by the number of training samples (see supplemental material). Interestingly, none of the above relies on a likelihood model of the corruption, nor a density model (prior) for the underlying clean image manifold. That is, we do not need an explicit p(noisy|clean) or p(clean), as long as we have data distributed according to them.\nIn many image restoration tasks, the expectation of the corrupted input data is the clean target that we seek to restore. Low-light photography is an example: a long, noise-free exposure is the average of short, independent, noisy exposures. With this in mind, the above suggests the ability to learn to remove photon noise given only pairs of noisy images, with no need for potentially expensive or difficult long exposures. Similar observations can be made about other loss functions. For instance, the L1 loss recovers the median of the targets, meaning that neural networks can be trained to repair images with significant (up top 50%) outlier content, again only requiring access to pairs of such corrupted images.\nIn the next sections, we present a wide variety of examples demonstrating that these theoretical capabilities are also efficiently realizable in practice."
  }, {
    "heading": "3. Practical Experiments",
    "text": "We now experimentally study the practical properties of noisy-target training. We start with simple noise distributions (Gaussian, Poisson, Bernoulli) in Sections 3.1 and 3.2, and continue to the much harder, analytically intractable Monte Carlo image synthesis noise (Section 3.3). In Section 3.4, we show that image reconstruction from subNyquist spectral samplings in magnetic resonance imaging (MRI) can be learned from corrupted observations only."
  }, {
    "heading": "3.1. Additive Gaussian Noise",
    "text": "We will first study the effect of corrupted targets using synthetic additive Gaussian noise. As the noise has zero mean, we use the L2 loss for training to recover the mean.\nOur baseline is a recent state-of-the-art method ”RED30” (Mao et al., 2016), a 30-layer hierarchical residual network with 128 feature maps, which has been demonstrated to be very effective in a wide range of image restoration tasks, including Gaussian noise. We train the network using 256×256-pixel crops drawn from the 50k images in\nthe IMAGENET validation set. We furthermore randomize the noise standard deviation σ ∈ [0, 50] separately for each training example, i.e., the network has to estimate the magnitude of noise while removing it (“blind” denoising).\nWe use three well-known datasets: BSD300 (Martin et al., 2001), SET14 (Zeyde et al., 2010), and KODAK1. As summarized in Table 1, the behavior is qualitatively similar in all three sets, and thus we discuss the averages. When trained using the standard way with clean targets (Equation 1), RED30 achieves 31.63± 0.02 dB with σ = 25. The confidence interval was computed by sampling five random initializations. The widely used benchmark denoiser BM3D (Dabov et al., 2007) gives ∼0.7 dB worse results. When we modify the training to use noisy targets (Equation 6) instead, the denoising performance remains equally good. Furthermore, the training converges just as quickly, as shown in Figure 1a. This leads us to conclude that clean targets are unnecessary in this application. This perhaps surprising observation holds also with different networks and network capacities. Figure 2a shows an example result.\nFor all further tests, we switch from RED30 to a shallower U-Net (Ronneberger et al., 2015) that is roughly 10× faster to train and gives similar results (−0.2 dB in Gaussian noise).\n1http://r0k.us/graphics/kodak/\nThe architecture and training parameters are described in the supplemental material.\nConvergence speed Clearly, every training example asks for the impossible: there is no way the network could succeed in transforming one instance of the noise to another. Consequently, the training loss does actually not decrease during training, and the loss gradients continue to be quite large. Why do the larger, noisier gradients not affect convergence speed? While the activation gradients are indeed noisy, the weight gradients are in fact relatively clean because Gaussian noise is independent and identically distributed (i.i.d.) in all pixels, and the weight gradients get averaged over 216 pixels in our fully convolutional network.\nFigure 1b makes the situation harder by introducing interpixel correlation to the noise. This brown additive noise is obtained by blurring white Gaussian noise by a spatial Gaussian filter of different bandwidths and scaling to retain σ = 25. An example is shown in Figure 1b. As the correlation increases, the effective averaging of weight gradients decreases, and the weight updates become noisier. This makes the convergence slower, but even with extreme blur, the eventual quality is similar (within 0.1 dB).\nFinite data and capture budget The previous studies relied on the availability of infinitely many noisy examples produced by adding synthetic noise to clean images. We now study corrupted vs. clean training data in the realistic scenario of finite data and a fixed capture budget. Our experiment setup is as follows. Let one ImageNet image with white additive Gaussian noise at σ = 25 correspond to one “capture unit” (CU). Suppose that 19 CUs are enough for a clean capture, so that one noisy realization plus the clean version (the average of 19 noisy realizations) consumes 20 CU. Let us fix a total capture budget of, say, 2000 CUs. This budget can be allocated between clean latents (N ) and noise realizations per clean latent (M ) such that N ∗M = 2000. In the traditional scenario, we have only 100 training pairs (N = 100, M = 20): a single noisy\nrealization and the corresponding clean image (= average of 19 noisy images; Figure 1c, Case 1). We first observe that using the same captured data as 100 ∗ 20 ∗ 19 = 38000 training pairs with corrupted targets — i.e., for each latent, forming all the 19 ∗ 20 possible noisy/clean pairs — yields notably better results (several .1s of dB) than the traditional, fixed noisy+clean pairs, even if we still only have N = 100 latents (Figure 1c, Case 2). Second, we observe that setting N = 1000 and M = 2, i.e., increasing the number of clean latents but only obtaining two noisy realizations of each (resulting in 2000 training pairs) yields even better results (again, by several .1s of dB, Figure 1c, Case 3).\nWe conclude that for additive Gaussian noise, corrupted targets offer benefits — not just the same performance but better — over clean targets on two levels: both 1) seeing more realizations of the corruption for the same latent clean image, and 2) seeing more latent clean images, even if just two corrupted realizations of each, are beneficial."
  }, {
    "heading": "3.2. Other Synthetic Noises",
    "text": "We will now experiment with other types of synthetic noise. The training setup is the same as described above.\nPoisson noise is the dominant source of noise in photographs. While zero-mean, it is harder to remove because it is signal-dependent. We use the L2 loss, and vary the noise magnitude λ ∈ [0, 50] during training. Training with clean targets results in 30.59± 0.02 dB, while noisy targets give an equally good 30.57 ± 0.02 dB, again at similar convergence speed. A comparison method (Mäkitalo & Foi, 2011) that first transforms the input Poisson noise into Gaussian (Anscombe transform), then denoises by BM3D, and finally inverts the transform, yields 2 dB less.\nOther effects, e.g., dark current and quantization, are dominated by Poisson noise, can be made zero-mean (Hasinoff et al., 2016), and hence pose no problems for training with noisy targets. We conclude that noise-free training data is unnecessary in this application. That said, saturation (gamut clipping) renders the expectation incorrect due to removing part of the distribution. As saturation is unwanted for other reasons too, this is not a significant limitation.\nMultiplicative Bernoulli noise (aka binomial noise) constructs a random mask m that is 1 for valid pixels and 0 for zeroed/missing pixels. To avoid backpropagating gradients from missing pixels, we exclude them from the loss:\nargmin θ ∑ i (m (fθ(x̂i)− ŷi))2, (7)\nas described by Ulyanov et al. (2017) in the context of their deep image prior (DIP).\nThe probability of corrupted pixels is denoted with p; in our training we vary p ∈ [0.0, 0.95] and during testing p = 0.5.\nTraining with clean targets gives an average of 31.85 ± 0.03 dB, noisy targets (separate m for input and target) give a slightly higher 32.02 ± 0.03 dB, possibly because noisy targets effectively implement a form of dropout (Srivastava et al., 2014) at the network output. DIP was almost 2 dB worse – DIP is not a learning-based solution, and as such very different from our approach, but it shares the property that neither clean examples nor an explicit model of the corruption is needed. We used the “Image reconstruction” setup as described in the DIP supplemental material.2\nText removal Figure 3 demonstrates blind text removal. The corruption consists of a large, varying number of random strings in random places, also on top of each other, and furthermore so that the font size and color are randomized as well. The font and string orientation remain fixed.\nThe network is trained using independently corrupted input and target pairs. The probability of corrupted pixels p is approximately [0, 0.5] during training, and p ≈ 0.25 during\n2https://dmitryulyanov.github.io/deep image prior\ntesting. In this test the mean (L2 loss) is not the correct answer because the overlaid text has colors unrelated to the actual image, and the resulting image would incorrectly tend towards a linear combination of the right answer and the average text color (medium gray). However, with any reasonable amount of overlaid text, a pixel retains the original color more often than not, and therefore the median is the correct statistic. Hence, we use L1 = |fθ(x̂)− ŷ| as the loss function. Figure 3 shows an example result.\nRandom-valued impulse noise replaces some pixels with noise and retains the colors of others. Instead of the standard\nsalt and pepper noise (randomly replacing pixels with black or white), we study a harder distribution where each pixel is replaced with a random color drawn from the uniform distribution [0, 1]3 with probability p and retains its color with probability 1− p. The pixels’ color distributions are a Dirac at the original color plus a uniform distribution, with relative weights given by the replacement probability p. In this case, neither the mean nor the median yield the correct result; the desired output is the mode of the distribution (the Dirac spike). The distribution remains unimodal. For approximate mode seeking, we use an annealed version of the “L0 loss” function defined as (|fθ(x̂) − ŷ| + )γ , where = 10−8, where γ is annealed linearly from 2 to 0 during training. This annealing did not cause any numerical issues in our tests. The relationship of the L0 loss and mode seeking is analyzed in the supplement.\nWe again train the network using noisy inputs and noisy targets, where the probability of corrupted pixels is randomized separately for each pair from [0, 0.95]. Figure 4 shows the inference results when 70% input pixels are randomized. Training with L2 loss biases the results heavily towards gray, because the result tends towards a linear combination the\ncorrect answer and and mean of the uniform random corruption. As predicted by theory, the L1 loss gives good results as long as fewer than 50% of the pixels are randomized, but beyond that threshold it quickly starts to bias dark and bright areas towards gray (Figure 5). L0, on the other hand, shows little bias even with extreme corruptions (e.g. 90% pixels), because of all the possible pixel values, the correct answer (e.g. 10%) is still the most common."
  }, {
    "heading": "3.3. Monte Carlo Rendering",
    "text": "Physically accurate renderings of virtual environments are most often generated through a process known as Monte Carlo path tracing. This amounts to drawing random sequences of scattering events (“light paths”) in the scene that connect light sources and virtual sensors, and integrating the radiance carried by them over all possible paths (Veach & Guibas, 1995). The Monte Carlo integrator is constructed such that the intensity of each pixel is the expectation of the random path sampling process, i.e., the sampling noise is zero-mean. However, despite decades of research into importance sampling techniques, little else can be said about the distribution. It varies from pixel to pixel, heavily depends on the scene configuration and rendering parameters, and can be arbitrarily multimodal. Some lighting effects, such as focused caustics, also result in extremely long-tailed distributions with rare, bright outliers.\nAll of these effects make the removal of Monte Carlo noise much more difficult than removing, e.g., Gaussian noise. On the other hand, the problem is somewhat alleviated by the possibility of generating auxiliary information that has been empirically found to correlate with the clean result during data generation. In our experiments, the denoiser input consists of not only the per-pixel luminance values, but also the average albedo (i.e., texture color) and normal vector of the surfaces visible at each pixel.\nHigh dynamic range (HDR) Even with adequate sampling, the floating-point pixel luminances may differ from each other by several orders of magnitude. In order to construct an image suitable for the generally 8-bit display devices, this high dynamic range needs to be compressed to a fixed range using a tone mapping operator (Cerdá-Company et al., 2016). We use a variant of Reinhard’s global operator (Reinhard et al., 2002): T (v) = (v/(1 + v))1/2.2, where v is a scalar luminance value, possibly pre-scaled with an image-wide exposure constant. This operator maps any v ≥ 0 into range 0 ≤ T (v) < 1.\nThe combination of virtually unbounded range of luminances and the nonlinearity of operator T poses a problem. If we attempt to train a denoiser that outputs luminance values v, a standard MSE loss L2 = (fθ(x̂)− ŷ)2 will be dominated by the long-tail effects (outliers) in the targets, and training does not converge. On the other hand, if the\ndenoiser were to output tonemapped values T (v), the nonlinearity of T would make the expected value of noisy target images E{T (v)} different from the clean training target T (E{v}), leading to incorrect predictions.\nA metric often used for measuring the quality of HDR images is the relative MSE (Rousselle et al., 2011), where the squared difference is divided by the square of approximate luminance of the pixel, i.e., (fθ(x̂)− ŷ)2/(ŷ + )2. However, this metric suffers from the same nonlinearity problem as comparing of tonemapped outputs. Therefore, we propose to use the network output, which tends towards the correct value in the limit, in the denominator: LHDR = (fθ(x̂)− ŷ)2/(fθ(x̂) + 0.01)2. It can be shown that LHDR converges to the correct expected value as long as we consider the gradient of the denominator to be zero.\nFinally, we have observed that it is beneficial to tone map the input image T (x̂) instead of using HDR inputs. The network continues to output non-tonemapped (linear-scale) luminance values, retaining the correctness of the expected value. Figure 6 evaluates the different loss functions.\nDenoising Monte Carlo rendered images We trained a denoiser for Monte Carlo path traced images rendered using 64 samples per pixel (spp). Our training set consisted of 860 architectural images, and the validation was done using 34 images from a different set of scenes. Three versions of the training images were rendered: two with 64 spp using different random seeds (noisy input, noisy target), and one with 131k spp (clean target). The validation images were rendered in both 64 spp (input) and 131k spp (reference) versions. All images were 960×540 pixels in size, and as mentioned earlier, we also saved the albedo and normal buffers for all of the input images. Even with such a small dataset, rendering the 131k spp clean images was a strenuous effort — for example, Figure 7d took 40 minutes to render on a high-end graphics server with 8 × NVIDIA Tesla P100 GPUs and a 40-core Intel Xeon CPU.\nThe average PSNR of the 64 spp validation inputs with respect to the corresponding reference images was 22.31 dB (see Figure 7a for an example). The network trained for 2000 epochs using clean target images reached an average PSNR of 31.83 dB on the validation set, whereas the similarly trained network using noisy target images gave 0.5 dB less. Examples are shown in Figure 7b,c – the training took 12 hours with a single NVIDIA Tesla P100 GPU.\nAt 4000 epochs, the noisy targets matched 31.83 dB, i.e., noisy targets took approximately twice as long to converge. However, the gap between the two methods had not narrowed appreciably, leading us to believe that some quality difference will remain even in the limit. This is not surprising, since the training dataset contained only a limited number of training pairs (and thus noise realizations) due\nPSNR\nto the cost of generating the clean target images, and we wanted to test both methods using matching data. That said, given that noisy targets are 2000 times faster to produce, one could trivially produce a larger quantity of them and still realize vast gains. The finite capture budget study (Section 3.1) supports this hypothesis.\nOnline training Since it can be tedious to collect a sufficiently large corpus of Monte Carlo images for training a generally applicable denoiser, a possibility is to train a model specific to a single 3D scene, e.g., a game level or a movie shot (Chaitanya et al., 2017). In this context, it can even be desirable to train on-the-fly while walking through\nthe scene. In order to maintain interactive frame rates, we can afford only few samples per pixel, and thus both input and target images will be inherently noisy.\nFigure 8 shows the convergence plots for an experiment where we trained a denoiser from scratch for the duration of 1000 frames in a scene flythrough. On an NVIDIA Titan V GPU, path tracing a single 512×512 pixel image with 8 spp took 190 ms, and we rendered two images to act as input and target. A single network training iteration with a random 256×256 pixel crop took 11.25 ms and we performed eight of them per frame. Finally, we denoised both rendered images, each taking 15 ms, and averaged the result to produce the final image shown to the user. Rendering, training and inference took 500 ms/frame.\nFigure 8 shows that training with clean targets does not perform appreciably better than noisy targets. As rendering a single clean image takes approx. 7 minutes in this scene (resp. 190 ms for a noisy target), the quality/time tradeoff clearly favors noisy targets."
  }, {
    "heading": "3.4. Magnetic Resonance Imaging (MRI)",
    "text": "Magnetic Resonance Imaging (MRI) produces volumetric images of biological tissues essentially by sampling the Fourier transform (the “k-space”) of the signal. Modern MRI techniques have long relied on compressed sensing\n(CS) to cheat the Nyquist-Shannon limit: they undersample k-space, and perform non-linear reconstruction that removes aliasing by exploiting the sparsity of the image in a suitable transform domain (Lustig et al., 2008).\nWe observe that if we turn the k-space sampling into a random process with a known probability density p(k) over the frequencies k, our main idea applies. In particular, we model the k-space sampling operation as a Bernoulli process where each individual frequency has a probability p(k) = e−λ|k| of being selected for acquisition.3 The frequencies that are retained are weighted by the inverse of the selection probability, and non-chosen frequencies are set to zero. Clearly, the expectation of this “Russian roulette” process is the correct spectrum. The parameter λ controls the overall fraction of k-space retained; in the following experiments, we choose it so that 10% of the samples are retained relative to a full Nyquist-Shannon sampling. The undersampled spectra are transformed to the primal image domain by the standard inverse Fourier transform. An example of an undersampled input/target picture, the corresponding fully sampled reference, and their spectra, are shown in Figure 9(a, d).\nNow we simply set up a regression problem of the form (6) and train a convolutional neural network using pairs of two independent undersampled images x̂ and ŷ of the same volume. As the spectra of the input and target are correct on expectation, and the Fourier transform is linear, we use the L2 loss. Additionally, we improve the result slightly by enforcing the exact preservation of frequencies that are present in the input image x̂ by Fourier transforming the result fθ(x̂), replacing the frequencies with those from the input, and transforming back to the primal domain before computing the loss: the final loss reads (F−1(Rx̂(F(fθ(x̂)))) − ŷ)2, where R denotes the replacement of non-zero frequencies from the input. This process is trained end-to-end.\nWe perform experiments on 2D slices extracted from the IXI brain scan MRI dataset.4 To simulate spectral sampling, we draw random samples from the FFT of the (already reconstructed) images in the dataset. Hence, in deviation from actual MRI samples, our data is real-valued and has the periodicity of the discrete FFT built-in. The training set contained 4936 images in 256×256 resolution from 50 subjects, and for validation we chose 500 random images from 10 different subjects. The baseline PSNR of the sparsely-sampled input images was 20.03 dB when reconstructed directly using IFFT. The network trained for 300 epochs with noisy targets reached an average PSNR of 31.10 dB on the validation data, and the network trained with clean targets reached\n3Our simplified example deviates from practical MRI in the sense that we do not sample the spectra along 1D trajectories. However, we believe that designing pulse sequences that lead to similar pseudo-random sampling characteristics is straightforward.\n4http://brain-development.org/ixi-dataset→ T1 images.\n31.14 dB. Here the training with clean targets is similar to prior art (Wang et al., 2016; Lee et al., 2017). Training took 13 hours on an NVIDIA Tesla P100 GPU. Figure 9(b, c) shows an example of reconstruction results between convolutional networks trained with noisy and clean targets, respectively. In terms of PSNR, our results quite closely match those reported in recent work."
  }, {
    "heading": "4. Discussion",
    "text": "We have shown that simple statistical arguments lead to new capabilities in learned signal recovery using deep neural networks; it is possible to recover signals under complex corruptions without observing clean signals, without an explicit statistical characterization of the noise or other corruption, at performance levels equal or close to using clean target data. That clean data is not necessary for denoising is not a new observation: indeed, consider, for instance, the classic BM3D algorithm (Dabov et al., 2007) that draws on self-similar patches within a single noisy image. We show that the previously-demonstrated high restoration performance of deep neural networks can likewise be achieved entirely without clean data, all based on the same generalpurpose deep convolutional model. This points the way to significant benefits in many applications by removing the need for potentially strenuous collection of clean data.\nAmbientGAN (Ashish Bora, 2018) trains generative adversarial networks (Goodfellow et al., 2014) using corrupted observations. In contrast to our approach, AmbientGAN needs an explicit forward model of the corruption. We find combining ideas along both paths intriguing."
  }, {
    "heading": "Acknowledgments",
    "text": "Bill Dally, David Luebke, Aaron Lefohn for discussions and supporting the research; NVIDIA Research staff for suggestions and discussion; Runa Lober and Gunter Sprenger for synthetic off-line training data; Jacopo Pantaleoni for the interactive renderer used in on-line training; Samuli Vuorinen for initial photography test data; Koos Zevenhoven for discussions on MRI; Peyman Milanfar for helpful comments."
  }],
  "year": 2018,
  "references": [{
    "title": "AmbientGAN: Generative models from lossy measurements",
    "authors": ["Ashish Bora", "Eric Price", "Alexandros G. Dimakis"],
    "year": 2018
  }, {
    "title": "Which tone-mapping operator is the best? A comparative study of perceptual quality",
    "authors": ["Cerdá-Company", "Xim", "Párraga", "C. Alejandro", "Otazu", "Xavier"],
    "year": 2016
  }, {
    "title": "Image denoising by sparse 3-D transform-domain collaborative filtering",
    "authors": ["K. Dabov", "A. Foi", "V. Katkovnik", "K. Egiazarian"],
    "venue": "IEEE Trans. Image Process.,",
    "year": 2007
  }, {
    "title": "Generative Adversarial Networks",
    "authors": ["Goodfellow", "Ian", "Pouget-Abadie", "Jean", "Mirza", "Mehdi", "Xu", "Bing", "Warde-Farley", "David", "Ozair", "Sherjil", "Courville", "Aaron", "Bengio", "Yoshua"],
    "venue": "In NIPS,",
    "year": 2014
  }, {
    "title": "Burst photography for high dynamic range and low-light imaging on mobile cameras",
    "authors": ["Hasinoff", "Sam", "Sharlet", "Dillon", "Geiss", "Ryan", "Adams", "Andrew", "Barron", "Jonathan T", "Kainz", "Florian", "Chen", "Jiawen", "Levoy", "Marc"],
    "venue": "ACM Trans. Graph.,",
    "year": 2016
  }, {
    "title": "Robust estimation of a location parameter",
    "authors": ["Huber", "Peter J"],
    "venue": "Ann. Math. Statist.,",
    "year": 1964
  }, {
    "title": "Globally and locally consistent image completion",
    "authors": ["Iizuka", "Satoshi", "Simo-Serra", "Edgar", "Ishikawa", "Hiroshi"],
    "venue": "ACM Trans. Graph.,",
    "year": 2017
  }, {
    "title": "Image-to-image translation with conditional adversarial networks",
    "authors": ["Isola", "Phillip", "Zhu", "Jun-Yan", "Zhou", "Tinghui", "Efros", "Alexei A"],
    "venue": "In Proc. CVPR",
    "year": 2017
  }, {
    "title": "Deep residual learning for compressed sensing MRI",
    "authors": ["D. Lee", "J. Yoo", "J.C. Ye"],
    "venue": "In Proc. IEEE 14th International Symposium on Biomedical Imaging (ISBI 2017),",
    "year": 2017
  }, {
    "title": "Compressed sensing MRI",
    "authors": ["Lustig", "Michael", "Donoho", "David L", "Santos", "Juan M", "Pauly", "John M"],
    "venue": "In IEEE Signal Processing Magazine,",
    "year": 2008
  }, {
    "title": "Image restoration using convolutional auto-encoders with symmetric skip connections",
    "authors": ["Mao", "Xiao-Jiao", "Shen", "Chunhua", "Yang", "Yu-Bin"],
    "venue": "In Proc. NIPS,",
    "year": 2016
  }, {
    "title": "A database of human segmented natural images and its application to evaluating segmentation algorithms and measuring ecological statistics",
    "authors": ["D. Martin", "C. Fowlkes", "D. Tal", "J. Malik"],
    "venue": "In Proc. ICCV,",
    "year": 2001
  }, {
    "title": "Optimal inversion of the Anscombe transformation in low-count Poisson image denoising",
    "authors": ["Mäkitalo", "Markku", "Foi", "Alessandro"],
    "venue": "IEEE Trans. Image Process.,",
    "year": 2011
  }, {
    "title": "Photographic tone reproduction for digital images",
    "authors": ["Reinhard", "Erik", "Stark", "Michael", "Shirley", "Peter", "Ferwerda", "James"],
    "venue": "ACM Trans. Graph.,",
    "year": 2002
  }, {
    "title": "U-net: Convolutional networks for biomedical image segmentation",
    "authors": ["Ronneberger", "Olaf", "Fischer", "Philipp", "Brox", "Thomas"],
    "venue": "MICCAI, 9351:234–241,",
    "year": 2015
  }, {
    "title": "Adaptive sampling and reconstruction using greedy error minimization",
    "authors": ["Rousselle", "Fabrice", "Knaus", "Claude", "Zwicker", "Matthias"],
    "venue": "ACM Trans. Graph.,",
    "year": 2011
  }, {
    "title": "Dropout: A simple way to prevent neural networks from overfitting",
    "authors": ["Srivastava", "Nitish", "Hinton", "Geoffrey", "Krizhevsky", "Alex", "Sutskever", "Ilya", "Salakhutdinov", "Ruslan"],
    "venue": "Journal of Machine Learning Research,",
    "year": 2014
  }, {
    "title": "Optimally combining sampling techniques for Monte Carlo rendering",
    "authors": ["Veach", "Eric", "Guibas", "Leonidas J"],
    "venue": "In Proc. ACM SIGGRAPH",
    "year": 1995
  }, {
    "title": "Accelerating magnetic resonance imaging via deep learning",
    "authors": ["S. Wang", "Z. Su", "L. Ying", "X. Peng", "S. Zhu", "F. Liang", "D. Feng", "D. Liang"],
    "venue": "In Proc. IEEE 13th International Symposium on Biomedical Imaging (ISBI),",
    "year": 2016
  }, {
    "title": "On single image scaleup using sparse-representations",
    "authors": ["R. Zeyde", "M. Elad", "M. Protter"],
    "venue": "In Proc. Curves and Surfaces: 7th International Conference,",
    "year": 2010
  }, {
    "title": "Colorful image colorization",
    "authors": ["Zhang", "Richard", "Isola", "Phillip", "Efros", "Alexei A"],
    "venue": "In Proc. ECCV,",
    "year": 2016
  }],
  "id": "SP:3d133b9d66e500948cae6e336402e31627655396",
  "authors": [{
    "name": "Jaakko Lehtinen",
    "affiliations": []
  }, {
    "name": "Jacob Munkberg",
    "affiliations": []
  }, {
    "name": "Jon Hasselgren",
    "affiliations": []
  }, {
    "name": "Samuli Laine",
    "affiliations": []
  }, {
    "name": "Tero Karras",
    "affiliations": []
  }, {
    "name": "Miika Aittala",
    "affiliations": []
  }, {
    "name": "Timo Aila",
    "affiliations": []
  }],
  "abstractText": "We apply basic statistical reasoning to signal reconstruction by machine learning – learning to map corrupted observations to clean signals – with a simple and powerful conclusion: it is possible to learn to restore images by only looking at corrupted examples, at performance at and sometimes exceeding training using clean data, without explicit image priors or likelihood models of the corruption. In practice, we show that a single model learns photographic noise removal, denoising synthetic Monte Carlo images, and reconstruction of undersampled MRI scans – all corrupted by different processes – based on noisy data only.",
  "title": "Noise2Noise: Learning Image Restoration without Clean Data"
}