{
  "sections": [{
    "heading": "1. Introduction",
    "text": "Nowadays, the Recurrent Neural Network (RNN), especially its more advanced variants such as the LSTM and the GRU, belong to the most successful machine learning approaches when it comes to sequence modeling. Especially in Natural Language Processing (NLP), great improvements have been achieved by exploiting these Neu-\n1Ludwig Maximilian University of Munich, Germany 2Siemens AG, Corporate Technology, Germany. Correspondence to: Yinchong Yang <yinchong.yang@siemens.com>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\nral Network architectures. This success motivates efforts to also apply these RNNs to video data, since a video clip could be seen as a sequence of image frames. However, plain RNN models turn out to be impractical and difficult to train directly on video data due to the fact that each image frame typically forms a relatively high-dimensional input, which makes the weight matrix mapping from the input to the hidden layer in RNNs extremely large. For instance, in case of an RGB video clip with a frame size of say 160×120×3, the input vector for the RNN would already be 57, 600 at each time step. In this case, even a small hidden layer consisting of only 100 hidden nodes would lead to 5,760,000 free parameters, only considering the inputto-hidden mapping in the model.\nIn order to circumvent this problem, state-of-the-art approaches often involve pre-processing each frame using Convolution Neural Networks (CNN), a Neural Network model proven to be most successful in image modeling. The CNNs do not only reduce the input dimension, but can also generate more compact and informative representations that serve as input to the RNN. Intuitive and tempting as it is, training such a model from scratch in an endto-end fashion turns out to be impractical for large video datasets. Thus, many current works following this concept focus on the CNN part and reduce the size of RNN in term of sequence length (Donahue et al., 2015; Srivastava et al., 2015), while other works exploit pre-trained deep CNNs as pre-processor to generate static features as input to RNNs (Yue-Hei Ng et al., 2015; Donahue et al., 2015; Sharma et al., 2015). The former approach neglects the capability of RNNs to handle sequences of variable lengths and therefore does not scale to larger, more realistic video data. The second approach might suffer from suboptimal weight parameters by not being trained end-to-end (Fernando & Gould, 2016). Furthermore, since these CNNs are pretrained on existing image datasets, it remains unclear how well the CNNs can generalize to video frames that could be of totally different nature from the image training sets.\nAlternative approaches were earlier applied to generate image representations using dimension reductions such as PCA (Zhang et al., 1997; Kambhatla & Leen, 1997; Ye et al., 2004) and Random Projection (Bingham & Mannila, 2001). Classifiers were built on such features to perform object and face recognition tasks. These models, however,\nare often restricted to be linear and cannot be trained jointly with the classifier.\nIn this work, we pursue a new direction where the RNN is exposed to the raw pixels on each frame without any CNN being involved. At each time step, the RNN first maps the large pixel input to a latent vector in a typically much lower dimensional space. Recurrently, each latent vector is then enriched by its predecessor at the last time step with a hidden-to-hidden mapping. In this way, the RNN is expected to capture the inter-frame transition patterns to extract the representation for the entire sequence of frames, analogous to RNNs generating a sentence representation based on word embeddings in NLP (Sutskever et al., 2014). In comparison with other mapping techniques, a direct input-to-hidden mapping in an RNN has several advantages. First it is much simpler to train than deep CNNs in an end-to-end fashion. Secondly it is exposed to the complete pixel input without the linear limitation as PCA and Random Projection. Thirdly and most importantly, since the input-to-hidden and hidden-to-hidden mappings are trained jointly, the RNN is expected to capture the correlation between spatial and temporal patterns.\nTo address the issue of having too large of a weight matrix for the input-to-hidden mapping in RNN models, we propose to factorize the matrix with the Tensor-Train decomposition (Oseledets, 2011). In (Novikov et al., 2015) the Tensor-Train has been applied to factorize a fullyconnected feed-forward layer that can consume image pixels as well as latent features. We conducted experiments on three large-scale video datasets that are popular benchmarks in the community, and give empirical proof that the proposed approach makes very simple RNN architectures competitive with the state-of-the-art models, even though they are of several orders of magnitude lower complexity.\nThe rest of the paper is organized as follows: In Section 2 we summarize the state-of-the-art works, especially in video classification using Neural Network models and the tensorization of weight matrices. In Section 3 we first introduce the Tensor-Train model and then provide a detailed derivation of our proposed Tensor-Train RNNs. In Section 4 we present our experimental results on three large scale video datasets. Finally, Section 5 serves as a wrap-up of our current contribution and provides an outlook of future work.\nNotation We index an entry in a d-dimensional tensor A ∈ Rp1×p2×...×pd using round parentheses such as A(l1, l2, ..., ld) ∈ R and A(l1) ∈ Rp2×p3×...×pd , when we only write the first index. Similarly, we also use A(l1, l2) ∈ Rp3×p4×...×pd to refer to the sub-tensor specified by two indices l1 and l2."
  }, {
    "heading": "2. Related Works",
    "text": "The current approaches to model video data are closely related to models for image data. A large majority of these works use deep CNNs to process each frame as image, and aggregate the CNN outputs. (Karpathy et al., 2014) proposes multiple fusion techniques such as Early, Late and Slow Fusions, covering different aspects of the video. This approach, however, does not fully take the order of frames into account. (Yue-Hei Ng et al., 2015) and (Fernando & Gould, 2016) apply global pooling of frame-wise CNNs, before feeding the aggregated information to the final classifier. An intuitive and appealing idea is to fuse these frame-wise spatial representations learned by CNNs using RNNs. The major challenge, however, is the computation complexity; and for this reason multiple compromises in the model design have to be made: (Srivastava et al., 2015) restricts the length of the sequences to be 16, while (Sharma et al., 2015) and (Donahue et al., 2015) use pre-trained CNNs. (Shi et al., 2015) proposed a more compact solution that applies convolutional layers as input-tohidden and hidden-to-hidden mapping in LSTM. However, they did not show its performance on large-scale video data. (Simonyan & Zisserman, 2014) applied two stacked CNNs, one for spatial features and the other for temporal ones, and fused the outcomes of both using averaging and a Support-Vector Machine as classifier. This approach is further enhanced with Residual Networks in (Feichtenhofer et al., 2016). To the best of our knowledge, there has been no published work on applying pure RNN models to video classification or related tasks.\nThe Tensor-Train was first introduced by (Oseledets, 2011) as a tensor factorization model with the advantage of being capable of scaling to an arbitrary number of dimensions. (Novikov et al., 2015) showed that one could reshape a fully connected layer into a high-dimensional tensor and then factorize this tensor using Tensor-Train. This was applied to compress very large weight matrices in deep Neural Networks where the entire model was trained end-toend. In these experiments they compressed fully connected layers on top of convolution layers, and also proved that a Tensor-Train Layer can directly consume pixels of image data such as CIFAR-10, achieving the best result among all known non-convolutional models. Then in (Garipov et al., 2016) it was shown that even the convolutional layers themselves can be compressed with Tensor-Train Layers. Actually, in an earlier work by (Lebedev et al., 2014) a similar approach had also been introduced, but their CP factorization is calculated in a pre-processing step and is only fine tuned with error back propagation as a post processing step.\n(Koutnik et al., 2014) performed two sequence classification tasks using multiple RNN architectures of relatively low dimensionality: The first task was to classify spoken\nwords where the input sequence had a dimension of 13 channels. In the second task, RNNs were trained to classify handwriting based on the time-stamped 4D spatial features. RNNs have been also applied to classify the sentiment of a sentence such as in the IMDB reviews dataset (Maas et al., 2011). In this case, the word embeddings form the input to RNN models and they may have a dimension of a few hundreds. The sequence classification model can be seen as a special case of the Encoder-Decoder-Framework (Sutskever et al., 2014) in the sense that a classifier decodes the learned representation for the entire sequence into a probabilistic distribution over all classes."
  }, {
    "heading": "3. Tensor-Train RNN",
    "text": "In this section, we first give an introduction to the core ingredient of our proposed approach, i.e., the Tensor-Train Factorization, and then use this to formulate a so-called Tensor-Train Layer (Novikov et al., 2015) which replaces the weight matrix mapping from the input vector to the hidden layer in RNN models. We emphasize that such a layer is learned end-to-end, together with the rest of the RNN in a very efficient way."
  }, {
    "heading": "3.1. Tensor-Train Factorization",
    "text": "A Tensor-Train Factorization (TTF) is a tensor factorization model that can scale to an arbitrary number of dimensions. Assuming a d-dimensional target tensor of the form A ∈ Rp1×p2×...×pd , it can be factorized in form of:\nÂ(l1, l2, ..., ld) TTF = G1(l1) G2(l2) ... Gd(ld) (1)\nwhere\nGk ∈ Rpk×rk−1×rk , lk ∈ [1, pk] ∀k ∈ [1, d] and r0 = rd = 1.\n(2)\nAs Eq. 1 suggests, each entry in the target tensor is represented as a sequence of matrix multiplications. The set of tensors {Gk}dk=1 are usually called core-tensors. The complexity of the TTF is determined by the ranks [r0, r1, ..., rd]. We demonstrate this calculation also in Fig. 1. Please note that the dimensions and core-tensors are indexed from 1 to d while the rank index starts from 0; also note that the first and last ranks are both restricted to be 1, which implies that the first and last core tensors can be seen as matrices so that the outcome of the chain of multiplications in Eq. 1 is always a scalar.\nIf one imposes the constraint that each integer pk as in Eq. (1) can be factorized as pk = mk · nk ∀k ∈ [1, d], and consequently reshapes each Gk into G∗k ∈ Rmk×nk×rk−1×rk , then each index lk in Eq. (1) and (2) can be uniquely rep-\nresented with two indices (ik, jk), i.e.\nik = b lk nk c, jk = lk − nkb lk nk c, (3) so that Gk(lk) = G∗k(ik, jk) ∈ Rrk−1×rk . (4)\nCorrespondingly, the factorization for the tensor A ∈ R(m1·n1)×(m2·n2)×...×(md·nd) can be rewritten equivalently to Eq.(1):\nÂ((i1, j1), (i2, j2), ..., (id, jd)) TTF = G∗1(i1, j1) G ∗ 2(i2, j2) ... G ∗ d(id, jd).\n(5)\nThis double index trick (Novikov et al., 2015) enables the factorizing of weight matrices in a feed-forward layer as described next."
  }, {
    "heading": "3.2. Tensor-Train Factorization of a Feed-Forward Layer",
    "text": "Here we factorize the weight matrix W of a fullyconnected feed-forward layer denoted in ŷ = Wx+ b.\nFirst we rewrite this layer in an equivalent way with scalars as:\nŷ(j) = M∑ i=1 W (i, j) · x(i) + b(j) ∀j ∈ [1, N ] and with x ∈ RM , y ∈ RN .\n(6)\nThen, if we assume that M = ∏d\nk=1mk, N =∏d k=1 nk i.e. both M and N can be factorized into two integer arrays of the same length, then we can reshape the input vector x and the output vector ŷ into two tensors with the same number of dimensions: X ∈ Rm1×m2×...×md ,Y ∈ Rn1×n2×...×nd , and the mapping function Rm1×m2×...×md → Rn1×n2×...×nd can be written as:\nŶ(j1, j2, ..., jd)\n= m1∑ i1=1 m2∑ i2=1 ... md∑ id=1 W((i1, j1), (i2, j2), ..., (id, jd))·\nX (i1, i2, ..., id) +B(j1, j2, ..., jd). (7)\nNote that Eq. (6) can be seen as a special case of Eq. (7) with d = 1. The d-dimensional double-indexed tensor of weights W in Eq.(7) can be replaced by its TTF representation:\nŴ((i1, j1), (i2, j2), ..., (id, jd)) TTF = G∗1(i1, j1) G ∗ 2(i2, j2) ... G ∗ d(id, jd).\n(8)\nNow instead of explicitly storing the full tensor W of size∏d k=1mk·nk =M ·N , we only store its TT-format, i.e., the\nset of low-rank core tensors {Gk}dk=1 of size ∑d\nk=1mk · nk · rk−1 · rk, which can approximately reconstruct W .\nThe forward pass complexity (Novikov et al., 2015) for one scalar in the output vector indexed by (j1, j2, ..., jd) turns out to beO(d ·m̃ · r̃2). Since one needs an iteration through all such tuples, yielding O(ñd), the total complexity for one Feed-Forward-Pass can be expressed as O(d · m̃ · r̃2 · ñd), where m̃ = maxk∈[1,d]mk, ñ = maxk∈[1,d] nk, r̃ = maxk∈[1,d] rk. This, however, would be O(M · N) for a fully-connected layer.\nOne could also compute the compression rate as the ratio between the number of weights in a fully connected layer and that in its compressed form as:\nr = ∑d k=1mknkrk−1rk∏d\nk=1mknk . (9)\nFor instance, an RGB frame of size 160 × 120 × 3 implies an input vector of length 57,600. With a hidden layer of size, say, 256 one would need a weight matrix consisting of 14,745,600 free parameters. On the other hand, a TTL that factorizes the input dimension with 8×20×20×18 is able to represent this matrix using 2,976 parameters with a TT-rank of 4, or 4,520 parameters with a TT-rank of 5 (Tab. 1), yielding compression rates of 2.0e-4 and 3.1e-4, respectively.\nFor the rest of the paper, we term a fully-connected layer in form of ŷ = Wx + b, whose weight matrix W is factorized with TTF, a Tensor-Train Layer (TTL) and use the notation\nŷ = TTL(W , b,x), or TTL(W ,x) (10)\nwhere in the second case no bias is required. Please also note that, in contrast to (Lebedev et al., 2014) where the weight tensor is firstly factorized using non-linear LeastSquare method and then fine-tuned with Back-Propagation, the TTL is always trained end-to-end. For details on the gradients calculations please refer to Section 5 in (Novikov et al., 2015)."
  }, {
    "heading": "3.3. Tensor-Train RNN",
    "text": "In this work we investigate the challenge of modeling highdimensional sequential data with RNNs. For this reason,\nwe factorize the matrix mapping from the input to the hidden layer with a TTL. For an Simple RNN (SRNN), which is also known as the Elman Network, this mapping is realized as a vector-matrix multiplication, whilst in case of LSTM and GRU, we consider the matrices that map from the input vector to the gating units:"
  }, {
    "heading": "TT-GRU:",
    "text": "r[t] = σ(TTL(W r,x[t]) +U rh[t−1] + br)\nz[t] = σ(TTL(W z,x[t]) +Uzh[t−1] + bz)\nd[t] = tanh(TTL(W d,x[t]) +Ud(r[t] ◦ h[t−1]))\nh[t] = (1− z[t]) ◦ h[t−1] + z[t] ◦ d[t],\n(11)"
  }, {
    "heading": "TT-LSTM:",
    "text": "k[t] = σ(TTL(W k,x[t]) +Ukh[t−1] + bk)\nf [t] = σ(TTL(W f ,x[t]) +Ufh[t−1] + bf )\no[t] = σ(TTL(W o,x[t]) +Uoh[t−1] + bo)\ng[t] = tanh(TTL(W g,x[t]) +Ugh[t−1] + bg)\nc[t] = f [t] ◦ c[t−1] + k[t] ◦ g[t]\nh[t] = o[t] ◦ tanh(c[t]).\n(12)\nOne can see that LSTM and GRU require 4 and 3 TTLs, respectively, one for each of the gating units. Instead of calculating these TTLs successively (which we call vanilla TT-LSTM and vanilla TT-GRU), we increase n1 —the first 1 of the factors that form the output size N = ∏d k=1 nk in a TTL— by a factor of 4 or 3, and concatenate all the gates as one output tensor, thus parallelizing the computation. This trick, inspired by the implementation of standard LSTM and GRU in (Chollet, 2015), can further reduce the number of parameters, where the concatenation is actually participating in the tensorization. The compression rate for the input-to-hidden weight matrix W now becomes\nr∗ =\n∑d k=1mknkrk−1rk + (c− 1)(m1n1r0r1)\nc · ∏d k=1mknk (13)\nwhere c = 4 in case of LSTM and 3 in case of GRU,\nand one can show that r∗ is always smaller than r as in Eq. 9. For the former numerical example of a input frame size 160×120×3, a vanilla TT-LSTM would simply require 4 times as many parameters as a TTL, which would be 11,904 for rank 4 and 18,080 for rank 5. Applying this trick would, however, yield only 3,360 and 5,000 parameters for both ranks, respectively. We cover other possible settings of this numerical example in Tab. 1.\nFinally to construct the classification model, we denote the i-th sequence of variable length Ti as a set of vectors\n1Though in theory one could of course choose any nk.\n{x[t]i } Ti t=1 with x [t] i ∈ RM∀t. For video data each x [t] i would be an RGB frame of 3 dimensions. For the sake of simplicity we denote an RNN model, either with or without TTL, with a function f(·):\nh [Ti] i = f({x [t] i } Ti t=1), where h [Ti] i ∈ R N , (14)\nwhich outputs the last hidden layer vector h[Ti]i out of a sequential input of variable length. This vector can be interpreted as a latent representation of the whole sequence, on top of which a parameterized classifier φ(·) with either softmax or logistic activation produces the distribution over all J classes:\nP(yi = 1|{x [t] i } Ti t=1) = φ(h [Ti] i )\n= φ(f(x [t] i } Ti t=1)) ∈ [0, 1]J ,\n(15)\nThe model is also illustrated in Fig. 2:"
  }, {
    "heading": "4. Experiments",
    "text": "In the following, we present our experiments conducted on three large video datasets. These empirical results demonstrate that the integration of the Tensor-Train Layer in plain RNN architectures such as a tensorized LSTM or GRU boosts the classification quality of these models tremendously when directly exposed to high-dimensional input data, such as video data. In addition, even though the plain architectures are of very simple nature and very low complexity opposed to the state-of-the-art solutions on these datasets, it turns out that the integration of the Tensor-Train Layer alone makes these simple networks very competitive to the state-of-the-art, reaching second best results in all cases.\nUCF11 Data (Liu et al., 2009) We first conduct experiments on the UCF11 – earlier known as the YouTube Action Dataset. It contains in total 1600 video clips belonging to 11 classes that summarize the human action visible in each video clip such as basketball shooting, biking, diving etc.. These videos originate from YouTube and have natural background (’in the\nwild’) and a resolution of 320 × 240. We generate a sequence of RGB frames of size 160 × 120 from each clip at an fps(frame per second) of 24, corresponding to the standard value in film and television production. The lengths of frame sequences vary therefore between 204 to 1492 with an average of 483.7.\nFor both the TT-GRUs and TT-LSTMs the input dimension at each time step is 160 × 120 × 3 = 57600 which is factorized as 8 × 20 × 20 × 18, the hidden layer is chosen to be 4 × 4 × 4 × 4 = 256 and the Tensor-Train ranks are [1, 4, 4, 4, 1]. A fully-connected layer for such a mapping would have required 14,745,600 parameters to learn, while the input-to-hidden layer in TT-GRU and TT-LSTM consist of only 3,360 and 3,232, respectively.\nAs the first baseline model we sample 6 random frames in ascending order. The model is a simple Multilayer Perceptron (MLP) with two layers of weight matrices, the first of which being a TTL. The input is the concatenation of all 6 flattened frames and the hidden layer is of the same size as the hidden layer in TT-RNNs. We term this model as Tensor-Train Multilayer Perceptron (TT-MLP) for the rest of the paper. As the second baseline model we use plain GRUs and LSTMs that have the same size of hidden layer as their TT pendants. We follow (Liu et al., 2013) and perform for each experimental setting a 5-fold cross validation with mutual exclusive data splits. The mean and standard deviation of the prediction accuracy scores are reported in Tab. 2.\nThe standard LSTM and GRU do not show large improvements compared with the TT-MLP model. The TT-LSTM and TT-GRU, however, do not only compress the weight matrix from over 40 millions to 3 thousands, but also significantly improve the classification accuracy. It seems that plain LSTM and GRU are not adequate to model such high-dimensional sequential data because of the large weight matrix from input to hidden layer. Compared to some latest state-of-the-art performances in Tab. 3, our model —simple as it is— shows accuracy scores second to (Sharma et al., 2015), which uses pre-trained GoogLeNet CNNs plus 3-fold stacked LSTM with attention mechanism. Please note that a GoogLeNet CNN alone consists of over 6 million parameters (Szegedy et al., 2015). In term of runtime, the plain GRU and LSTM took on average more than 8 and 10 days to train, respectively; while the TTGRU and TT-LSTM both approximately 2 days. Therefore please note the TTL reduces the training time by a factor of 4 to 5 on these commodity hardwares."
  }, {
    "heading": "Hollywood2 Data (Marszałek et al., 2009)",
    "text": "The Hollywood2 dataset contains video clips from 69 movies, from which 33 movies serve as training set and 36 movies as test set. From these movies 823 training clips and 884 test clips are generated and each clip is assigned one or multiple of 12 action labels such as answering the phone, driving a car, eating or fighting a person. This data set is much more realistic and challenging since the same action could be performed in totally different style in front of different background in different movies. Furthermore, there are often montages, camera movements and zooming within a single clip.\nThe original frame sizes of the videos vary, but based on the majority of the clips we generate frames of size 234 × 100, which corresponds to the Anamorphic Format, at fps of 12. The length of training sequences varies from 29 to 1079 with an average of 134.8; while the length of test sequences varies from 30 to 1496 frames with an average of 143.3.\nThe input dimension at each time step, being 234× 100× 3 = 70200, is factorized as 10× 18× 13× 30. The hidden layer is still 4 × 4 × 4 × 4 = 256 and the Tensor-Train ranks are [1, 4, 4, 4, 1]. Since each clip might have more\nthan one label (multi-class multi-label problem) we implement a logistic activated classifier for each class on top of the last hidden layer. Following (Marszałek et al., 2009) we measure the performances using Mean Average Precision across all classes, which corresponds to the Area-UnderPrecision-Recall-Curve.\nAs before we conduct experiments on this dataset using the plain LSTM, GRU and their respective TT modifications. The results are presented in in Tab. 4 and state-of-the-art in Tab. 5.\n(Fernando et al., 2015) and (Jain et al., 2013) use improved trajectory features with Fisher encoding (Wang & Schmid, 2013) and Histogram of Optical Flow (HOF) features (Laptev et al., 2008), respectively, and achieve so far the best score. (Sharma et al., 2015) and (Fernando & Gould, 2016) provide best scores achieved with Neural Network models but only the latter applies end-toend training. To this end, the TT-LSTM model provides the second best score in general and the best score with Neural Network models, even though it merely replaces the input-to-hidden mapping with a TTL. Please note the large difference between the plain LSTM/GRU and the TT-\nLSTM/GRU, which highlights the significant performance improvements the Tensor-Train Layer contributes to the RNN models.\nIt is also to note that, although the plain LSTM and GRU consist of up to approximately 23K as many parameters as their TT modifications do, the training time does not reflect such discrepancy due to the good parallelization power of GPUs. However, the obvious difference in their training qualities confirms that training larger models may require larger amounts of data. In such cases, powerful hardwares are no guarantee for successful training."
  }, {
    "heading": "Youtube Celebrities Face Data (Kim et al., 2008)",
    "text": "This dataset consists of 1910 Youtube video clips of 47 prominent individuals such as movie stars and politicians. In the simplest cases, where the face of the subject is visible as a long take, a mere frame level classification would suffice. The major challenge, however, is posed by the fact that some videos involve zooming and/or changing the angle of view. In such cases a single frame may not provide enough information for the classification task and we believe it is advantageous to apply RNN models that can aggregate frame level information over time.\nThe original frame sizes of the videos vary but based on the majority of the clips we generate frames of size 160 × 120 at fps of 12. The retrieved sequences have lengths varying from 2 to 85 with an average of 39.9. The input dimension at each time step is 160 × 120 × 3 = 57600 which is factorized as 4× 20× 20× 36, the hidden layer is again 4× 4× 4× 4 = 256 and the Tensor-Train ranks are\n[1, 4, 4, 4, 1].\nAs expected, the baseline of TT-MLP model tends to perform well on the simpler video clips where the position of the face remains less changed over time, and can even outperform the plain GRU and LSTM. The TT-GRU and TT-LSTM, on the other hand, provide accuracy very close to the best state-of-the-art model (Tab. 7) using Mean Sequence Sparse Representation-based Classification (Ortiz et al., 2013) as feature extraction."
  }, {
    "heading": "Experimental Settings",
    "text": "We applied 0.25 Dropout (Srivastava et al., 2014) for both input-to-hidden and hidden-to-hidden mappings in plain GRU and LSTM as well as their respective TT modifications; and 0.01 ridge regularization for the single-layered classifier. The models were implemented in Theano (Bastien et al., 2012) and deployed in Keras (Chollet, 2015). We used the Adam (Kingma & Ba, 2014) step rule for the updates with an initial learning rate 0.001."
  }, {
    "heading": "5. Conclusions and Future Work",
    "text": "We proposed to integrate Tensor-Train Layers into Recurrent Neural Network models including LSTM and GRU, which enables them to be trained end-to-end on highdimensional sequential data. We tested such integration on three large-scale realistic video datasets. In comparison to the plain RNNs, which performed very poorly on these video datasets, we could empirically show that the integration of the Tensor-Train Layer alone significantly improves\nthe modeling performances. In contrast to related works that heavily rely on deep and large CNNs, one advantage of our classification model is that it is simple and lightweight, reducing the number of free parameters from tens of millions to thousands. This would make it possible to train and deploy such models on commodity hardware and mobile devices. On the other hand, with significantly less free parameters, such tensorized models can be expected to be trained with much less labeled data, which are quite expensive in the video domain.\nMore importantly, we believe that our approach opens up a large number of possibilities to model high-dimensional sequential data such as videos using RNNs directly. In spite of its success in modeling other sequential data such as natural language, music data etc., RNNs have not been applied to video data in a fully end-to-end fashion, presumably due to the large input-to-hidden weight mapping. With TTRNNs that can directly consume video clips on the pixel level, many RNN-based architectures that are successful in other applications, such as NLP, can be transferred to modeling video data: one could implement an RNN autoencoder that can learn video representations similar to (Srivastava et al., 2015), an Encoder-Decoder Network (Cho et al., 2014) that can generate captions for videos similar to (Donahue et al., 2015), or an attention-based model that can learn on which frame to allocate the attention in order to improve the classification.\nWe believe that the TT-RNN provides a fundamental building block that would enable the transfer of techniques from fields, where RNNs have been very successful, to fields that deal with very high-dimensional sequence data –where RNNs have failed in the past.\nThe source codes of our TT-RNN implementations and all the experiments in Sec. 4 are publicly available at https: //github.com/Tuyki/TT_RNN. In addition, we also provide codes of unit tests, simulation studies as well as experiments performed on the HMDB51 dataset (Kuehne et al., 2011)."
  }],
  "year": 2017,
  "references": [{
    "title": "Theano: new features and speed improvements",
    "authors": ["Bastien", "Frédéric", "Lamblin", "Pascal", "Pascanu", "Razvan", "Bergstra", "James", "Goodfellow", "Ian J", "Bergeron", "Arnaud", "Bouchard", "Nicolas", "Bengio", "Yoshua"],
    "venue": "Deep Learning and Unsupervised Feature Learning NIPS 2012 Workshop,",
    "year": 2012
  }, {
    "title": "Random projection in dimensionality reduction: applications to image and text data",
    "authors": ["Bingham", "Ella", "Mannila", "Heikki"],
    "venue": "In Proceedings of the seventh ACM SIGKDD international conference on Knowledge discovery and data mining,",
    "year": 2001
  }, {
    "title": "On the properties of neural machine translation: Encoder-decoder approaches",
    "authors": ["Cho", "Kyunghyun", "Van Merriënboer", "Bart", "Bahdanau", "Dzmitry", "Bengio", "Yoshua"],
    "venue": "arXiv preprint arXiv:1409.1259,",
    "year": 2014
  }, {
    "title": "Keras: Deep learning library for theano and tensorflow",
    "authors": ["Chollet", "François"],
    "venue": "https://github.com/ fchollet/keras,",
    "year": 2015
  }, {
    "title": "Image set classification by symmetric positive semidefinite matrices",
    "authors": ["Faraki", "Masoud", "Harandi", "Mehrtash T", "Porikli", "Fatih"],
    "venue": "In Applications of Computer Vision (WACV),",
    "year": 2016
  }, {
    "title": "Spatiotemporal residual networks for video action recognition",
    "authors": ["Feichtenhofer", "Christoph", "Pinz", "Axel", "Wildes", "Richard"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2016
  }, {
    "title": "Learning end-toend video classification with rank-pooling",
    "authors": ["Fernando", "Basura", "Gould", "Stephen"],
    "venue": "In Proc. of the International Conference on Machine Learning (ICML),",
    "year": 2016
  }, {
    "title": "Modeling video evolution for action recognition",
    "authors": ["Fernando", "Basura", "Gavves", "Efstratios", "Oramas", "Jose M", "Ghodrati", "Amir", "Tuytelaars", "Tinne"],
    "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
    "year": 2015
  }, {
    "title": "Ultimate tensorization: compressing convolutional and fc layers alike",
    "authors": ["Garipov", "Timur", "Podoprikhin", "Dmitry", "Novikov", "Alexander", "Vetrov"],
    "venue": "arXiv preprint arXiv:1611.03214,",
    "year": 2016
  }, {
    "title": "Learning both weights and connections for efficient neural network",
    "authors": ["Han", "Song", "Pool", "Jeff", "Tran", "John", "Dally", "William"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2015
  }, {
    "title": "Dictionary learning and sparse coding on grassmann manifolds: An extrinsic solution",
    "authors": ["Harandi", "Mehrtash", "Sanderson", "Conrad", "Shen", "Chunhua", "Lovell", "Brian C"],
    "venue": "In Proceedings of the IEEE International Conference on Computer Vision, pp. 3120–3127,",
    "year": 2013
  }, {
    "title": "Better exploiting motion for better action recognition",
    "authors": ["Jain", "Mihir", "Jegou", "Herve", "Bouthemy", "Patrick"],
    "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
    "year": 2013
  }, {
    "title": "Dimension reduction by local principal component analysis",
    "authors": ["Kambhatla", "Nandakishore", "Leen", "Todd K"],
    "venue": "Neural computation,",
    "year": 1997
  }, {
    "title": "Face tracking and recognition with visual constraints in real-world videos",
    "authors": ["Kim", "Minyoung", "Kumar", "Sanjiv", "Pavlovic", "Vladimir", "Rowley", "Henry"],
    "venue": "In Computer Vision and Pattern Recognition,",
    "year": 2008
  }, {
    "title": "Adam: A method for stochastic optimization",
    "authors": ["Kingma", "Diederik", "Ba", "Jimmy"],
    "venue": "arXiv preprint arXiv:1412.6980,",
    "year": 2014
  }, {
    "title": "A clockwork rnn",
    "authors": ["Koutnik", "Jan", "Greff", "Klaus", "Gomez", "Faustino", "Schmidhuber", "Juergen"],
    "venue": "arXiv preprint arXiv:1402.3511,",
    "year": 2014
  }, {
    "title": "Imagenet classification with deep convolutional neural networks. In Advances in neural information processing",
    "authors": ["Krizhevsky", "Alex", "Sutskever", "Ilya", "Hinton", "Geoffrey E"],
    "year": 2012
  }, {
    "title": "HMDB: a large video database for human motion recognition",
    "authors": ["H. Kuehne", "H. Jhuang", "E. Garrote", "T. Poggio", "T. Serre"],
    "venue": "In Proceedings of the International Conference on Computer Vision (ICCV),",
    "year": 2011
  }, {
    "title": "Learning realistic human actions from movies",
    "authors": ["Laptev", "Ivan", "Marszalek", "Marcin", "Schmid", "Cordelia", "Rozenfeld", "Benjamin"],
    "venue": "In Computer Vision and Pattern Recognition,",
    "year": 2008
  }, {
    "title": "Learning hierarchical invariant spatio-temporal features for action recognition with independent subspace analysis",
    "authors": ["Le", "Quoc V", "Zou", "Will Y", "Yeung", "Serena Y", "Ng", "Andrew Y"],
    "venue": "In Computer Vision and Pattern Recognition (CVPR),",
    "year": 2011
  }, {
    "title": "Speedingup convolutional neural networks using fine-tuned cpdecomposition",
    "authors": ["Lebedev", "Vadim", "Ganin", "Yaroslav", "Rakhuba", "Maksim", "Oseledets", "Ivan", "Lempitsky", "Victor"],
    "venue": "arXiv preprint arXiv:1412.6553,",
    "year": 2014
  }, {
    "title": "Spatialtemporal motion information integration for action detection and recognition in non-static background",
    "authors": ["Liu", "Dianting", "Shyu", "Mei-Ling", "Zhao", "Guiru"],
    "venue": "In Information Reuse and Integration (IRI),",
    "year": 2013
  }, {
    "title": "Recognizing realistic actions from videos “in the wild",
    "authors": ["Liu", "Jingen", "Luo", "Jiebo", "Shah", "Mubarak"],
    "venue": "In Computer Vision and Pattern Recognition,",
    "year": 2009
  }, {
    "title": "Actions in context",
    "authors": ["Marszałek", "Marcin", "Laptev", "Ivan", "Schmid", "Cordelia"],
    "venue": "In IEEE Conference on Computer Vision & Pattern Recognition,",
    "year": 2009
  }, {
    "title": "Tensorizing neural networks",
    "authors": ["Vetrov", "Dmitry P"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2015
  }, {
    "title": "Face recognition in movie trailers via mean sequence sparse representation-based classification",
    "authors": ["Ortiz", "Enrique G", "Wright", "Alan", "Shah", "Mubarak"],
    "venue": "In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition,",
    "year": 2013
  }, {
    "title": "Action recognition using visual attention",
    "authors": ["Sharma", "Shikhar", "Kiros", "Ryan", "Salakhutdinov", "Ruslan"],
    "venue": "arXiv preprint arXiv:1511.04119,",
    "year": 2015
  }, {
    "title": "Convolutional lstm network: a machine learning approach for precipitation nowcasting",
    "authors": ["Shi", "Xingjian", "Chen", "Zhourong", "Wang", "Hao", "Yeung", "Dityan", "Wong", "Waikin", "Woo", "Wangchun"],
    "year": 2015
  }, {
    "title": "Two-stream convolutional networks for action recognition in videos",
    "authors": ["Simonyan", "Karen", "Zisserman", "Andrew"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2014
  }, {
    "title": "Dropout: a simple way to prevent neural networks from overfitting",
    "authors": ["Srivastava", "Nitish", "Hinton", "Geoffrey E", "Krizhevsky", "Alex", "Sutskever", "Ilya", "Salakhutdinov", "Ruslan"],
    "venue": "Journal of Machine Learning Research,",
    "year": 1929
  }, {
    "title": "Unsupervised learning of video representations using lstms",
    "authors": ["Srivastava", "Nitish", "Mansimov", "Elman", "Salakhutdinov", "Ruslan"],
    "venue": "CoRR, abs/1502.04681,",
    "year": 2015
  }, {
    "title": "Sequence to sequence learning with neural networks. In Advances in neural information processing",
    "authors": ["Sutskever", "Ilya", "Vinyals", "Oriol", "Le", "Quoc V"],
    "year": 2014
  }, {
    "title": "Action recognition with improved trajectories",
    "authors": ["Wang", "Heng", "Schmid", "Cordelia"],
    "venue": "In Proceedings of the IEEE International Conference on Computer Vision,",
    "year": 2013
  }, {
    "title": "Gpca: an efficient dimension reduction scheme for image compression and retrieval",
    "authors": ["Ye", "Jieping", "Janardan", "Ravi", "Li", "Qi"],
    "venue": "In Proceedings of the tenth ACM SIGKDD international conference on Knowledge discovery and data mining,",
    "year": 2004
  }, {
    "title": "Face recognition: eigenface, elastic matching, and neural nets",
    "authors": ["Zhang", "Jun", "Yan", "Yong", "Lades", "Martin"],
    "venue": "Proceedings of the IEEE,",
    "year": 1997
  }],
  "id": "SP:e36822c6b526ed9c938abf28441191538108ef85",
  "authors": [{
    "name": "Yinchong Yang",
    "affiliations": []
  }, {
    "name": "Denis Krompass",
    "affiliations": []
  }, {
    "name": "Volker Tresp",
    "affiliations": []
  }],
  "abstractText": "The Recurrent Neural Networks and their variants have shown promising performances in sequence modeling tasks such as Natural Language Processing. These models, however, turn out to be impractical and difficult to train when exposed to very high-dimensional inputs due to the large input-to-hidden weight matrix. This may have prevented RNNs’ large-scale application in tasks that involve very high input dimensions such as video modeling; current approaches reduce the input dimensions using various feature extractors. To address this challenge, we propose a new, more general and efficient approach by factorizing the input-to-hidden weight matrix using Tensor-Train decomposition which is trained simultaneously with the weights themselves. We test our model on classification tasks using multiple real-world video datasets and achieve competitive performances with state-of-the-art models, even though our model architecture is orders of magnitude less complex. We believe that the proposed approach provides a novel and fundamental building block for modeling highdimensional sequential data with RNN architectures and opens up many possibilities to transfer the expressive and advanced architectures from other domains such as NLP to modeling highdimensional sequential data.",
  "title": "Tensor-Train Recurrent Neural Networks for Video Classification"
}