{
  "sections": [{
    "text": "Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics, pages 47–57, Baltimore, Maryland, USA, June 23-25 2014. c©2014 Association for Computational Linguistics"
  }, {
    "heading": "1 Introduction",
    "text": "This paper studies and extends previous work using the structured perceptron (Collins, 2002) for complex NLP tasks. We show that for the task of coreference resolution the straightforward combination of beam search and early update (Collins and Roark, 2004) falls short of more limited feature sets that allow for exact search. This contrasts with previous work on, e.g., syntactic parsing (Collins and Roark, 2004; Huang, 2008; Zhang and Clark, 2008) and linearization (Bohnet et al., 2011), and even simpler structured prediction problems, where early updates are not even necessary, such as part-of-speech tagging (Collins, 2002) and named entity recognition (Ratinov and Roth, 2009).\nThe main reason why early updates underperform in our setting is that the task is too difficult and that the learning algorithm is not able to profit from all training data. Put another way, early updates happen too early, and the learning algorithm rarely reaches the end of the instances as it halts, updates, and moves on to the next instance.\nAn alternative would be to continue decoding the same instance after the early updates,\nwhich is equivalent to Learning as Search Optimization (LaSO; Daumé III and Marcu (2005b)). The learning task we are tackling is however further complicated since the target structure is under-determined by the gold standard annotation. Coreferent mentions in a document are usually annotated as sets of mentions, where all mentions in a set are coreferent. We adopt the recently popularized approach of inducing a latent structure within these sets (Fernandes et al., 2012; Chang et al., 2013; Durrett and Klein, 2013). This approach provides a powerful boost to the performance of coreference resolvers, but we find that it does not combine well with the LaSO learning strategy. We therefore propose a modification to LaSO, which delays updates until after each instance. The combination of this modification with non-local features leads to further improvements in the clustering accuracy, as we show in evaluation results on all languages from the CoNLL 2012 Shared Task – Arabic, Chinese, and English. We obtain the best results to date on these data sets.1"
  }, {
    "heading": "2 Background",
    "text": "Coreference resolution is the task of grouping referring expressions (or mentions) in a text into disjoint clusters such that all mentions in a cluster refer to the same entity. An example is given in Figure 1 below, where mentions from two clusters are marked with brackets:\n1Our system is available at http://www.ims. uni-stuttgart.de/˜anders/coref.html\n47\nIn recent years much work on coreference resolution has been devoted to increasing the expressivity of the classical mention-pair model, in which each coreference classification decision is limited to information about two mentions that make up a pair. This shortcoming has been addressed by entity-mention models, which relate a candidate mention to the full cluster of mentions predicted to be coreferent so far (for more discussion on the model types, see, e.g., (Ng, 2010)).\nNevertheless, the two best systems in the latest CoNLL Shared Task on coreference resolution (Pradhan et al., 2012) were both variants of the mention-pair model. While the second best system (Björkelund and Farkas, 2012) followed the widely used baseline of Soon et al. (2001), the winning system (Fernandes et al., 2012) proposed the use of a tree representation.\nThe tree-based model of Fernandes et al. (2012) construes the representation of coreference clusters as a rooted tree. Figure 2 displays an example tree over the clusters from Figure 1. Every mention corresponds to a node in the tree, and arcs between mentions indicate that they are coreferent. The tree additionally has a dummy root node. Every subtree under the root node corresponds to a cluster of coreferent mentions.\nSince coreference training data is typically not annotated with trees, Fernandes et al. (2012) proposed the use of latent trees that are induced during the training phase of a coreference resolver. The latent tree provides more meaningful antecedents for training.2 For instance, the popular pair-wise instance creation method suggested by Soon et al. (2001) assumes non-branching trees, where the antecedent of every mention is its linear predecessor (i.e., heb2 is the antecedent of Gary Wilberb3). Comparing the two alternative antecedents of Gary Wilberb3 , the tree in Figure 2 provides a more reliable basis for training a coreference resolver, as the two mentions of Gary Wilber are both proper names and have an exact string match."
  }, {
    "heading": "3 Representation and Learning",
    "text": "LetM = {m0,m1, ...,mn} denote the set of mentions in a document, including the artificial root mention (denoted by m0). We assume that the\n2We follow standard practice and overload the terms anaphor and antecedent to be any type of mention, i.e., names as well as pronouns. An antecedent is simply the mention to the left of the anaphor.\nmentions are ordered ascendingly with respect to the linear order of the document, where the document root precedes all other mentions.3 For each mention mj , let Aj denote the set of potential antecedents. That is, the set of all mentions that precede mj according to the linear order including the root node, or, Aj = {mi | i < j}. Finally, let A denote the set of all antecedent sets {A0, A1, ..., An}.\nIn the tree model, each mention corresponds to a node, and an antecedent-anaphor pair 〈ai,mi〉, where ai ∈ Ai, corresponds to a directed edge (or arc) pointing from antecedent to anaphor.\nThe score of an arc 〈ai,mi〉 is defined as the scalar product between a weight vector w and a feature vector Φ(〈ai,mi〉), where Φ is a feature extraction function over an arc (thus extracting features from the antecedent and the anaphor). The score of a coreference tree y = {〈a1,m1〉, 〈a2,m2〉, ..., 〈an,mn〉} is defined as the sum of the scores of all the mention pairs:\nscore(〈ai,mi〉) = w · Φ(〈ai,mi〉) (1) score(y) = ∑ 〈ai,mi〉∈y score(〈ai,mi〉)\nThe objective is to find the output ŷ that maximizes the scoring function:\nŷ = arg max y∈Y(A) score(y) (2)\nwhere Y(A) denotes the set of possible trees given the antecedent sets A. By treating the mentions as nodes in a directed graph and assigning scores to the arcs according to (1), Fernandes et al. (2012) solved the search problem using the Chu-LiuEdmonds (CLE) algorithm (Chu and Liu, 1965;\n3We impose a total order on mentions. In case of nested mentions, the mention that begins first is assumed to precede the embedded one. If two mentions begin at the same token, the longer one is taken to precede the shorter one.\nEdmonds, 1967), which is a maximum spanning tree algorithm that finds the optimal tree over a connected directed graph. CLE, however, has the drawback that the scores of the arcs must remain fixed and can not change depending on other arcs and it is not clear how to include non-local features in a CLE decoder."
  }, {
    "heading": "3.1 Online learning",
    "text": "We find the weight vector w by online learning using a variant of the structured perceptron (Collins, 2002). Specifically, we use the passive-aggressive (PA) algorithm (Crammer et al., 2006), since we found that this performed slightly better in preliminary experiments.4\nThe structured perceptron iterates over training instances 〈xi, yi〉, where xi are inputs and yi are outputs. For each instance it uses the current weight vector w to make a prediction ŷi given the input xi. If the prediction is incorrect, the weight vector is updated in favor of the correct structure. Otherwise the weight vector is left untouched. In our setting inputs xi correspond to documents and outputs yi are trees over mentions in a document. The training data is, however, not annotated with trees, but only with clusters of mentions. That is, the yi’s are not defined a priori."
  }, {
    "heading": "3.2 Latent antecedents",
    "text": "In order to have a tree structure to update against, we use the current weight vector and apply the decoder to a constrained antecedent set and obtain a latent tree over the mentions in a document, where each mention is assigned a single correct antecedent (Fernandes et al., 2012). We constrain the antecedent sets such that only trees that correspond to the correct clustering can be built. Specifically, let Ãj denote the set of correct antecedents for a mention mj , or\nÃj = { {m0} if mj has no correct antecedent {ai | COREF(ai,mj), ai ∈ Aj} otherwise\nthat is, if mention mj is non-referential or the first mention of its cluster, Ãj contains only the document root. Otherwise it is the set of all mentions to the left that belong to the same cluster as mj . Analogously to A, let Ã denote the set of constrained antecedent sets. The latent tree ỹ needed\n4We also implement the feature mapping function Φ as a hash kernel (Bohnet, 2010) and apply averaging (Collins, 2002), though for brevity we omit this from the pseudocode.\nfor updates is then defined to be the optimal tree over Y(Ã), subject to the current weight vector:\nỹ = arg max y∈Y(Ã) score(y)\nThe intuition behind the latent tree is that during online learning, the weight vector will start favoring latent trees that are easier to learn (such as the one in Figure 2).\nAlgorithm 1 PA algorithm with latent trees Input: Training data D, number of iterations T Output: Weight vector w 1: w = −→ 0\n2: for t ∈ 1..T do 3: for 〈Mi,Ai, Ãi〉 ∈ D do 4: ŷi = arg maxY(A) score(y) . Predict 5: if ¬CORRECT(ŷi) then 6: ỹi = arg maxY(Ã) score(y) . Latent tree 7: ∆ = Φ(ŷi)− Φ(ỹi) 8: τ = ∆·w+LOSS(ŷi)‖∆‖2 . PA weight 9: w = w + τ∆ . PA update\n10: return w\nAlgorithm 1 shows pseudocode for the learning algorithm, which we will refer to as the baseline learning algorithm. Instead of looping over pairs 〈x, y〉 of documents and trees, it loops over triples 〈M,A, Ã〉 that comprise the set of mentions M and the two sets of antecedent candidates (line 3). Moreover, rather than checking that the tree is identical to the latent tree, it only requires the tree to correctly encode the gold clustering (line 5). The update that occurs in lines 7-9 is the passive-aggressive update. A loss function LOSS that quantifies the error in the prediction is used to compute a scalar τ that controls how much the weights are moved in each update. If τ is set to 1, the update reduces to the standard structured perceptron update. The loss function can be an arbitrarily complex function that returns a numerical value of how bad the prediction is. In the simplest case, Hamming loss can be used, i.e., for each incorrect arc add 1. We follow Fernandes et al. (2012) and penalize erroneous root attachments, i.e., mentions that erroneously get the root node as their antecedent, with a loss of 1.5. For all other arcs we use Hamming loss."
  }, {
    "heading": "4 Incremental Search",
    "text": "We now show that the search problem in (2) can equivalently be solved by the more intuitive bestfirst decoder (Ng and Cardie, 2002), rather than using the CLE decoder. The best-first decoder\nworks incrementally by making a left-to-right pass over the mentions, selecting for each mention the highest scoring antecedent.\nThe key aspect that makes the best-first decoder equivalent to the CLE decoder is that all arcs point from left to right, both in this paper and in the work of Fernandes et al. (2012). We sketch a proof that this decoder also returns the highest scoring tree.\nFirst, note that this algorithm indeed returns a tree. This can be shown by assuming the opposite, in which case the tree has to have a cycle. Then there must be a mention that has its antecedent to the right. Though this is not possible since all arcs point from left to right.\nSecond, this tree is the highest scoring tree. Again, assume the contrary, i.e., that there is a higher scoring tree in Y(A). This implies that for some mention there is a higher scoring antecedent than the one selected by the decoder. This contradicts the fact that the best-first decoder selects the highest scoring antecedent for each mention.5"
  }, {
    "heading": "5 Introducing Non-local Features",
    "text": "Since the best-first decoder makes a left-to-right pass, it is possible to extract features on the partial structure on the left. Such non-local features are able to capture information beyond that of a mention and its potential antecedent, e.g., the size of a partially built cluster, or features extracted from the antecedent of the antecedent.\nWhen only local features are used, greedy search (either with CLE or the best-first decoder) suffices to find the highest scoring tree. That is, greedy search provides an exact solution to equation 2. Non-local features, however, render the exact search problem intractable. This is because with non-local features, locally suboptimal (i.e., non-greedy) antecedents for some mentions may lead to a higher total score over a whole document.\nIn order to keep some options around during search, we extend the best-first decoder with beam search. Beam search works incrementally by keeping an agenda of state items. At each step, all items on the agenda are expanded. The subset of size k (the beam size) of the highest scoring expansions are retained and put back into the agenda for the next step. The feature extraction function Φ\n5In case there are multiple maximum spanning trees, the best-first decoder will return one of them. This also holds for the CLE algorithm. With proper definitions, the proof can be constructed to show that both search algorithms return trees belonging to the set of maximum spanning trees over a graph.\nis also extended such that it also receives the current state s as an argument: Φ(〈mi,mj〉, s). The state encodes the previous decisions and enables Φ to extract features from the partial tree on the left.\nWe now outline three different ways of learning the weight vector w with non-local features."
  }, {
    "heading": "5.1 Early updates",
    "text": "The beam search decoder can be plugged into the training algorithm, replacing the calls to arg max. Since state items leading to the best tree may be pruned from the agenda before the decoder reaches the end of the document, the introduction of non-local features may cause the decoder to return a non-optimal tree. This is problematic as it might cause updates although the correct tree has a higher score than the predicted one. It has previously been observed (Huang et al., 2012) that substantial gains can be made by applying an early update strategy (Collins and Roark, 2004): if the correct item is pruned before reaching the end of the document, then stop and update.\nWhile beam search and early updates have been successfully applied to other NLP applications, our task differs in two important aspects: First, coreference resolution is a much more difficult task, which relies on more (world) knowledge than what is available in the training data. In other words, it is unlikely that we can devise a feature set that is informative enough to allow the weight vector to converge towards a solution that lets the learning algorithm see the entire documents during training, at least in the situation when no external knowledge sources are used.\nSecond, our gold structure is not known but is induced latently, and may vary from iteration to iteration. With non-local features this is troublesome since the best latent tree of a complete document may not necessarily coincide with the best partial tree at some intermediate mentionmj , j < n, i.e., a mention before the last in a document. We therefore also apply beam search to find the latent tree to have a partial gold structure for every mention in a document.\nAlgorithm 2 shows pseudocode for the beam search and early update training procedure. The algorithm maintains two parallel agendas, one for gold items and one for predicted items. At every mention, both agendas are expanded and thus cover the same set of mentions. Then the predicted agenda is checked to see if it contains any correct\nAlgorithm 2 Beam search and early update Input: Data set D, epochs T , beam size k Output: weight vector w 1: w = −→ 0\n2: for t ∈ 1..T do 3: for 〈Mi,Ai, Ãi〉 ∈ D do 4: AgendaG = {} 5: AgendaP = {} 6: for j ∈ 1..n do 7: AgendaG = EXPAND(AgendaG , Ãj ,mj , k) 8: AgendaP = EXPAND(AgendaP , Aj ,mj , k) 9: if ¬CONTAINSCORRECT(AgendaP ) then\n10: ỹ = EXTRACTBEST(AgendaG) 11: ŷ = EXTRACTBEST(AgendaP ) 12: update . PA update 13: GOTO 3 . Skip and move to next instance 14: ŷ = EXTRACTBEST(AgendaP ) 15: if ¬CORRECT(ŷ) then 16: ỹ = EXTRACTBEST(AgendaG) 17: update . PA update\nitem. If there is no correct item in the predicted agenda, search is halted and an update is made against the best item from the gold agenda. The algorithm then moves on to the next document. If the end of a document is reached, the top scoring predicted item is checked for correctness. If it is not, an update is made against the best gold item.\nA drawback of early updates is that the remainder of the document is skipped when an early update is applied, effectively discarding some training data.6 An alternative strategy that makes better use of the training data is to apply the maxviolation procedure suggested by Huang et al. (2012). However, since our gold trees change from iteration to iteration, and even inside of a single document, it is not entirely clear with respect to what gold tree the maximum violation should be computed. Initial experiments with max-violation updates indicated that they did not improve much over early updates, and also had a tendency to only consider a smaller portion of the training data."
  }, {
    "heading": "5.2 LaSO",
    "text": "To make full use of the training data we implemented Learning as Search Optimization (LaSO; Daumé III and Marcu, 2005b). It is very similar to early updates, but differs in one crucial respect: When an early update is made, search is continued rather than aborted. Thus the learning algorithm always reaches the end of a document, avoiding the problem that early updates discard parts of the training data.\n6In fact, after 50 iterations about 70% of the mentions in the training data are still being ignored due to early updates.\nCorrect items are computed the same way as with early updates, where an agenda of gold items is maintained in parallel. When search is resumed after an intermediate LaSO update, the prediction agenda is re-seeded with gold items (i.e., items that are all correct). This is necessary since the update influences what the partial gold structure looks like, and the gold agenda therefore needs to be recreated from the beginning of the document. Specifically, after each intermediate LaSO update, the gold agenda is expanded repeatedly from the beginning of the document to the point where the update was made, and is then copied over to seed the prediction agenda. In terms of pseudocode, this is accomplished by replacing lines 12 and 13 in Algorithm 2 with the following: 12: update . PA update 13: AgendaG = {} 14: for mi ∈ {m1, ...,mj} . Recreate gold agenda 15: AgendaG = EXPAND(AgendaG , Ãi,mi, k) 16: AgendaP = COPY(AgendaG) 17: GOTO 6 . Continue"
  }, {
    "heading": "5.3 Delayed LaSO updates",
    "text": "When we applied LaSO, we noticed that it performed worse than the baseline learning algorithm when only using local features. We believe that the reason is that updates are made in the middle of documents which means that lexical forms of antecedents are “fresh in memory” of the weight vector. This results in fewer mistakes during training and leads to fewer updates. While this feedback makes it easier during training, such feedback is not available during test time, and the LaSO learning setting therefore mimics the testing setting to a lesser extent.\nWe also found that LaSO updates change the shape of the latent tree and that the average distance between mentions connected by an arc increased. This problem can also be attributed to how lexical items are fresh in memory. Such trees tend to deviate from the intuition that the latent trees are easier to learn. They also render distancebased features (which are standard practice and generally rather useful) less powerful, as distance in sentences or mentions becomes less of a reliable indicator for coreference.\nTo cope with this problem, we devised the delayed LaSO update, which differs from LaSO only in the respect that it postpones the actual updates until the end of a document. This is accomplished by summing the distance vectors ∆ at every point where LaSO would make an update. At\nAlgorithm 3 Delayed LaSO update Input: Data set D, iterations T , beam size k Output: weight vector w 1: w = −→ 0\n2: for t ∈ 1..T do 3: for 〈Mi,Ai, Ãi〉 ∈ D do 4: AgendaG = {} 5: AgendaP = {} 6: ∆acc = −→ 0 7: lossacc = 0 8: for j ∈ 1..n do 9: AgendaG = EXPAND(AgendaG , Ãj ,mj , k) 10: AgendaP = EXPAND(AgendaP , Aj ,mj , k) 11: if ¬CONTAINSCORRECT(AgendaP ) then 12: ỹ = EXTRACTBEST(AgendaG) 13: ŷ = EXTRACTBEST(AgendaP ) 14: ∆acc = ∆acc + Φ(ŷ)− Φ(ỹ) 15: lossacc = lossacc + LOSS(ŷ) 16: AgendaP = AgendaG 17: ŷ = EXTRACTBEST(AgendaP ) 18: if ¬CORRECT(ŷ) then 19: ỹ = EXTRACTBEST(AgendaG) 20: ∆acc = ∆acc + Φ(ŷ)− Φ(ỹ) 21: lossacc = lossacc + LOSS(ŷ) 22: if ∆acc 6= −→0 then 23: update w.r.t. ∆acc and lossacc\nthe end of a document, an update is made with respect to the sum of all ∆’s. Similarly, a running sum of the partial loss is maintained within a document. Since the PA update only depends on the distance vector ∆ and the loss, it can be applied with respect to these sums at the end of the document. When only local features are used, this update is equivalent to the updates in the baseline learning algorithm. This follows because greedy search finds the optimal tree when only local features are used. Similarly, using only local features, the beam-based best-first decoder will also return the optimal tree. Algorithm 3 shows the pseudocode for the delayed LaSO learning algorithm."
  }, {
    "heading": "6 Features",
    "text": "In this section we briefly outline the type of features we use. The feature sets are customized for each language. As a baseline we use the features from Björkelund and Farkas (2012), who ranked second in the 2012 CoNLL shared task and is publicly available. The exact definitions and feature sets that we use are available as part of the download package of our system."
  }, {
    "heading": "6.1 Local features",
    "text": "Basic features that can be extracted on one or both mentions in a pair include (among others): Mention type, which is either root, pro-\nnoun, name, or common; Distance features, e.g., the distance in sentences or mentions; Rule-based features, e.g., StringMatch or SubStringMatch; Syntax-based features, e.g., category labels or paths in the syntax tree; Lexical features, e.g., the head word of a mention or the last word of a mention.\nIn order to have a strong local baseline, we applied greedy forward/backward feature selection on the training data using a large set of local feature templates. Specifically, the training set of each language was split into two parts where 75% was used for training, and 25% for testing. Feature templates were incrementally added or removed in order to optimize the mean of MUC, B3, and CEAFe (i.e., the CoNLL average)."
  }, {
    "heading": "6.2 Non-local Features",
    "text": "We experimented with non-local features drawn from previous work on entity-mention models (Luo et al., 2004; Rahman and Ng, 2009), however they did not improve performance in preliminary experiments. The one exception is the size of a cluster (Culotta et al., 2007). Additional features we use are Shape encodes the linear “shape” of a cluster in terms of mention type. For instance, the clusters representing Gary Wilber and Drug Emporium Inc. from the example in Figure 1, would be represented as RNPN and RNCCC, respectively. Where R, N, P, and C denote the root node, names, pronouns, and common noun phrases, respectively. Local syntactic context is inspired by the Entity Grid (Barzilay and Lapata, 2008), where the basic assumption is that references to an entity follow particular syntactic patterns. For instance, an entity may be introduced as an object in one sentence, whereas in subsequent sentences it is referred to in subject position. Grammatical functions are approximated by the path in the syntax tree from a mention to its closest S node. The partial paths of a mention and its linear predecessor, given the cluster of the current antecedent, informs the model about the local syntactic context. Cluster start distance denotes the distance in mentions from the beginning of the document where the cluster of the antecedent in consideration begins.\nAdditionally, the non-local model also has access to the basic properties of other mentions in the partial tree structure, such as head words. The\nnon-local features were selected with the same greedy forward strategy as the local features, starting from the optimized local feature sets."
  }, {
    "heading": "7 Experimental Setup",
    "text": "We apply our model to the CoNLL 2012 Shared Task data, which includes a training, development, and test set split for three languages: Arabic, Chinese and English. We follow the closed track setting where systems may only be trained on the provided training data, with the exception of the English gender and number data compiled by Bergsma and Lin (2006). We use automatically extracted mentions using the same mention extraction procedure as Björkelund and Farkas (2012).\nWe evaluate our system using the CoNLL 2012 scorer, which computes several coreference metrics: MUC (Vilain et al., 1995), B3 (Bagga and Baldwin, 1998), and CEAFe and CEAFm (Luo, 2005). We also report the CoNLL average (also known as MELA; Denis and Baldridge (2009)), i.e., the arithmetic mean of MUC, B3, and CEAFe. It should be noted that for B3 and the CEAF metrics, multiple ways of handling twinless mentions7 have been proposed (Rahman and Ng, 2009; Stoyanov et al., 2009). We use the most recent version of the CoNLL scorer (version 7), which implements the original definitions of these metrics.8\nOur system is evaluated on the version of the data with automatic preprocessing information (e.g., predicted parse trees). Unless otherwise stated we use 25 iterations of perceptron training and a beam size of 20. We did not attempt to tune either of these parameters. We experiment with two feature sets for each language: the optimized local feature sets (denoted local), and the optimized local feature sets extended with non-local features (denoted non-local)."
  }, {
    "heading": "8 Results",
    "text": "Learning strategies. We begin by looking at the different learning strategies. Since early updates do not always make use of the complete documents during training, it can be expected that it will require either a very wide beam or more iterations to get up to par with the baseline learning algorithm. Figure 3 shows the CoNLL average on\n7i.e., mentions that appear in the prediction but not in gold, or the other way around\n8Available at http://conll.cemantix.org/ 2012/software.html\nthe English development set as a function of number of training iterations with two different beam sizes, 20 and 100, over the local and non-local feature sets. The figure shows that even after 50 iterations, early update falls short of the baseline, even when the early update system has access to more informative non-local features.9\nIn Figure 4 we compare early update with LaSO and delayed LaSO on the English development set. The left half uses the local feature set, and the right the extended non-local feature set. Recall that with only local features, delayed LaSO is equivalent to the baseline learning algorithm. As before, early update is considerably worse than other learning strategies. We also see that delayed LaSO outperforms LaSO, both with and without non-local features. Note that plain LaSO with non-local features only barely outperforms the delayed LaSO with only local features (i.e., the baseline), which indicates that only delayed LaSO is able to fully leverage non-local features. From these results we conclude that we are better off when the learning algorithm handles one document at a time, instead of getting feedback within documents.\nLocal vs. Non-local feature sets. Table 1 displays the differences in F-measures and CoNLL average between the local and non-local systems when applied to the development sets for each language. All metrics improve when more informative non-local features are added to the local feature set. Arabic and English show considerable improvements, and the CoNLL average increases\n9Although the Early systems still seem to show slight increases after 50 iterations, it needs a considerable number of iterations to catch up with the baseline – after 100 iterations the best early system is still more than half a point behind the baseline.\nabout one point. For Chinese the gains are generally not as pronounced, though the MUC metric goes up by more than half a point.\nFinal results. In Table 2 we compare the results of the non-local system (This paper) to the best results from the CoNLL 2012 Shared Task.10 Specifically, this includes Fernandes et al.’s (2012) system for Arabic and English (denoted Fernandes), and Chen and Ng’s (2012) system for Chinese (denoted C&N). For English we also compare it to the Berkeley system (Durrett and Klein, 2013), which, to our knowledge, is the best publicly available system for English coreference resolution (denoted D&K). As a general baseline, we also include Björkelund and Farkas’ (2012) system (denoted B&F), which was the second best system in the shared task. For almost all metrics our system is significantly better than the best competitor. For a few metrics the best competitor outperforms our results for either precision or recall, but in terms of F-measures and the CoNLL average our system is the best for all languages.\n10Thanks to Sameer Pradhan for providing us with the outputs of the other systems for significance testing."
  }, {
    "heading": "9 Related Work",
    "text": "On the machine learning side Collins and Roark’s (2004) work on the early update constitutes our starting point. The LaSO framework was introduced by Daumé III and Marcu (2005b), but has, to our knowledge, only been applied to the related task of entity detection and tracking (Daumé III and Marcu, 2005a). The theoretical motivation for early updates was only recently explained rigorously (Huang et al., 2012). The delayed LaSO update that we propose decomposes the prediction task of a complex structure into a number of subproblems, each of which guarantee violation, using Huang et al.’s (2012) terminology. We believe this is an interesting novelty, as it leverages the complete structures for every training instance during every iteration, and expect it to be applicable also to other structured prediction tasks.\nOur approach also resembles imitation learning techniques such as SEARN (Daumé III et al., 2009) and DAGGER (Ross et al., 2011), where the search problem is reduced to a sequence of classification steps that guide the search algorithm through the search space. These frameworks, however, rely on the notion of an expert policy which provides an optimal decision at each point during search. In our context that would require antecedents for every mention to be given a priori, rather than using latent antecedents as we do.\nPerceptrons for coreference. The perceptron has previously been used to train coreference resolvers either by casting the problem as a binary classification problem that considers pairs of mentions in isolation (Bengtson and Roth, 2008; Stoyanov et al., 2009; Chang et al., 2012, inter alia) or in the structured manner, where a clustering for an entire document is predicted in one go (Fernandes et al., 2012). However, none of these works use non-local features. Stoyanov and Eisner (2012) train an Easy-First coreference system with the perceptron to learn a sequence of join operations between arbitrary mentions in a document and accesses non-local features through previous merge operations in later stages. Culotta et al. (2007) also apply online learning in a first-order logic framework that enables non-local features, though using a greedy search algorithm.\nLatent antecedents. The use of latent antecedents goes back to the work of Yu and Joachims (2009), although the idea of determining\nmeaningful antecedents for mentions can be traced back to Ng and Cardie (2002) who used a rulebased approach. Latent antecedents have recently gained popularity and were used by two systems in the CoNLL 2012 Shared Task, including the winning system (Fernandes et al., 2012; Chang et al., 2012). Durrett and Klein (2013) present a coreference resolver with latent antecedents that predicts clusterings over entire documents and fit a loglinear model with a custom task-specific loss function using AdaGrad (Duchi et al., 2011). Chang et al. (2013) use a max-margin approach to learn a pairwise model and rely on stochastic gradient descent to circumvent the costly operation of decoding the entire training set in order to compute the gradients and the latent antecedents. None of the aforementioned works use non-local features in their models, however.\nEntity-mention models. Entity-mention models that compare a single mention to a (partial) cluster have been studied extensively and several works have evaluated non-local entity-level features (Luo et al., 2004; Yang et al., 2008; Rahman and Ng, 2009). Luo et al. (2004) also apply beam search at test time, but use a static assignment of antecedents and learns log-linear model using batch learning. Moreover, these works alter the basic feature definitions from their pairwise models when introducing entity-level features. This contrasts with our work, as our mention-pair model simply constitutes a special case of the non-local system."
  }, {
    "heading": "10 Conclusion",
    "text": "We presented experiments with a coreference resolver that leverages non-local features to improve its performance. The application of non-local features requires the use of an approximate search algorithm to keep the problem tractable. We evaluated standard perceptron learning techniques for this setting both using early updates and LaSO. We found that the early update strategy is considerably worse than a local baseline, as it is unable to exploit all training data. LaSO resolves this issue by giving feedback within documents, but still underperforms compared to the baseline as it distorts the choice of latent antecedents.\nWe introduced a modification to LaSO, where updates are delayed until each document is processed. In the special case where only local features are used, this method coincides with standard structured perceptron learning that uses exact search. Moreover, it is also able to profit from nonlocal features resulting in improved performance. We evaluated our system on all three languages from the CoNLL 2012 Shared Task and present the best results to date on these data sets."
  }, {
    "heading": "Acknowledgments",
    "text": "We are grateful to the anonymous reviewers as well as Christian Scheible and Wolfgang Seeker for comments on earlier versions of this paper. This research has been funded by the DFG via SFB 732, project D8."
  }],
  "year": 2014,
  "references": [{
    "title": "Algorithms for scoring coreference chains",
    "authors": ["Amit Bagga", "Breck Baldwin."],
    "venue": "In The First International Conference on Language Resources and Evaluation Workshop on Linguistics Coreference, pages 563–566.",
    "year": 1998
  }, {
    "title": "Modeling local coherence: An entity-based approach",
    "authors": ["Regina Barzilay", "Mirella Lapata."],
    "venue": "Computational Linguistics, 34(1):1–34.",
    "year": 2008
  }, {
    "title": "Understanding the value of features for coreference resolution",
    "authors": ["Eric Bengtson", "Dan Roth."],
    "venue": "Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing, pages 294–303, Honolulu, Hawaii, October. Association",
    "year": 2008
  }, {
    "title": "Bootstrapping path-based pronoun resolution",
    "authors": ["Shane Bergsma", "Dekang Lin."],
    "venue": "Proceedings of the 21st International Conference on Computational Linguistics and 44th Annual Meeting of the Association for Computational Linguistics, pages 33–40,",
    "year": 2006
  }, {
    "title": "Datadriven multilingual coreference resolution using resolver stacking",
    "authors": ["Anders Björkelund", "Richárd Farkas."],
    "venue": "Joint Conference on EMNLP and CoNLL - Shared Task, pages 49–55, Jeju Island, Korea, July. Association for Computational Linguistics.",
    "year": 2012
  }, {
    "title": "<stumaba >: From deep representation to surface",
    "authors": ["Bernd Bohnet", "Simon Mille", "Benoı̂t Favre", "Leo Wanner"],
    "venue": "In Proceedings of the Generation Challenges Session at the 13th European Workshop on Natural Language Generation,",
    "year": 2011
  }, {
    "title": "Top accuracy and fast dependency parsing is not a contradiction",
    "authors": ["Bernd Bohnet."],
    "venue": "Proceedings of the 23rd International Conference on Computational Linguistics (Coling 2010), pages 89–97, Beijing, China, August.",
    "year": 2010
  }, {
    "title": "Illinoiscoref: The ui system in the conll-2012 shared task",
    "authors": ["Kai-Wei Chang", "Rajhans Samdani", "Alla Rozovskaya", "Mark Sammons", "Dan Roth."],
    "venue": "Joint Conference on EMNLP and CoNLL - Shared Task, pages 113–117, Jeju Island, Korea, July. Asso-",
    "year": 2012
  }, {
    "title": "A constrained latent variable model for coreference resolution",
    "authors": ["Kai-Wei Chang", "Rajhans Samdani", "Dan Roth."],
    "venue": "Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, pages 601–612, Seattle, Washington,",
    "year": 2013
  }, {
    "title": "Combining the best of two worlds: A hybrid approach to multilingual coreference resolution",
    "authors": ["Chen Chen", "Vincent Ng."],
    "venue": "Joint Conference on EMNLP and CoNLL - Shared Task, pages 56–63,",
    "year": 2012
  }, {
    "title": "On the shortest aborescence of a directed graph",
    "authors": ["Yoeng-jin Chu", "Tseng-hong Liu."],
    "venue": "Science Sinica, 14:1396–1400.",
    "year": 1965
  }, {
    "title": "Incremental parsing with the perceptron algorithm",
    "authors": ["Michael Collins", "Brian Roark."],
    "venue": "Proceedings of the 42nd Meeting of the Association for Computational Linguistics (ACL’04), Main Volume, pages 111–118, Barcelona, Spain, July.",
    "year": 2004
  }, {
    "title": "Discriminative training methods for hidden markov models: Theory and experiments with perceptron algorithms",
    "authors": ["Michael Collins."],
    "venue": "Proceedings of the 2002 Conference on Empirical Methods in Natural Language Processing, pages 1–8. Associ-",
    "year": 2002
  }, {
    "title": "Online passive–aggressive algorithms",
    "authors": ["Koby Crammer", "Ofer Dekel", "Joseph Keshet", "Shai Shalev-Shwartz", "Yoram Singer."],
    "venue": "Journal of Machine Learning Reseach, 7:551–585, March.",
    "year": 2006
  }, {
    "title": "First-order probabilistic models for coreference resolution",
    "authors": ["Aron Culotta", "Michael Wick", "Andrew McCallum."],
    "venue": "Human Language Technologies 2007: The Conference of the North American Chapter of the Association for Computational Linguistics;",
    "year": 2007
  }, {
    "title": "A largescale exploration of effective global features for a joint entity detection and tracking model",
    "authors": ["Hal Daumé III", "Daniel Marcu."],
    "venue": "Proceedings of Human Language Technology Conference and Conference on Empirical Methods in Natu-",
    "year": 2005
  }, {
    "title": "Learning as search optimization: approximate large margin methods for structured prediction",
    "authors": ["Hal Daumé III", "Daniel Marcu."],
    "venue": "ICML, pages 169–176.",
    "year": 2005
  }, {
    "title": "Search-based structured prediction",
    "authors": ["Hal Daumé III", "John Langford", "Daniel Marcu."],
    "venue": "Machine Learning, 75(3):297–325.",
    "year": 2009
  }, {
    "title": "Global Joint Models for Coreference Resolution and Named Entity Classification",
    "authors": ["Pascal Denis", "Jason Baldridge."],
    "venue": "Procesamiento del Lenguaje Natural 42, pages 87–96, Barcelona: SEPLN.",
    "year": 2009
  }, {
    "title": "Adaptive subgradient methods for online learning and stochastic optimization",
    "authors": ["John Duchi", "Elad Hazan", "Yoram Singer."],
    "venue": "J. Mach. Learn. Res., 12:2121–2159, July.",
    "year": 2011
  }, {
    "title": "Easy victories and uphill battles in coreference resolution",
    "authors": ["Greg Durrett", "Dan Klein."],
    "venue": "Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, pages 1971–1982,",
    "year": 2013
  }, {
    "title": "Optimum branchings",
    "authors": ["Jack Edmonds."],
    "venue": "Journal of Research of the National Bureau of Standards, 71(B):233–240.",
    "year": 1967
  }, {
    "title": "Latent structure perceptron with feature induction for unrestricted coreference resolution",
    "authors": ["Eraldo Fernandes", "Cı́cero dos Santos", "Ruy Milidiú"],
    "venue": "In Joint Conference on EMNLP and CoNLL - Shared Task,",
    "year": 2012
  }, {
    "title": "Structured perceptron with inexact search",
    "authors": ["Liang Huang", "Suphan Fayong", "Yang Guo."],
    "venue": "Proceedings of the 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages",
    "year": 2012
  }, {
    "title": "Forest reranking: Discriminative parsing with non-local features",
    "authors": ["Liang Huang."],
    "venue": "Proceedings of ACL-08: HLT, pages 586–594, Columbus, Ohio, June. Association for Computational Linguistics.",
    "year": 2008
  }, {
    "title": "A mentionsynchronous coreference resolution algorithm based on the bell tree",
    "authors": ["Xiaoqiang Luo", "Abe Ittycheriah", "Hongyan Jing", "Nanda Kambhatla", "Salim Roukos."],
    "venue": "Proceedings of the 42nd Meeting of the Association for Computational Linguis-",
    "year": 2004
  }, {
    "title": "On coreference resolution performance metrics",
    "authors": ["Xiaoqiang Luo."],
    "venue": "Proceedings of Human Language Technology Conference and Conference on Empirical Methods in Natural Language Processing, pages 25–32, Vancouver, British Columbia,",
    "year": 2005
  }, {
    "title": "Improving machine learning approaches to coreference resolution",
    "authors": ["Vincent Ng", "Claire Cardie."],
    "venue": "Proceedings of 40th Annual Meeting of the Association for Computational Linguistics, pages 104– 111, Philadelphia, Pennsylvania, USA, July. Asso-",
    "year": 2002
  }, {
    "title": "Supervised noun phrase coreference research: The first fifteen years",
    "authors": ["Vincent Ng."],
    "venue": "Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics, pages 1396– 1411, Uppsala, Sweden, July. Association for Com-",
    "year": 2010
  }, {
    "title": "Conll2012 shared task: Modeling multilingual unrestricted coreference in ontonotes",
    "authors": ["Sameer Pradhan", "Alessandro Moschitti", "Nianwen Xue", "Olga Uryupina", "Yuchen Zhang."],
    "venue": "Joint Conference on EMNLP and CoNLL - Shared Task, pages",
    "year": 2012
  }, {
    "title": "Supervised models for coreference resolution",
    "authors": ["Altaf Rahman", "Vincent Ng."],
    "venue": "Proceedings of the 2009 Conference on Empirical Methods in Natural Language Processing, pages 968–977, Singapore, August. Association for Computational Linguistics.",
    "year": 2009
  }, {
    "title": "Design challenges and misconceptions in named entity recognition",
    "authors": ["Lev Ratinov", "Dan Roth."],
    "venue": "Proceedings of the Thirteenth Conference on Computational Natural Language Learning (CoNLL-2009), pages 147–155, Boulder, Colorado,",
    "year": 2009
  }, {
    "title": "A reduction of imitation learning and structured prediction to no-regret online learning",
    "authors": ["Stéphane Ross", "Geoffrey J. Gordon", "J. Andrew Bagnell."],
    "venue": "AISTATS, pages 627–635.",
    "year": 2011
  }, {
    "title": "A machine learning approach to coreference resolution of noun phrases",
    "authors": ["Wee Meng Soon", "Hwee Tou Ng", "Daniel Chung Yong Lim."],
    "venue": "Computational Linguistics, 27(4):521–544.",
    "year": 2001
  }, {
    "title": "Easy-first coreference resolution",
    "authors": ["Veselin Stoyanov", "Jason Eisner."],
    "venue": "Proceedings of COLING 2012, pages 2519–2534, Mumbai, India, December.",
    "year": 2012
  }, {
    "title": "Conundrums in noun phrase coreference resolution: Making sense of the stateof-the-art",
    "authors": ["Veselin Stoyanov", "Nathan Gilbert", "Claire Cardie", "Ellen Riloff."],
    "venue": "Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th In-",
    "year": 2009
  }, {
    "title": "A model theoretic coreference scoring scheme",
    "authors": ["Marc Vilain", "John Burger", "John Aberdeen", "Dennis Connolly", "Lynette Hirschman."],
    "venue": "Proceedings MUC-6, pages 45–52, Columbia, Maryland.",
    "year": 1995
  }, {
    "title": "An entitymention model for coreference resolution with inductive logic programming",
    "authors": ["Xiaofeng Yang", "Jian Su", "Jun Lang", "Chew Lim Tan", "Ting Liu", "Sheng Li."],
    "venue": "Proceedings of ACL08: HLT, pages 843–851, Columbus, Ohio, June.",
    "year": 2008
  }, {
    "title": "Learning structural svms with latent variables",
    "authors": ["Chun-Nam Yu", "T. Joachims."],
    "venue": "International Conference on Machine Learning (ICML).",
    "year": 2009
  }, {
    "title": "A tale of two parsers: Investigating and combining graph-based and transition-based dependency parsing",
    "authors": ["Yue Zhang", "Stephen Clark."],
    "venue": "Proceedings of the 2008 Conference on Empirical Methods in Natural Language Processing, pages 562–",
    "year": 2008
  }],
  "id": "SP:467992aeffdea98eb45a548024388ea1d161f152",
  "authors": [{
    "name": "Anders Björkelund",
    "affiliations": []
  }, {
    "name": "Jonas Kuhn",
    "affiliations": []
  }],
  "abstractText": "We investigate different ways of learning structured perceptron models for coreference resolution when using non-local features and beam search. Our experimental results indicate that standard techniques such as early updates or Learning as Search Optimization (LaSO) perform worse than a greedy baseline that only uses local features. By modifying LaSO to delay updates until the end of each instance we obtain significant improvements over the baseline. Our model obtains the best results to date on recent shared task data for Arabic, Chinese, and English.",
  "title": "Learning Structured Perceptrons for Coreference Resolution with Latent Antecedents and Non-local Features"
}