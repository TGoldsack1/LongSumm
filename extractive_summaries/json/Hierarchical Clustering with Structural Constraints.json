{
  "sections": [{
    "heading": "1. Introduction",
    "text": "Hierarchical clustering (HC) is a widely used data analysis tool, ubiquitous in information retrieval, data mining, and machine learning (see a survey by (Berkhin, 2006)). This clustering technique represents a given dataset as a binary tree; each leaf represents an individual data point and each internal node represents a cluster on the leaves of its descendants. HC has become the most popular method for\n1Department of Computer Science, Stanford University, Stanford, CA, USA. Correspondence to: Moses Charikar <moses@cs.stanford.edu >, Vaggos Chatziafratis <vaggos@stanford.edu >, Rad Niazadeh <rad@cs.stanford.edu>.\nProceedings of the 35 th International Conference on Machine Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018 by the author(s).\ngene expression data analysis (Eisen et al., 1998), and also has been used in the analysis of social networks (Leskovec et al., 2014; Mann et al., 2008), bioinformatics (Diez et al., 2015), image and text classification (Steinbach et al., 2000), and even in analysis of financial markets (Tumminello et al., 2010). It is attractive because it provides richer information at all levels of granularity simultaneously, compared to more traditional flat clustering approaches like k-means.\nRecently, (Dasgupta, 2016) formulated HC as a combinatorial optimization problem, giving a principled way to compare the performance of different HC algorithms. This optimization viewpoint has since received a lot of attention (Roy & Pokutta, 2016; Charikar & Chatziafratis, 2017; CohenAddad et al., 2017; Moseley & Wang, 2017; Cohen-Addad et al., 2018) that has led not only to the development of new algorithms but also to theoretical justifications for the observed success of popular algorithms (e.g. average-linkage).\nHowever, in real applications of clustering, the user often has background knowledge about the data that may not be captured by the input to the clustering algorithm. There is a rich body of work on constrained (flat) clustering formulations that take into account such user input in the form of “cannot link” and “must link” constraints (Wagstaff & Cardie, 2000; Wagstaff et al., 2001; Bilenko et al., 2004; Rangapuram & Hein, 2012). Very recently, “semi-supervised” versions of HC that incorporate additional constraints have been studied (Vikram & Dasgupta, 2016), where the natural form of such constraints is triplet (or “must link before”) constraints ab|c1: these require that valid solutions contain a sub-cluster with a, b together and c previously separated from them.2 Such triplet constraints, as we show later, can encode more general structural constraints in the form of rooted subtrees. Surprisingly, such simple triplet constraints already pose significant challenges for bottom-up linkage methods. (Figure 1).\nOur work is motivated by applying the optimization lens to study the interaction of hierarchical clustering algorithms with structural constraints. Constraints can be fairly natu-\n1Hierarchies on data imply that all datapoints are linked at the highest level and all are separated at the lowest level, hence “cannot link” and “must link” constraints are not directly meaningful.\n2For a concrete example from taxonomy of species, a triplet constraint may look like (TUNA, SALMON|LION).\nrally incorporated into top-down (i.e. divisive) algorithms for hierarchical clustering; but can we establish guarantees on the quality of the solution they produce? Another issue is that incorporating constraints from multiple experts may lead to a conflicting set of constraints; can the optimization viewpoint of hierarchical clustering still help us obtain good solutions even in the presence of infeasible constraints? Finally, different objective functions for HC have been studied in the literature; do algorithms designed for these objectives behave similarly in the presence of constraints? To the best of our knowledge, this is the first work to propose a unified approach for constrained HC through the lens of optimization and to give provable approximation guarantees for a collection of fast and simple top-down algorithms that have been used for unconstrained HC in practice (e.g. community detection in social networks (Mann et al., 2008)).\nBackground on Optimization View of HC. (Dasgupta, 2016) introduced a natural optimization framework for HC. Given a weighted graph G(V,E,w) and pairwise similarities wij ≥ 0 between the n data points i, j ∈ V , the goal is to find a hierarchical tree T ∗ such that\nT ∗ = arg min all trees T ∑ (i,j)∈E wij · |Tij | (1)\nwhere Tij is the subtree rooted at the lowest common ancestor of i, j in T and |Tij | is the number of leaves it contains.3 We denote (1) as similarity-HC. For applications where the geometry of the data is given by dissimilarities, again denoted by {wij}(i,j)∈E , (Cohen-Addad et al., 2018) proposed an analogous approach, where the goal is to find a hierarchical tree T ∗ such that\nT ∗ = arg max all trees T ∑ (i,j)∈E wij · |Tij | (2)\nWe denote (2) as dissimlarity-HC. A comprehensive list of desirable properties of the aformentioned objectives can be found in (Dasgupta, 2016; Cohen-Addad et al., 2018). In\n3Observe that in HC, all edges get cut eventually. Therefore it is better to postpone cutting “heavy” edges to when the clusters become small, i.e .as far down the tree as possible.\nparticular, if there is an underlying ground-truth hierarchical structure in the data, then T ∗ can recover the ground-truth. Also, both objectives are NP-hard to optimize, so the focus is on approximation algorithms.\nOur Results. i) We design algorithms that take into account both the geometry of the data, in the form of similarities, and the structural constraints imposed by the users. Our algorithms emerge as the natural extensions of Dasgupta’s original recursive sparsest cut algorithm and the recursive balanced cut suggested in (Charikar & Chatziafratis, 2017). We generalize previous analyses to handle constraints and we prove an O(kαn)-approximation guarantee4, thus surprisingly matching the best approximation guarantee of the unconstrained HC problem for constantly many constraints.\nii) In the case of infeasible constraints, we extend the similarity-HC optimization framework, and we measure the quality of a possible tree T by a constraint-based regularized objective. The regularization naturally favors solutions with as few constraint violations as possible and as far down the tree as possible (similar to the motivation behind similarity-HC objective). For this problem, we provide a top-down O(kαn)-approximation algorithm by drawing an interesting connection to an instance of the hypergraph sparsest cut problem.\niii) We then change gears and study the dissimilarity-HC objective. Surprisingly, we show that known top-down techniques do not cope well with constraints, drawing a contrast with the situation for similarity-HC. Specifically, the (locally) densest cut heuristic performs poorly even if there is only one triplet constraint, blowing up its approximation factor to O(n). Moreover, we improve upon the state-ofthe-art in (Cohen-Addad et al., 2018), by showing a simple randomized partitioning is a 23 -approximation algorithm. We also give a deterministic local-search algorithm with the same worst-case guarantee. Furthermore, we show that our randomized algorithm is robust under constraints, mainly because of its “exploration” behavior. In fact, besides the number of constraints, we propose an inherent notion of dependency measure among constraints to capture this behavior quantitatively. This helps us not only to explain why “non-exploring” algorithms may perform poorly, but also gives tight guarantees for our randomized algorithm.\nExperimental results. We run experiments on the Zoo dataset (Lichman, 2013) to demonstrate our approach and the performance of our algorithms for a taxonomy application. Due to lack of space, we present these results in the full online version of our paper (Chatziafratis et al., 2018).\nConstrained HC work-flow in Practice. Throughout this paper, we develop different tools to handle user-defined\n4For n data points, αn = O( √\nlogn) is the best approximation factor for the sparsest cut and k is the number of constraints.\nstructural constraints for hierarchical clustering. Here we describe a recipe on how to use our framework in practice.\n(1) Preprocessing constraints to form triplets. User-defined structural constraints as rooted binary subtrees are convenient for the user and hence for the usability of our algorithm. The following proposition (whose proof is in the supplement) allows us to focus on studying HC with just triplet constraints. Proposition 1. Given constraints as a rooted binary subtree T on k data points (k ≥ 3), there is linear time algorithm that returns an equivalent set of at most k triplet constraints.\n(2) Detecting feasibility. The next step is to see if the set of triplet constraints is consistent, i.e. whether there exists a HC satisfying all the constraints. For this, we use a simple linear time algorithm called BUILD (Aho et al., 1981).\n(3) Hard constraints vs. regularization. BUILD can create a hierarchical decomposition that satisfies triplet constraints, but ignores the geometry of the data, whereas our goal here is to consider both simultaneously. Moreover, in the case that the constraints are infeasible, we aim to output a clustering that minimizes the cost of violating constraints combined with the cost of the clustering itself.\n• Feasible instance: to output a feasible HC, we propose using Constrained Recursive Sparsest Cut (CRSC) or Constrained Recursive Balanced Cut (CRBC): two simple topdown algorithms which are natural adaptations of recursive sparsest cut (Mann et al., 2008; Dasgupta, 2016) or recursive balanced cut (Charikar & Chatziafratis, 2017) to respect constraints (Section 2).\n• Infeasible instance: in this case, we turn our attention to a regularized version of HC, where the cost of violating constraints is added to the tree cost. We then propose an adaptation of CRSC, namely Hypergraph Recursive Sparsest Cut (HRSC) for the regularized problem (Section 3).\nSee the supplementary materials for a real-world application examples, demonstrating our proposed HC work-flow.\nFurther related work. Similar to (Vikram & Dasgupta, 2016), constraints in the form of triplet queries have been used in an (adaptive) active learning framework by (Tamuz et al., 2011; Emamjomeh-Zadeh & Kempe, 2018), showing that approximately O(n log n) triplet queries are enough to learn an underlying HC. Other forms of user interaction in order to improve the quality of the produced clusterings have been used in (Balcan & Blum, 2008; Awasthi et al., 2014) where they prove that interactive feedback in the form of cluster split/merge requests can lead to significant improvements. Robust algorithms for HC in the presence of noise were studied in (Balcan et al., 2014) and a variety of sufficient conditions on the similarity function that would allow linkage-style methods to produce good clusters was\nexplored in (Balcan et al., 2008). On a different setting, the notion of triplets has been used as a measure of distance between hierarchical decomposition trees on the same data points (Brodal et al., 2013). More technically distant analogs of how to use relations among triplets points have recently been proposed in (Kleindessner & von Luxburg, 2017) for defining kernel functions corresponding to high-dimensional embeddings."
  }, {
    "heading": "2. Constrained Sparsest (Balanced) Cut",
    "text": "Given an instance of the constrained hierarchical clustering, our proposed CRSC algorithm uses a blackbox αn-approximation algorithm for the sparsest cut problem (the best-known approximation factor for this problem is O( √\nlog n) due to (Arora et al., 2009)). Moreover, it also maintains the feasibility of the solution in a top-down approach by recursive partitioning of what we call the supergraph G′. Informally speaking, the supergraph is a simple data structure to track the progress of the algorithm and the resolved constraints.\nMore formally, for every constraint ab|c we merge the nodes a and b into a supernode {a, b} while maintaining the edges in G (now connecting to their corresponding supernodes). Note that G′ may have parallel edges, but this can easily be handled by grouping edges together and replacing them with the sum of their weights. We repeatedly continue this merging procedure until there are no more constraints. Observe that any feasible solution needs to start splitting the original graph G by using a cut that is also present in G′. When cutting the graph G′ = (G1, G2), if a constraint ab|c is resolved,5 then we can safely unpack the supernode {a, b} into two nodes again (unless there is another constraint ab|c′ in which case we should keep the supernode). By continuing and recursively finding approximate sparsest cuts on the supergraph G1 and G2, we can find a feasible hierarchical decomposition of G respecting all triplet constraints. Next, we show the approximation guarantees for our algorithm.\nAlgorithm 1 CRSC 1: Given G and the triplet constraints ab|c, run BUILD to\ncreate the supergraph G′. 2: Use a blackbox access to an αn-approximation oracle\nfor the sparsest cut problem, i.e. arg minS⊆V wG′ (S,S̄)\n|S|·|S̄| . (|S| = total size of supernodes in S) 3: Given the output cut (S, S̄), separate the graph G′ into two pieces G1(S,E1) and G2(V \\ S,E2). 4: Recursively compute a HC T1 for G1 using only G1’s active constraints. Similarly compute T2 for G2. 5: Output T = (T1, T2).\nAnalysis of CRSC Algorithm. The main result of this section is the following theorem:\n5A constraint ab|c is resolved, if c gets separated from a, b.\nTheorem 1. Given a weighted graph G(V,E,w) with k triplet constraints ab|c for a, b, c ∈ V , the CRSC algorithm outputs a HC respecting all triplet constraints and is O(kαn)-approximation for the HC-similarity objective (1).\nNotations and Definitions. We slightly abuse notation by having OPT denote the optimum hierarchical decomposition or its optimum value as measured by (1). Similarly for CRSC. For t ∈ [n], OPT(t) denotes the maximal clusters in OPT of size at most t. Note that OPT(t) induces a partitioning of V . We use OPT(t) to denote edges cut by OPT(t) (i.e. edges with endpoints in different clusters in OPT(t)) or their total weight; the meaning will be clear from context. For convenience, we define OPT(0) = ∑ (i,j)∈E wij . For a cluster A created by CRSC, a constraint ab|c is active if a, b, c ∈ A, otherwise ab|c is resolved and can be discarded.\nOverview of the Analysis. There are three main ingredients: The first is to view a HC of n datapoints as a collection of partitions, one for each level t = n − 1, . . . , 1, as in (Charikar & Chatziafratis, 2017). For a level t, the partition consists of maximal clusters of size at most t. The total cost incurred by OPT is then a combination of costs incurred at each level of this partition. This is useful for comparing our CRSC cost with OPT. The second idea is in handling constraints and it is the main obstacle where previous analyses (Charikar & Chatziafratis, 2017; Cohen-Addad et al., 2018) break down: constraints inevitably limit the possible cuts that are feasible at any level, and since the set of active constraints6 differ for CRSC and OPT, a direct comparison between them is impossible. If we have no constraints, we can charge the cost of partitioning a clusterA to lower levels of the OPT decomposition. However, when we have triplet constraints, the partition induced by the lower levels of OPT in a cluster A will not be feasible in general (Figure 2). The natural way to overcome this obstacle is merging pieces of this partition so as to respect constraints and using higher levels of OPT, but it still may be impossible to compare CRSC with OPT if all pieces are merged. We overcome this difficulty by an indirect comparison between the CRSC cost and lower levels r6kA of OPT, where kA is the number of active constraints in A. Finally, after a cluster-by-cluster analysis bounding the CRSC cost for each cluster, we exploit disjointness of clusters of the same level in the CRSC partition allowing us to combine their costs.\nProof of Theorem 1. We start by borrowing the following facts from (Charikar & Chatziafratis, 2017), modified slightly for the purpose of our analysis (proofs are provided in the supplementary materials).\nFact 1 (Decomposition of OPT). The total cost paid by OPT can be decomposed into costs of the different levels in\n6All constraints are active in the beginning of CRSC.\nthe OPT partition, i.e. OPT = ∑n t=0 w(OPT(t)).\nFact 2 (OPT at scaled levels). Let k ≤ n6 be the number of constraints. Then, OPT ≥ 16k · ∑n t=0 w(OPT(b t 6k c)).\nGiven the above facts, we look at any clusterA of size r produced by the algorithm. Here is the main technical lemma that allows us to bound the cost of CRSC for partitioning A.\nLemma 1. Suppose CRSC partitions a cluster A (|A| = r) in two clusters (B1, B2) (w.l.o.g. |B1| = s, |B2| = r − s, s ≤ b r2c ≤ r − s). Let the size r ≥ 6k and let l = 6kA, where kA denotes the number of active constraints for A. Then: r · w(B1, B2) ≤ 4αn · s · w(OPT(b rl c) ∩A).\nProof. The cost incurred by CRSC for partitioning A is r · w(B1, B2). Now consider OPT(b rl c). This induces a partitioning of A into pieces {Ai}i∈[m], where by design |Ai| = γi|A|, γi ≤ 1l ,∀i ∈ [m]. Now, consider the cuts {(Ai, A \\ Ai)}. Even though all m cuts are allowed for OPT, for CRSC some of them are forbidden: for example, in Figure 2, the constraints ab|c, de|f render 4 out of the 6 cuts infeasible. But how many of them can become infeasible with kA active constraints? Since every constraint is involved in at most 2 cuts, we may have at most 2kA infeasible cuts. Let F ⊆ [m] denote the index set of feasible cuts, i.e. if i ∈ F , the cut (Ai, A \\Ai) is feasible for CRSC. To cut A, we use an αn-approximation of sparsest cut, whose sparsity is upper bounded by any feasible cut:\nw(B1, B2)\ns(r − s) ≤ αn · SP.CUT(A) ≤ αn min i∈F w(Ai, A \\Ai) |Ai||A \\Ai|\n≤ αn ∑ i∈F w(Ai, A \\Ai)∑ i∈F |Ai||A \\Ai|\nwhere for the last inequality we used the standard fact that mini\nµi νi ≤ ∑ i µi∑ i νi\nfor µi ≥ 0 and νi > 0. We also have the following series of inequalities:\nαn ∑ i∈F w(Ai, A \\Ai)∑ i∈F |Ai||A \\Ai| ≤ αn 2w(OPT(b rl c) ∩A) r2 ∑ i∈F γi(1− γi)\n≤ 4αn w(OPT(b rl c) ∩A)\nr2\nwhere the first inequality holds because we double count some (potentially all) edges of OPT(b rl c)∩A (these are the edges cut by OPT(b rl c) that are also present in cluster A, i.e. they have both endpoints in A) and the second inequality holds because γi ≤ 16k =⇒ 1− γi ≥\n6k−1 6k and∑ i∈F γi(1− γi) ≥ m∑ i=1 γi(1− γi)− 2 ∑ i∈[m]\\F 1 6k\n≥ 6k − 1 6k m∑ i=1 γi − 2k 6k = 4k − 1 6k ≥ 1/2\nFinally, we are ready to prove the lemma by combining the above inequalities ( r−sr ≤ 1):\nr · w(B1, B2) = r · s(r − s) · w(B1, B2)\ns(r − s)\n≤ r · s(r − s) · 4αn w(OPT(b rl c) ∩A)\nr2\n≤ 4αn · s · w(OPT(b rl c) ∩A).\nIt is clear that we exploited the charging to lower levels of OPT, since otherwise if all pieces in A were merged, the denominator with the |Ai|’s would become 0. The next lemma lets us combine the costs incurred by CRSC for different clustersA (proof is in the supplementary materials)\nLemma 2 (Combining the costs of clusters in CRSC). The total CRSC cost for partitioning all clusters A into (B1, B2) (with |A| = rA, |B1| = sA) is bounded by: (1) ∑\nA:|A|≥6k rA · w(B1, B2) ≤ O(αn) · n∑ t=0 w(OPT(b t6k c))\n(2) ∑\nA:|A|<6k\nrAw(B1, B2) ≤ 6k · OPT\nCombining Fact 2 and Lemma 2 finishes the proof.\nRemark 1. In the supplementary material, we prove how one can use balanced cut, i.e. finding a cut S such that\narg min S⊆V :|S|≥n/3,|S̄|≥n/3 wG′(S, S̄) (3)\ninstead of sparsest cut, and using approximation algorithms for this problem achieves the same approximation factor as in Theorem 1, but with better running time.\nTheorem 2 (The divisive algorithm using balanced cut). Given a weighted graph G(V,E,w) with k triplet constraints ab|c for a, b, c ∈ V , the constrained recursive balanced cut algorithm CRBC (same as CRSC, but using balanced cut instead of sparsest cut) outputs a HC respecting all triplet constraints and achieves an O(kαn)approximation for Dasgupta’s HC objective. Moreover, the running time is almost linear time."
  }, {
    "heading": "3. Constraints and Regularization",
    "text": "Previously, we assumed that constraints were feasible. However, in many practical applications, users/experts may disagree, hence our algorithm may receive conflicting constraints as input. Here we want to explore how to still output a satisfying HC that is a good in terms of objective (1) (similarity-HC) and also respects the constraints as much as possible. To this end, we propose a regularized version of Dasgupta’s objective, where the regularizer measures quantitatively the degree by which constraints get violated.\nInformally, the idea is to penalize a constraint more if it is violated at top levels of the decomposition compared to lower levels. We also allow having different violation weights for different constraints (potentially depending on the expertise of the users providing the constraints). More concretely, inspired by the Dasgupta’s original objective function, we consider the following optimization problem:\nmin T∈T ( ∑ (i,j)∈E wij |Tij |\n+ λ · ∑\nab|c∈K\ncab|c|Tab| · 1{ab|c is violated} ) , (4)\nwhere T is the set of all possible binary HC trees for the given data points, K is the set of the k triplet constraints, Tab is the size of the subtree rooted at the least common ancestor of a, b, and cab|c is defined as the base cost of violating triplet constraint ab|c. Note that the regularization parameter λ ≥ 0 allows us to interpolate between satisfying the constraints or respecting the geometry of the data.\nHypergraph Recursive Sparsest Cut In order to design approximation algorithms for the regularized objective, we draw an interesting connection to a different problem, which we call 3-Hypergraph Hierarchical Clustering (3HHC). An instance of this problem consists of a hypergraph GH = (V,E,EH) with edges E, and hyperedges of size 3, EH, together with similarity weights for edges, {wij}(i,j)∈E , and similarity weights for 3-hyperedges,7 {wij|k}(i,j,k)∈EH . We now think of HC on the hypergraphGH, where for every binary tree T we define the cost to be the natural extension of Dasgupta’s objective:∑\n(i,j)∈E\nwij |Tij |+ ∑\n(i,j,k)∈EH wTijk|Tijk| (5)\nwhere wTijk is either equal to wij|k, wjk|i or wki|j , and Tijk is either the subtree rooted at LCA(i, j),8 LCA(i, k) or LCA(k, j), all depending on how T cuts the 3-hyperedge\n7We have 3 different weights corresponding to the 3 possible ways of partitioning {i, j, k} in two parts: wij|k, wjk|i and wki|j .\n8LCA(i, j) denotes the lowest common ancestor of i, j ∈ T .\n{i, j, k}. The goal is to find a hierarchical clustering of this hypergraph, so as to minimize the cost (5) of the tree.\nReduction from Regularization to 3HHC. Given an instance of HC with constraints (with their costs of violations) and a parameter λ, we create a hypergraph GH so that the total cost of any binary clustering tree in the 3HHC problem (5) corresponds to the regularized objective of the same tree as in (4). GH has exactly the same set of vertices, (normal) edges and (normal) edge weights as in the original instance of the HC problem. Moreover, for every constraint ab|c (with cost cab|c) it has a hyperedge {a, b, c}, to which we assign three weights wab|c = 0, wac|b = wbc|a = λ · cab|c. Therefore, we ensure that any divisive algorithm for the 3HHC problem avoids the cost |Tabc| · λ · cab|c only if it chops {a, b, c} into {a, b} and {c} at some level, which matches the regularized objective.\nReduction from 3HHC to Hypergraph Sparsest Cut. A natural generalization of the sparsest cut problem for our hypergraphs, which we call Hyper Sparsest Cut (HSC), is the following problem:\narg min S⊆V\n( w(S, S̄) + ∑ (i,j,k)∈EH w S ijk\n|S||S̄|\n) ,\nwhere w(S, S̄) is the weight of the cut (S, S̄) and wSijk is either equal to wij|k, wjk|i or wki|j , depending on how (S, S̄) chops the hyperedge {i, j, k}. Now, similar to (Charikar & Chatziafratis, 2017; Dasgupta, 2016), we can recursively run a blackbox approximation algorithm for HSC to solve 3HHC. The main result of this section is the following technical proposition, whose proof is analogous to that of Theorem 1 (provided in the supplementary materials).\nProposition 2. Given the hypergraph GH with k hyperedges, and given access an αn-approximation algorithm for HSC, the Recursive Hypergraph Sparsest Cut (R-HSC) algorithm achieves an O(kαn)-approximation.\nReduction from HSC back to Sparsest Cut. We now show how to get an αn-approximation oracle for our instance of the HSC problem by a general reduction to sparsest cut. Our reduction is simple: given a hypergraphGH and all the weights, create an instance of sparsest cut with the same vertices, (normal) edges and (normal) edge weights. Moreover, for every 3-hyperedge {a, b, c} consider adding a triangle to the graph, i.e. three weighted edges connecting {a, b, c}, where:\nw′ab = wbc|a + wac|b − wab|c\n2 = λ · cab|c,\nw′ac = wbc|a + wab|c − wac|b\n2 = 0,\nw′bc = wac|b + wab|c − wbc|a\n2 = 0.\nThis construction can be seen in Figure 3. The important observation is that w′ab + w ′ ac = wbc|a, w ′ ab + w ′ bc = wac|b and w′bc + w ′ ac = wab|c, which are exactly the weights associated with the corresponding splits of the 3-hyperedge {a, b, c}. So, correctness of the reduction9 follows as the weight of each cut is preserved between the hypergraph and the graph after adding the triangles. For a discussion on extending this gadget more generally, see the supplement."
  }, {
    "heading": "4. Variations on a Theme",
    "text": "In this section we study dissimilarity-HC, and we look into the problem of designing approximation algorithms for both unconstrained and constrained hierarchical clustering. In (Cohen-Addad et al., 2017), they show that average linkage is a 12 -approximation for this problem and they propose a top-down approach based on locally densest cut achieving a ( 23 − )-approximation in time Õ ( n2(n+m) ) . Notably, when gets small the running time blows up.\nHere, we prove that the most natural randomized algorithm for this problem, i.e. recursive random cutting, is a 23 - approximation with expected running time O(n log n). We further derandomize this algorithm to get a simple deterministic local-search style 23 -approximation algorithm.\nIf we also have structural constraints for the dissimilarityHC, we show that the existing approaches fail. In fact we show that they lead to an Ω(n)-approximation factor due to the lack of “exploration” (e.g. recursive densest cut). We then show that recursive random cutting is robust to adding user constraints, and indeed it preserves a constant approximation factor when there are, roughly speaking, constantly many user constraints.\nRandomized 23 -approximation. Consider the most natural randomized algorithm for hierarchical clustering, i.e. recursively partition each cluster into two, where each point in the current cluster independently flips an unbiased coin and based on the outcome, it is put in one of the two parts.\nTheorem 3. Recursive-Random-Cutting is a 23 - approximation for maximizing dissimilarity-HC objective.\nProof sketch. An alternative view of Dasgupta’s objective is to divide the reward of the clustering tree between all possible triples {i, j, k}, where (i, j) ∈ E and k is another point (possibly equal to i or j). Now, in any hierarchical clustering tree, if at the moment right before i and j become separated the vertex k has still been in the same cluster as\n9Since all weights in the final graph are non-negative, standard techniques for Sparsest Cut can be used.\n{i, j}, then this triple contributes wij to the objective function. We claim this event happens with probability exactly 2 3 . To see this, consider an infinite independent sequence of coin flips for i, j, and k. Without loss of generality, condition on i’s sequence to be all heads. The aforementioned event happens only if j’s first tales in its sequence happens no later than k’s first tales in its sequence. This happens with probability ∑ i≥1 1 2 ( 1 4 ) i−1 = 23 . Therefore, the algo-\nrithm gets the total reward 2n3 ∑\n(i,j)∈E wij in expectation. Moreover, the total reward of any hierarchical clustering is upper-bounded by n ∑ (i,j)∈E wij , which completes the proof of the 23 -approximation.\nRemark 2. This algorithm runs in time O(n log n) in expectation, due to the fact that the binary clustering tree has expected depth O(log n) (see for example (Cormen et al., 2009)) and at each level we only perform n operations.\nWe now derandomize the recursive random cutting algorithm using the method of conditional expectations. At every recursion, we go over the points in the current cluster one by one, and decide whether to put them in the “left” partition or “right” partition for the next recursion. Once we make a decision for a point, we fix that point and go to the next one. Roughly speaking, these local improvements can be done in polynomial time, which will result in a simple local-search style deterministic algorithm.\nTheorem 4. There is a deterministic local-search style 23 - approximation algorithm for maximizing dissimilarity-HC objective that runs in time O(n2(n+m)).\nMaximizing the Objective with User Constraints From a practical point of view, one can think of many settings in which the output of the hierarchical clustering algorithm should satisfy user-defined hard constraints. Now, combining the new perspective of maximizing Dasgupta’s objective with this practical consideration raises a natural question: which algorithms are robust to adding user constraints, in the sense that a simple variation of these algorithms still achieve a decent approximation factor?\n• Failure of “Non-exploring” Approaches. Surprisingly enough, there are convincing reasons that adapting existing algorithms for maximizing Dasgupta’s objective (e.g. those proposed in (Cohen-Addad et al., 2018)) to handle user constraints is either challenging or hopeless. First, bottom-up algorithms, e.g. average-linkage, fail to output a feasible outcome if they only consider each constraint separately and not all the constraints jointly (as we saw in Figure 1). Second, maybe more surprisingly, the natural extension of (locally) Recursive-Densest-Cut10 algorithm proposed in (Cohen-Addad et al., 2018) to handle user constraints performs poorly in the worst-case, even when we\n10While a locally densest cut can be found in poly-time, desnest cut is NP-hard, making our negative result stronger.\nhave only one constraint. Recursive-Densest-Cut proceeds by repeatedly picking the cut that has maximum density, i.e. arg maxS⊆V w(S,S̄) |S|·|S̄| and making two clusters. To handle the user constraints, we run it recursively on the supergraph generated by the constraints, similar to the approach in Section 2. Note that once the algorithm resolves a triplet constraint, it also breaks its corresponding supernode.\nNow consider the following example in Figure 4, in which there is just one triplet constraint ab|c. The weightW should be thought of as large and as small. By choosing appropriate weights on the edges of the clique Kn, we can fool the algorithm into cutting the dense parts in the clique, without ever resolving the ab|c constraint until it is too late. The algorithm gets a gain of O(n3 + W ) whereas OPT gets Ω(nW ) by starting with the removal of the edge (b, c) and then removing (a, b), thus enjoying a gain of ≈ nW .\n• Constrained Recursive Random Cutting. The example in Figure 4, although a bit pathological, suggests that a meaningful algorithm for this problem should explore cutting low-weight edges that might lead to resolving constraints, maybe randomly, with the hope of unlocking rewarding edges that were hidden before this exploration.\nFormally, our approach is showing that the natural extension of recursive random cutting for the constrained problem, i.e. by running it on the supergraph generated by constraints and unpacking supernodes as we resolve the constraints (in a similar fashion to CSC), achieves a constant factor approximation when the constraints have bounded dependency. In the remaining of this section, we define an appropriate notion of dependency between the constraints, under the name of dependency measure and analyze the approximation factor of constrained recursive random cutting (Constrained-RRC ) based on this notion.\nSuppose we are given an instance of hierarchical clustering with triplet constraints {c1, . . . , ck}, where ci = xi|yizi,∀i ∈ [k]. For any triplet constraint ci, lets call the pair {yi, zi} the base, and zi the key of the constraint. We first partition our constraints into equivalence classes C1, . . . , CN , where Ci ⊆ {c1, . . . , ck}. For every i, j, the constraints ci and cj belong to the same class C if they share\nthe same base (see Figure 5).\nDefinition 1 (Dependency digraph). The Dependency digraph is a directed graph with vertex set {C1, . . . , CL}. For every i, j, there is a directed edge Ci → Cj if ∃ c = x|yz, c′ = x′|y′z′, such that c ∈ Ci, c′ ∈ Cj , and either {x, z} = {y′, z′} or {x, y} = {y′, z′} (see Figure 6).\nThe dependency digraph captures how groups of constraints impact each other. Formally, the existence of the edge Ci → Cj implies that all the constraints in Cj should be resolved before one can separate the two endpoints of the (common) base edge of the constraints in Ci.\nRemark 3. If the constraints {c1, . . . , ck} are feasible, i.e. there exists a hierarchical clustering that can respect all the constraints, the dependency digraph is clearly acyclic.\nDefinition 2 (Layered dependency subgraph). Given any class C, the layered dependency subgraph of C is the induced subgraph in the dependency digraph by all the classes that are reachable from C. Moreover, the vertex set of this subgraph can be partitioned into layers {I0, I1, . . . , IL}, where L is the maximum length of any directed path leaving C and Il is a subset of classes where the length of the longest path from C to each of them is exactly equal to l (see Figure 7).\nWe are now ready to define a crisp quantity for every dependency graph. This will later help us give a more meaningful and refined beyond-worst-case guarantee for the approximation factor of the Constrained-RRC algorithm.\nDefinition 3 (Dependency measure). Given any class C,\nthe dependency measure of C is defined as\nDM(C) , L∏ l=0 (1 + ∑ C′∈Il |C′|),\nwhere I0, . . . , IL are the layers of the dependency subgraph of C, as in Definition 2. Moreover, the dependency measure of a set of constraints DMC({c1, . . . , ck}) is defined as maxC DM(C), where the maximum is taken over all the classes generated by {c1, . . . , ck}.\nIntuitively speaking, the notion of the dependency measure quantitatively expresses how “deeply” the base of a constraint is protected by the other constraints, i.e. how many constraints need to be resolved first before the base of a particular constraint is unpacked and the Constrained-RRC algorithm can enjoy its weight. This intuition is formalized through the following theorem, whose proof is deferred to the supplementary materials. Theorem 5. The constrained recursive random cutting (Constrained-RRC ) algorithm is an α-approximation algorithm for maximizing dissimilarity-HC objective objective given a set of feasible constraints {c1, . . . , ck}, where\nα = 2(1− k/n) 3 · DMC({c1, . . . , ck}) ≤ 2(1− k/n) 3 ·maxC DM(C)\nCorollary 1. Constrained-RRC is an O(1)approximation for maximizing dissimilarity-HC objective, given feasible constraints of constant dependency measure."
  }, {
    "heading": "5. Conclusion",
    "text": "We studied the problem of hierarchical clustering when we have structural constraints on the feasible hierarchies. We followed the optimization viewpoint that was recently developed in (Dasgupta, 2016; Cohen-Addad et al., 2018) and we analyzed two natural top-down algorithms giving provable approximation guarantees. In the case where the constraints are infeasible, we proposed and analyzed a regularized version of the HC objective by using the hypergraph version of the sparsest cut. Finally, we explored a variation of Dasgupta’s objective and improved upon previous techniques, both in the unconstrained and in the constrained setting."
  }, {
    "heading": "Acknowledgements",
    "text": "Vaggos Chatziafratis was partially supported by ONR grant N00014-17-1-2562. Rad Niazadeh was supported by Stanford Motwani fellowship. Moses Charikar was supported by NSF grant CCF-1617577 and a Simons Investigator Award. We would also like to thank Leo Keselman, Aditi Raghunathan and Yang Yuan for providing comments on an earlier draft of the paper. We also thank the anonymous reviewers for their helpful comments and suggestions."
  }],
  "year": 2018,
  "references": [{
    "title": "Inferring a tree from lowest common ancestors with an application to the optimization of relational expressions",
    "authors": ["A.V. Aho", "Y. Sagiv", "T.G. Szymanski", "J.D. Ullman"],
    "venue": "SIAM Journal on Computing,",
    "year": 1981
  }, {
    "title": "Expander flows, geometric embeddings and graph partitioning",
    "authors": ["S. Arora", "S. Rao", "U. Vazirani"],
    "venue": "Journal of the ACM (JACM),",
    "year": 2009
  }, {
    "title": "Local algorithms for interactive clustering",
    "authors": ["P. Awasthi", "M. Balcan", "K. Voevodski"],
    "venue": "In International Conference on Machine Learning,",
    "year": 2014
  }, {
    "title": "Clustering with interactive feedback",
    "authors": ["Balcan", "M.-F", "A. Blum"],
    "venue": "In International Conference on Algorithmic Learning Theory,",
    "year": 2008
  }, {
    "title": "A discriminative framework for clustering via similarity functions",
    "authors": ["Balcan", "M.-F", "A. Blum", "S. Vempala"],
    "venue": "In Proceedings of the fortieth annual ACM symposium on Theory of computing,",
    "year": 2008
  }, {
    "title": "Robust hierarchical clustering",
    "authors": ["Balcan", "M.-F", "Y. Liang", "P. Gupta"],
    "venue": "The Journal of Machine Learning Research,",
    "year": 2014
  }, {
    "title": "A survey of clustering data mining techniques",
    "authors": ["P. Berkhin"],
    "venue": "In Grouping multidimensional data,",
    "year": 2006
  }, {
    "title": "Integrating constraints and metric learning in semi-supervised clustering",
    "authors": ["M. Bilenko", "S. Basu", "R.J. Mooney"],
    "venue": "In Proceedings of the twenty-first international conference on Machine learning,",
    "year": 2004
  }, {
    "title": "Hierarchical clustering with structural constraints",
    "authors": ["V. Chatziafratis", "R. Niazadeh", "M. Charikar"],
    "venue": "arXiv preprint arXiv:1805.09476,",
    "year": 2018
  }, {
    "title": "Hierarchical clustering beyond the worst-case",
    "authors": ["V. Cohen-Addad", "V. Kanade", "F. Mallmann-Trenn"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2017
  }, {
    "title": "Hierarchical clustering: Objective functions and algorithms",
    "authors": ["V. Cohen-Addad", "V. Kanade", "F. Mallmann-Trenn", "C. Mathieu"],
    "venue": "In Proceedings of the Twenty-Ninth Annual ACM-SIAM Symposium on Discrete Algorithms,",
    "year": 2018
  }, {
    "title": "Introduction to Algorithms, Third Edition",
    "authors": ["T.H. Cormen", "C.E. Leiserson", "R.L. Rivest", "C. Stein"],
    "year": 2009
  }, {
    "title": "A cost function for similarity-based hierarchical clustering",
    "authors": ["S. Dasgupta"],
    "venue": "In Proceedings of the forty-eighth annual ACM symposium on Theory of Computing,",
    "year": 2016
  }, {
    "title": "A novel brain partition highlights the modular skeleton shared by structure and function",
    "authors": ["I. Diez", "P. Bonifazi", "I. Escudero", "B. Mateos", "M.A. Muñoz", "S. Stramaglia", "J.M. Cortes"],
    "venue": "Scientific reports,",
    "year": 2015
  }, {
    "title": "Cluster analysis and display of genome-wide expression patterns",
    "authors": ["M.B. Eisen", "P.T. Spellman", "P.O. Brown", "D. Botstein"],
    "venue": "Proceedings of the National Academy of Sciences,",
    "year": 1998
  }, {
    "title": "Adaptive hierarchical clustering using ordinal queries",
    "authors": ["E. Emamjomeh-Zadeh", "D. Kempe"],
    "venue": "In Proceedings of the Twenty-Ninth Annual ACM-SIAM Symposium on Discrete Algorithms,",
    "year": 2018
  }, {
    "title": "Kernel functions based on triplet comparisons",
    "authors": ["M. Kleindessner", "U. von Luxburg"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2017
  }, {
    "title": "Uci machine learning repository, zoo dataset, 2013. URL http://archive.ics.uci.edu/ml/ datasets/zoo",
    "authors": ["M. Lichman"],
    "year": 2013
  }, {
    "title": "The use of sparsest cuts to reveal the hierarchical community structure of social networks",
    "authors": ["C.F. Mann", "D.W. Matula", "E.V. Olinick"],
    "venue": "Social Networks,",
    "year": 2008
  }, {
    "title": "Approximation bounds for hierarchical clustering: Average linkage, bisecting k-means, and local search",
    "authors": ["B. Moseley", "J. Wang"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2017
  }, {
    "title": "Constrained 1-spectral clustering",
    "authors": ["S.S. Rangapuram", "M. Hein"],
    "venue": "In Artificial Intelligence and Statistics,",
    "year": 2012
  }, {
    "title": "Hierarchical clustering via spreading metrics",
    "authors": ["A. Roy", "S. Pokutta"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2016
  }, {
    "title": "A comparison of document clustering techniques",
    "authors": ["M. Steinbach", "G. Karypis", "V Kumar"],
    "venue": "In KDD workshop on text mining,",
    "year": 2000
  }, {
    "title": "Adaptively learning the crowd kernel",
    "authors": ["O. Tamuz", "C. Liu", "S. Belongie", "O. Shamir", "A.T. Kalai"],
    "venue": "In Proceedings of the 28th International Conference on International Conference on Machine Learning,",
    "year": 2011
  }, {
    "title": "Correlation, hierarchies, and networks in financial markets",
    "authors": ["M. Tumminello", "F. Lillo", "R.N. Mantegna"],
    "venue": "Journal of Economic Behavior & Organization,",
    "year": 2010
  }, {
    "title": "Interactive bayesian hierarchical clustering",
    "authors": ["S. Vikram", "S. Dasgupta"],
    "venue": "In International Conference on Machine Learning,",
    "year": 2016
  }, {
    "title": "Constrained k-means clustering with background knowledge",
    "authors": ["K. Wagstaff", "C. Cardie", "S. Rogers", "S Schrödl"],
    "venue": "In ICML,",
    "year": 2001
  }],
  "id": "SP:9136da88c4b2bb5149c826f1e573eb3c1b8dbe19",
  "authors": [{
    "name": "Vaggos Chatziafratis",
    "affiliations": []
  }, {
    "name": "Rad Niazadeh",
    "affiliations": []
  }, {
    "name": "Moses Charikar",
    "affiliations": []
  }],
  "abstractText": "Hierarchical clustering is a popular unsupervised data analysis method. For many real-world applications, we would like to exploit prior information about the data that imposes constraints on the clustering hierarchy, and is not captured by the set of features available to the algorithm. This gives rise to the problem of hierarchical clustering with structural constraints. Structural constraints pose major challenges for bottom-up approaches like average/single linkage and even though they can be naturally incorporated into top-down divisive algorithms, no formal guarantees exist on the quality of their output. In this paper, we provide provable approximation guarantees for two simple top-down algorithms, using a recently introduced optimization viewpoint of hierarchical clustering with pairwise similarity information (Dasgupta, 2016). We show how to find good solutions even in the presence of conflicting prior information, by formulating a constraint-based regularization of the objective. Furthermore, we explore a variation of this objective for dissimilarity information (Cohen-Addad et al., 2018) and improve upon current techniques. Finally, we demonstrate our approach on a real dataset for the taxonomy application.",
  "title": "Hierarchical Clustering with Structural Constraints"
}