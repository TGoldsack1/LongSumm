{
  "sections": [{
    "heading": "1. Introduction",
    "text": "In recent years, Bayesian optimization has gained a growing attention from machine learning experts in, both, academia and industry (Shahriari et al., 2016). It takes the widespread application of machine learning to the next level of sophistication as it enables to automatically fine-tune hyperparameters (Snoek et al., 2012), whether they are parametrizing data pre-processors, models or the learning algorithms. Finetuning is essential to obtain state-of-the-art performance\n1Amazon, Berlin, Germany. 2Amazon, Cambridge, United Kingdom. Correspondence to: Rodolphe Jenatton <jenatton@amazon.de>, Cedric Archambeau <cedrica@amazon.de>, Javier Gonzalez <gojav@amazon.co.uk>, Matthias Seeger <matthias@amazon.de>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\nwith complex machine learning models, such as deep neural networks. Historically, this vital step has been done, either manually, or via regular or random grid search, which can consume vast amounts of human expert time and are wasteful of computing resources. Hence, one of the main benefits of Bayesian optimization is that it removes this burden from the shoulders of the practitioners, who can then focus their attention on more rewarding value-adding tasks.\nTo set the stage, our goal is to solve a global optimization problem:\nmin x∈X f(x),\nwhere X is the optimization domain and f is a black-box function, typically continuous and multimodal. We further assume that querying f is costly. For example, f may be the outcome of a physical experiment or require a large amount of computation. The latter arises when f corresponds to a model selection score for a machine learning model trained on a possibly large dataset.\nThe protocol for sequential Bayesian optimization proceeds as follows (Mockus et al., 1978; Shahriari et al., 2016). Given n noisy evaluations yi ≈ f(xi), i ∈ {1, . . . , n}, a surrogate probabilistic model of f is maintained. Our goal is to find a global optimum of f by querying it as few times as possible. The location xn+1 is chosen by maximizing an acquisition function which performs an explorationexploitation trade-off. A common choice for the surrogate model is a Gaussian process (GP) (Rasmussen & Williams, 2006). For a GP surrogate model, common acquisition functions can be tractably computed and optimized via gradientbased optimization algorithms. While existing Bayesian optimization approaches mitigate the high evaluation cost of f , they suffer from the curse of dimensionality when facing a high-dimensional space X .\nIn this paper, we introduce a novel methodology able to exploit a given tree-shaped dependency structure on X by transferring information between overlapping paths. By constructing a surrogate model tailored to the structure, we can reduce the number of evaluations of commonly used acquisition functions. The same structure also allows us to take acquisition decisions more efficiently, thus speeding up the search of candidates.\nTree-based dependencies occur often in practice. For exam-\nple, faced with a classification problem, we may want to simultaneously search over many different machine learning models, each coming with their own hyperparameters. Some configurations may also share parameters (e.g., logistic regression with `2 and `1 penalty may share the learning rate). These choices could be encoded in a decision tree, where inner nodes select between different models and hyperparameters populate leaf nodes. Another example arises when having to decide on a deep neural network architecture: the size of a layer, choice of activation function, or dropout fraction may depend on the number of layers (Bengio, 2009)."
  }, {
    "heading": "1.1. Baselines and Related Work",
    "text": "A baseline approach to Bayesian optimization in this setting is to ignore the structure of X and, as a result, choose a GP with covariance kernel K(x,x′) defined over the joint input space. When comparing a pair of points, all coordinates are taken into account. While easy to run in existing Bayesian optimization toolboxes, this approach can be highly inefficient. Not only do we encounter a cost of O(n3) after n acquisitions due to the global nature of the GP, but we also suffer from the curse of dimensionality when searching over X . Several authors attempted to design covariance functions that are aware of the structure: Duvenaud et al. (2011) consider kernels with an additive structure, while Swersky et al. (2014a); Hutter & Osborne (2013) introduce the Arc-kernel. However, the cost remains O(n3).\nAnother idea is to consider an independent GP for every valid subset of hyperparameters, as proposed by Bergstra et al. (2011). This approach corresponds to having an independent GP per leaf in the dependency tree. It scales as O( ∑ p n 3 p), where np is the number of evaluations at leaf\nnode p and ∑ p np = n. However, it lacks a mechanism for information sharing across the leaves. As we will show, information sharing can be beneficial in order to cut down on the number of evaluations. Moreover, the independent approach requires a sizable number of evaluations at each leaf, which can be problematic when there are many leafs.\nTree-structured dependencies can also be dealt with by assigning default values to coordinates of x which do not fall into the leaf node under consideration, using a Random Forest model to make this choice (Hutter et al., 2011). This strategy is implemented in the SMAC library.\nFinally, Zhang et al. (2016) proposed a dedicated approach to tune data analytic pipelines, via a two-layer Bayesian optimization framework. Their method first uses a parametric model to select some promising algorithms, whose hyperparameters are then refined by a nonparametric model."
  }, {
    "heading": "1.2. Contributions",
    "text": "First, we introduce a novel Bayesian optimization methodology able to leverage conditional dependencies between hyperparameters. To this end, we build a tree-structured surrogate model, with separate GPs at the leaf nodes, and random linear (or constant) functions at the inner nodes. This allows us to transfer information between leafs that share nodes on their respective paths, which enables us in turn to efficiently search the space X . Yet, we also retain the beneficial scaling of the independent approach (Bergstra et al., 2011). To our knowledge, no prior published work satisfied these two aspects. The Arc-kernel allows for information sharing, but comes with O(n3) computations. Hutter et al. (2011) rely on Random Forests to represent correlations, but no particular sharing mechanism exists.\nSecond, we introduce a novel acquisition function which is also able to exploit the tree structure and relies on the expected improvement (Mockus et al., 1978). The acquisition operates in two steps. We first select the most promising leaf node to score, effectively restricting our attention to a portion of X . We then optimize over all possible anchor points in this portion of space. This can result in a drastic reduction in the number of surrogate functions to optimize over. In comparison, the independent baseline requires to score every anchor point of every leaf in the tree at each iteration.\nThe paper is organized as follows. In Section 2, we detail our surrogate GP model and inference computations. In Section 3, we show how the model structure gives rise to efficient acquisition optimization. For a range of experiments on simulated and real data, we report in Section 4 favorable comparisons with existing alternatives. We conclude with possible extensions in Section 5."
  }, {
    "heading": "2. Tree-structured semi-parametric Gaussian process regression model",
    "text": "We assume that the hyperparameters exhibit conditional dependencies, which can be modeled with decision tree T . The set of inner nodes V is indexed by v ∈ {1, . . . , V }; each v has a decision variable and a weight variable cv. The set of leaf nodes P is indexed by p ∈ {1, . . . , P}. Equivalently, p indexes (unique) paths from the root to a leaf.\nFurther, let Dn = {(xi, yi)}ni=1 be the set of observations. We introduce a set of auxiliary variables {pi | pi ∈ P}ni=1 that indicate the leaf to which observation i is associated and let np= |{i | pi=p}|. Note that xi∈Xpi since the input domain may vary from one leaf to another."
  }, {
    "heading": "2.1. Model with Random Inner Node Parameters",
    "text": "We consider a surrogate model that associates with leaf p a latent function gp with GP prior, whose mean function and covariance kernel are bp and Kp(x,x′). We impose a zero-mean Gaussian prior over the weight vector c = [c1, . . . , cV ] T .\nThe resulting generative model is given by\nc ∼ N (0,Σc), gp(·) ∼ GP ( bp,Kp ) ,\nyi|pi, {gp(xi)}Pp=1, c ∼ N (gpi(xi) + z>pic, σ 2). (1)\nwhere Σc, {bp}Pp=1 and σ2 are the prior covariance, the scalar offsets and the noise variance. Vector zp∈ {0, 1}V is a binary mask that activates the weights of the inner node decision variables on the path to leaf node p. In other words, (zp)v = 1 iff v lies on the path from the root to p. The prior covariance Σc will be diagonal in our experiments.\nWhen c=0, model (1) boils down to assuming P independent GPs. While inference only scales as O( ∑ p n 3 p) in this case, information is not transferred between overlapping paths. Introducing the weight vector c allows us to couple inference for such paths, while keeping the favorable scaling and better exploring the optimization space (see Section 4).\nNext, we show how to perform efficient inference in this model and give an interpretation of the induced kernel when computing the marginal likelihood. Posterior inference over the surrogate models {gp(·)} and the random weights c is needed to compute the acquisition functions (see Section 3)."
  }, {
    "heading": "2.2. Posterior Inference",
    "text": "Before starting, we need some notation. Let y ∈ Rn be the vector of all observations and g ∈ Rn the vector of latent function values at {xi}ni=1. Further, let Ip = {i | pi = p}, noting that np = |Ip|. We partition the data accordingly, so that yp = [yi]i∈Ip , and similarly gp = [gp(xi)]i∈Ip . Also, we define the matrix Zp = zp1>np ∈ R\nV×np , where 1np = [1] ∈ Rnp , and the vector bp = bp1np ∈ Rnp .\nThe joint distribution P (y,g, c) of our model is given by P (c) ∏ pN (gp; bp,Kp)N (yp; gp + Z > p c, σ 2Inp), (2)\nwhere Kp = [Kp(xi,xj)]i,j∈Ip are kernel matrices, with the prior P (c) = N (c; 0,Σc). Our goal is to obtain the posterior process P (gp(·)|c,yp) and the posterior distribution P (c|y).\nWe can directly read off the posterior over the latent functions and parameters after rewriting the joint distribution into the following form (see Section 2 of the Appendix for details):\nP (y)P (c|y) ∏ pP (gp|c,yp).\nFirst, we obtain the posterior GP over the latent functions:\ngp(·)|c,yp ∼ GP ( mp(·), Sp(·, ·) ) ,\nwhere mp(x) = kp(x)>M−1p (yp − Z>p c − bp) + bp, Sp(x,x\n′) = Kp(x,x′) − kp(x)>M−1p kp(x′) and Mp = Kp + σ 2Inp .\nNext, we obtain the posterior for the weights c:\nc|y ∼ N (Λ−1c fc,Λ −1 c ),\nwhere fc = ∑ p ZpM −1 p (yp − bp) and Λc = Σ −1 c +∑\np ZpM −1 p Z > p .\nIn the sequel, we compute expressions such as M−1p and log |Mp| by using the Cholesky decomposition Mp = LpL > p . Similarly, the expressions depending on Λc are computed using its Cholesky decomposition."
  }, {
    "heading": "2.3. Marginal Likelihood and Its Interpretation",
    "text": "As shown in Section 2 of the Appendix, we can derive the expression for the log-marginal likelihood logP (y) in closed form:\nlogP (y) = ∑ p logN (yp; Z>p c + bp,Mp)\n+ logN (c; 0,Σc)− logP (c|y), (3)\nThe p-dependent terms require computing the Cholesky decompositions of all Mp ∈ Rnp×np , whereas the final term needs the Cholesky decomposition of Λc ∈ RV×V . Therefore, logP (y) can be computed in O(V 3 + ∑ p n 3 p). Note that this computation is required for optimizing the hyperparameters of the GPs.\nWe can also obtain an interesting interpretation for the induced kernel of the marginal likelihood by computing it in a different way. Let Z = [Zp] ∈ RV×n, b = [bp] ∈ Rn and Kblock ∈ Rn×n the block-diagonal matrix with blocks Kp. With these notations, it can be shown that P (yp|c) = N (yp|Z>p c + bp,Mp). Integrating out c leads to\nP (y) = N ( b,Z>ΣcZ + K block + σ2I ) . (4)\nIf we further assume that Σc = σ2cIV , then\nZ>ΣcZ = [ σ2cZ > p Zp′ ] p,p′ = [ σ2c (z > p zp′)1np1 > np′ ] p,p′ .\nHence, the diagonal blocks are proportional to z>p zp, which is the length of path p, and the off-diagonal blocks are proportional to z>p zp′ , which is the path overlap length between p and p′. The resulting kernel is thus the intersection kernel (see Shawe-Taylor & Cristianini (2004), Section 9.5)."
  }, {
    "heading": "2.4. Model with Random Linear Inner Node Functions",
    "text": "We have so far associated a random scalar cv with each inner node. More generally, we can use linear functions c>v rv, where cv is a weight vector and rv∈Rdv is a feature vector. The special case above is obtained with dv=1 and rv=[1].\nWe collect the weight vectors in c = [cv] ∈ Rd, where d = ∑ v dv. Let Vp ⊆ V be the set of inner nodes on the path from the root to leaf p. Concatenating the rv’s, we define the induced feature vector zp = [rv]v∈Vp such that\nc>zp = ∑ v∈Vp c > v rv.\nHence, the dataset we collect during the optimization is now the extended set Dn = {(xi, yi, pi, zpi =[rv,i]v∈Vpi )} n i=1. It is easy to see that all our results above transfer to this more general case, if only we redefine\nZp = [zpi ]i∈Ip = [rv,i]i∈Ip,v∈Vpi ∈ R d×np .\nExcept for an increased dimensionality d > V of the weight vector c, the extension with random linear inner node functions is not more difficult to implement or run.\nIn Section 4, we will use rv to encode both numerical (i.e., dv = 1) and categorical parameters (via one-hot representations, so that dv equals the number of categories). In our deep learning use case, parameters such as the learning rate, the number of units and the type of activation functions are encoded via the rv’s (see Figure 3, bottom). We will refer to the parameter associated with rv as a shared parameter since it is shared across all the leaves whose paths contain v."
  }, {
    "heading": "3. Acquisition Functions",
    "text": "Bayesian optimization generally proceeds by discretizing the search space X into a set of anchor points, for example by using quasi-random sequences (Sobol, 1967). We then maximize an acquisition function starting from the most promising anchor point(s), typically with a numerical solver like L-BFGS (Nocedal & Wright, 2006). Acquisition functions are defined in terms of expectations over the surrogate model posterior. Frequently used choices include Thompson sampling (Thompson, 1933), probability of improvement (PI) (Kushner, 1964), expected improvement (EI) (Mockus et al., 1978), or GP-UCB (Srinivas et al., 2010). We will focus on EI in the sequel as it has been shown to perform better than PI. Our initial experiments also showed that Thompson sampling was not performing well.\nThe naive approach of globally optimizing EI over anchor points does not scale well with a high-dimensional X . In the previous section, we specified a tree-structured model for the (random) surrogate function, with which the evaluation of an acquisition function at some x ∈ X is sped up. In this section, we show how the model structure can also be exploited in order to speed up the optimization itself."
  }, {
    "heading": "3.1. Acquisition Strategies",
    "text": "The acquisition function α(x|Dn) plays a critical role in Bayesian Optimization as it selects anchor points by performing an exploration-exploitation trade-off. The key question that concerns us is whether we can leverage the explicit structure in high-dimensional structured space in order to make the search more efficient. The naive approach ignores structure in the search space, using a surrogate model based on a global kernel, like the one proposed by Swersky et al. (2014a). While the design of a kernel that incorporate structure is non-trivial, it is not explicitly used to guide the search and the cost of evaluations still scales as O(n3).\nAs noted above, we can speed up evaluations to O( ∑ p n 3 p) by adopting an independent model, which corresponds to our tree model with c = 0, so that the surrogate models {gp(·)}Pp=1 can be learnt and queried independently from each other. With this approach, the search decouples across the leaf nodes and can be parallelized accordingly. However, if acquisitions are done sequentially, then all leafs have to be searched in order to find the overall best candidate. The independent model also fails to represent dependencies between the leaf nodes, so that a larger total number of evaluations may be required to reach a good solution.\nGiven our tree-structured surrogate model, we can improve on both the naive and the independent approach. The acquisition function becomes α(x, p|Dn), p being the leaf node where x is evaluated. For our model, α(x, p|Dn) can be evaluated in O(V 3 + ∑ p n 3 p), which is often much cheaper than O(n3) required in the naive approach, and is comparable to O( ∑ p n 3 p) for independent. We could maximize α(x, p|Dn) separately at each leaf p, and then pick the best candidate across leaf nodes:\n(x?, p?) ∈ arg max p∈P,x∈Xp α(x, p|Dn).\nIn practice, the set of leaf nodes P can become large, in which case the requirement to search in every leaf node can be costly. We propose to further exploit the tree structure of our surrogate model in order to speed up the optimization. Namely, our model implies a path acquisition function α(p|Dn). Based on this, we select p? and x? in two steps:\np? = arg max p∈P α(p|Dn), x? ∈ arg max x∈Xp? α(x, p?|Dn).\nThis strategy can greatly speed up the optimization. There are obvious intermediates, such as searching in a subset of top-ranked leafs p, which we defer for future work."
  }, {
    "heading": "3.2. Two-step Expected Improvement",
    "text": "Given our surrogate model, the EI acquisition function is: α(x, p|Dn) = E { [ymin − gp(x)− z>p c]+ } , (5)\nTable 1. Comparison of different surrogate models and acquisition strategies (see text for details). Here,M(X ) is the complexity of optimizing a surrogate function over the space X . p? is the path selected by tree, and Xp? is the corresponding leaf domain.\nsharing? complexity independent × O\n(∑\np n 3 p · M(Xp)\n)\nnaive X O ( ( ∑\np np) 3 · M\n( P× ∏ pXp )) tree X O ( V 3 + n3p? · M(Xp?)\n) where [u]+ = max{u, 0}, and ymin is the best evaluation so far (across all leafs). The expectation is computed with respect to the posterior of gp(x) + z>p c, which is a GP with mean and covariance functions respectively given by\nm̃p(x) = kp(x) >M−1p (yp − bp) + tp(x)>Λ −1 c fc + bp,\nS̃p(x,x ′) = Sp(x,x ′) + tp(x) >Λ−1c tp(x ′),\nwhere tp(x) = zp − ZpM−1p kp(x). We can analytically compute (5), leading to\nα(x, p|Dn) = σ̃p(x) (ξΦ(ξ) +N (ξ; 0, 1)) ,\nwhere σ̃p(x) = {S̃p(x,x)}1/2, ξ = m̃p(x)−yminσ̃p(x) and Φ(ξ) is the CDF of a standard Gaussian.\nAs noted above, we could optimize α(x, p|Dn) at all leaves and pick the overall winner. Instead, we propose a two-step approach, based on a path EI acquisition function:\nα(p|Dn) = E { [ymin − bp − z>p c]+ } , (6)\nwhere the expectation is taken with respect to z>p c + bp ∼ N (z>p Λ −1 c fc + bp, z > p Λ −1 c zp). We first select the path p? = arg maxp α(p|Dn), then find x? by maximizing α(x, p?|Dn) at leaf p? only. Our tree acquisition strategy is related to the naive and independent ones in Table 1. Interestingly, tree can be faster than independent overall. Finally, (6) is easily extended to the case where we have random linear functions at the inner nodes by considering the augmented induced variable zp = [rv]v∈Vp (see Section 2.4 for details). In particular, the resulting optimization of (6) is carried out jointly over p and zp = [rv]v∈Vp ."
  }, {
    "heading": "4. Experiments",
    "text": "In this section, we conduct two sets of experiments. First, we focus on optimizing synthetic functions designed to have tree-structured conditional relationships. We then consider the tuning of a multi-layer perceptron for binary classification, which we evaluate over a large number of datasets.\nThroughout the experiments, we use the following acronyms to refer to the different competing methods: tree is our proposed approach, independent is a baseline that consider an independent GP for every leaf, arc corresponds\nto (Swersky et al., 2014a), smac refers to (Hutter et al., 2011) and gp-baseline is a standard GP-based Bayesian optimization solver taken from (GPyOpt, 2016). For tree, independent and gp-baseline, we use 5/2 Matérn kernels. marginal is another baseline obtained by replacing the kernel of gp-baseline by that stemming from the marginal (4), where c is viewed as a nuisance variable and integrated out. Finally, random is standard random search (Bergstra & Bengio, 2012).\nUnless otherwise specified, all the results displayed in this section correspond to the means and twice the standard errors computed over 25 random replications. Also, in order to minimize the initialization bias, all methods (except smac1) start from the same set of random candidates; there is one random candidate drawn per conditional path. Our implementation is in Python and we ran the experiments on a fleet of Amazon AWS c4.8xlarge machines."
  }, {
    "heading": "4.1. Synthetic Tree-structured Functions",
    "text": "The functions we consider are defined over binary trees: Each inner node, including the root, corresponds to a binary variable. A path in this tree thus represents successive binary decisions. The leaves contain univariate quadratic functions that are shifted by different constant terms. We give an example of such a function in Figure 1. In the sequel, we study the two functions from Figure 1 (referred to as small balanced), in addition to a higher-dimensional version of those, with a depth of 4 and 8 leaves whose constant shifts are {a× 0.1}8a=1 (referred to as large balanced). In the supplementary material, we provide further results based\n1We use https://github.com/sfalkner/pySMAC. To the best of our knowledge, we cannot specify the starting point.\non unbalanced binary trees of increasing sizes, for which similar conclusions hold. All the non-shared continuous variables xj’s are defined in [−1, 1], while the shared ones are in [0, 1]. The best function value will thus always be 0.1.\nThose functions encode conditional relationships since given a path p and its leaf `p, all the binary variables outside of the path p and all the continuous variables defined in the leaves `′ 6= `p are irrelevant. We report in Figure 2 the optimization results for the different competing methods. We make the following observations:\nApproaches blind to structure perform poorly: The results show that, both gp-baseline and random, which cannot use the conditional structure, do not fare well. As expected, the performance gap widens as the trees get deeper.\nIndependent vs. tree vs. arc: independent, tree and arc represent 3 ways of increasingly incorporating conditional structure. Indeed, independent takes into account the tree structure but does not allow for any sharing of information across different paths, arc defines a joint kernel over the union of all the leaves, while tree makes intermediate modeling assumptions. We can observe that, thanks to its joint nature, arc tends to perform well initially, but it is quickly overtaken by tree and later also by independent that lags behind because of the absence of sharing, but catches up once sufficient observations were collected. Also, as the dimension of the optimization space gets larger, the performance of independent worsens, while that of tree is barely affected (we do observe the same scalability with respect to the dimension on unbalanced binary trees, as reported in the supplementary material). At this juncture, we would also like to emphasize that while independent catches up with tree in some cases, it is more wasteful of resources as it requires to score every leaf at each iteration unlike tree (see also Table 1).\nImportance of exploiting the latent variables c: It is interesting to observe that marginal, which considers c to be a nuisance variable and integrates it out, performs significantly worse than tree. Note that marginal cannot de facto be applied in presence of shared variables, which explains why it does not appear in the right panels of Figure 1.\nApproach not based on GPs: smac is known to be stateof-the-art for optimization tasks in presence of conditional relationships (Eggensperger et al., 2013). In particular, it is known to work better than GP-based approaches, especially when the dimension gets large. We observe in our experiments (e.g., for large balanced, 7 categorical and 10 continuous parameters, 2 of which being shared) that smac does not reach good solutions on these synthetic tasks."
  }, {
    "heading": "4.2. Multi-layer Perceptron Tuning",
    "text": "We now focus our attention on the tuning of a multilayer perceptron (MLP) for binary classification. The setting we consider is reminiscent of that proposed by Swersky et al. (2014a). We optimize for the number of hidden layers in {0, 1, 2, 3, 4}, the number of units per layer in {1, 2, . . . , 30} (provided the corresponding layer is activated), the choice of the activation function in {identity, logistic, tanh, relu}, which we constrain to be identical across all layers, the amount of `2 regularization in [10−6, 10−1], the learning rate in [10−5, 10−1] of the underlying Adam solver (Kingma & Ba, 2014), the tolerance in [10−5, 10−2] of the solver (based on relative decrease), and the type of data pre-processing, which can be unit `2-norm observation-wise normalization, `∞-norm feature-wise normalization, mean/standarddeviation feature-wise whitening or no normalization at all.\nThe optimization task can be specified in various ways, resulting in different topologies for the trees of conditional relationships.We consider the two instantiations of conditional relationships illustrated in Figure 3. The first one has all the variables duplicated (top tree), which is similar to how independent proceeds. The second one consists in having most of the variables shared (bottom tree). Note that in the two settings, we have one regularization parameter λk per number k of hidden layer(s) of the network. We do\nso to account for the fact that the λk’s regularize matrices of different dimensions. In between those two extreme settings, we could consider intermediate modeling assumptions (e.g., a learning rate ηlinear for the case with no hidden layers and a shared learning rate ηnon-linear otherwise).\nTo provide a robust evaluation of the different competing methods, we consider a subset of the datasets from the Libsvm repository (Chang & Lin, 2011). More specifically, we consider all the datasets whose number of features is smaller than 106, which results in 45 data sets. In absence of pre-defined default train-test split, we took a random 80%−20% split. To limit the overall computational burden, we cap the training and test set sizes to a maximum of respectively 103 and 104 instances (randomly selected when the subsampling applies). Note that this subsampling step is not related to a computational limitation of our approach, but is a practical consideration only modifying the properties of the black-box function we optimize. We use the MLP implementation of scikit-learn (Pedregosa et al., 2011)\nand we add a CPU-time constraint of 5 minutes to each evaluation, beyond which the worst classification error 1.0 is returned. Under this constraint, the total computational time of the experiment was roughly 100 CPU days.\nWe run all the methods for 85 iterations and initialize them with one random choice for each of the 5 conditional paths. We aggregate the average classification errors per dataset by displaying the average rank of each method as a function of the number of iterations. We say that the rank of a method is equal to i if it performs the ith best (see, e.g., Bardenet et al. (2013); Feurer et al. (2015)). We can draw the following conclusions:\nEffect of z>p c without shared variables: The top panel in Figure 4 compares independent with tree-based method when it is defined on the independent topology shown in Figure 3(top). Since there are no shared variables in the inner nodes, the sharing mechanism of tree only\nhappens via the term z>p c which contributes to the mean. As expected, sharing results in tree makes faster progress towards the optimum. However, when more observations are collected, independent outperforms tree because it better explores all the leafs (though, at a higher computational cost; see Table 1). We next show how we can additionally benefit from sharing parameters at inner nodes.\nShared topology: The lower panel in Figure 4 compares all the methods using the shared topology shown in Figure 3(bottom). We found that arc, gp-baseline, random and smac all benefitted from running with the shared topology. The results show that tree not only greatly improves upon all other GP-based approaches, but also converges faster than smac that finally reaches the same level of performance after about 75 iterations. We can observe that a standard GP-based technique that is blind to the conditional structure, like gp-baseline, performs poorly. Of independent interest is the comparison of arc with smac, which was not reported by Swersky et al. (2014a). Finally, it is worth emphasizing that tree obtains good results while only modeling shared variables at the inner nodes in a linear fashion. This conclusion is in agreement with the recent observations from (Zhang et al., 2016) where linear models lead to good results in the context of the optimization of data analytic pipelines. Next, we discuss an extension to model the shared variables non-linearly."
  }, {
    "heading": "4.3. Nonlinear Extensions",
    "text": "The approach we have introduced in Section 2.4 can easily be extended to account for non-linearities through the use of basis expansions. More specifically, we focus on the use of random Fourier features (Rahimi et al., 2007) that proved successful for large-scale kernel methods (Lu et al., 2014). Combining basis expansion with linear models for Bayesian optimization is by no means new (see (Shahriari et al., 2016) and references therein). We also follow this methodology since it naturally fits our proposed semi-parametric model.\nIn the supplementary material, we report results on synthetic tree-structured functions where the objectives at the leaves depend now quadratically on the shared variables and on the MLP tuning task. In a nutshell, on the synthetic functions with linearly-dependent shared variables, tree-nonlinear converges slower than the linear version tree, which might be due to the fact that c is of higher dimensionality. Moreover, in presence of quadratically-dependent shared variables, we observe that tree fails to model adequately the non-linearities, while tree-nonlinear, as expected, can. As for the MLP task, we notice that the non-linear extension of tree tends to perform worse than its linear counterpart."
  }, {
    "heading": "5. Concluding Remarks",
    "text": "The black-box functions typically encountered in machine learning rely on incremental learning procedures, such as the application of (stochastic) gradient descent over several epochs. A recent line of work has been focusing on leveraging this property to speed up Bayesian optimization (Swersky et al., 2013; 2014b; Domhan et al., 2014; Li et al., 2016; Klein et al., 2016). In particular, Li et al. (2016) and Klein et al. (2016) have reported state-of-the-art results with methods based respectively on bandits and GPs, exploiting a dynamic subsampling of the training sets.\nThe goal of our work is orthogonal to this idea and consists instead in efficiently encoding conditional relationships with GPs. We next outline ways of combining our work with the aforementioned subsampling idea:\nCombination with Klein et al. (2016): The proposal of Klein et al. (2016) uses some contextual variable (also referred to as environmental variable) to encode the subsampling rate of the training set. Let us denote it by β ∈ [0, 1]. Klein et al. (2016) define the following joint kernel:\nK((x, β), (x′, β′)) = K0(x,x′) · Kcontext(β, β′).\nThe optimization is then driven by a cost-normalized acquisition function maxβ′,x α(x, β = 1|Dn)/cost(x, β′) where both x and β are sought to perform well on the final task of interest where no subsampling is applied (i.e., β = 1).\nLooking at our case, we could easily replace our kernel Kp by K̃p((x, β), (x′, β′)) , Kp(x,x′) · Kcontext(β, β′). To apply the two-step procedure, we could normalize (6) by a cost following a separate model (1) where the contextual variable β would be a shared variables at the root. Formally, we could consider a joint path/subsampling selection criterion:\n(p?, β?) ∈ arg max p∈P,β′∈[0,1]\nE { [ymin − bp − zp(β = 1)>c]+ }\nE { zp(β′)>ccost } , where zp(β) refers to the feature representation of the path p with context variable β.\nCombination with Li et al. (2016): The approach of Li et al. (2016) is based on successive halving procedures where a pool containing initially many models is progressively refined and trimmed. The output of their theoreticallyjustifed algorithm, named hyperband, can be seen as triplets Hn , {(xi, yi, βi)}ni=1 representing all the tested configurations xi along with their corresponding evaluations yi and subsampling rates βi.\nA natural approach to leverage hyperband is therefore to useHn to warm-start our context-aware extension with kernel K̃p while fixing β = 1. In other words, our approach would be used to refine the smart and computationallyefficient initialization provided by hyperband."
  }],
  "year": 2017,
  "references": [{
    "title": "Collaborative hyperparameter tuning",
    "authors": ["Bardenet", "Rémi", "Brendel", "Mátyás", "Kégl", "Balázs", "Sebag", "Michele"],
    "venue": "In Proceedings of the International Conference on Machine Learning (ICML),",
    "year": 2013
  }, {
    "title": "Learning deep architectures for AI",
    "authors": ["Y. Bengio"],
    "venue": "Foundations and Trends in Machine Learning,",
    "year": 2009
  }, {
    "title": "Random search for hyper-parameter optimization",
    "authors": ["Bergstra", "James", "Bengio", "Yoshua"],
    "venue": "Journal of Machine Learning Research,",
    "year": 2012
  }, {
    "title": "Implementations of algorithms for hyper-parameter optimization",
    "authors": ["Bergstra", "James", "Bardenet", "Rémi", "B Kégl", "Y. Bengio"],
    "venue": "In NIPS Workshop on Bayesian optimization,",
    "year": 2011
  }, {
    "title": "LIBSVM: A library for support vector machines",
    "authors": ["Chang", "Chih-Chung", "Lin", "Chih-Jen"],
    "venue": "ACM Transactions on Intelligent Systems and Technology,",
    "year": 2011
  }, {
    "title": "Extrapolating learning curves of deep neural networks",
    "authors": ["Domhan", "Tobias", "Springenberg", "Hutter", "Frank"],
    "venue": "In ICML 2014 AutoML Workshop,",
    "year": 2014
  }, {
    "title": "Additive gaussian processes",
    "authors": ["Duvenaud", "David K", "Nickisch", "Hannes", "Rasmussen", "Carl E"],
    "venue": "Advances in Neural Information Processing Systems",
    "year": 2011
  }, {
    "title": "Initializing Bayesian hyperparameter optimization via metalearning",
    "authors": ["Feurer", "Matthias", "T Springenberg", "Hutter", "Frank"],
    "venue": "In Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence,",
    "year": 2015
  }, {
    "title": "Sequential model-based optimization for general algorithm configuration",
    "authors": ["F. Hutter", "H.H. Hoos", "K. Leyton-Brown"],
    "venue": "In Proceedings of LION-5,",
    "year": 2011
  }, {
    "title": "A kernel for hierarchical parameter spaces",
    "authors": ["Hutter", "Frank", "Osborne", "Michael A"],
    "venue": "Technical report, preprint arXiv:1310.5738,",
    "year": 2013
  }, {
    "title": "Adam: A method for stochastic optimization",
    "authors": ["Kingma", "Diederik", "Ba", "Jimmy"],
    "venue": "Technical report, preprint arXiv:1412.6980,",
    "year": 2014
  }, {
    "title": "Fast Bayesian optimization of machine learning hyperparameters on large datasets",
    "authors": ["Klein", "Aaron", "Falkner", "Stefan", "Bartels", "Simon", "Hennig", "Philipp", "Hutter", "Frank"],
    "venue": "Technical report, preprint arXiv:1605.07079,",
    "year": 2016
  }, {
    "title": "A new method of locating the maximum point of an arbitrary multipeak curve in the presence of noise",
    "authors": ["Kushner", "Harold J"],
    "venue": "Journal of Fluids Engineering,",
    "year": 1964
  }, {
    "title": "Hyperband: A novel bandit-based approach to hyperparameter optimization",
    "authors": ["Li", "Lisha", "Jamieson", "Kevin", "DeSalvo", "Giulia", "Rostamizadeh", "Afshin", "Talwalkar", "Ameet"],
    "venue": "Technical report, preprint arXiv:1603.06560,",
    "year": 2016
  }, {
    "title": "The application of Bayesian methods for seeking the extremum",
    "authors": ["Mockus", "Jonas", "Tiesis", "Vytautas", "Zilinskas", "Antanas"],
    "venue": "Towards Global Optimization,",
    "year": 1978
  }, {
    "title": "Random features for large-scale kernel machines",
    "authors": ["Rahimi", "Ali", "Recht", "Benjamin"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2007
  }, {
    "title": "Gaussian Processes for Machine Learning",
    "authors": ["Rasmussen", "Carl", "Williams", "Chris"],
    "year": 2006
  }, {
    "title": "Taking the human out of the loop: A review of Bayesian optimization",
    "authors": ["Shahriari", "Bobak", "Swersky", "Kevin", "Wang", "Ziyu", "Adams", "Ryan P", "de Freitas", "Nando"],
    "venue": "Proceedings of the IEEE,",
    "year": 2016
  }, {
    "title": "Kernel Methods for Pattern Analysis",
    "authors": ["J. Shawe-Taylor", "N. Cristianini"],
    "year": 2004
  }, {
    "title": "On the distribution of points in a cube and the approximate evaluation of integrals",
    "authors": ["Sobol", "Ilya M"],
    "venue": "USSR Computational Mathematics and Mathematical Physics,",
    "year": 1967
  }, {
    "title": "Multitask Bayesian optimization",
    "authors": ["Swersky", "Kevin", "Snoek", "Jasper", "Adams", "Ryan P"],
    "venue": "In Advances in Neural Information Processing Systems, pp. 2004–2012,",
    "year": 2013
  }, {
    "title": "Raiders of the lost architecture: Kernels for Bayesian optimization in conditional parameter spaces",
    "authors": ["Swersky", "Kevin", "Duvenaud", "David", "Snoek", "Jasper", "Hutter", "Frank", "Osborne", "Michael A"],
    "venue": "Technical report, preprint arXiv:1409.4011,",
    "year": 2014
  }, {
    "title": "Freeze-thaw Bayesian optimization",
    "authors": ["Swersky", "Kevin", "Snoek", "Jasper", "Adams", "Ryan Prescott"],
    "venue": "Technical report, preprint arXiv:1406.3896,",
    "year": 2014
  }, {
    "title": "On the likelihood that one unknown probability exceeds another in view of the evidence of two samples",
    "authors": ["Thompson", "William R"],
    "year": 1933
  }, {
    "title": "Flash: Fast bayesian optimization for data analytic pipelines",
    "authors": ["Zhang", "Yuyu", "Bahadori", "Mohammad Taha", "Su", "Hang", "Sun", "Jimeng"],
    "year": 2016
  }],
  "id": "SP:5da035b7ea8f18548d427dd8cc211c145ee60a15",
  "authors": [{
    "name": "Rodolphe Jenatton",
    "affiliations": []
  }, {
    "name": "Cedric Archambeau",
    "affiliations": []
  }, {
    "name": "Javier Gonzalez",
    "affiliations": []
  }, {
    "name": "Matthias Seeger",
    "affiliations": []
  }],
  "abstractText": "Bayesian optimization has been successfully used to optimize complex black-box functions whose evaluations are expensive. In many applications, like in deep learning and predictive analytics, the optimization domain is itself complex and structured. In this work, we focus on use cases where this domain exhibits a known dependency structure. The benefit of leveraging this structure is twofold: we explore the search space more efficiently and posterior inference scales more favorably with the number of observations than Gaussian Process-based approaches published in the literature. We introduce a novel surrogate model for Bayesian optimization which combines independent Gaussian Processes with a linear model that encodes a tree-based dependency structure and can transfer information between overlapping decision sequences. We also design a specialized two-step acquisition function that explores the search space more effectively. Our experiments on synthetic tree-structured objectives and on the tuning of feedforward neural networks show that our method compares favorably with competing approaches.",
  "title": "Bayesian Optimization with Tree-structured Dependencies"
}