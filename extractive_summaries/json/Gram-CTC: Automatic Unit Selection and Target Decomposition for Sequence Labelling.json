{
  "sections": [{
    "heading": "1. Introduction",
    "text": "In recent years, there has been an explosion of interest in sequence labelling tasks. Connectionist Temporal Classification (CTC) loss (Graves et al., 2006) and Sequenceto-sequence (seq2seq) models (Cho et al., 2014; Sutskever et al., 2014) present powerful approaches to multiple applications, such as Automatic Speech Recognition (ASR) (Chan et al., 2016a; Hannun et al., 2014; Bahdanau et al.,\n*Equal contribution 1Baidu Silicon Valley AI Lab, 1195 Bordeaux Dr, Sunnyvale, CA 94089, USA. Correspondence to: Hairong Liu <liuhairong@baidu.com>.\nProceedings of the 34th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\n2016), machine translation (Sébastien et al., 2015), and parsing (Vinyals et al., 2015). These methods are based on 1) a fixed and carefully chosen set of basic units, such as words (Sutskever et al., 2014), phonemes (Chorowski et al., 2015) or characters (Chan et al., 2016a), and 2) a fixed and pre-determined decomposition of target sequences into these basic units. While these two preconditions greatly simplify the problems, especially the training processes, they are also strict and unnecessary constraints, which usually lead to suboptimal solutions. CTC models are especially harmed by fixed basic units in target space, because they build on the independence assumption between successive outputs in that space - an assumption which is often violated in practice.\nThe problem with fixed set of basic units is obvious: it is really hard, if not impossible, to determine the optimal set of basic units beforehand. For example, in English ASR, if we use words as basic units, we will need to deal with the large vocabulary-sized softmax, as well as rare words and data sparsity problem. On the other hand, if we use characters as basic units, the model is forced to learn the complex rules of English spelling and pronunciation. For example, the \"oh\" sound can be spelled in any of following ways, depending on the word it occurs in - { o, oa, oe, ow, ough, eau, oo, ew }. While CTC can easily model commonly co-occuring grams together, it is impossible to give roughly equal probability to many possible spellings when transcribing unseen words. Most speech recognition systems model phonemes, sub-phoneme units and senones e.g, (Xiong et al., 2016a) to get around these problems. Similarly, state-of-the-art neural machine translation systems use pre-segmented word pieces e.g, (Wu et al., 2016a) aiming to find the best of both worlds.\nIn reality, groups of characters are typically cohesive units for many tasks. For the ASR task, words can be decomposed into groups of characters that can be associated with sound (such as ‘tion’ and ‘eaux’). For the machine translation task, there may be values in decomposing words as root words and extensions (so that meaning may be shared explicitly between ‘paternal’ and ‘paternity’). Since this information is already available in the training data, it is perhaps, better to let the model figure it out by itself. At the same time, it raises another import question: how to de-\ncompose a target sequence into basic units? This is coupled with the problem of automatic selection of basic units, thus also better to let the model determine. Recently, there are some interesting attempts in these directions in the seq2seq framework. For example, Chan et al (Chan et al., 2016b) proposed the Latent Sequence Decomposition to decompose target sequences with variable length units as a function of both input sequence and the output sequence.\nIn this work, we propose Gram-CTC - a strictly more general version of CTC - to automatically seek the best set of basic units from the training data, called grams, and automatically decompose target sequences into sequences of grams. Just as sequence prediction with cross entropy training can be seen as special case of the CTC loss with a fixed alignment, CTC can be seen as a special case of Gram-CTC with a fixed decomposition of target sequences. Since it is a loss function, it can be applied to many seq2seq tasks to enable automatic selection of grams and decomposition of target sequences without modifying the underlying networks. Extensive experiments on multiple scales of data validate that Gram-CTC can improve CTC in terms of both performance and efficiency, and that using Gram-CTC the models outperform state-of-the-arts on standard speech benchmarks."
  }, {
    "heading": "2. Related Work",
    "text": "The basic text units that previous works utilized for text prediction tasks (e.g,, automatic speech recognition, handwriting recognition, machine translation, and image captioning) can be generally divided into two categories: handcrafted ones and learning-based ones.\nHand-crafted Basic Units. Fixed sets of characters (graphemes) (Graves et al., 2006; Amodei et al., 2015), word-pieces (Wu et al., 2016b; Collobert et al., 2016; Zweig et al., 2016a), words (Soltau et al., 2016; Sébastien et al., 2015), and phonemes (Lee and Hon, 1988; Sercu and Goel, 2016; Xiong et al., 2016b) have been widely used as basic units for text prediction, but all of them have drawbacks. Using these fixed deterministic decompositions of text sequences defines a prior, which is not necessarily optimal for end-to-end learning.\n• Word-segmented models remove the component of learning to spell and thus enable direct optimization towards reducing Word Error Rate (WER). However, these models suffer from having to handle a large vocabulary (1.7 million in (Soltau et al., 2016)), out-of-vocabulary words (Soltau et al., 2016; Sébastien et al., 2015) and data sparsity problems (Soltau et al., 2016).\n• Using characters results in much smaller vocabularies (e.g, 26 for English and thousands for Chinese), but it requires much longer contexts compared to using words or word-pieces and poses the challenge of composing characters to words (Graves et al., 2006; Chan et al., 2015),\nwhich is very noisy for languages like English.\n• Word-pieces lie at the middle-ground of words and characters, providing a good trade-off between vocabulary size and context size, while the performance of using word pieces is sensitive to the choice of the word-piece set and its decomposition.\n• For the ASR task, the use of phonemes was popular in the past few decades as it eases acoustic modeling (Lee and Hon, 1988) and good results were reported with phonemic models (Xiong et al., 2016b; Sercu and Goel, 2016). However, it introduces the uncertainties of mapping phonemes to words during decoding (Doss et al., 2003), which becomes less robust especially for accented speech data.\nLearning-based Basic Units. More recently, attempts have been made to learn basic unit sets automatically. (Luong and Manning, 2016) proposed a hybrid WordCharacter model which translates mostly at the word level and consults the character components for rare words. Chan et al (Chan et al., 2016b) proposed the Latent Sequence Decompositions framework to decomposes target sequences with variable length-ed basic units as a function of both input sequence and the output sequence.\nThere exist some earlier works on the “unit discovery” task (Cartwright and Brent, 1994; Goldwater et al., 2006). A standard problem with MLE solutions to this task is that there are degenerate solutions, i.e., predicting the full corpus with probability 1 at the start. Often Bayesian priors or “minimum description length” constraints are used to remedy this."
  }, {
    "heading": "3. Gram-CTC",
    "text": ""
  }, {
    "heading": "3.1. CTC",
    "text": "CTC (Graves et al., 2006) is a very popular method in seq2seq learning since it does not require the alignment information between inputs and outputs, which is usually expensive, if not impossible, to obtain.\nSince there is no alignment information, CTC marginalizes over all possible alignments. That is, it tries to maximize p(l|x) = ∑ π p(π|x), where x is input, and π represent a valid alignment. For example, if the size of input is 3, and the output is ‘hi’, whose length is 2, there are three possible alignments, ‘-hi’, ‘h-i’ and ‘hi-’, where ‘-’ represents blank. For the details, please refer to the original paper (Graves et al., 2006)."
  }, {
    "heading": "3.2. From CTC to Gram-CTC",
    "text": "In CTC, the basic units are fixed, which is not desirable in some applications. Here we generalize CTC by considering a sequence of basic units, called gram, as a whole, which is usually more reasonable in many applications.\nLet G be a set of n-grams of the set of basic units C of the target sequence, and τ be the length of the longest gram in G. A Gram-CTC network has a softmax output layer with |G|+1 units, that is, the probability over all grams inG and one additional symbol, blank. To simplify the problem, we also assume C ⊆ G. 1\nFor an input sequence x of length T , let y = Nw(x) be the sequence of network outputs, and denote by ytk as the probability of the k-th gram at time t, where k is the index of grams in G′ = G ∪ {blank}, then we have\np(π|x) = T∏ t=1 ytπt ,∀π ∈ G ′T (1)\nJust as in the case of CTC, here we refer to the elements of G′T as paths, and denote them by π, which represents a possible alignment between input and output. The difference is that for each word in the target sequence, it may be decomposed into different sequences of grams. For example, the word ‘hello’ can only be decomposed into the sequence [‘h’, ‘e’, ‘l’, ‘l’, ‘o’] for CTC (assume uni-gram CTC here), but it also can be decomposed into the sequence [‘he’, ‘ll’, ‘o’] if ‘he’ and ‘ll’ are in G.\nFor each π, we map it into a target sequence in the same way as CTC using the collapsing function that 1) removes all repeated labels from the path and then 2) removes all blanks. Note that essentially it is these rules which de-\n1This is because there may be no valid decompositions for some target sequences if C 6⊆ G. Since Gram-CTC will figure out the ideal decomposition of target sequences into grams during training, this condition guarantees that there is at least one valid decomposition for every target sequence.\ntermine the transitions between the states of adjacent time steps in Figure 1. This is a many-to-one mapping and we denote it by B. Note that other rules can be adopted here and the general idea presented in this paper does not depend on these specific rules. For a target sequence l, B−1(l) represents all paths mapped to l. Then, we have\np(l|x) = ∑\nπ∈B−1(l)\np(π|x) (2)\nThis equation allows for training sequence labeling models without any alignment information using CTC loss, because it marginalizes over all possible alignments during training. Gram-CTC uses the same effect to enable the model to marginalize over not only alignments, but also decompositions of the target sequence.\nNote that for each target sequence l, the set B−1(l) has O(τ2) more paths than it does in CTC. This is because there are O(τ) times more valid states per time step, and each state may have a valid transition from O(τ) states in the previous time step. The original CTC method is thus, a special case of Gram-CTC when G = C and τ = 1. While the quadratic increase in the complexity of the algorithm is non trivial, we assert that it is a trivial increase in the overall training time of typical neural networks, where the computation time is dominated by the neural networks themselves. Additionally, the algorithm extends generally to any arbitrary G and need not have all possible n-grams up to length τ ."
  }, {
    "heading": "3.3. The Forward-Backward Algorithm",
    "text": "To efficiently compute p(l|x), we also adopt the dynamic programming algorithm. The essence here is identifying\nthe states of the problem, so that we may solve future states by reusing solutions to earlier states. In our case, the state must contain all the information required to identify all valid extensions of an incomplete path π such that the collapsing function will eventually collapse the complete π back to l. For Gram-CTC, this can be done by collapsing all but the last element of the path π. Therefore, the state is a tuple (l1:i, j), where the first item is a collapsed path, representing a prefix of the target label sequence, and j ∈ {0, . . . , τ} is the length of the last gram (li−j+1:i) used for making the prefix. j = 0 is valid and means that blank was used. We denote the gram (li−j+1:i) by g j i (l), and the state (l1:i, j) as s j i (l). For readability, we will further shorten sji (l) to s j i and g j i (l) to g j i . For a state s, its corresponding gram is denoted by sg , and the positions of the first character and last character of sg are denoted by b(s) and e(s), respectively. During dynamic programming, we are dealing with sequence of states, for a state sequence ζ, its corresponding gram sequences is unique, denoted by ζg .\nFigure 1 illustrates partially the dynamic programming process for the target sequence ‘CAT’. Here we suppose G contains all possible uni-grams and bi-grams. Thus, for each character in ‘CAT’, there are three possible states associated with it: 1) the current character, 2) the bi-gram ending in current character, and 3) the blank after current character. There is also one blank at beginning. In total we have 10 states.\nSupposing the maximum length of grams inG is τ , we first scan l to get the set S of all possible states, such that for all sji ∈ S, its corresponding g j i ∈ G′. i ∈ {0, . . . , |l|} and j ∈ {0, . . . , τ}. For a target sequence l, define the forward variable αt(s) for any s ∈ S to the total probability of all valid paths prefixes that end at state s at time t.\nαt(s) def = ∑ ζ|B(ζg)=l1:e(s),ζt=s t∏ t′=1 yt ′ ζt′g (3)\nFollowing this definition, we have the following rules for initialization\nα1(s) =  y1b s = s 0 0 y1 gii\ns = sii ∀i ∈ {1, . . . , τ} 0 otherwise\n(4)\nand recursion\nαt(s) =  α̂it−1 ∗ ytb when s = s0i , [α̂i−jt−1 + αt−1(s)] ∗ ytgji when s = sji and g j i 6= g j i−j , [α̂i−jt−1 + αt−1(s)− αt−1(s j i−j)] ∗ ytgji\nwhen s = sji and g j i = g j i−j\n(5)\nwhere α̂it = ∑τ j=0 αt(s j i ) and y t b is the probability of blank at time t.\nThe total probability of the target sequence l is then expressed in the following way:\np(l|x) = τ∑ j=0 αT (s j |l|) (6)\nsimilarly, we can define the backward variable βt(s) as:\nβt(s) def = ∑ ζ|B(ζg)=lb(s):l,ζt=s T∏ t′=t yt ′ ζt′g (7)\nFor the initialization and recursion of βt(s), we have\nβT (s) =  yTb s = s 0 T yT giT\ns = siT ∀i ∈ {1, . . . , τ} 0 otherwise\n(8)\nand\nβt(s) =  β̂it+1 ∗ ytb when s = s0i , [β̂i+jt+1 + βt+1(s)] ∗ ytgji when s = sji and g j i 6= g j i+j , [β̂i+jt+1 + βt+1(s)− βt+1(s j i+j)] ∗ ytgji\nwhen s = sji and g j i = g j i+j\n(9) where β̂it = ∑τ j=0 βt(s j i+j)"
  }, {
    "heading": "3.4. BackPropagation",
    "text": "Similar to CTC, we have the following expression:\np(l|x) = ∑ s∈S αt(s)βt(s) ytsg ∀t ∈ {1, . . . ,T} (10)\nThe derivative with regards to ytk is:\n∂p(l|x) ∂ytk = 1 ytk 2 ∑ s∈lab(l,k) αt(s)βt(s) (11)\nwhere lab(l, k) is the set of states in S whose corresponding gram is k. This is because there may be multiple states corresponding to the same gram.\nFor the backpropagation, the most important formula is the partial derivative of loss with regard to the unnormalized output utk.\n∂ ln p(l|x) ∂utk = ytk − 1 ytkZt ∑ s∈lab(l,k) αt(s)βt(s) (12)\nwhere Zt def = ∑ s∈S\nαt(s)βt(s) ytsg .\n(a) Training curves before (blue) and after (orange) auto-refinement of grams. (b) Training curves without (blue) and with (orange) joint-training\nGram-CTC C _ AT\nCTC _ C _ A T _\nGram-CTC C - AT\nCTC - C - A T -\n(c) Joint-training Architecture\nFigure 2. (Figure 2a) compares the training curves before (blue) and after (orange) auto-refinement of grams. They look very similar, although the number of grams is greatly reduced after refinement, which makes training faster and potentially more robust due to less gram sparsity. Figure (2b) Training curve of model with and without joint-training. The model corresponding to the orange training curve is jointly trained together with vanilla CTC, such models are often more stable during training. Figure (2c) Typical joint-training model architecture - vanilla CTC loss is best applied a few levels lower than the Gram-CTC loss."
  }, {
    "heading": "4. Methodology",
    "text": "Here we describe additional techniques we found useful in practice to enable the Gram-CTC to work efficiently as well as effectively."
  }, {
    "heading": "4.1. Iterative Gram Selection",
    "text": "Although Gram-CTC can automatically select useful grams, it is challenging to train with a large G. The total number of possible grams is usually huge. For example, in English, we have 26 characters, then the total number of bi-grams is 262 = 676, the total number of tri-grams are 263 = 17576, . . . , which grows exponentially and quickly becomes intractable. However, it is unnecessary to consider many grams, such as ‘aaaa’, which are obviously useless.\nIn our experiments, we first eliminate most of useless grams from the statistics of a huge corpus, that is, we count the frequency of each gram in the corpus and drop these grams with rare frequencies. Then, we train a model with Gram-CTC on all the remaining grams. By applying (decoding) the trained model on a large speech dataset, we get the real statistics of gram’s usage. Ultimately, we choose high frequency grams together with all uni-grams as our final gram set G. Table 1 shows the impact of iterative gram selection on WSJ (without LM). Figure 2a shows its corresponding training curve. For details, please refer to Section 5.2."
  }, {
    "heading": "4.2. Joint Training with Vanilla CTC",
    "text": "Gram-CTC needs to solve both decomposition and alignment tasks, which is a harder task for a model to learn than CTC. This is often manifested in unstable training curves, forcing us to lower the learning rate which in turn results\nin models converging to a worse optima. To overcome this difficulty, we found it beneficial to train a model with both the Gram-CTC, as well as the vanilla CTC loss (similar to joint-training CTC together with CE loss as mentioned in (Sak et al., 2015)). Joint training of multiple objectives for sequence labelling has also been explored in previous works (Kim et al., 2016; Kim and Rush, 2016).\nA typical joint-training model looks like Figure 2c, and the corresponding training curve is shown in Figure 2b. The effect of joint-training are shown in Table 4 and Table 5 in the experiments."
  }, {
    "heading": "5. Experiments",
    "text": "We test the Gram-CTC loss on the ASR task, while both CTC and the introduced Gram-CTC are generic techniques for other sequence labelling tasks. For all of the experiments, the model specification and training procedure are the same as in (Amodei et al., 2015) - The model is a recurrent neural network (RNN) with 2 two-dimensional convolutional input layers, followed by K forward (Fwd) or bidirectional (Bidi) Gated Recurrent layers, N cells each, and one fully connected layer before a softmax layer. In short hand, such a model is written as ‘2x2D Conv - KxN GRU’. The network is trained end-to-end with the CTC, GramCTC or a weighted combination of both. This combination is described in the earlier section.\nIn all experiments, audio data is is sampled at 16kHz. Linear FFT features are extracted with a hop size of 10ms and window size of 20ms, and are normalized so that each input feature has zero mean and unit variance. The network inputs are thus spectral magnitude maps ranging from 0-8kHz with 161 features per 10ms frame. At each epoch, 40% of the utterances are randomly selected to add\nbackground noise to. The optimization method we use is stochastic gradient descent with Nesterov momentum. Learning hyperparameters (batch-size, learning-rate, momentum, and etc.) vary across different datasets and are tuned for each model by optimizing a hold-out set. Typical values are a learning rate of 10−3 and momentum of 0.99."
  }, {
    "heading": "5.1. Data and Setup",
    "text": "Wall Street Journal (WSJ). This corpora consists primarily of read speech with texts drawn from a machinereadable corpus of Wall Street Journal news text, and contains about 80 hours speech data. We used the standard configuration of train si284 dataset for training, dev93 for validation and eval92 for testing. This is a relatively ‘clean’ task and often used for model prototyping (Miao et al., 2015; Bahdanau et al., 2016; Zhang et al., 2016; Chan et al., 2016b).\nFisher-Switchboard. This is a commonly used English conversational telephone speech (CTS) corpora, which contains 2300 hours CTS data. Following the previous works (Zweig et al., 2016b; Povey et al., 2016; Xiong et al., 2016b; Sercu and Goel, 2016), evaluation is carried out on the NIST 2000 CTS test set, which comprises both Switchboard (SWB) and CallHome (CH) subsets.\n10K Speech Dataset. We conduct large scale ASR experiments on a noisy internal dataset of 10,000 hours. This dataset contains speech collected from various scenarios, such as different background noises, far-field, different accents, and so on. Due to its inherent complexities, it is a very challenging task, and can thus validate the effectiveness of the proposed method for real-world application."
  }, {
    "heading": "5.2. Gram Selection",
    "text": "We employ the WSJ dataset for demonstrating different strategies of selecting grams for Gram-CTC, since it is a widely used dataset and also small enough for rapid idea verification. However, because it is small, we cannot use large grams here due to data sparsity problem. Thus, the auto-refined gram set on WSJ is not optimal for other larger datasets, where larger grams could be effectively used, but the procedure of refinement is the same for them.\nWe first train a model using all uni-grams and bi-grams (29\nuni-grams and 262 = 676 bi-grams, in total 705 grams), and then do decoding with the obtained model on another speech dataset to get the statistics of the usage of grams. Top 100 bi-grams together with all 29 uni-grams (autorefined grams) are used for the second round of training. For comparison, we also present the result of the best handpicked grams, as well as the results on uni-grams. All the results are shown in Table 1.\nSome interesting observations can be found in Table 1. First, the performance of auto-refined grams is only slightly better than the combination of all uni-grams and all bigrams. This is probably because WSJ is so small that gram learning suffers from the data sparsity problem here (similar to word-segmented models). The auto-refined gram set contains only a small subset of bi-grams, thus more robust. This is also why we only try bi-grams, not including higher-order grams. Second, the performance of best handpicked grams is worse than auto-refined grams. This is desirable. It is time-consuming to handpick grams, especially when you consider high-order grams. The method of iterative gram selection is not only fast, but usually better. Third, the performance of Gram-CTC on auto-refined grams is only slightly better than CTC on uni-grams. This is because Gram-CTC is inherently difficult to train, since it needs to learn both decomposition and alignment. WSJ is too small to provide enough data to train Gram-CTC."
  }, {
    "heading": "5.3. Sequence Labelling in Large Stride",
    "text": "Using a large time stride for sequence labelling with RNNs can greatly boost the overall computation efficiency, since it effectively reduces the time steps for recurrent computation, thus speeds up the process of both forward inference and backward propagation. However, the largest stride that can be used is limited by the gram set we use. The (unigram) CTC has to work in a high time resolution (small stride) in order to have enough number of frames to output every character. This is very inefficient as we know the same acoustic feature could correspond to several grams of different lengths (e.g., {‘i’, ‘igh’, ‘eye’}) . The larger the grams are, the larger stride we are potentially able to use.\nDS2 (Amodei et al., 2015) employed non-overlapping bigram outputs to allow for a larger stride. This imposes an artificial constraint forcing the model to learn, not only the spelling of each word, but also how to split words into bigrams. For example, part is split as [pa, rt] but the word\napart is forced to be decomposed as [ap, ar, t]. GramCTC removes this constraint by allowing the model to decompose words into larger units into the most convenient or sensible decomposition. Comparison results show this change enables Gram-CTC to work much better than bigram CTC, as in Table 2.\nIn Table 2, we compare the performance of trained model and training efficiency on two strides, 2 and 4. For GramCTC, we use the auto-refined gram set from previous section. As expected, using stride 4 almost cuts the training time per epoch into half, compared to stride 2. From stride 2 to stride 4, the performance of uni-gram CTC drops quickly. This is because small grams inherently need higher time resolutions. As for Gram-CTC, from stride 2 to stride 4, its performance decreases a little bit, while in experiments on the other datasets, Gram-CTC constantly works better in stride 4. One possible explanation is that WSJ is too small for Gram-CTC to learn large grams well. In contrast, the performance of bi-gram CTC is not as good as that of Gram-CTC in either stride."
  }, {
    "heading": "5.4. Decoding Examples",
    "text": "Figure 3 illustrates the max-decoding results of both CTC and Gram-CTC on nine utterances. Here the label set for CTC is the set of all characters, and the label set for GramCTC is an auto-refined gram set containing all uni-grams and some high-frequency high-order grams. Here Gram-\nCTC uses stride 4 while CTC uses stride 2.\nFrom Figure 3, we can find that: 1) Gram-CTC does automatically find many intuitive and meaningful grams, such as ‘the’, ‘ng’, and ‘are’. 2) It also decomposes the sentences into segments which are meaningful in term of pronunciation. This decomposition resembles the phonetic decomposition, but in larger granularity and arguably more natural. 3) Since Gram-CTC predicts a chunk of characters (a gram) each time, each prediction utilizes larger context and these characters in the same predicted chunk are dependent, thus potentially more robust. One example is the word ‘will’ in the last sentence in Figure 3. 4) Since the output of network is the probability over all grams, the decoding process is almost the same as CTC, still end-toend. This makes such decomposition superior to phonetic decomposition. In summary, Gram-CTC combines the advantages of both CTC on characters and CTC on phonemes."
  }, {
    "heading": "5.5. Comparison with Other Methods",
    "text": ""
  }, {
    "heading": "5.5.1. WSJ DATASET",
    "text": "The model used here is [2x2D conv, 3x1280 Bidi GRU] with a CTC or Gram-CTC loss. The results are shown in Table 3. For all models we trained, language model can greatly improve their performances, in term of WER. Though this dataset contains very limited amount of text data for learning gram selection and decomposition, Gram-\nCTC can still improve the vanilla CTC notably."
  }, {
    "heading": "5.5.2. FISHER-SWITCHBOARD",
    "text": "The acoustic model trained here is composed of two 2D convolutions and six bi-directional GRU layer in 2048 dimension. The corresponding labels are used for training N-gram language models.\n• Switchboard English speech 97S62 • Fisher English speech Part 1 - 2004S13, 2004T19 • Fisher English speech Part 2 - 2005S13, 2005T19\nWe use a sample of the Switchboard-1 portion of the NIST 2002 dataset (2004S11 RT-02) for tuning language model hyper-parameters. The evaluation is done on the NIST 2000 set. This configuration forms a standard benchmark for evaluating ASR models. Results are in Table 4.\nWe compare our model against best published results on in-domain data. These results can often be improved using out-of-domain data for training the language model, and sometimes the acoustic model as well. Together these techniques allow (Xiong et al., 2016b) to reach a WER of 5.9 on the SWBD set."
  }, {
    "heading": "5.5.3. 10K SPEECH DATASET",
    "text": "Finally, we experiment on a large noisy dataset collected by ourself for building large-vocabulary Continuous Speech Recognition (LVCSR) systems. This dataset contains about 10000 hours speech in a diversity of scenarios, such as farfield, background noises, accents. In all cases, the model is [2x2D Conv, 3x2560 Fwd GRU, LA Conv] with only a change in the loss function. ‘LA Conv’ refers to a look ahead convolution layer as seen in (Amodei et al., 2015) which works together with forward-only RNNs for deployment purpose.\nAs with the Fisher-Switchboard dataset, the optimal stride is 4 for Gram-CTC and 2 for vanilla CTC on this dataset. Thus, in both experiments, both Gram-CTC and vanilla\nCTC + Gram-CTC are trained mush faster than vanilla CTC itself. The result is shown in Table 5. Gram-CTC performs better than CTC. After joint-training with vanilla CTC and alignment information through a CE loss, its performance is further boosted, which verifies joint-training helps training. In fact, with only a small additional cost of time, it effectively reduces the WER from 27.56% to 25.59% (without language model)."
  }, {
    "heading": "6. Conclusions and Future Work",
    "text": "In this paper, we have proposed the Gram-CTC loss to enable automatic decomposition of target sequences into learned grams. We also present techniques to train the Gram-CTC in a clean and stable way. Our extensive experiments demonstrate the proposed Gram-CTC enables the models to run more efficiently than the vanilla CTC, by using larger stride, while obtaining better performance of sequence labelling. Comparison experiments on multiplescale datasets show the proposed Gram-CTC obtains stateof-the-art results on various ASR tasks.\nAn interesting observation is that the learning of GramCTC implicitly avoids the “degenerated solution” that occurring in the traditional “unit discovery” task, without involving any Bayesian priors or the “minimum description length” constraint. Using a small gram set that contains only short (up to 5 in our experiments) as well as highfrequency grams may explain the success here.\nWe will continue investigating techniques of improving the optimization of Gram-CTC loss, as well as the applications of Gram-CTC for other sequence labelling tasks."
  }],
  "year": 2017,
  "references": [{
    "title": "Learning phrase representations using rnn encoder-decoder for statistical machine translation",
    "authors": ["Kyunghyun Cho", "Bart Van Merriënboer", "Caglar Gulcehre", "Dzmitry Bahdanau", "Fethi Bougares", "Holger Schwenk", "Yoshua Bengio"],
    "venue": "arXiv preprint arXiv:1406.1078,",
    "year": 2014
  }, {
    "title": "Sequence to sequence learning with neural networks",
    "authors": ["Ilya Sutskever", "Oriol Vinyals", "Quoc V Le"],
    "venue": "In Advances in neural information processing systems,",
    "year": 2014
  }, {
    "title": "Listen, attend and spell: A neural network for large vocabulary conversational speech recognition",
    "authors": ["William Chan", "Navdeep Jaitly", "Quoc Le", "Oriol Vinyals"],
    "venue": "IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP),",
    "year": 2016
  }, {
    "title": "Deep speech: Scaling up end-to-end speech recognition",
    "authors": ["Awni Y. Hannun", "Carl Case", "Jared Casper", "Bryan Catanzaro", "Greg Diamos", "Erich Elsen", "Ryan Prenger", "Sanjeev Satheesh", "Shubho Sengupta", "Adam Coates", "Andrew Y. Ng"],
    "venue": "CoRR, abs/1412.5567,",
    "year": 2014
  }, {
    "title": "End-to-end attention-based large vocabulary speech recognition",
    "authors": ["Dzmitry Bahdanau", "Jan Chorowski", "Dmitriy Serdyuk", "Yoshua Bengio"],
    "venue": "In 2016 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP),",
    "year": 2016
  }, {
    "title": "On using very large target vocabulary for neural machine translation",
    "authors": ["Jean Sébastien", "Kyunghyun Cho", "Roland Memisevic", "Yoshua Bengio"],
    "year": 2015
  }, {
    "title": "Grammar as a foreign language",
    "authors": ["Oriol Vinyals", "Łukasz Kaiser", "Terry Koo", "Slav Petrov", "Ilya Sutskever", "Geoffrey Hinton"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2015
  }, {
    "title": "Attention-based models for speech recognition",
    "authors": ["Jan K Chorowski", "Dzmitry Bahdanau", "Dmitriy Serdyuk", "Kyunghyun Cho", "Yoshua Bengio"],
    "venue": "In Advances in Neural Information Processing Systems,",
    "year": 2015
  }, {
    "title": "The microsoft 2016 conversational speech recognition system",
    "authors": ["W Xiong", "J Droppo", "X Huang", "F Seide", "M Seltzer", "A Stolcke", "D Yu", "G Zweig"],
    "venue": "arXiv preprint arXiv:1609.03528,",
    "year": 2016
  }, {
    "title": "Latent sequence decompositions",
    "authors": ["William Chan", "Yu Zhang", "Quoc Le", "Navdeep Jaitly"],
    "venue": "In Arxiv,",
    "year": 2016
  }, {
    "title": "Wav2letter: an end-to-end convnet-based speech recognition system",
    "authors": ["Ronan Collobert", "Christian Puhrsch", "Gabriel Synnaeve"],
    "venue": "arXiv preprint arXiv:1609.03193,",
    "year": 2016
  }, {
    "title": "Advances in all-neural speech recognition",
    "authors": ["Geoffrey Zweig", "Chengzhu Yu", "Jasha Droppo", "Andreas Stolcke"],
    "venue": "arXiv preprint arXiv:1609.05935,",
    "year": 2016
  }, {
    "title": "Neural speech recognizer: Acoustic-to-word lstm model for large vocabulary speech recognition",
    "authors": ["Hagen Soltau", "Hank Liao", "Hasim Sak"],
    "venue": "arXiv preprint arXiv:1610.09975,",
    "year": 2016
  }, {
    "title": "Large-vocabulary speakerindependent continuous speech recognition using hmm",
    "authors": ["K-F Lee", "H-W Hon"],
    "venue": "In Acoustics, Speech, and Signal Processing,",
    "year": 1988
  }, {
    "title": "Dense prediction on sequences with time-dilated convolutions for speech recognition",
    "authors": ["Tom Sercu", "Vaibhava Goel"],
    "venue": "arXiv preprint arXiv:1611.09288,",
    "year": 2016
  }, {
    "title": "Achieving human parity in conversational speech recognition",
    "authors": ["Wayne Xiong", "Jasha Droppo", "Xuedong Huang", "Frank Seide", "Mike Seltzer", "Andreas Stolcke", "Dong Yu", "Geoffrey Zweig"],
    "venue": "arXiv preprint arXiv:1610.05256,",
    "year": 2016
  }, {
    "title": "Listen, attend and spell",
    "authors": ["William Chan", "Navdeep Jaitly", "Quoc V Le", "Oriol Vinyals"],
    "venue": "arXiv preprint arXiv:1508.01211,",
    "year": 2015
  }, {
    "title": "Phoneme-grapheme based speech recognition system",
    "authors": ["Mathew Magimai Doss", "Todd A Stephenson", "Hervé Bourlard", "Samy Bengio"],
    "venue": "In Automatic Speech Recognition and Understanding,",
    "year": 2003
  }, {
    "title": "Achieving open vocabulary neural machine translation with hybrid word-character models",
    "authors": ["Minh-Thang Luong", "Christopher D Manning"],
    "venue": "arXiv preprint arXiv:1604.00788,",
    "year": 2016
  }, {
    "title": "Segmenting speech without a lexicon: The roles of phonotactics and speech source",
    "authors": ["Timothy Andrew Cartwright", "Michael R Brent"],
    "venue": "arXiv preprint cmplg/9412005,",
    "year": 1994
  }, {
    "title": "Fast and accurate recurrent neural network acoustic models for speech recognition",
    "authors": ["Hasim Sak", "Andrew W. Senior", "Kanishka Rao", "FranÃğoise Beaufays"],
    "venue": "CoRR, abs/1507.06947,",
    "year": 2015
  }, {
    "title": "Joint ctc-attention based end-to-end speech recognition using multi-task learning",
    "authors": ["Suyoun Kim", "Takaaki Hori", "Shinji Watanabe"],
    "venue": "arXiv preprint arXiv:1609.06773,",
    "year": 2016
  }, {
    "title": "Sequence-level knowledge distillation",
    "authors": ["Yoon Kim", "Alexander M Rush"],
    "venue": "arXiv preprint arXiv:1606.07947,",
    "year": 2016
  }, {
    "title": "Eesen: End-to-end speech recognition using deep rnn models and wfst-based decoding",
    "authors": ["Yajie Miao", "Mohammad Gowayyed", "Florian Metze"],
    "venue": "In Automatic Speech Recognition and Understanding (ASRU),",
    "year": 2015
  }, {
    "title": "Very deep convolutional networks for end-to-end speech recognition",
    "authors": ["Yu Zhang", "William Chan", "Navdeep Jaitly"],
    "venue": "arXiv preprint arXiv:1610.03022,",
    "year": 2016
  }, {
    "title": "Advances in all-neural speech recognition",
    "authors": ["Geoffery Zweig", "Ghengzhu Yu", "Jasha Droppo", "Andreas Stolcke"],
    "venue": "arXiv preprint arXiv:1609.05935,",
    "year": 2016
  }, {
    "title": "Towards better decoding and language model integration in sequence to sequence models",
    "authors": ["Jan Chorowski", "Jaitly Navdeep"],
    "venue": "arXiv preprint arXiv:1612.02695,",
    "year": 2016
  }],
  "id": "SP:c8301a871a211e9bb87dd0339915129730fbc250",
  "authors": [{
    "name": "Hairong Liu",
    "affiliations": []
  }, {
    "name": "Zhenyao Zhu",
    "affiliations": []
  }, {
    "name": "Xiangang Li",
    "affiliations": []
  }, {
    "name": "Sanjeev Satheesh",
    "affiliations": []
  }],
  "abstractText": "Most existing sequence labelling models rely on a fixed decomposition of a target sequence into a sequence of basic units. These methods suffer from two major drawbacks: 1) the set of basic units is fixed, such as the set of words, characters or phonemes in speech recognition, and 2) the decomposition of target sequences is fixed. These drawbacks usually result in sub-optimal performance of modeling sequences. In this paper, we extend the popular CTC loss criterion to alleviate these limitations, and propose a new loss function called Gram-CTC. While preserving the advantages of CTC, Gram-CTC automatically learns the best set of basic units (grams), as well as the most suitable decomposition of target sequences. Unlike CTC, Gram-CTC allows the model to output variable number of characters at each time step, which enables the model to capture longer term dependency and improves the computational efficiency. We demonstrate that the proposed Gram-CTC improves CTC in terms of both performance and efficiency on the large vocabulary speech recognition task at multiple scales of data, and that with Gram-CTC we can outperform the state-of-the-art on a standard speech benchmark.",
  "title": "Gram-CTC: Automatic Unit Selection and Target Decomposition for Sequence Labelling"
}