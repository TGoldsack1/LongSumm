{
  "sections": [{
    "text": "Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 1215–1225 Brussels, Belgium, October 31 - November 4, 2018. c©2018 Association for Computational Linguistics\n1215"
  }, {
    "heading": "1 Introduction",
    "text": "Benefited from the recent advances in neural networks (NNs) and the access to nearly unlimited corpora, neural language models are able to achieve a good perplexity score and generate highquality sentences. These LMs automatically capture abundant linguistic information and patterns from large text corpora, and can be applied to facilitate a wide range of NLP applications (Rei, 2017; Liu et al., 2018; Peters et al., 2018).\nRecently, efforts have been made on learning contextualized representations with pre-trained language models (LMs) (Peters et al., 2018). These pre-trained layers brought significant improvements to various NLP benchmarks, yielding\nup to 30% relative error reductions. However, due to high variability of language, gigantic NNs (e.g., LSTMs with 8,192 hidden states) are preferred to construct informative LMs and extract multifarious linguistic information (Peters et al., 2017). Even though these models can be integrated without retraining (using their forward pass only), they still result in heavy computation workloads during inference stage, making them prohibitive for realworld applications.\nIn this paper, we aim to compress LMs for the end task in a plug-in-and-play manner. Typically, NN compression methods require the retraining of the whole model (Mellempudi et al., 2017). However, neural language models are usually composed of RNNs, and their backpropagations require significantly more RAM than their inference. It would become even more cumbersome when the target task equips the coupled LMs to capture information in both directions. Therefore, these methods do not fit our scenario very\nwell. Accordingly, we try to compress LMs while avoiding costly retraining.\nIntuitively, layers of different depths would capture linguistic information of different levels. Meanwhile, since LMs are trained in a taskagnostic manner, not all layers and their extracted information are relevant to the end task. Hence, we propose to compress the model by layer selection, which retains useful layers for the target task and prunes irrelevant ones. However, for the widely-used stacked-LSTM, directly pruning any layers will eliminate all subsequent ones. To overcome this challenge, we introduce the dense connectivity. As shown in Fig. 1, it allows us to detach any layers while keeping all remaining ones, thus creating the basis to avoid retraining. Moreover, such connectivity can stretch shallow and wide LMs to be deep and narrow (Huang et al., 2017), and enable a more fine-grained layer selection.\nFurthermore, we try to retain the effectiveness of the pruned model. Specifically, we modify the L1 regularization for encouraging the selection weights to be not only sparse but binary, which protects the retained layer connections from shrinkage. Besides, we design a layer-wise dropout to make LMs more robust and better prepared for the layer selection.\nWe refer to our model as LD-Net, since the layer selection and the dense connectivity form the basis of our pruning methods. For evaluation, we apply LD-Net on two sequence labeling benchmark datasets, and demonstrated the effectiveness of the proposed method. In the CoNLL03 Named Entity Recognition (NER) task, the F1 score increases from 90.78±0.24% to 91.86±0.15% by integrating the unpruned LMs. Meanwhile, after pruning over 90% calculation workloads from the best performing model1 (92.03%), the resulting model still yields 91.84±0.14%. Our implementations and pre-trained models would be released for futher study2."
  }, {
    "heading": "2 LD-Net",
    "text": "Given a input sequence of T word-level tokens, {x1, x2, · · · , xT }, we use xt to denote the embedding of xt. For a L-layers NN, we mark the input and output of the lth layer at the tth time stamp as xl,t and hl,t.\n1Based on their performance on the development sets 2 https://github.com/LiyuanLucasLiu/\nLD-Net."
  }, {
    "heading": "2.1 RNN and Dense Connectivity",
    "text": "We represent one RNN layer as a function:\nhl,t = Fl(xl,t,hl,t−1) (1)\nwhere Fl is the recurrent unit of lth layer, it could be any RNNs variants, and the vanilla LSTMs is used in our experiments.\nAs deeper NNs usually have more representation power, RNN layers are often stacked together to form the final model by setting xl,t = hl−1,t. These vanilla stacked-RNN models, however, suffer from problems like the vanishing gradient, and it’s hard to train very deep models.\nRecently, the dense connectivity and residual connectivity have been proposed to handle these problems (He et al., 2016; Huang et al., 2017). Specifically, dense connectivity refers to adding direct connections from any layer to all its subsequent layers. As illustrated in Figure 1, the input of lth layer is composed of the original input and the output of all preceding layers as follows.\nxl,t = [xt,h1,t, · · · ,hl−1,t]\nSimilarly, the final output of the L-layer RNN is ht = [xt,h1,t, · · · ,hL,t]. With dense connectivity, we can detach any single layer without eliminating its subsequent layers (as in Fig. 1). Also, existing practices in computer vision demonstrate that such connectivities can lead to deep and narrow NNs and distribute parameters into different layers. Moreover, different layers in LMs usually capture linguistic information of different levels. Hence, we can compress LMs for a specific task by pruning unrelated or unimportant layers."
  }, {
    "heading": "2.2 Language Modeling",
    "text": "Language modeling aims to describe the sequence generation. Normally, the generation probability of the sequence {x1, · · · , xT } is defined in a “forward” manner:\np(x1, · · · , xT ) = T∏ t=1 p(xt|x1, · · · , xt−1) (2)\nWhere p(xt|x1, · · · , xt−1) is computed based on the output of RNN, ht. Due to the dense connectivity, ht is composed of outputs from different layers, which are designed to capture linguistic information of different levels. Similar to the bottleneck layers employed in the DenseNet (Huang et al., 2017), we add additional layers to unify such\ninformation. Accordingly, we add an projection layer with the ReLU activation function:\nh∗t = ReLU(Wproj · ht + bproj) (3)\nBased on h∗t , it’s intuitive to calculate p(xt|x1, · · · , xt−1) by the softmax function, i.e., softmax(Wout · h∗t + b).\nSince the training of language models needs nothing but the raw text, it has almost unlimited corpora. However, conducting training on extensive corpora results in a huge dictionary, and makes calculating the vanilla softmax intractable. Several techniques have been proposed to handle this problem, including adaptive softmax (Grave et al., 2017), slim word embedding (Li et al., 2018), the sampled softmax and the noise contrastive estimation (Józefowicz et al., 2016). Since the major focus of our paper does not lie in the language modeling task, we choose the adaptive softmax because of its practical efficiency when accelerated with GPUs."
  }, {
    "heading": "2.3 Contextualized Representations",
    "text": "As pre-trained LMs can describe the text generation accurately, they can be utilized to extract information and construct features for other tasks. These features, referred as contextualized representations, have been demonstrated to be essentially useful (Peters et al., 2018). To capture information from both directions, we utilized not only forward LMs, but also backward LMs. Backward LMs are based on Eqn. 4 instead of Eqn. 2. Similar to forward LMs, backward LMs approach p(xt|xt+1, · · · , xT ) with NNs. For reference, the output of the RNN in backward LMs for xt is recorded as hrt .\np(x1, · · · , xn) = T∏ t=1 p(xt|xt+1, · · · , xT ) (4)\nIdeally, the final output of LMs (e.g., h∗t ) would be the same as the representation of the target word (e.g., xt+1); therefore, it may not contain much context information. Meanwhile, the output of the densely connected RNN (e.g., ht) includes outputs from every layer, thus summarizing all extracted features. Since the dimensions of ht could be too large for the end task, we add a non-linear transformation to calculate the contextualized representation (rt):\nrt = ReLU(Wcr · [ht,hrt ] + bcr) (5)\nOur proposed method bears the same intuition as the ELMo (Peters et al., 2018). ELMo is designed for the vanilla stacked-RNN, and tries to calculate a weighted average of different layers’ outputs as the contextualized representation. Our method, benefited from the dense connectivity and its narrow structure, can directly combine the outputs of different layers by concatenation. It does not assume the outputs of different layers to be in the same vector space, thus having more potential for transferring the constructed token representations. More discussions are available in Sec. 4."
  }, {
    "heading": "2.4 Layer Selection",
    "text": "Typical model compression methods require retraining or gradient calculation. For the coupled LMs, these methods require even more computation resources compared to the training of LMs, thus not fitting our scenario very well.\nBenefited from the dense connectivity, we are able to train deep and narrow networks. Moreover, we can detach one of its layer without eliminating all subsequent layers (as in Fig. 1). Since different layers in NNs could capture different linguistic information, only a few of them would be relevant or useful for a specific task. As a result, we try to compress these models by the task-guided layer selection. For i-th layer, we introduce a binary mask zi ∈ {0, 1} and calculate hl,t with Eqn. 6 instead of Eqn. 1.\nhl,t = zi · Fl(xl,t,hl,t−1) (6)\nWith this setting, we can conduct a layer selection by optimizing the regularized empirical risk:\nminL+ λ0 · R (7)\nwhere L is the empirical risk for the sequence labeling task andR is the sparse regularization.\nThe ideal choice for R would be the L0 regularization of z, i.e., R0(z) = |z|0. However, it is not continuous and cannot be efficiently optimized. Hence, we relax zi from binary to a real value (i.e., 0 ≤ zi ≤ 1) and replaceR0 by:\nR1 = |z|1\nDespite the sparsity achieved by R1, it could hurt the performance by shifting all zi far away from 1. Such shrinkage introduces additional noise in hl,t and xl,t, which may result in ineffective pruned LMs. Since our goal is to conduct\npruning without retraining, we further modify the L1 regularization to achieve sparsity while alleviating its shrinkage effect. As the target of R is to make z sparse, it can be “turned-off” after achieving a satisfying sparsity. Therefore, we extendR1 to a margin-based regularization:\nR2 = δ(|z|0 > λ1)|z|1\nIn addition, we also want to make up the relaxation made on z, i.e., relaxing its values from binary to [0, 1]. Accordingly, we add the penalty |z(1 − z)|1 to encourage z to be binary (Murray and Ng, 2010) and modifyR2 intoR3:\nR3 = δ(|z|0 > λ1)|z|1 + |z(1− z)|1\nTo compare R1, R2 and R3, we visualize their penalty values in Fig. 2. The visualization is generated for a 3-dimensional z while the targeted sparsity, λ1, is set to 2. Comparing to R1, we can observe that R2 enlarges the optimal point set from 0 to all z with a satisfying sparsity, thus avoiding the over-shrinkage. To better demonstrate the effect of R3, we further visualize its penalties after achieving a satisfying sparsity (w.l.o.g., assuming z3 = 0). One can observe that it penalizes non-binary z and favors binary values."
  }, {
    "heading": "2.5 Layer-wise Dropout",
    "text": "So far, we’ve customized the regularization term for the layer-wise pruning, which protects the retained connections among layers from shrinking. After that, we try to further retain the effectiveness of the compressed model. Specifically, we choose to prepare the LMs for the pruned inputs, thus making them more robust to pruning.\nAccordingly, we conduct the training of LMs with a layer-wise dropout. As in Figure 3, a random part of layers in the LMs are randomly dropped during each batch. The outputs of the dropped layers will not be passed to their subsequent recurrent layers, but will be sent to the projection layer (Eqn. 3) for predicting the next word.\nIn other words, this dropout is only applied to the input of recurrent layers, which aims to imitate the pruned input without totally removing any layers."
  }, {
    "heading": "3 Sequence Labeling",
    "text": "In this section, we will introduce our sequence labeling architecture, which is augmented with the contextualized representations."
  }, {
    "heading": "3.1 Neural Architecture",
    "text": "Following the recent studies (Liu et al., 2018; Kuru et al., 2016), we construct the neural architecture as in Fig. 4. Given the input sequence {x1, x2, · · · , xT }, for tth token (xt), we assume its word embedding is wt, its label is yt, and its character-level input is {ci,1, ci,2, · · · , ci, }, where ci, is the space character following xt.\nThe character-level representations have become the required components for most of the state-of-the-art. Following the recent study (Liu et al., 2018), we employ LSTMs to take the character-level input in a context-aware manner, and mark its output for xt as ct. Similar to the contextualized representation, ct usually has more dimensions than wt. To integrate them together, we set the output dimension of Eqn. 5 as the dimension of wt, and project ct to a new space with the same dimension number. We mark the projected character-level representation as c∗t .\nAfter projections, these vectors are concatenated as vt = [c∗t ; rt;wt],∀i ∈ [1, T ] and further fed into the word-level LSTMs. We refer to their output as U = {u1, · · · ,uT }. To ensure the model to predict valid label sequences, we append a first-order conditional random field (CRF) layer to the model (Lample et al., 2016). Specifically, the model defines the generation probability of y = {y1, · · · , yT } as\np(y|U) = ∏T t=1 φ(yt−1, yt,ut)∑\nŷ∈Y(U) ∏T t=1 φ(ŷt−1, ŷt,ut) (8)\nwhere ŷ = {ŷ1, . . . , ŷT } is a generic label sequence, Y(U) is the set of all generic label sequences for U and φ(yt−1, yt,ut) is the potential function. In our model, φ(yt−1, yt,ut) is defined as exp(Wytut + byt−1,yt), where Wyt and byt−1,yt are the weight and bias parameters."
  }, {
    "heading": "3.2 Model Training and Inference",
    "text": "We use the following negative log-likelihood as the empirical risk.\nL = − ∑ U log p(y|U) (9)\nFor testing or decoding, we want to find the optimal sequence y∗ that maximizes the likelihood.\ny∗ = argmax y∈Y(U) p(y|U) (10)\nAlthough the denominator of Eq. 8 is complicated, we can calculate Eqs. 9 and 10 efficiently by the Viterbi algorithm.\nFor optimization, we decompose it into two steps, i.e., model training and model pruning. Model training. We set λ0 to 0 and optimize the empirical risk without any regularization, i.e., minL. In this step, we conduct optimization with\nthe stochastic gradient descent with momentum. Following (Peters et al., 2018), dropout would be added to both the coupled LMs and the sequence labeling model. Model pruning. We conduct the pruning based on the checkpoint which has the best performance on the development set during the model training. We set λ0 to non-zero values and optimize minL + λ0R3 by the projected gradient descent with momentum. Any layer i with zi = 0 would be deleted in the final model to complete the pruning. To get a better stability, dropout is only added to the sequence labeling model."
  }, {
    "heading": "4 Experiments",
    "text": "We will first discuss the capability of the LD-Net as language models, then explore the effectiveness of its contextualized representations."
  }, {
    "heading": "4.1 Language Modeling",
    "text": "For comparison, we conducted experiments on the one billion word benchmark dataset (Chelba et al., 2013) with both LD-Net (with 1,600 dimensional projection) and the vanilla stacked-LSTM. Both kinds of models use word embedding (random initialized) of 300 dimension as input and use the adaptive softmax (with default setting) as an approximation of the full softmax. Additionally, as preprocessing, we replace all tokens occurring equal or less than 3 times with as UNK, which shrinks the dictionary from 0.79M to 0.64M.\nThe optimization is performed by the Adam algorithm (Kingma and Ba, 2014), the gradient is clipped at 5.0 and the learning rate is set to start from 0.001. The layer-wise dropout ratio is set to 0.5, the RNNs are unrolled for 20 steps without resetting the LSTM states, and the batch size is set to 128. Their performances are summarized in Table 1, together with several LMs used in our sequence labeling baselines. For models without official reported parameter numbers, we estimate their values (marked with†) by assuming they adopted the vanilla LSTM. Note that, for models 3, 5, 6, 7, 8, and 9, PPL refers to the averaged perplexity of the forward and the backward LMs.\nWe can observe that, for those models taking word embedding as the input, embedding composes the vast majority of model parameters. However, embedding can be embodied as a “sparse” layer which is computationally efficient. Instead, the intense calculations are conducted in\nRNN layers and softmax layer for language modeling, or RNN layers for contextualized representations. At the same time, comparing the model 8192-1024 and CNN-8192-1024, their only difference is the input method. Instead of taking word embedding as the input, CNN-8192-1024 utilizes CNN to compose word representation from the character-level input. Despite the greatly reduced parameter number, the perplexity of the resulting models remains almost unchanged. Since replacing embedding layer with CNN would make the training slower, we only conduct experiments with models taking word embedding as the input.\nComparing LD-Net with other baselines, we think it achieves satisfactory performance with regard to the size of hidden states. It demonstrates the LD-Net’s capability of capturing the underlying structure of natural language. Meanwhile, we find that the layer-wise dropout makes it harder to train LD-Net and its resulting model achieves less competitive results. However, as would be discussed in the next section, layer-wise dropout allows the resulting model to generate better contextualized representations and be more robust to pruning, even with a higher perplexity."
  }, {
    "heading": "4.2 Sequence Labeling",
    "text": "Following TagLM (Peters et al., 2017), we evaluate our methods in two benchmark datasets, the CoNLL03 NER task (Tjong Kim Sang and De Meulder, 2003) and the CoNLL00 Chunking task (Tjong Kim Sang and Buchholz, 2000). CoNLL03 NER has four entity types and includes\nthe standard training, development and test sets. CoNLL00 chunking defines eleven syntactic chunk types (e.g., NP and VP) in addition to Other. Since it only includes training and test sets, we sampled 1000 sentences from training set as a held-out development set (Peters et al., 2017).\nIn both cases, we use the BIOES labeling scheme (Ratinov and Roth, 2009) and use the micro-averaged F1 as the evaluation metric. Based on the analysis conducted in the development set, we set λ0 = 0.05 for the NER task, and λ0 = 0.5 for the Chunking task. As discussed before, we conduct optimization with the stochastic gradient descent with momentum. We set the batch size, the momentum, and the learning rate to 10, 0.9, and ηt = η01+ρt respectively. Here, η0 = 0.015 is the initial learning rate and ρ = 0.05 is the decay ratio. Dropout is applied in our model, and its ratio is set to 0.5. For a better stability, we use gradient clipping of 5.0. Furthermore, we employ the early stopping in the development set and report averaged score across five different runs.\nRegarding the network structure, we use the 30-dimension character-level embedding. Both character-level and word-level RNNs are set to one-layer LSTMs with 150-dimension hidden states in each direction. The GloVe 100-dimension pre-trained word embedding3 is used as the initialization of word embedding wt, and will be finetuned during the training. The layer selection variables zi are initialized as 1, remained unchanged\n3 https://nlp.stanford.edu/projects/glove/\nduring the model training and only be updated during the model pruning. All other variables are randomly initialized (Glorot and Bengio, 2010). Compared methods. The first baseline, referred as NoLM, is our sequence labeling model without the contextualized representations, i.e., calculating vt as [c∗t ;wt] instead of [c ∗ t ; rt;wt]. Besides, ELMo (Peters et al., 2018) is the major baseline. To make comparison more fair, we implemented the ELMo model and use it to calculate the rt in Eqn. 5 instead of [ht,hrt ]. Results of reimplemented models are referred with R-ELMo (λ is set to the recommended value, 0.1) and the results reported in its original paper are referred with O-ELMo. Additionally, since TagLM (Peters et al., 2017) with one-layer NNs can be viewed as a special case of ELMo, we also include its results. Sequence labeling results. Table 2 and 3 summarizes the results of LD-Net and baselines. Besides the F1 score and averaged perplexity, we also estimate FLOPs (i.e., the number of floatingpoint multiplication-adds) for the efficiency evaluation. Since our model takes both word-level and character-level inputs, we estimated the FLOPs value for a word-level input with 4.39 characterlevel inputs, while 4.39 is the averaged length of words in the CoNLL03 dataset.\nBefore the model pruning, LD-Net achieves a 96.05±0.08 F1 score in the CoNLL00 Chunking task, yielding nearly 30% error reductions over the NoLM baseline. Also, it scores 91.86±0.15 F1 in the CoNLL03 NER task with over 10% error reductions. Similar to the language modeling, we\nobserve that the most complicated models achieve the best perplexity and provide the most improvements in the target task. Still, considering the number of model parameters and the resulting perplexity, our model demonstrates its effectiveness in generating contextualized representations. For example, comparing to our methods, R-ELMo (7) leverages LMs with the similar perplexity and parameter number, but cannot get the same improvements with our method on both datasets.\nActually, contextualized representations have strong connections with the skip-thought vectors (Kiros et al., 2015). Skip-thought models try to embed sentences and are trained by predicting the previous and afterwards sentences. Similarly, LMs encode a specific context as the hidden states of RNNs, and use them to predict future contexts. Specifically, we recognize the cell states of LSTMs are more like to be the sentence embedding (Radford et al., 2017), since they are only passed to the next time stamps. At the same time, because the hidden states would be passed to other layers, we think they are more like to be the token representations capturing necessary signals for predicting the next word or updating context representations4. Hence, LD-Net should be more\n4We tried to combine the cell states with the hidden states to construct the contextualized representations by concatenation or weighted average, but failed to get better performance.\neffective then ELMo, as concatenating could preserve all extracted signals while weighted average might cause information loss.\nAlthough the layer-wise dropout makes the model harder to train, their resulting LMs generate better contextualized representations, even without the same perplexity. Also, as discussed in (Peters et al., 2018, 2017), the performance of the contextualized representation can be further improved by training larger models or using the CNN to represent words.\nFor the pruning, we started from the model with the best performance on the development set (referred with “origin”), and refer the performances of pruned models with “pruned” in Table 2 and 3. Essentially, we can observe the pruned models get rid of the vast majority of calculation while still retaining a significant improvement. We will discuss more on the pruned models in Sec. 4.4."
  }, {
    "heading": "4.3 Speed Up Measurements",
    "text": "We use FLOPs for measuring the inference efficiency as it reflects the time complexity (Han et al., 2015), and thus is independent of specific implementations. For models with the same structure, improvements in FLOPs would result in monotonically decreasing inference time. However, it may not reflect the actual efficiency of models due to the model differences in parallelism. Accordingly, we also tested wall-clock speeds of our implementations.\nOur implementations are based on the PyTorch 0.3.15, and all experiments are conducted on the CoNLL03 dataset with the Nvidia GTX 1080 GPU. Specifically, due to the limited size of CoNLL03 test set, we measure such speeds on the training set. As in Table 4, we can observe that, the pruned model achieved about 5 times speed up. Although there is still a large margin between\nWe think it implies that ELMo works as token representations instead of sentence representations\n5http://pytorch.org/\nthe actual speed-up and the FLOPs speed-up, we think the resulting decode speed (166K words/s) is sufficient for most real-world applications."
  }, {
    "heading": "4.4 Case Studies",
    "text": "Effect of the pruning ratio. To explore the effect of the pruning ratio, we adjust λ1 and visualize the performance of pruned models v.s. their FLOPs # in Fig 5. We can observe that LD-Net outperforms its variants and demonstrates its effectiveness.\nAs the pruning ratio becoming larger, we can observe the performance of LD-Net first increases a little, then starts dropping. Besides, in the CoNLL03 NER task, LMs can be pruned to a relatively small size without much loss of efficiency. As in Table 3, we can observe that, after pruning over 90% calculations, the error of the resulting model only increases about 2%, yielding a competitive performance. As for the CoNLL00 Chunking task, the performance of LD-Net decays in a faster rate than that in the NER task. For example, after pruning over 80% calculations, the error of the resulting model increases about 13%. Considering the fact that this corpus is only half the size of the CoNLL03 NER dataset, we can expect the resulting models have more dependencies on the LMs. Still, the pruned model achieves a 25% error reduction over the NoLM baseline.\nTable 1 0 1 2 3 4 5 6 7 8 9 >10 4 3 3 1 1 0 0 1 1 2 4\n1\nLayer selection pattern. We further studied the layer selection patterns. Specifically, we use the same setting of LD-Net (9) in Table 3, conduct model pruning using for 50 times, and summarize the statics in Figure 6. We can observe that network layers formulate two clear clusters, one is likely to be preserved during the selection, and the other is likely to be pruned. This is consistent with our intuition that some layers are more important than others and the layer selection algorithm would pick up layers meaningfully.\nHowever, there is some randomness in the selection result. We conjugate that large networks trained with dropout can be viewed as a ensemble of small sub-networks (Hara et al., 2016), also there would be several sub-networks having the similar function. Accordingly, we think the randomness mainly comes from such redundancy. Effectiveness of model pruning. Zhu and Gupta (2017) observed pruned large models consistently outperform small models on various tasks (including LM). These observations are consistent with our experiments. For example, LD-Net achieves 91.84 after pruning on the CoNLL03 dataset. It outperforms TagLM (4) and R-ELMo (7), whose performances are 91.62 and 91.54. Besides, we trained small LMs of the same size as the pruned LMs (1-layer densely connected LSTMs). Its perplexity is 69 and its performance on the CoNLL03 dataset is 91.55± 0.19."
  }, {
    "heading": "5 Related Work",
    "text": "Sequence labeling. Linguistic sequence labeling is one of the fundamental tasks in NLP, encompassing various applications including POS tagging, chunking, and NER. Many attempts have been made to conduct end-to-end learning and build reliable models without handcrafted features (Chiu and Nichols, 2016; Lample et al., 2016; Ma and Hovy, 2016).\nLanguage modeling. Language modeling is a core task in NLP. Many attempts have been paid to develop better neural language models (Zilly et al., 2017; Inan et al., 2016; Godin et al., 2017; Melis et al., 2017). Specifically, with extensive corpora, language models can be well trained to generate high-quality sentences from scratch (Józefowicz et al., 2016; Grave et al., 2017; Li et al., 2018; Shazeer et al., 2017). Meanwhile, initial attempts have been made to improve the performance of other tasks with these methods. Some methods treat the language modeling as an additional supervision, and conduct co-training for knowledge transfer (Dai and Le, 2015; Liu et al., 2018; Rei, 2017). Others, including this paper, aim to construct additional features (referred as contextualized representations) with the pre-trained language models (Peters et al., 2017, 2018). Neural Network Acceleration. There are mainly three kinds of NN acceleration methods, i.e., prune network into smaller sizes (Han et al., 2015; Wen et al., 2016), converting float operation into customized low precision arithmetic (Hubara et al., 2018; Courbariaux et al., 2016), and using shallower networks to mimic the output of deeper ones (Hinton et al., 2015; Romero et al., 2014). However, most of them require costly retraining."
  }, {
    "heading": "6 Conclusion",
    "text": "Here, we proposed LD-Net, a novel framework for efficient contextualized representation. As demonstrated on two benchmarks, it can conduct the layer-wise pruning for a specific task. Moreover, it requires neither the gradient oracle of LMs nor the costly retraining. In the future, we plan to apply LD-Net to other applications."
  }, {
    "heading": "Acknowledgments",
    "text": "We thank Junliang Guo and all reviewers for their constructive comments. Research was sponsored by the Army Research Laboratory and was accomplished under Cooperative Agreement Number W911NF-09-2-0053 (the ARL Network Science CTA). The views and conclusions in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Army Research Laboratory or the U.S. Government. The U.S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation here on."
  }],
  "year": 2018,
  "references": [{
    "title": "One billion word benchmark for measuring progress in statistical language modeling",
    "authors": ["Ciprian Chelba", "Tomas Mikolov", "Mike Schuster", "Qi Ge", "Thorsten Brants", "Phillipp Koehn", "Tony Robinson."],
    "venue": "Technical report, Google.",
    "year": 2013
  }, {
    "title": "Named entity recognition with bidirectional lstm-cnns",
    "authors": ["Jason P.C. Chiu", "Eric Nichols."],
    "venue": "TACL.",
    "year": 2016
  }, {
    "title": "Binarized neural networks: Training deep neural networks with weights and activations constrained to+ 1 or-1",
    "authors": ["Matthieu Courbariaux", "Itay Hubara", "Daniel Soudry", "Ran El-Yaniv", "Yoshua Bengio."],
    "venue": "arXiv preprint arXiv:1602.02830.",
    "year": 2016
  }, {
    "title": "Semi-supervised sequence learning",
    "authors": ["Andrew M Dai", "Quoc V Le."],
    "venue": "Advances in neural information processing systems, pages 3079–3087.",
    "year": 2015
  }, {
    "title": "Understanding the difficulty of training deep feedforward neural networks",
    "authors": ["Xavier Glorot", "Yoshua Bengio."],
    "venue": "Proceedings of the Thirteenth International Conference on Artificial Intelligence and Statistics.",
    "year": 2010
  }, {
    "title": "Improving language modeling using densely connected recurrent neural networks",
    "authors": ["Fréderic Godin", "Joni Dambre", "Wesley De Neve."],
    "venue": "arXiv preprint arXiv:1707.06130.",
    "year": 2017
  }, {
    "title": "Efficient softmax approximation for gpus",
    "authors": ["Edouard Grave", "Armand Joulin", "Moustapha Cissé", "David Grangier", "Hervé Jégou."],
    "venue": "International Conference on Machine Learning, pages 1302–1310.",
    "year": 2017
  }, {
    "title": "Learning both weights and connections for efficient neural network",
    "authors": ["Song Han", "Jeff Pool", "John Tran", "William Dally."],
    "venue": "Advances in neural information processing systems, pages 1135–1143.",
    "year": 2015
  }, {
    "title": "Analysis of dropout learning regarded as ensemble learning",
    "authors": ["Kazuyuki Hara", "Daisuke Saitoh", "Hayaru Shouno."],
    "venue": "International Conference on Artificial Neural Networks, pages 72–79. Springer.",
    "year": 2016
  }, {
    "title": "Identity mappings in deep residual networks",
    "authors": ["Kaiming He", "Xiangyu Zhang", "Shaoqing Ren", "Jian Sun."],
    "venue": "European Conference on Computer Vision, pages 630–645. Springer.",
    "year": 2016
  }, {
    "title": "Distilling the knowledge in a neural network",
    "authors": ["Geoffrey E. Hinton", "Oriol Vinyals", "Jeffrey Dean."],
    "venue": "CoRR, abs/1503.02531.",
    "year": 2015
  }, {
    "title": "Densely connected convolutional networks",
    "authors": ["Gao Huang", "Zhuang Liu", "Laurens Van Der Maaten", "Kilian Q Weinberger."],
    "venue": "CVPR.",
    "year": 2017
  }, {
    "title": "Quantized neural networks: Training neural networks with low precision weights and activations",
    "authors": ["Itay Hubara", "Matthieu Courbariaux", "Daniel Soudry", "Ran El-Yaniv", "Yoshua Bengio."],
    "venue": "Journal of Machine Learning Research, 18(187):1–30.",
    "year": 2018
  }, {
    "title": "Tying word vectors and word classifiers: A loss framework for language modeling",
    "authors": ["Hakan Inan", "Khashayar Khosravi", "Richard Socher."],
    "venue": "CoRR, abs/1611.01462.",
    "year": 2016
  }, {
    "title": "Exploring the limits of language modeling",
    "authors": ["Rafal Józefowicz", "Oriol Vinyals", "Mike Schuster", "Noam Shazeer", "Yonghui Wu."],
    "venue": "CoRR, abs/1602.02410.",
    "year": 2016
  }, {
    "title": "Adam: A method for stochastic optimization",
    "authors": ["Diederik P. Kingma", "Jimmy Ba."],
    "venue": "CoRR, abs/1412.6980.",
    "year": 2014
  }, {
    "title": "Skip-thought vectors",
    "authors": ["Ryan Kiros", "Yukun Zhu", "Ruslan R Salakhutdinov", "Richard Zemel", "Raquel Urtasun", "Antonio Torralba", "Sanja Fidler."],
    "venue": "Advances in neural information processing systems, pages 3294–3302.",
    "year": 2015
  }, {
    "title": "Charner: Character-level named entity recognition",
    "authors": ["Onur Kuru", "Ozan Arkan Can", "Deniz Yuret."],
    "venue": "Proceedings of COLING 2016, the 26th International Conference on Computational Linguistics: Technical Papers, pages 911–921.",
    "year": 2016
  }, {
    "title": "Neural architectures for named entity recognition",
    "authors": ["Guillaume Lample", "Miguel Ballesteros", "Kazuya Kawakami", "Sandeep Subramanian", "Chris Dyer."],
    "venue": "NAACL-HLT.",
    "year": 2016
  }, {
    "title": "Slim embedding layers for recurrent neural language models",
    "authors": ["Zhongliang Li", "Raymond Kulhanek", "Shaojun Wang", "Yunxin Zhao", "Shuang Wu."],
    "venue": "CoRR, abs/1711.09873.",
    "year": 2018
  }, {
    "title": "Empower sequence labeling with task-aware neural language model",
    "authors": ["Liyuan Liu", "Jingbo Shang", "Frank F. Xu", "Xiang Ren", "Huan Gui", "Jian Peng", "Jiawei Han."],
    "venue": "CoRR, abs/1709.04109.",
    "year": 2018
  }, {
    "title": "End-to-end sequence labeling via bi-directional lstm-cnns-crf",
    "authors": ["Xuezhe Ma", "Eduard Hovy."],
    "venue": "ACL.",
    "year": 2016
  }, {
    "title": "On the state of the art of evaluation in neural language models",
    "authors": ["Gábor Melis", "Chris Dyer", "Phil Blunsom."],
    "venue": "CoRR, abs/1707.05589.",
    "year": 2017
  }, {
    "title": "Ternary neural networks with finegrained quantization",
    "authors": ["Naveen Mellempudi", "Abhisek Kundu", "Dheevatsa Mudigere", "Dipankar Das", "Bharat Kaul", "Pradeep Dubey."],
    "venue": "CoRR, abs/1705.01462.",
    "year": 2017
  }, {
    "title": "An algorithm for nonlinear optimization problems with binary variables",
    "authors": ["Walter Murray", "Kien-Ming Ng."],
    "venue": "Computational Optimization and Applications, 47(2):257–288.",
    "year": 2010
  }, {
    "title": "Semi-supervised sequence tagging with bidirectional language models",
    "authors": ["Matthew E. Peters", "Waleed Ammar", "Chandra Bhagavatula", "Russell Power."],
    "venue": "ACL.",
    "year": 2017
  }, {
    "title": "Deep contextualized word representations",
    "authors": ["Matthew E. Peters", "Mark Neumann", "Mohit Iyyer", "Matt Gardner", "Christopher Clark", "Kenton Lee", "Luke S. Zettlemoyer."],
    "venue": "NAACL-HLT.",
    "year": 2018
  }, {
    "title": "Learning to generate reviews and discovering sentiment",
    "authors": ["Alec Radford", "Rafal Jozefowicz", "Ilya Sutskever."],
    "venue": "arXiv preprint arXiv:1704.01444.",
    "year": 2017
  }, {
    "title": "Design challenges and misconceptions in named entity recognition",
    "authors": ["Lev Ratinov", "Dan Roth."],
    "venue": "CoNLL.",
    "year": 2009
  }, {
    "title": "Semi-supervised multitask learning for sequence labeling",
    "authors": ["Marek Rei."],
    "venue": "ACL.",
    "year": 2017
  }, {
    "title": "Fitnets: Hints for thin deep nets",
    "authors": ["Adriana Romero", "Nicolas Ballas", "Samira Ebrahimi Kahou", "Antoine Chassang", "Carlo Gatta", "Yoshua Bengio."],
    "venue": "CoRR, abs/1412.6550.",
    "year": 2014
  }, {
    "title": "Outrageously large neural networks: The sparsely-gated mixture-of-experts layer",
    "authors": ["Noam Shazeer", "Azalia Mirhoseini", "Krzysztof Maziarz", "Andy Davis", "Quoc V. Le", "Geoffrey E. Hinton", "Jeff Dean."],
    "venue": "CoRR, abs/1701.06538.",
    "year": 2017
  }, {
    "title": "Introduction to the conll-2000 shared task: Chunking",
    "authors": ["Erik F Tjong Kim Sang", "Sabine Buchholz."],
    "venue": "Learning language in logic and CoNLL.",
    "year": 2000
  }, {
    "title": "Introduction to the conll-2003 shared task: Language-independent named entity recognition",
    "authors": ["Erik F Tjong Kim Sang", "Fien De Meulder."],
    "venue": "Natural language learning at NAACL-HLT.",
    "year": 2003
  }, {
    "title": "Learning structured sparsity in deep neural networks",
    "authors": ["Wei Wen", "Chunpeng Wu", "Yandan Wang", "Yiran Chen", "Hai Li."],
    "venue": "Advances in Neural Information Processing Systems, pages 2074–2082.",
    "year": 2016
  }, {
    "title": "To prune, or not to prune: exploring the efficacy of pruning for model compression",
    "authors": ["Michael Zhu", "Suyog Gupta."],
    "venue": "CoRR, abs/1710.01878.",
    "year": 2017
  }, {
    "title": "Recurrent Highway Networks",
    "authors": ["Julian Georg Zilly", "Rupesh Kumar Srivastava", "Jan Koutnk", "Jrgen Schmidhuber."],
    "venue": "ICML.",
    "year": 2017
  }],
  "id": "SP:5568bb56fa8ffdceb33674fe39558be1de58e8c2",
  "authors": [{
    "name": "Liyuan Liu",
    "affiliations": []
  }, {
    "name": "Xiang Ren",
    "affiliations": []
  }, {
    "name": "Jingbo Shang",
    "affiliations": []
  }, {
    "name": "Xiaotao Gu",
    "affiliations": []
  }, {
    "name": "Jian Peng",
    "affiliations": []
  }, {
    "name": "Jiawei Han",
    "affiliations": []
  }],
  "abstractText": "Many efforts have been made to facilitate natural language processing tasks with pre-trained language models (LMs), and brought significant improvements to various applications. To fully leverage the nearly unlimited corpora and capture linguistic information of multifarious levels, large-size LMs are required; but for a specific task, only parts of these information are useful. Such large-sized LMs, even in the inference stage, may cause heavy computation workloads, making them too time-consuming for large-scale applications. Here we propose to compress bulky LMs while preserving useful information with regard to a specific task. As different layers of the model keep different information, we develop a layer selection method for model pruning using sparsityinducing regularization. By introducing the dense connectivity, we can detach any layer without affecting others, and stretch shallow and wide LMs to be deep and narrow. In model training, LMs are learned with layerwise dropouts for better robustness. Experiments on two benchmark datasets demonstrate the effectiveness of our method.",
  "title": "Efficient Contextualized Representation: Language Model Pruning for Sequence Labeling"
}