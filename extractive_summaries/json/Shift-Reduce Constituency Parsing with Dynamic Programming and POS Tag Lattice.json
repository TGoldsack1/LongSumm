{
  "sections": [{
    "text": "Human Language Technologies: The 2015 Annual Conference of the North American Chapter of the ACL, pages 1030–1035, Denver, Colorado, May 31 – June 5, 2015. c©2015 Association for Computational Linguistics\nWe present the first dynamic programming (DP) algorithm for shift-reduce constituency parsing, which extends the DP idea of Huang and Sagae (2010) to context-free grammars. To alleviate the propagation of errors from part-of-speech tagging, we also extend the parser to take a tag lattice instead of a fixed tag sequence. Experiments on both English and Chinese treebanks show that our DP parser significantly improves parsing quality over non-DP baselines, and achieves the best accuracies among empirical linear-time parsers."
  }, {
    "heading": "1 Introduction",
    "text": "Incremental parsing has gained popularity in both dependency (Nivre, 2004; Zhang and Clark, 2008) and constituency parsing (Zhu et al., 2013; Wang and Xue, 2014). However, the greedy or beam search algorithms used in these parsers can only explore a tiny fraction of trees among exponentially many candidates. To alleviate this problem, Huang and Sagae (2010) propose a dynamic programming (DP) algorithm, reducing the search space to a polynomial size by merging equivalent states. This idea has been extended by Kuhlmann et al. (2011) and Cohen et al. (2011) to other dependency parsing paradigms.\nIn constituency parsing, however, DP has not yet been applied to incremental parsing, and the bigger search space in constituency parsing suggests a potentially even bigger advantage by DP. However, with unary rules and more-than-binary branchings, constituency parsing presents challenges not found in dependency parsing that must be addressed before applying DP. Thus, we first present an odd-even\nshift-reduce constituency parser which always finishes in same number of steps, eliminating the complicated asynchronicity issue in previous work (Zhu et al., 2013; Wang and Xue, 2014), and then develop dynamic programming on top of that. Secondly, to alleviate the error propagation from POS tagging, we also extends the algorithm to take a tagging sausage lattice as input, which is a compromise between pipeline and joint approaches (Hatori et al., 2011; Li et al., 2011; Wang and Xue, 2014).\nOur DP parser achieves state-of-the-art performances on both Chinese and English treebanks (at 90.8% on PTB and 83.9% on CTB, the latter being the highest in literature)."
  }, {
    "heading": "2 Odd-Even Shift-Reduce CFG Parser",
    "text": "One major challenge in constituency parsing is unary rules. Unlike dependency parsing where shiftreduce always finishes in 2n−1 steps, existing incremental constituency parsers (Zhu et al., 2013; Wang and Xue, 2014) reach the goal state (full parse tree) in different steps due to different number of unary rules. So we propose a new, synchronized, “oddeven” system to reach the goal in the same 4n − 2 steps. A state is notated p = 〈S,Q〉, where S is a stack of trees ..., s1, s0, and Q is a queue of wordtag pairs. At even steps (when step index is even) we can choose one of the three standard actions\n• sh: shift the head of Q, a word-tag pair (t, w), onto S as a singleton tree t(w);\n• rexx: combine the top two trees on the stack and replace them with a new tree x(s1, s0), x being the root nonterminal, headed on s0;\n• rexy: similar to rexx but headed on s1; and at odd steps we can choose two new actions:\n1030\n• unx : replace s0 with a new tree x(s0) with x being the root nonterminal;\n• st: no action. Figure 1 shows the deductive system. Note that we alternate between standard shift-reduce actions in even steps and unary actions (unx or st) in odd steps, and the first action must be sh, followed by a unx or st, and followed by another sh. Continuing this procedure, we can always achieve the goal in 2(2n− 1) steps.\nIn practice, we have larger than two-way rules and multi-level unary rules, so we binarize them and collapse multi-level unary rules into one level, for example,\nNP\nS\nVP\nPPNPV\n=⇒\nNP+S\nVP\nPPVP′\nNPV\nFollowing Huang and Sagae (2010), we represent feature templates as functions f(·, ·) on stack S and queue Q. Table 1 shows the 43 feature templates we use in this paper, all adopted from Zhu et al. (2013). They are combinations of the 32 atomic features f̃(S,Q) (e.g. s0.t and s0.c denote the head tag and\nsyntactic category of tree s0, resp., and s0.lc.w is the head word of its leftmost child)."
  }, {
    "heading": "3 Dynamic Programming",
    "text": "The key idea towards DP is the merging of equivalent states, after which the stacks are organized in a “graph-structured stack” (GSS)(Tomita, 1988). Following Huang and Sagae (2010), “equivalent states” ∼ in a same beam are defined by the atomic features f̃(S,Q) and the span of s0:\n〈S,Q〉 ∼ 〈S′, Q′〉 ⇔ f̃(S,Q) = f̃(S′, Q′) and s0.span = s′0.span.\nSimilarly, for each state p, π(p) is a set of predictor states, each of which can be combined with p in a rexx or re x y action. For each action, we have different operations on π(p). If a state pmakes a sh action and generates a state p′, then π(p′) = {p}. If two shifted states p′ and p′′ are equivalent, p′ ∼ p′′, we merge π(p′) and π(p′′). If a state p makes a reduce (rexx or re x y) action, p tries to combine with every p′ ∈ π(p), and each combination generates a state r with π(r) = π(p′). If two reduced states are equivalent, we only keep one predictor states, as their predictor states are identical. If a state p fires an unx or a st action resulting in a state u, we copy the predictor states π(u) = π(p). Similar to reduce actions, if two resulting states after applying an unx or a st action are equivalent, we only keep the best one with highest score (the recombined ones are only useful for searching k-best trees).\ninput (T1, w1)...(Tn, wn)\naxioms 0 : 〈 , (t, w1)...(Tn, wn)({</s>}, </s>)〉 : 0,∀ t ∈ T1\nsh l : 〈S, (t, w)|(T ′, w′)|Q〉 : (c, v) l+1 : 〈S|t(w), (t′, w′)|Q〉 : (c+csh, 0) t′ ∈ T ′, l is even\nFigure 3: Extended shift-reduce deductive system with tagging sausage lattice, only showing sh.\nIn order to compute all the scores in GSS, for each state p, we calculate the prefix score, c, which is the total cost of the best action sequence from the initial state to the end of state p, and the inside score v, which is the score since the last shift (Figure 2).\nThe new mechanism beyond Huang and Sagae (2010) is the non-trivial dynamic programming treatment of unary actions (unx and st), which is not found in dependency parsing. Note that the score calculation is quite different from shift in the sense that unary actions are more like reduces."
  }, {
    "heading": "4 Incorporating Tag Lattices",
    "text": "It is easy to extend our deductive system to take tagging sausage lattices as input. The key difference is that the tag t associated with each word in the input sequence becomes a set of tags T . Thus, in the sh action, we split the state with all the possible tags t′ in the tagset T ′ for the second word on the queue. Figure 3 shows the deductive system, where we only change the sh action, input and axiom. For simplicity reasons we only present one word look\n87.5\n88\n88.5\n89\n89.5\n90\n2 4 6 8 10 12 14 16 18\nF 1\no n\nt h\ne d\ne v s\ne t\niteration\n11th\n15th\nDP non-DP\nFigure 4: The learning curves of non-DP and DP parsers on the development set. DP achieves the best performance at 11th iteration with 89.8%, while non-DP gets its optimal iteration at 15th with a lower F1 89.5%.\nahead (we just need to know the tag of the first word on the queue), but in practice, we use a look ahead of 4 words (q0..q3, see Table 1), so each shift actually splits the tagset of the 5th word on the queue (q4)."
  }, {
    "heading": "5 Experiments",
    "text": "We evaluate our parsers on both Penn English Treebank (PTB) and Chinese Treebank (CTB). For PTB, we use sections 02-21 as the training, section 24 as the dev set, and section 23 as the test. For CTB, we use the version of 5.1, articles 001-270 and 440- 1151 as the training data, articles 301-325 as the dev set, and articles 271-300 as the test set.\nBesides training with gold POS tags, we add k-best automatic tagging results to the training set using a MaxEnt model with ten-way jackknifing (Collins, 2000). And we automatically tag the dev and test sets with k-best tagging sequences us-\ning the MaxEnt POS tagger (at 97.1% accuracy on English, and 94.5% on Chinese) trained on the training set. We set k to 20 for English. And we run two sets of experiments, 1-best vs. 20-best, for Chinese to address the tagging issue. We train our parsers using “max-violation perceptron” (Huang et al., 2012) (which has been shown to converge much faster than “early-update” of Collins and Roark (2004)) with minibatch parallelization (Zhao and Huang, 2013) on the head-out binarized and unary-collapsed training set. We finally debinarize the trees to recover the collapsed unary rules.\nWe evaluate parser performance with EVALB including labeled precision (LP), labeled recall (LR), and bracketing F1. We use a beam size of 32, and pick the optimal iteration number based on the performances on the dev set.\nOur baseline is the shift-reduce parser without state recombination (henceforth “non-DP”), and our dynamic programming parser (henceforth “DP”) is the extension of the baseline."
  }, {
    "heading": "5.1 Learning Curves and Search Quality",
    "text": "Figure 4 shows the learning curves on the PTB dev set. With a same beam width, DP parser achieves a better performance (89.8%, peaking at the 11th iteration) and converges faster than non-DP. Picking the optimal iterations for DP and non-DP models, we test each with various beam size, and plot the F1 curves in Figure 5. Again, DP is always better than non-DP, with 0.5% difference at beam of 64."
  }, {
    "heading": "5.2 Final Results on English",
    "text": "Table 2 shows the final results on the PTB test set. The last column shows the empirical time complexity. Our baseline parser achieves a competitive score, which is higher than Berkeley even with a linear time complexity, and is comparable to Zhu et al. (2013). Our DP parser improves the F1 score by 0.5 points over the non-DP, and achieves the best F1 score among empirical linear-time parsers."
  }, {
    "heading": "5.3 Sausage Lattice Parsing",
    "text": "To alleviate the propagation of errors from POS tagging, we run sausage lattice parsing on both Chinese and English, where Chinese tagging accuracy significantly lag behind English.\nTable 3 shows the F1 score and POS tagging accuracy of all parsing models on the Chinese 5.1 test set. Our MaxEnt POS tagger achieves an accuracy of 94.5% on 1-best outputs, and an oracle score of 97.1% on 20-best results. The average number of\ntags for each word in the 20-best list is 1.1. The joint tagging and parsing approach of Wang and Xue (2014) improves the F1 score from 80.1% to 83.6% (see lines 4 and 5). We instead use sausage lattices, a much cheaper way. The non-DP (1-best POS) and non-DP (20-best POS) lines show the effectiveness of using sausage lattices (+1.1 for tagging and +2.6 for parsing). As Wang and Xue (2014) is a non-DP model, it is comparable to our non-DP results. With the help of 20-best tagging lattices, we achieve the same tagging accuracy at 95.5%, but still 0.4 worse on the F1 score than the joint model. It suggests that we need a larger k to catch up the gap. But our DP model boosts the performance further to the best score at 83.9% with a similar set of features.\nThe last two lines (non-DP and DP) in Table 2 show our English lattice parsing results. So we run another baseline with the non-DP English parser on 1-best POS tags, and the baseline achieves a tagging accuracy at 97.11 and an F1 score at 90.1. Comparing to the tagging accuracy (97.15) and F1 score (90.3) of our non-DP lattice parser, sausage lattice parsing doesn’t help the tagging accuracy, but helps parsing a little by 0.2 points. The statistics show that 2 percent of POS tags in the lattice parsing result are different from the baseline, and those differences lead to a slight improvement on parsing."
  }, {
    "heading": "6 Conclusions",
    "text": "In this paper, we present a dynamic programming algorithm based on graph-structured stack (GSS) for shift-reduce constituency parsing, and extend the algorithm to take tagging sausage lattices as input. Experiments on both English and Chinese treebanks show that our DP parser outperforms almost all other parsers except of Carreras et al. (2008), which runs in a much higher time complexity."
  }, {
    "heading": "Acknowledgment",
    "text": "We thank the anonymous reviewers for comments. Haitao Mi is supported by DARPA HR0011-12C-0015 (BOLT), and Liang Huang is supported by DARPA FA8750-13-2-0041 (DEFT), NSF IIS1449278, and a Google Faculty Research Award. The views and findings in this paper are those of the authors and are not endorsed by the DARPA."
  }],
  "year": 2015,
  "references": [{
    "title": "Tag, dynamic programming, and the perceptron for efficient, feature-rich parsing",
    "authors": ["Xavier Carreras", "Michael Collins", "Terry Koo."],
    "venue": "Proceedings of CoNLL 2008.",
    "year": 2008
  }, {
    "title": "A maximum-entropy-inspired parser",
    "authors": ["Eugene Charniak."],
    "venue": "Proceedings of NAACL.",
    "year": 2000
  }, {
    "title": "Exact inference for generative probabilistic non-projective dependency parsing",
    "authors": ["Shay B. Cohen", "Carlos Gómez-Rodrı́guez", "Giorgio Satta"],
    "venue": "In Proceedings of the Conference on Empirical Methods in Natural Language Processing",
    "year": 2011
  }, {
    "title": "Incremental parsing with the perceptron algorithm",
    "authors": ["Michael Collins", "Brian Roark."],
    "venue": "Proceedings of ACL.",
    "year": 2004
  }, {
    "title": "Head-Driven Statistical Models for Natural Language Parsing",
    "authors": ["Michael Collins."],
    "venue": "Ph.D. thesis, University of Pennsylvania.",
    "year": 1999
  }, {
    "title": "Discriminative reranking for natural language parsing",
    "authors": ["Michael Collins."],
    "venue": "Proceedings of ICML, pages 175–182.",
    "year": 2000
  }, {
    "title": "Incremental joint pos tagging and dependency parsing in chinese",
    "authors": ["Jun Hatori", "Takuya Matsuzaki", "Yusuke Miyao", "Jun’ichi Tsujii"],
    "venue": "In IJCNLP",
    "year": 2011
  }, {
    "title": "Dynamic programming for linear-time incremental parsing",
    "authors": ["Liang Huang", "Kenji Sagae."],
    "venue": "Proceedings of ACL 2010.",
    "year": 2010
  }, {
    "title": "Structured perceptron with inexact search",
    "authors": ["Liang Huang", "Suphan Fayong", "Yang Guo."],
    "venue": "Proceedings of NAACL.",
    "year": 2012
  }, {
    "title": "Dynamic programming algorithms for transition-based dependency parsers",
    "authors": ["Marco Kuhlmann", "Carlos Gmez-Rodrguez", "Giorgio Satta."],
    "venue": "Proceedings of ACL.",
    "year": 2011
  }, {
    "title": "Joint models for chinese pos tagging and dependency parsing",
    "authors": ["Zhenghua Li", "Min Zhang", "Wanxiang Che", "Ting Liu", "Wenliang Chen", "Haizhou Li."],
    "venue": "Proceedings of EMNLP, pages 1180–1191.",
    "year": 2011
  }, {
    "title": "Incrementality in deterministic dependency parsing",
    "authors": ["Joakim Nivre."],
    "venue": "Incremental Parsing: Bringing Engineering and Cognition Together. Workshop at ACL-2004, Barcelona.",
    "year": 2004
  }, {
    "title": "Improved inference for unlexicalized parsing",
    "authors": ["Slav Petrov", "Dan Klein."],
    "venue": "Proceedings of HLTNAACL.",
    "year": 2007
  }, {
    "title": "A linear observed time statistical parser based on maximum entropy models",
    "authors": ["Adwait Ratnaparkhi."],
    "venue": "Proceedings of EMNLP, pages 1–10.",
    "year": 1997
  }, {
    "title": "A best-first probabilistic shift-reduce parser",
    "authors": ["Kenji Sagae", "Alon Lavie."],
    "venue": "Proceedings of ACL (poster).",
    "year": 2006
  }, {
    "title": "Graph-structured stack and natural language parsing",
    "authors": ["Masaru Tomita."],
    "venue": "Proceedings of the 26th annual meeting on Association for Computational Linguistics, pages 249–257, Morristown, NJ, USA. Association for Computational Linguistics.",
    "year": 1988
  }, {
    "title": "Joint pos tagging and transition-based constituent parsing in chinese with non-local features",
    "authors": ["Zhiguo Wang", "Nianwen Xue."],
    "venue": "Proceedings of ACL.",
    "year": 2014
  }, {
    "title": "A tale",
    "authors": ["Yue Zhang", "Stephen Clark"],
    "year": 2008
  }, {
    "title": "Minibatch and parallelization for online large margin structured learning",
    "authors": ["Kai Zhao", "Liang Huang."],
    "venue": "Proceedings of NAACL 2013.",
    "year": 2013
  }, {
    "title": "Fast and accurate shift-reduce constituent parsing",
    "authors": ["Muhua Zhu", "Yue Zhang", "Wenliang Chen", "Min Zhang", "Jingbo Zhu."],
    "venue": "Proceedings of ACL 2013.",
    "year": 2013
  }],
  "id": "SP:35ba7e131ed10befa46678b5864ed488d5319722",
  "authors": [{
    "name": "Haitao Mi",
    "affiliations": []
  }, {
    "name": "Liang Huang",
    "affiliations": []
  }],
  "abstractText": "We present the first dynamic programming (DP) algorithm for shift-reduce constituency parsing, which extends the DP idea of Huang and Sagae (2010) to context-free grammars. To alleviate the propagation of errors from part-of-speech tagging, we also extend the parser to take a tag lattice instead of a fixed tag sequence. Experiments on both English and Chinese treebanks show that our DP parser significantly improves parsing quality over non-DP baselines, and achieves the best accuracies among empirical linear-time parsers.",
  "title": "Shift-Reduce Constituency Parsing with Dynamic Programming and POS Tag Lattice"
}